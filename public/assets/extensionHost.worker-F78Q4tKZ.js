var UE = (t) => {
  throw TypeError(t);
};
var $E = (t, e, i) => e.has(t) || UE("Cannot " + i);
var zt = (t, e, i) => ($E(t, e, "read from private field"), i ? i.call(t) : e.get(t)), If = (t, e, i) => e.has(t) ? UE("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, i), Cf = (t, e, i, n) => ($E(t, e, "write to private field"), n ? n.call(t, i) : e.set(t, i), i);
class Vi {
  constructor(e) {
    this.executor = e, this._didRun = !1;
  }
  get hasValue() {
    return this._didRun;
  }
  get value() {
    if (!this._didRun)
      try {
        this._value = this.executor();
      } catch (e) {
        this._error = e;
      } finally {
        this._didRun = !0;
      }
    if (this._error)
      throw this._error;
    return this._value;
  }
  get rawValue() {
    return this._value;
  }
}
let V5 = class {
  constructor() {
    this.listeners = [], this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        throw e.stack ? Xr.isErrorNoTelemetry(e) ? new Xr(e.message + `

` + e.stack) : new Error(e.message + `

` + e.stack) : e;
      }, 0);
    };
  }
  addListener(e) {
    return this.listeners.push(e), () => {
      this._removeListener(e);
    };
  }
  emit(e) {
    this.listeners.forEach((i) => {
      i(e);
    });
  }
  _removeListener(e) {
    this.listeners.splice(this.listeners.indexOf(e), 1);
  }
  setUnexpectedErrorHandler(e) {
    this.unexpectedErrorHandler = e;
  }
  getUnexpectedErrorHandler() {
    return this.unexpectedErrorHandler;
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e), this.emit(e);
  }
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
};
const sf = new V5();
function fv(t) {
  sf.setUnexpectedErrorHandler(t);
}
function Cp(t) {
  sf.onUnexpectedError(t);
}
function Li(t) {
  Yr(t) || sf.onUnexpectedError(t);
}
function pv(t) {
  Yr(t) || sf.onUnexpectedExternalError(t);
}
function Oc(t) {
  if (t instanceof Error) {
    const { name: e, message: i, cause: n } = t, r = t.stacktrace || t.stack;
    return {
      $isError: !0,
      name: e,
      message: i,
      stack: r,
      noTelemetry: Xr.isErrorNoTelemetry(t),
      cause: n ? Oc(n) : void 0,
      code: t.code
    };
  }
  return t;
}
function XC(t) {
  let e;
  return t.noTelemetry ? e = new Xr() : (e = new Error(), e.name = t.name), e.message = t.message, e.stack = t.stack, t.code && (e.code = t.code), t.cause && (e.cause = XC(t.cause)), e;
}
const Tp = "Canceled";
function Yr(t) {
  return t instanceof zn ? !0 : t instanceof Error && t.name === Tp && t.message === Tp;
}
class zn extends Error {
  constructor() {
    super(Tp), this.name = this.message;
  }
}
const Zl = class Zl extends Error {
  static is(e) {
    return e instanceof Zl || e instanceof Error && e.name === Zl._name;
  }
  constructor(e) {
    super(e), this.name = Zl._name;
  }
};
Zl._name = "PendingMigrationError";
let Pp = Zl;
function HE() {
  const t = new Error(Tp);
  return t.name = t.message, t;
}
function ze(t) {
  return t ? new Error(`Illegal argument: ${t}`) : new Error("Illegal argument");
}
function gx(t) {
  return t ? new Error(`Illegal state: ${t}`) : new Error("Illegal state");
}
class la extends TypeError {
  constructor(e) {
    super(e ? `${e} is read-only and cannot be changed` : "Cannot change read-only property");
  }
}
class z5 extends Error {
  constructor(e) {
    super("NotImplemented"), e && (this.message = e);
  }
}
class gv extends Error {
  constructor(e) {
    super("NotSupported"), e && (this.message = e);
  }
}
class Xr extends Error {
  constructor(e) {
    super(e), this.name = "CodeExpectedError";
  }
  static fromError(e) {
    if (e instanceof Xr)
      return e;
    const i = new Xr();
    return i.message = e.message, i.stack = e.stack, i;
  }
  static isErrorNoTelemetry(e) {
    return e.name === "CodeExpectedError";
  }
}
class rn extends Error {
  constructor(e) {
    super(e || "An unexpected bug occurred."), Object.setPrototypeOf(this, rn.prototype);
  }
}
function An(t, e, i = (n, r) => n === r) {
  if (t === e)
    return !0;
  if (!t || !e || t.length !== e.length)
    return !1;
  for (let n = 0, r = t.length; n < r; n++)
    if (!i(t[n], e[n]))
      return !1;
  return !0;
}
function q5(t, e) {
  const i = [];
  let n;
  for (const r of t.slice(0).sort(e))
    !n || e(n[0], r) !== 0 ? (n = [r], i.push(n)) : n.push(r);
  return i;
}
function ZC(t, e, i) {
  const n = [];
  function r(a, l, c) {
    if (l === 0 && c.length === 0)
      return;
    const u = n[n.length - 1];
    u && u.start + u.deleteCount === a ? (u.deleteCount += l, u.toInsert.push(...c)) : n.push({ start: a, deleteCount: l, toInsert: c });
  }
  let s = 0, o = 0;
  for (; ; ) {
    if (s === t.length) {
      r(s, 0, e.slice(o));
      break;
    }
    if (o === e.length) {
      r(s, t.length - s, []);
      break;
    }
    const a = t[s], l = e[o], c = i(a, l);
    c === 0 ? (s += 1, o += 1) : c < 0 ? (r(s, 1, []), s += 1) : c > 0 && (r(s, 0, [l]), o += 1);
  }
  return n;
}
function j5(t, e, i) {
  const n = ZC(t, e, i), r = [], s = [];
  for (const o of n)
    r.push(...t.slice(o.start, o.start + o.deleteCount)), s.push(...o.toInsert);
  return { removed: r, added: s };
}
function Kt(t) {
  return t.filter((e) => !!e);
}
function G5(t) {
  let e = 0;
  for (let i = 0; i < t.length; i++)
    t[i] && (t[e] = t[i], e += 1);
  t.length = e;
}
function mx(t) {
  return !Array.isArray(t) || t.length === 0;
}
function of(t) {
  return Array.isArray(t) && t.length > 0;
}
function Fl(t, e = (i) => i) {
  const i = /* @__PURE__ */ new Set();
  return t.filter((n) => {
    const r = e(n);
    return i.has(r) ? !1 : (i.add(r), !0);
  });
}
function BE(t, e) {
  let i;
  i = Math.random;
  for (let n = t.length - 1; n > 0; n -= 1) {
    const r = Math.floor(i() * (n + 1)), s = t[n];
    t[n] = t[r], t[r] = s;
  }
}
function mv(t, e) {
  return Array.isArray(t) ? t.map(e) : e(t);
}
function qn(t) {
  return Array.isArray(t) ? t : [t];
}
var _v;
(function(t) {
  function e(s) {
    return s < 0;
  }
  t.isLessThan = e;
  function i(s) {
    return s <= 0;
  }
  t.isLessThanOrEqual = i;
  function n(s) {
    return s > 0;
  }
  t.isGreaterThan = n;
  function r(s) {
    return s === 0;
  }
  t.isNeitherLessOrGreaterThan = r, t.greaterThan = 1, t.lessThan = -1, t.neitherLessOrGreaterThan = 0;
})(_v || (_v = {}));
const ec = class ec {
  constructor(e) {
    this.iterate = e;
  }
  forEach(e) {
    this.iterate((i) => (e(i), !0));
  }
  toArray() {
    const e = [];
    return this.iterate((i) => (e.push(i), !0)), e;
  }
  filter(e) {
    return new ec((i) => this.iterate((n) => e(n) ? i(n) : !0));
  }
  map(e) {
    return new ec((i) => this.iterate((n) => i(e(n))));
  }
  some(e) {
    let i = !1;
    return this.iterate((n) => (i = e(n), !i)), i;
  }
  findFirst(e) {
    let i;
    return this.iterate((n) => e(n) ? (i = n, !1) : !0), i;
  }
  findLast(e) {
    let i;
    return this.iterate((n) => (e(n) && (i = n), !0)), i;
  }
  findLastMaxBy(e) {
    let i, n = !0;
    return this.iterate((r) => ((n || _v.isGreaterThan(e(r, i))) && (n = !1, i = r), !0)), i;
  }
};
ec.empty = new ec((e) => {
});
let WE = ec;
function Q5(t, e) {
  const i = /* @__PURE__ */ Object.create(null);
  for (const n of t) {
    const r = e(n);
    let s = i[r];
    s || (s = i[r] = []), s.push(n);
  }
  return i;
}
function K5(t, e) {
  const i = [], n = [];
  for (const r of t)
    e.has(r) || i.push(r);
  for (const r of e)
    t.has(r) || n.push(r);
  return { removed: i, added: n };
}
var VE, zE, qE;
function J5(t, e, i) {
  let n = t.get(e);
  return n === void 0 && (n = i, t.set(e, n)), n;
}
class Y5 {
  constructor(e, i) {
    this.uri = e, this.value = i;
  }
}
function X5(t) {
  return Array.isArray(t);
}
const ia = class ia {
  constructor(e, i) {
    if (this[VE] = "ResourceMap", e instanceof ia)
      this.map = new Map(e.map), this.toKey = i ?? ia.defaultToKey;
    else if (X5(e)) {
      this.map = /* @__PURE__ */ new Map(), this.toKey = i ?? ia.defaultToKey;
      for (const [n, r] of e)
        this.set(n, r);
    } else
      this.map = /* @__PURE__ */ new Map(), this.toKey = e ?? ia.defaultToKey;
  }
  set(e, i) {
    return this.map.set(this.toKey(e), new Y5(e, i)), this;
  }
  get(e) {
    return this.map.get(this.toKey(e))?.value;
  }
  has(e) {
    return this.map.has(this.toKey(e));
  }
  get size() {
    return this.map.size;
  }
  clear() {
    this.map.clear();
  }
  delete(e) {
    return this.map.delete(this.toKey(e));
  }
  forEach(e, i) {
    typeof i < "u" && (e = e.bind(i));
    for (const [n, r] of this.map)
      e(r.value, r.uri, this);
  }
  *values() {
    for (const e of this.map.values())
      yield e.value;
  }
  *keys() {
    for (const e of this.map.values())
      yield e.uri;
  }
  *entries() {
    for (const e of this.map.values())
      yield [e.uri, e.value];
  }
  *[(VE = Symbol.toStringTag, Symbol.iterator)]() {
    for (const [, e] of this.map)
      yield [e.uri, e.value];
  }
};
ia.defaultToKey = (e) => e.toString();
let fi = ia;
class e4 {
  constructor(e, i) {
    this[zE] = "ResourceSet", !e || typeof e == "function" ? this._map = new fi(e) : (this._map = new fi(i), e.forEach(this.add, this));
  }
  get size() {
    return this._map.size;
  }
  add(e) {
    return this._map.set(e, e), this;
  }
  clear() {
    this._map.clear();
  }
  delete(e) {
    return this._map.delete(e);
  }
  forEach(e, i) {
    this._map.forEach((n, r) => e.call(i, r, r, this));
  }
  has(e) {
    return this._map.has(e);
  }
  entries() {
    return this._map.entries();
  }
  keys() {
    return this._map.keys();
  }
  values() {
    return this._map.keys();
  }
  [(zE = Symbol.toStringTag, Symbol.iterator)]() {
    return this.keys();
  }
}
var Bi;
(function(t) {
  t[t.None = 0] = "None", t[t.AsOld = 1] = "AsOld", t[t.AsNew = 2] = "AsNew";
})(Bi || (Bi = {}));
class Z5 {
  constructor() {
    this[qE] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
  }
  clear() {
    this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    return this._head?.value;
  }
  get last() {
    return this._tail?.value;
  }
  has(e) {
    return this._map.has(e);
  }
  get(e, i = Bi.None) {
    const n = this._map.get(e);
    if (n)
      return i !== Bi.None && this.touch(n, i), n.value;
  }
  set(e, i, n = Bi.None) {
    let r = this._map.get(e);
    if (r)
      r.value = i, n !== Bi.None && this.touch(r, n);
    else {
      switch (r = { key: e, value: i, next: void 0, previous: void 0 }, n) {
        case Bi.None:
          this.addItemLast(r);
          break;
        case Bi.AsOld:
          this.addItemFirst(r);
          break;
        case Bi.AsNew:
          this.addItemLast(r);
          break;
        default:
          this.addItemLast(r);
          break;
      }
      this._map.set(e, r), this._size++;
    }
    return this;
  }
  delete(e) {
    return !!this.remove(e);
  }
  remove(e) {
    const i = this._map.get(e);
    if (i)
      return this._map.delete(e), this.removeItem(i), this._size--, i.value;
  }
  shift() {
    if (!this._head && !this._tail)
      return;
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    const e = this._head;
    return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
  }
  forEach(e, i) {
    const n = this._state;
    let r = this._head;
    for (; r; ) {
      if (i ? e.bind(i)(r.value, r.key, this) : e(r.value, r.key, this), this._state !== n)
        throw new Error("LinkedMap got modified during iteration.");
      r = r.next;
    }
  }
  keys() {
    const e = this, i = this._state;
    let n = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== i)
          throw new Error("LinkedMap got modified during iteration.");
        if (n) {
          const s = { value: n.key, done: !1 };
          return n = n.next, s;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  values() {
    const e = this, i = this._state;
    let n = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== i)
          throw new Error("LinkedMap got modified during iteration.");
        if (n) {
          const s = { value: n.value, done: !1 };
          return n = n.next, s;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  entries() {
    const e = this, i = this._state;
    let n = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== i)
          throw new Error("LinkedMap got modified during iteration.");
        if (n) {
          const s = { value: [n.key, n.value], done: !1 };
          return n = n.next, s;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  [(qE = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let i = this._head, n = this.size;
    for (; i && n > e; )
      this._map.delete(i.key), i = i.next, n--;
    this._head = i, this._size = n, i && (i.previous = void 0), this._state++;
  }
  trimNew(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let i = this._tail, n = this.size;
    for (; i && n > e; )
      this._map.delete(i.key), i = i.previous, n--;
    this._tail = i, this._size = n, i && (i.next = void 0), this._state++;
  }
  addItemFirst(e) {
    if (!this._head && !this._tail)
      this._tail = e;
    else if (this._head)
      e.next = this._head, this._head.previous = e;
    else
      throw new Error("Invalid list");
    this._head = e, this._state++;
  }
  addItemLast(e) {
    if (!this._head && !this._tail)
      this._head = e;
    else if (this._tail)
      e.previous = this._tail, this._tail.next = e;
    else
      throw new Error("Invalid list");
    this._tail = e, this._state++;
  }
  removeItem(e) {
    if (e === this._head && e === this._tail)
      this._head = void 0, this._tail = void 0;
    else if (e === this._head) {
      if (!e.next)
        throw new Error("Invalid list");
      e.next.previous = void 0, this._head = e.next;
    } else if (e === this._tail) {
      if (!e.previous)
        throw new Error("Invalid list");
      e.previous.next = void 0, this._tail = e.previous;
    } else {
      const i = e.next, n = e.previous;
      if (!i || !n)
        throw new Error("Invalid list");
      i.previous = n, n.next = i;
    }
    e.next = void 0, e.previous = void 0, this._state++;
  }
  touch(e, i) {
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    if (!(i !== Bi.AsOld && i !== Bi.AsNew)) {
      if (i === Bi.AsOld) {
        if (e === this._head)
          return;
        const n = e.next, r = e.previous;
        e === this._tail ? (r.next = void 0, this._tail = r) : (n.previous = r, r.next = n), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
      } else if (i === Bi.AsNew) {
        if (e === this._tail)
          return;
        const n = e.next, r = e.previous;
        e === this._head ? (n.previous = void 0, this._head = n) : (n.previous = r, r.next = n), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
      }
    }
  }
  toJSON() {
    const e = [];
    return this.forEach((i, n) => {
      e.push([n, i]);
    }), e;
  }
  fromJSON(e) {
    this.clear();
    for (const [i, n] of e)
      this.set(i, n);
  }
}
let eA = class extends Z5 {
  constructor(e, i = 1) {
    super(), this._limit = e, this._ratio = Math.min(Math.max(0, i), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(e) {
    this._limit = e, this.checkTrim();
  }
  get ratio() {
    return this._ratio;
  }
  set ratio(e) {
    this._ratio = Math.min(Math.max(0, e), 1), this.checkTrim();
  }
  get(e, i = Bi.AsNew) {
    return super.get(e, i);
  }
  peek(e) {
    return super.get(e, Bi.None);
  }
  set(e, i) {
    return super.set(e, i, Bi.AsNew), this;
  }
  checkTrim() {
    this.size > this._limit && this.trim(Math.round(this._limit * this._ratio));
  }
};
class _x extends eA {
  constructor(e, i = 1) {
    super(e, i);
  }
  trim(e) {
    this.trimOld(e);
  }
  set(e, i) {
    return super.set(e, i), this.checkTrim(), this;
  }
}
class tA {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(e, i) {
    let n = this.map.get(e);
    n || (n = /* @__PURE__ */ new Set(), this.map.set(e, n)), n.add(i);
  }
  delete(e, i) {
    const n = this.map.get(e);
    n && (n.delete(i), n.size === 0 && this.map.delete(e));
  }
  forEach(e, i) {
    const n = this.map.get(e);
    n && n.forEach(i);
  }
  get(e) {
    const i = this.map.get(e);
    return i || /* @__PURE__ */ new Set();
  }
}
function vx(t, e) {
  const i = this;
  let n = !1, r;
  return function() {
    return n || (n = !0, r = t.apply(i, arguments)), r;
  };
}
function Wi(t, e) {
  if (!t)
    throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
}
function vv(t, e = "Unreachable") {
  throw new Error(e);
}
function wv(t, e = "unexpected state") {
  if (!t)
    throw typeof e == "string" ? new rn(`Assertion Failed: ${e}`) : e;
}
function t4(t) {
  if (!t()) {
    debugger;
    t(), Li(new rn("Assertion Failed"));
  }
}
function it(t) {
  return typeof t == "string";
}
function iA(t) {
  return Array.isArray(t) && t.every((e) => it(e));
}
function ri(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t) && !(t instanceof RegExp) && !(t instanceof Date);
}
function nA(t) {
  const e = Object.getPrototypeOf(Uint8Array);
  return typeof t == "object" && t instanceof e;
}
function xa(t) {
  return typeof t == "number" && !isNaN(t);
}
function rA(t) {
  return !!t && typeof t[Symbol.iterator] == "function";
}
function Ku(t) {
  return typeof t > "u";
}
function Tn(t) {
  return !ni(t);
}
function ni(t) {
  return Ku(t) || t === null;
}
function i4(t, e) {
  if (!t)
    throw new Error(e ? `Unexpected type, expected '${e}'` : "Unexpected type");
}
function Fc(t) {
  return wv(t != null, "Argument is `undefined` or `null`."), t;
}
const sA = Object.prototype.hasOwnProperty;
function n4(t) {
  if (!ri(t))
    return !1;
  for (const e in t)
    if (sA.call(t, e))
      return !1;
  return !0;
}
function r4(t) {
  return typeof t == "function";
}
function oA(t, e) {
  const i = Math.min(t.length, e.length);
  for (let n = 0; n < i; n++)
    s4(t[n], e[n]);
}
function s4(t, e) {
  if (it(e)) {
    if (typeof t !== e)
      throw new Error(`argument does not match constraint: typeof ${e}`);
  } else if (r4(e)) {
    try {
      if (t instanceof e)
        return;
    } catch {
    }
    if (!ni(t) && t.constructor === e || e.length === 1 && e.call(void 0, t) === !0)
      return;
    throw new Error(
      "argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true"
    );
  }
}
var Oi;
(function(t) {
  function e(Q) {
    return !!Q && typeof Q == "object" && typeof Q[Symbol.iterator] == "function";
  }
  t.is = e;
  const i = Object.freeze([]);
  function n() {
    return i;
  }
  t.empty = n;
  function* r(Q) {
    yield Q;
  }
  t.single = r;
  function s(Q) {
    return e(Q) ? Q : r(Q);
  }
  t.wrap = s;
  function o(Q) {
    return Q || i;
  }
  t.from = o;
  function* a(Q) {
    for (let re = Q.length - 1; re >= 0; re--)
      yield Q[re];
  }
  t.reverse = a;
  function l(Q) {
    return !Q || Q[Symbol.iterator]().next().done === !0;
  }
  t.isEmpty = l;
  function c(Q) {
    return Q[Symbol.iterator]().next().value;
  }
  t.first = c;
  function u(Q, re) {
    let K = 0;
    for (const ye of Q)
      if (re(ye, K++))
        return !0;
    return !1;
  }
  t.some = u;
  function d(Q, re) {
    let K = 0;
    for (const ye of Q)
      if (!re(ye, K++))
        return !1;
    return !0;
  }
  t.every = d;
  function f(Q, re) {
    for (const K of Q)
      if (re(K))
        return K;
  }
  t.find = f;
  function* g(Q, re) {
    for (const K of Q)
      re(K) && (yield K);
  }
  t.filter = g;
  function* _(Q, re) {
    let K = 0;
    for (const ye of Q)
      yield re(ye, K++);
  }
  t.map = _;
  function* w(Q, re) {
    let K = 0;
    for (const ye of Q)
      yield* re(ye, K++);
  }
  t.flatMap = w;
  function* v(...Q) {
    for (const re of Q)
      rA(re) ? yield* re : yield re;
  }
  t.concat = v;
  function S(Q, re, K) {
    let ye = K;
    for (const Fe of Q)
      ye = re(ye, Fe);
    return ye;
  }
  t.reduce = S;
  function E(Q) {
    let re = 0;
    for (const K of Q)
      re++;
    return re;
  }
  t.length = E;
  function* A(Q, re, K = Q.length) {
    for (re < -Q.length && (re = 0), re < 0 && (re += Q.length), K < 0 ? K += Q.length : K > Q.length && (K = Q.length); re < K; re++)
      yield Q[re];
  }
  t.slice = A;
  function j(Q, re = Number.POSITIVE_INFINITY) {
    const K = [];
    if (re === 0)
      return [K, Q];
    const ye = Q[Symbol.iterator]();
    for (let Fe = 0; Fe < re; Fe++) {
      const Te = ye.next();
      if (Te.done)
        return [K, t.empty()];
      K.push(Te.value);
    }
    return [K, { [Symbol.iterator]() {
      return ye;
    } }];
  }
  t.consume = j;
  async function V(Q) {
    const re = [];
    for await (const K of Q)
      re.push(K);
    return re;
  }
  t.asyncToArray = V;
  async function le(Q) {
    let re = [];
    for await (const K of Q)
      re = re.concat(K);
    return re;
  }
  t.asyncToArrayFlat = le;
})(Oi || (Oi = {}));
function o4(t) {
  return typeof t == "object" && t !== null && typeof t.dispose == "function" && t.dispose.length === 0;
}
function Wn(t) {
  if (Oi.is(t)) {
    const e = [];
    for (const i of t)
      if (i)
        try {
          i.dispose();
        } catch (n) {
          e.push(n);
        }
    if (e.length === 1)
      throw e[0];
    if (e.length > 1)
      throw new AggregateError(e, "Encountered errors while disposing of store");
    return Array.isArray(t) ? [] : t;
  } else if (t)
    return t.dispose(), t;
}
function wx(...t) {
  return Ee(() => Wn(t));
}
function Ee(t) {
  return {
    dispose: vx(() => {
      t();
    })
  };
}
const d_ = class d_ {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = !1;
  }
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this.clear());
  }
  get isDisposed() {
    return this._isDisposed;
  }
  clear() {
    if (this._toDispose.size !== 0)
      try {
        Wn(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
  }
  add(e) {
    if (!e)
      return e;
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._isDisposed ? d_.DISABLE_DISPOSED_WARNING || console.warn(new Error(
      "Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!"
    ).stack) : this._toDispose.add(e), e;
  }
  delete(e) {
    if (e) {
      if (e === this)
        throw new Error("Cannot dispose a disposable on itself!");
      this._toDispose.delete(e), e.dispose();
    }
  }
  deleteAndLeak(e) {
    e && this._toDispose.has(e) && this._toDispose.delete(e);
  }
};
d_.DISABLE_DISPOSED_WARNING = !1;
let De = d_;
var Cc;
let ve = (Cc = class {
  constructor() {
    this._store = new De(), this._store;
  }
  dispose() {
    this._store.dispose();
  }
  _register(e) {
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._store.add(e);
  }
}, Cc.None = Object.freeze({ dispose() {
} }), Cc);
class Ss {
  constructor() {
    this._isDisposed = !1;
  }
  get value() {
    return this._isDisposed ? void 0 : this._value;
  }
  set value(e) {
    this._isDisposed || e === this._value || (this._value?.dispose(), this._value = e);
  }
  clear() {
    this.value = void 0;
  }
  dispose() {
    this._isDisposed = !0, this._value?.dispose(), this._value = void 0;
  }
  clearAndLeak() {
    const e = this._value;
    return this._value = void 0, e;
  }
}
class Ap {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._isDisposed = !1;
  }
  dispose() {
    this._isDisposed = !0, this.clearAndDisposeAll();
  }
  clearAndDisposeAll() {
    if (this._store.size)
      try {
        Wn(this._store.values());
      } finally {
        this._store.clear();
      }
  }
  has(e) {
    return this._store.has(e);
  }
  get size() {
    return this._store.size;
  }
  get(e) {
    return this._store.get(e);
  }
  set(e, i, n = !1) {
    this._isDisposed && console.warn(new Error(
      "Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!"
    ).stack), n || this._store.get(e)?.dispose(), this._store.set(e, i);
  }
  deleteAndDispose(e) {
    this._store.get(e)?.dispose(), this._store.delete(e);
  }
  deleteAndLeak(e) {
    const i = this._store.get(e);
    return this._store.delete(e), i;
  }
  keys() {
    return this._store.keys();
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
}
function a4(t, e) {
  return new aA(t, e);
}
class aA {
  constructor(e, i) {
    this.reducer = e, this.options = i, this.state = {
      flowing: !1,
      ended: !1,
      destroyed: !1
    }, this.buffer = {
      data: [],
      error: []
    }, this.listeners = {
      data: [],
      error: [],
      end: []
    }, this.pendingWritePromises = [];
  }
  pause() {
    this.state.destroyed || (this.state.flowing = !1);
  }
  resume() {
    this.state.destroyed || this.state.flowing || (this.state.flowing = !0, this.flowData(), this.flowErrors(), this.flowEnd());
  }
  write(e) {
    if (!this.state.destroyed) {
      if (this.state.flowing)
        this.emitData(e);
      else if (this.buffer.data.push(e), typeof this.options?.highWaterMark == "number" && this.buffer.data.length > this.options.highWaterMark)
        return new Promise((i) => this.pendingWritePromises.push(i));
    }
  }
  error(e) {
    this.state.destroyed || (this.state.flowing ? this.emitError(e) : this.buffer.error.push(e));
  }
  end(e) {
    this.state.destroyed || (typeof e < "u" && this.write(e), this.state.flowing ? (this.emitEnd(), this.destroy()) : this.state.ended = !0);
  }
  emitData(e) {
    this.listeners.data.slice(0).forEach((i) => i(e));
  }
  emitError(e) {
    this.listeners.error.length === 0 ? Li(e) : this.listeners.error.slice(0).forEach((i) => i(e));
  }
  emitEnd() {
    this.listeners.end.slice(0).forEach((e) => e());
  }
  on(e, i) {
    if (!this.state.destroyed)
      switch (e) {
        case "data":
          this.listeners.data.push(i), this.resume();
          break;
        case "end":
          this.listeners.end.push(i), this.state.flowing && this.flowEnd() && this.destroy();
          break;
        case "error":
          this.listeners.error.push(i), this.state.flowing && this.flowErrors();
          break;
      }
  }
  removeListener(e, i) {
    if (this.state.destroyed)
      return;
    let n;
    switch (e) {
      case "data":
        n = this.listeners.data;
        break;
      case "end":
        n = this.listeners.end;
        break;
      case "error":
        n = this.listeners.error;
        break;
    }
    if (n) {
      const r = n.indexOf(i);
      r >= 0 && n.splice(r, 1);
    }
  }
  flowData() {
    if (this.buffer.data.length === 0)
      return;
    if (typeof this.reducer == "function") {
      const i = this.reducer(this.buffer.data);
      this.emitData(i);
    } else
      for (const i of this.buffer.data)
        this.emitData(i);
    this.buffer.data.length = 0;
    const e = [...this.pendingWritePromises];
    this.pendingWritePromises.length = 0, e.forEach((i) => i());
  }
  flowErrors() {
    if (this.listeners.error.length > 0) {
      for (const e of this.buffer.error)
        this.emitError(e);
      this.buffer.error.length = 0;
    }
  }
  flowEnd() {
    return this.state.ended ? (this.emitEnd(), this.listeners.end.length > 0) : !1;
  }
  destroy() {
    this.state.destroyed || (this.state.destroyed = !0, this.state.ended = !0, this.buffer.data.length = 0, this.buffer.error.length = 0, this.listeners.data.length = 0, this.listeners.error.length = 0, this.listeners.end.length = 0, this.pendingWritePromises.length = 0);
  }
}
function lA(t, e) {
  const i = [];
  let n;
  for (; (n = t.read()) !== null; )
    i.push(n);
  return e(i);
}
function cA(t, e) {
  return new Promise((i, n) => {
    const r = [];
    l4(t, {
      onData: (s) => {
        e && r.push(s);
      },
      onError: (s) => {
        e ? n(s) : i(void 0);
      },
      onEnd: () => {
        i(e ? e(r) : void 0);
      }
    });
  });
}
function l4(t, e, i) {
  t.on("error", (n) => {
    i?.isCancellationRequested || e.onError(n);
  }), t.on("end", () => {
    i?.isCancellationRequested || e.onEnd();
  }), t.on("data", (n) => {
    i?.isCancellationRequested || e.onData(n);
  });
}
function uA(t, e) {
  const i = a4(e);
  return i.end(t), i;
}
const Lu = typeof Buffer < "u", dA = new Vi(() => new Uint8Array(256));
let L1, N1;
class ue {
  static alloc(e) {
    return Lu ? new ue(Buffer.allocUnsafe(e)) : new ue(new Uint8Array(e));
  }
  static wrap(e) {
    return Lu && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new ue(e);
  }
  static fromString(e, i) {
    return !(i?.dontUseNodeBuffer || !1) && Lu ? new ue(Buffer.from(e)) : (L1 || (L1 = new TextEncoder()), new ue(L1.encode(e)));
  }
  static fromByteArray(e) {
    const i = ue.alloc(e.length);
    for (let n = 0, r = e.length; n < r; n++)
      i.buffer[n] = e[n];
    return i;
  }
  static concat(e, i) {
    if (typeof i > "u") {
      i = 0;
      for (let s = 0, o = e.length; s < o; s++)
        i += e[s].byteLength;
    }
    const n = ue.alloc(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s];
      n.set(a, r), r += a.byteLength;
    }
    return n;
  }
  static isNativeBuffer(e) {
    return Lu && Buffer.isBuffer(e);
  }
  constructor(e) {
    this.buffer = e, this.byteLength = this.buffer.byteLength;
  }
  clone() {
    const e = ue.alloc(this.byteLength);
    return e.set(this), e;
  }
  toString() {
    return Lu ? this.buffer.toString() : (N1 || (N1 = new TextDecoder()), N1.decode(this.buffer));
  }
  slice(e, i) {
    return new ue(this.buffer.subarray(e, i));
  }
  set(e, i) {
    if (e instanceof ue)
      this.buffer.set(e.buffer, i);
    else if (e instanceof Uint8Array)
      this.buffer.set(e, i);
    else if (e instanceof ArrayBuffer)
      this.buffer.set(new Uint8Array(e), i);
    else if (ArrayBuffer.isView(e))
      this.buffer.set(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), i);
    else
      throw new Error("Unknown argument 'array'");
  }
  readUInt32BE(e) {
    return Jf(this.buffer, e);
  }
  writeUInt32BE(e, i) {
    Yf(this.buffer, e, i);
  }
  readUInt32LE(e) {
    return gA(this.buffer, e);
  }
  writeUInt32LE(e, i) {
    mA(this.buffer, e, i);
  }
  readUInt8(e) {
    return _A(this.buffer, e);
  }
  writeUInt8(e, i) {
    vA(this.buffer, e, i);
  }
  indexOf(e, i = 0) {
    return hA(this.buffer, e instanceof ue ? e.buffer : e, i);
  }
  equals(e) {
    return this === e ? !0 : this.byteLength !== e.byteLength ? !1 : this.buffer.every((i, n) => i === e.buffer[n]);
  }
}
function hA(t, e, i = 0) {
  const n = e.byteLength, r = t.byteLength;
  if (n === 0)
    return 0;
  if (n === 1)
    return t.indexOf(e[0]);
  if (n > r - i)
    return -1;
  const s = dA.value;
  s.fill(e.length);
  for (let c = 0; c < e.length; c++)
    s[e[c]] = e.length - c - 1;
  let o = i + e.length - 1, a = o, l = -1;
  for (; o < r; )
    if (t[o] === e[a]) {
      if (a === 0) {
        l = o;
        break;
      }
      o--, a--;
    } else
      o += Math.max(e.length - a, s[t[o]]), a = e.length - 1;
  return l;
}
function fA(t, e) {
  return t[e + 0] << 0 >>> 0 | t[e + 1] << 8 >>> 0;
}
function pA(t, e, i) {
  t[i + 0] = e & 255, e = e >>> 8, t[i + 1] = e & 255;
}
function Jf(t, e) {
  return t[e] * 2 ** 24 + t[e + 1] * 2 ** 16 + t[e + 2] * 2 ** 8 + t[e + 3];
}
function Yf(t, e, i) {
  t[i + 3] = e, e = e >>> 8, t[i + 2] = e, e = e >>> 8, t[i + 1] = e, e = e >>> 8, t[i] = e;
}
function gA(t, e) {
  return t[e + 0] << 0 >>> 0 | t[e + 1] << 8 >>> 0 | t[e + 2] << 16 >>> 0 | t[e + 3] << 24 >>> 0;
}
function mA(t, e, i) {
  t[i + 0] = e & 255, e = e >>> 8, t[i + 1] = e & 255, e = e >>> 8, t[i + 2] = e & 255, e = e >>> 8, t[i + 3] = e & 255;
}
function _A(t, e) {
  return t[e];
}
function vA(t, e, i) {
  t[i] = e;
}
function wA(t) {
  return lA(t, (e) => ue.concat(e));
}
function bA(t) {
  return uA(t, (e) => ue.concat(e));
}
function Uc(t) {
  let e = 0, i = 0, n = 0;
  const r = new Uint8Array(Math.floor(t.length / 4 * 3)), s = (a) => {
    switch (i) {
      case 3:
        r[n++] = e | a, i = 0;
        break;
      case 2:
        r[n++] = e | a >>> 2, e = a << 6, i = 3;
        break;
      case 1:
        r[n++] = e | a >>> 4, e = a << 4, i = 2;
        break;
      default:
        e = a << 2, i = 1;
    }
  };
  for (let a = 0; a < t.length; a++) {
    const l = t.charCodeAt(a);
    if (l >= 65 && l <= 90)
      s(l - 65);
    else if (l >= 97 && l <= 122)
      s(l - 97 + 26);
    else if (l >= 48 && l <= 57)
      s(l - 48 + 52);
    else if (l === 43 || l === 45)
      s(62);
    else if (l === 47 || l === 95)
      s(63);
    else {
      if (l === 61)
        break;
      throw new SyntaxError(`Unexpected base64 character ${t[a]}`);
    }
  }
  const o = n;
  for (; i > 0; )
    s(0);
  return ue.wrap(r).slice(0, o);
}
const yA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", xA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
function U_({ buffer: t }, e = !0, i = !1) {
  const n = i ? xA : yA;
  let r = "";
  const s = t.byteLength % 3;
  let o = 0;
  for (; o < t.byteLength - s; o += 3) {
    const a = t[o + 0], l = t[o + 1], c = t[o + 2];
    r += n[a >>> 2], r += n[(a << 4 | l >>> 4) & 63], r += n[(l << 2 | c >>> 6) & 63], r += n[c & 63];
  }
  if (s === 1) {
    const a = t[o + 0];
    r += n[a >>> 2], r += n[a << 4 & 63], e && (r += "==");
  } else if (s === 2) {
    const a = t[o + 0], l = t[o + 1];
    r += n[a >>> 2], r += n[(a << 4 | l >>> 4) & 63], r += n[l << 2 & 63], e && (r += "=");
  }
  return r;
}
const jE = "0123456789abcdef";
function c4({ buffer: t }) {
  let e = "";
  for (let i = 0; i < t.length; i++) {
    const n = t[i];
    e += jE[n >>> 4], e += jE[n & 15];
  }
  return e;
}
function EA(t) {
  if (t.length % 2 !== 0)
    throw new SyntaxError("Hex string must have an even length");
  const e = new Uint8Array(t.length >> 1);
  for (let i = 0; i < t.length; )
    e[i >> 1] = GE(t, i++) << 4 | GE(t, i++);
  return ue.wrap(e);
}
function GE(t, e) {
  const i = t.charCodeAt(e);
  if (i >= 48 && i <= 57)
    return i - 48;
  if (i >= 97 && i <= 102)
    return i - 87;
  if (i >= 65 && i <= 70)
    return i - 55;
  throw new SyntaxError(`Invalid hex character at position ${e}`);
}
var As;
let qt = (As = class {
  constructor(e) {
    this.element = e, this.next = As.Undefined, this.prev = As.Undefined;
  }
}, As.Undefined = new As(void 0), As);
class Ro {
  constructor() {
    this._first = qt.Undefined, this._last = qt.Undefined, this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === qt.Undefined;
  }
  clear() {
    let e = this._first;
    for (; e !== qt.Undefined; ) {
      const i = e.next;
      e.prev = qt.Undefined, e.next = qt.Undefined, e = i;
    }
    this._first = qt.Undefined, this._last = qt.Undefined, this._size = 0;
  }
  unshift(e) {
    return this._insert(e, !1);
  }
  push(e) {
    return this._insert(e, !0);
  }
  _insert(e, i) {
    const n = new qt(e);
    if (this._first === qt.Undefined)
      this._first = n, this._last = n;
    else if (i) {
      const s = this._last;
      this._last = n, n.prev = s, s.next = n;
    } else {
      const s = this._first;
      this._first = n, n.next = s, s.prev = n;
    }
    this._size += 1;
    let r = !1;
    return () => {
      r || (r = !0, this._remove(n));
    };
  }
  shift() {
    if (this._first !== qt.Undefined) {
      const e = this._first.element;
      return this._remove(this._first), e;
    }
  }
  pop() {
    if (this._last !== qt.Undefined) {
      const e = this._last.element;
      return this._remove(this._last), e;
    }
  }
  _remove(e) {
    if (e.prev !== qt.Undefined && e.next !== qt.Undefined) {
      const i = e.prev;
      i.next = e.next, e.next.prev = i;
    } else e.prev === qt.Undefined && e.next === qt.Undefined ? (this._first = qt.Undefined, this._last = qt.Undefined) : e.next === qt.Undefined ? (this._last = this._last.prev, this._last.next = qt.Undefined) : e.prev === qt.Undefined && (this._first = this._first.next, this._first.prev = qt.Undefined);
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let e = this._first;
    for (; e !== qt.Undefined; )
      yield e.element, e = e.next;
  }
}
const SA = globalThis.performance.now.bind(globalThis.performance);
class Ms {
  static create(e) {
    return new Ms(e);
  }
  constructor(e) {
    this._now = e === !1 ? Date.now : SA, this._startTime = this._now(), this._stopTime = -1;
  }
  stop() {
    this._stopTime = this._now();
  }
  reset() {
    this._startTime = this._now(), this._stopTime = -1;
  }
  elapsed() {
    return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
  }
}
var It;
(function(t) {
  t.None = () => ve.None;
  function e(X, Y) {
    return f(X, () => {
    }, 0, void 0, !0, void 0, Y);
  }
  t.defer = e;
  function i(X) {
    return (Y, Z = null, ie) => {
      let ce = !1, Le;
      return Le = X((Be) => {
        if (!ce)
          return Le ? Le.dispose() : ce = !0, Y.call(Z, Be);
      }, null, ie), ce && Le.dispose(), Le;
    };
  }
  t.once = i;
  function n(X, Y) {
    return t.once(t.filter(X, Y));
  }
  t.onceIf = n;
  function r(X, Y, Z) {
    return u((ie, ce = null, Le) => X((Be) => ie.call(ce, Y(Be)), null, Le), Z);
  }
  t.map = r;
  function s(X, Y, Z) {
    return u((ie, ce = null, Le) => X((Be) => {
      Y(Be), ie.call(ce, Be);
    }, null, Le), Z);
  }
  t.forEach = s;
  function o(X, Y, Z) {
    return u((ie, ce = null, Le) => X((Be) => Y(Be) && ie.call(ce, Be), null, Le), Z);
  }
  t.filter = o;
  function a(X) {
    return X;
  }
  t.signal = a;
  function l(...X) {
    return (Y, Z = null, ie) => {
      const ce = wx(...X.map((Le) => Le((Be) => Y.call(Z, Be))));
      return d(ce, ie);
    };
  }
  t.any = l;
  function c(X, Y, Z, ie) {
    let ce = Z;
    return r(X, (Le) => (ce = Y(ce, Le), ce), ie);
  }
  t.reduce = c;
  function u(X, Y) {
    let Z;
    const ie = {
      onWillAddFirstListener() {
        Z = X(ce.fire, ce);
      },
      onDidRemoveLastListener() {
        Z?.dispose();
      }
    }, ce = new N(ie);
    return Y?.add(ce), ce.event;
  }
  function d(X, Y) {
    return Y instanceof Array ? Y.push(X) : Y && Y.add(X), X;
  }
  function f(X, Y, Z = 100, ie = !1, ce = !1, Le, Be) {
    let qe, St, Jt, ct = 0, $t;
    const ln = {
      leakWarningThreshold: Le,
      onWillAddFirstListener() {
        qe = X((yr) => {
          ct++, St = Y(St, yr), ie && !Jt && (gi.fire(St), St = void 0), $t = () => {
            const Gn = St;
            St = void 0, Jt = void 0, (!ie || ct > 1) && gi.fire(Gn), ct = 0;
          }, typeof Z == "number" ? (Jt && clearTimeout(Jt), Jt = setTimeout($t, Z)) : Jt === void 0 && (Jt = null, queueMicrotask($t));
        });
      },
      onWillRemoveListener() {
        ce && ct > 0 && $t?.();
      },
      onDidRemoveLastListener() {
        $t = void 0, qe.dispose();
      }
    }, gi = new N(ln);
    return Be?.add(gi), gi.event;
  }
  t.debounce = f;
  function g(X, Y = 0, Z) {
    return t.debounce(X, (ie, ce) => ie ? (ie.push(ce), ie) : [ce], Y, void 0, !0, void 0, Z);
  }
  t.accumulate = g;
  function _(X, Y = (ie, ce) => ie === ce, Z) {
    let ie = !0, ce;
    return o(X, (Le) => {
      const Be = ie || !Y(Le, ce);
      return ie = !1, ce = Le, Be;
    }, Z);
  }
  t.latch = _;
  function w(X, Y, Z) {
    return [
      t.filter(X, Y, Z),
      t.filter(X, (ie) => !Y(ie), Z)
    ];
  }
  t.split = w;
  function v(X, Y = !1, Z = [], ie) {
    let ce = Z.slice(), Le = X((St) => {
      ce ? ce.push(St) : qe.fire(St);
    });
    ie && ie.add(Le);
    const Be = () => {
      ce?.forEach((St) => qe.fire(St)), ce = null;
    }, qe = new N({
      onWillAddFirstListener() {
        Le || (Le = X((St) => qe.fire(St)), ie && ie.add(Le));
      },
      onDidAddFirstListener() {
        ce && (Y ? setTimeout(Be) : Be());
      },
      onDidRemoveLastListener() {
        Le && Le.dispose(), Le = null;
      }
    });
    return ie && ie.add(qe), qe.event;
  }
  t.buffer = v;
  function S(X, Y) {
    return (ie, ce, Le) => {
      const Be = Y(new A());
      return X(function(qe) {
        const St = Be.evaluate(qe);
        St !== E && ie.call(ce, St);
      }, void 0, Le);
    };
  }
  t.chain = S;
  const E = Symbol("HaltChainable");
  class A {
    constructor() {
      this.steps = [];
    }
    map(Y) {
      return this.steps.push(Y), this;
    }
    forEach(Y) {
      return this.steps.push((Z) => (Y(Z), Z)), this;
    }
    filter(Y) {
      return this.steps.push((Z) => Y(Z) ? Z : E), this;
    }
    reduce(Y, Z) {
      let ie = Z;
      return this.steps.push((ce) => (ie = Y(ie, ce), ie)), this;
    }
    latch(Y = (Z, ie) => Z === ie) {
      let Z = !0, ie;
      return this.steps.push((ce) => {
        const Le = Z || !Y(ce, ie);
        return Z = !1, ie = ce, Le ? ce : E;
      }), this;
    }
    evaluate(Y) {
      for (const Z of this.steps)
        if (Y = Z(Y), Y === E)
          break;
      return Y;
    }
  }
  function j(X, Y, Z = (ie) => ie) {
    const ie = (...qe) => Be.fire(Z(...qe)), ce = () => X.on(Y, ie), Le = () => X.removeListener(Y, ie), Be = new N(
      { onWillAddFirstListener: ce, onDidRemoveLastListener: Le }
    );
    return Be.event;
  }
  t.fromNodeEventEmitter = j;
  function V(X, Y, Z = (ie) => ie) {
    const ie = (...qe) => Be.fire(Z(...qe)), ce = () => X.addEventListener(Y, ie), Le = () => X.removeEventListener(Y, ie), Be = new N(
      { onWillAddFirstListener: ce, onDidRemoveLastListener: Le }
    );
    return Be.event;
  }
  t.fromDOMEventEmitter = V;
  function le(X, Y) {
    let Z;
    const ie = new Promise((ce, Le) => {
      const Be = i(X)(ce, null, Y);
      Z = () => Be.dispose();
    });
    return ie.cancel = Z, ie;
  }
  t.toPromise = le;
  function Q(X) {
    const Y = new N();
    return X.then((Z) => {
      Y.fire(Z);
    }, () => {
      Y.fire(void 0);
    }).finally(() => {
      Y.dispose();
    }), Y.event;
  }
  t.fromPromise = Q;
  function re(X, Y) {
    return X((Z) => Y.fire(Z));
  }
  t.forward = re;
  function K(X, Y, Z) {
    return Y(Z), X((ie) => Y(ie));
  }
  t.runAndSubscribe = K;
  class ye {
    constructor(Y, Z) {
      this._observable = Y, this._counter = 0, this._hasChanged = !1;
      const ie = {
        onWillAddFirstListener: () => {
          Y.addObserver(this), this._observable.reportChanges();
        },
        onDidRemoveLastListener: () => {
          Y.removeObserver(this);
        }
      };
      this.emitter = new N(ie), Z && Z.add(this.emitter);
    }
    beginUpdate(Y) {
      this._counter++;
    }
    handlePossibleChange(Y) {
    }
    handleChange(Y, Z) {
      this._hasChanged = !0;
    }
    endUpdate(Y) {
      this._counter--, this._counter === 0 && (this._observable.reportChanges(), this._hasChanged && (this._hasChanged = !1, this.emitter.fire(this._observable.get())));
    }
  }
  function Fe(X, Y) {
    return new ye(X, Y).emitter.event;
  }
  t.fromObservable = Fe;
  function Te(X) {
    return (Y, Z, ie) => {
      let ce = 0, Le = !1;
      const Be = {
        beginUpdate() {
          ce++;
        },
        endUpdate() {
          ce--, ce === 0 && (X.reportChanges(), Le && (Le = !1, Y.call(Z)));
        },
        handlePossibleChange() {
        },
        handleChange() {
          Le = !0;
        }
      };
      X.addObserver(Be), X.reportChanges();
      const qe = {
        dispose() {
          X.removeObserver(Be);
        }
      };
      return ie instanceof De ? ie.add(qe) : Array.isArray(ie) && ie.push(qe), qe;
    };
  }
  t.fromObservableLight = Te;
})(It || (It = {}));
const tc = class tc {
  constructor(e) {
    this.listenerCount = 0, this.invocationCount = 0, this.elapsedOverall = 0, this.durations = [], this.name = `${e}_${tc._idPool++}`, tc.all.add(this);
  }
  start(e) {
    this._stopWatch = new Ms(), this.listenerCount = e;
  }
  stop() {
    if (this._stopWatch) {
      const e = this._stopWatch.elapsed();
      this.durations.push(e), this.elapsedOverall += e, this.invocationCount += 1, this._stopWatch = void 0;
    }
  }
};
tc.all = /* @__PURE__ */ new Set(), tc._idPool = 0;
let bv = tc, DA = -1;
const h_ = class h_ {
  constructor(e, i, n = (h_._idPool++).toString(16).padStart(3, "0")) {
    this._errorHandler = e, this.threshold = i, this.name = n, this._warnCountdown = 0;
  }
  dispose() {
    this._stacks?.clear();
  }
  check(e, i) {
    const n = this.threshold;
    if (n <= 0 || i < n)
      return;
    this._stacks || (this._stacks = /* @__PURE__ */ new Map());
    const r = this._stacks.get(e.value) || 0;
    if (this._stacks.set(e.value, r + 1), this._warnCountdown -= 1, this._warnCountdown <= 0) {
      this._warnCountdown = n * 0.5;
      const [s, o] = this.getMostFrequentStack(), a = `[${this.name}] potential listener LEAK detected, having ${i} listeners already. MOST frequent listener (${o}):`;
      console.warn(a), console.warn(s);
      const l = new kA(a, s);
      this._errorHandler(l);
    }
    return () => {
      const s = this._stacks.get(e.value) || 0;
      this._stacks.set(e.value, s - 1);
    };
  }
  getMostFrequentStack() {
    if (!this._stacks)
      return;
    let e, i = 0;
    for (const [n, r] of this._stacks)
      (!e || i < r) && (e = [n, r], i = r);
    return e;
  }
};
h_._idPool = 1;
let yv = h_;
class bx {
  static create() {
    const e = new Error();
    return new bx(e.stack ?? "");
  }
  constructor(e) {
    this.value = e;
  }
  print() {
    console.warn(this.value.split(`
`).slice(2).join(`
`));
  }
}
class kA extends Error {
  constructor(e, i) {
    super(e), this.name = "ListenerLeakError", this.stack = i;
  }
}
class IA extends Error {
  constructor(e, i) {
    super(e), this.name = "ListenerRefusalError", this.stack = i;
  }
}
let CA = 0;
class Xf {
  constructor(e) {
    this.value = e, this.id = CA++;
  }
}
const TA = 2, PA = (t, e) => {
  if (t instanceof Xf)
    e(t);
  else
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      n && e(n);
    }
};
class N {
  constructor(e) {
    this._size = 0, this._options = e, this._leakageMon = this._options?.leakWarningThreshold ? new yv(
      e?.onListenerError ?? Li,
      this._options?.leakWarningThreshold ?? DA
    ) : void 0, this._perfMon = this._options?._profName ? new bv(this._options._profName) : void 0, this._deliveryQueue = this._options?.deliveryQueue;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._deliveryQueue?.current === this && this._deliveryQueue.reset(), this._listeners && (this._listeners = void 0, this._size = 0), this._options?.onDidRemoveLastListener?.(), this._leakageMon?.dispose());
  }
  get event() {
    return this._event ??= (e, i, n) => {
      if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
        const a = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
        console.warn(a);
        const l = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1], c = new IA(
          `${a}. HINT: Stack shows most frequent listener (${l[1]}-times)`,
          l[0]
        );
        return (this._options?.onListenerError || Li)(c), ve.None;
      }
      if (this._disposed)
        return ve.None;
      i && (e = e.bind(i));
      const r = new Xf(e);
      let s;
      this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2) && (r.stack = bx.create(), s = this._leakageMon.check(r.stack, this._size + 1)), this._listeners ? this._listeners instanceof Xf ? (this._deliveryQueue ??= new AA(), this._listeners = [this._listeners, r]) : this._listeners.push(r) : (this._options?.onWillAddFirstListener?.(this), this._listeners = r, this._options?.onDidAddFirstListener?.(this)), this._options?.onDidAddListener?.(this), this._size++;
      const o = Ee(() => {
        s?.(), this._removeListener(r);
      });
      return n instanceof De ? n.add(o) : Array.isArray(n) && n.push(o), o;
    }, this._event;
  }
  _removeListener(e) {
    if (this._options?.onWillRemoveListener?.(this), !this._listeners)
      return;
    if (this._size === 1) {
      this._listeners = void 0, this._options?.onDidRemoveLastListener?.(this), this._size = 0;
      return;
    }
    const i = this._listeners, n = i.indexOf(e);
    if (n === -1)
      throw console.log("disposed?", this._disposed), console.log("size?", this._size), console.log("arr?", JSON.stringify(this._listeners)), new Error("Attempted to dispose unknown listener");
    this._size--, i[n] = void 0;
    const r = this._deliveryQueue.current === this;
    if (this._size * TA <= i.length) {
      let s = 0;
      for (let o = 0; o < i.length; o++)
        i[o] ? i[s++] = i[o] : r && s < this._deliveryQueue.end && (this._deliveryQueue.end--, s < this._deliveryQueue.i && this._deliveryQueue.i--);
      i.length = s;
    }
  }
  _deliver(e, i) {
    if (!e)
      return;
    const n = this._options?.onListenerError || Li;
    if (!n) {
      e.value(i);
      return;
    }
    try {
      e.value(i);
    } catch (r) {
      n(r);
    }
  }
  _deliverQueue(e) {
    const i = e.current._listeners;
    for (; e.i < e.end; )
      this._deliver(i[e.i++], e.value);
    e.reset();
  }
  fire(e) {
    if (this._deliveryQueue?.current && (this._deliverQueue(this._deliveryQueue), this._perfMon?.stop()), this._perfMon?.start(this._size), this._listeners) if (this._listeners instanceof Xf)
      this._deliver(this._listeners, e);
    else {
      const i = this._deliveryQueue;
      i.enqueue(this, e, this._listeners.length), this._deliverQueue(i);
    }
    this._perfMon?.stop();
  }
  hasListeners() {
    return this._size > 0;
  }
}
class AA {
  constructor() {
    this.i = -1, this.end = 0;
  }
  enqueue(e, i, n) {
    this.i = 0, this.end = n, this.current = e, this.value = i;
  }
  reset() {
    this.i = this.end, this.current = void 0, this.value = void 0;
  }
}
class id extends N {
  async fireAsync(e, i, n) {
    if (this._listeners)
      for (this._asyncDeliveryQueue || (this._asyncDeliveryQueue = new Ro()), PA(this._listeners, (r) => this._asyncDeliveryQueue.push([r.value, e])); this._asyncDeliveryQueue.size > 0 && !i.isCancellationRequested; ) {
        const [r, s] = this._asyncDeliveryQueue.shift(), o = [], a = {
          ...s,
          token: i,
          waitUntil: (l) => {
            if (Object.isFrozen(o))
              throw new Error("waitUntil can NOT be called asynchronous");
            n && (l = n(l, r)), o.push(l);
          }
        };
        try {
          r(a);
        } catch (l) {
          Li(l);
          continue;
        }
        await Promise.allSettled(o).then((l) => {
          for (const c of l)
            c.status === "rejected" && Li(c.reason);
        });
      }
  }
}
class Rp extends N {
  get isPaused() {
    return this._isPaused !== 0;
  }
  constructor(e) {
    super(e), this._isPaused = 0, this._eventQueue = new Ro(), this._mergeFn = e?.merge;
  }
  pause() {
    this._isPaused++;
  }
  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0)
      if (this._mergeFn) {
        if (this._eventQueue.size > 0) {
          const e = Array.from(this._eventQueue);
          this._eventQueue.clear(), super.fire(this._mergeFn(e));
        }
      } else
        for (; !this._isPaused && this._eventQueue.size !== 0; )
          super.fire(this._eventQueue.shift());
  }
  fire(e) {
    this._size && (this._isPaused !== 0 ? this._eventQueue.push(e) : super.fire(e));
  }
}
class RA extends Rp {
  constructor(e) {
    super(e), this._delay = e.delay ?? 100;
  }
  fire(e) {
    this._handle || (this.pause(), this._handle = setTimeout(() => {
      this._handle = void 0, this.resume();
    }, this._delay)), super.fire(e);
  }
}
class LA extends N {
  constructor(e) {
    super(e), this._queuedEvents = [], this._mergeFn = e?.merge;
  }
  fire(e) {
    this.hasListeners() && (this._queuedEvents.push(e), this._queuedEvents.length === 1 && queueMicrotask(() => {
      this._mergeFn ? super.fire(this._mergeFn(this._queuedEvents)) : this._queuedEvents.forEach((i) => super.fire(i)), this._queuedEvents = [];
    }));
  }
}
var $d;
(function(t) {
  t[t.Desktop = 1] = "Desktop", t[t.Web = 2] = "Web";
})($d || ($d = {}));
var QE;
(function(t) {
  t[t.VersionMismatch = 55] = "VersionMismatch", t[t.UnexpectedError = 81] = "UnexpectedError";
})(QE || (QE = {}));
var pr;
(function(t) {
  t[t.Initialized = 0] = "Initialized", t[t.Ready = 1] = "Ready", t[t.Terminate = 2] = "Terminate";
})(pr || (pr = {}));
function KE(t) {
  const e = ue.alloc(1);
  switch (t) {
    case pr.Initialized:
      e.writeUInt8(1, 0);
      break;
    case pr.Ready:
      e.writeUInt8(2, 0);
      break;
    case pr.Terminate:
      e.writeUInt8(3, 0);
      break;
  }
  return e;
}
function NA(t, e) {
  if (t.byteLength !== 1)
    return !1;
  switch (t.readUInt8(0)) {
    case 1:
      return e === pr.Initialized;
    case 2:
      return e === pr.Ready;
    case 3:
      return e === pr.Terminate;
    default:
      return !1;
  }
}
var JE;
(function(t) {
  t.Start = "START_NATIVE_LOG", t.End = "END_NATIVE_LOG";
})(JE || (JE = {}));
function M1(t) {
  const e = [];
  typeof t == "number" && e.push("code/timeOrigin", t);
  function i(r, s) {
    e.push(r, s?.startTime ?? Date.now());
  }
  function n() {
    const r = [];
    for (let s = 0; s < e.length; s += 2)
      r.push({
        name: e[s],
        startTime: e[s + 1]
      });
    return r;
  }
  return { mark: i, getMarks: n };
}
function MA() {
  if (typeof performance == "object" && typeof performance.mark == "function" && !performance.nodeTiming)
    return typeof performance.timeOrigin != "number" && !performance.timing ? M1() : {
      mark(t, e) {
        performance.mark(t, e);
      },
      getMarks() {
        let t = performance.timeOrigin;
        typeof t != "number" && (t = (performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart) ?? 0);
        const e = [{ name: "code/timeOrigin", startTime: Math.round(t) }];
        for (const i of performance.getEntriesByType("mark"))
          e.push({
            name: i.name,
            startTime: Math.round(t + i.startTime)
          });
        return e;
      }
    };
  if (typeof process == "object") {
    const t = performance?.timeOrigin;
    return M1(t);
  } else
    return console.trace("perf-util loaded in UNKNOWN environment"), M1();
}
function OA(t) {
  return t.MonacoPerformanceMarks || (t.MonacoPerformanceMarks = MA()), t.MonacoPerformanceMarks;
}
const u4 = OA(globalThis), tn = u4.mark, FA = u4.getMarks;
var L;
(function(t) {
  t[t.Null = 0] = "Null", t[t.Backspace = 8] = "Backspace", t[t.Tab = 9] = "Tab", t[t.LineFeed = 10] = "LineFeed", t[t.CarriageReturn = 13] = "CarriageReturn", t[t.Space = 32] = "Space", t[t.ExclamationMark = 33] = "ExclamationMark", t[t.DoubleQuote = 34] = "DoubleQuote", t[t.Hash = 35] = "Hash", t[t.DollarSign = 36] = "DollarSign", t[t.PercentSign = 37] = "PercentSign", t[t.Ampersand = 38] = "Ampersand", t[t.SingleQuote = 39] = "SingleQuote", t[t.OpenParen = 40] = "OpenParen", t[t.CloseParen = 41] = "CloseParen", t[t.Asterisk = 42] = "Asterisk", t[t.Plus = 43] = "Plus", t[t.Comma = 44] = "Comma", t[t.Dash = 45] = "Dash", t[t.Period = 46] = "Period", t[t.Slash = 47] = "Slash", t[t.Digit0 = 48] = "Digit0", t[t.Digit1 = 49] = "Digit1", t[t.Digit2 = 50] = "Digit2", t[t.Digit3 = 51] = "Digit3", t[t.Digit4 = 52] = "Digit4", t[t.Digit5 = 53] = "Digit5", t[t.Digit6 = 54] = "Digit6", t[t.Digit7 = 55] = "Digit7", t[t.Digit8 = 56] = "Digit8", t[t.Digit9 = 57] = "Digit9", t[t.Colon = 58] = "Colon", t[t.Semicolon = 59] = "Semicolon", t[t.LessThan = 60] = "LessThan", t[t.Equals = 61] = "Equals", t[t.GreaterThan = 62] = "GreaterThan", t[t.QuestionMark = 63] = "QuestionMark", t[t.AtSign = 64] = "AtSign", t[t.A = 65] = "A", t[t.B = 66] = "B", t[t.C = 67] = "C", t[t.D = 68] = "D", t[t.E = 69] = "E", t[t.F = 70] = "F", t[t.G = 71] = "G", t[t.H = 72] = "H", t[t.I = 73] = "I", t[t.J = 74] = "J", t[t.K = 75] = "K", t[t.L = 76] = "L", t[t.M = 77] = "M", t[t.N = 78] = "N", t[t.O = 79] = "O", t[t.P = 80] = "P", t[t.Q = 81] = "Q", t[t.R = 82] = "R", t[t.S = 83] = "S", t[t.T = 84] = "T", t[t.U = 85] = "U", t[t.V = 86] = "V", t[t.W = 87] = "W", t[t.X = 88] = "X", t[t.Y = 89] = "Y", t[t.Z = 90] = "Z", t[t.OpenSquareBracket = 91] = "OpenSquareBracket", t[t.Backslash = 92] = "Backslash", t[t.CloseSquareBracket = 93] = "CloseSquareBracket", t[t.Caret = 94] = "Caret", t[t.Underline = 95] = "Underline", t[t.BackTick = 96] = "BackTick", t[t.a = 97] = "a", t[t.b = 98] = "b", t[t.c = 99] = "c", t[t.d = 100] = "d", t[t.e = 101] = "e", t[t.f = 102] = "f", t[t.g = 103] = "g", t[t.h = 104] = "h", t[t.i = 105] = "i", t[t.j = 106] = "j", t[t.k = 107] = "k", t[t.l = 108] = "l", t[t.m = 109] = "m", t[t.n = 110] = "n", t[t.o = 111] = "o", t[t.p = 112] = "p", t[t.q = 113] = "q", t[t.r = 114] = "r", t[t.s = 115] = "s", t[t.t = 116] = "t", t[t.u = 117] = "u", t[t.v = 118] = "v", t[t.w = 119] = "w", t[t.x = 120] = "x", t[t.y = 121] = "y", t[t.z = 122] = "z", t[t.OpenCurlyBrace = 123] = "OpenCurlyBrace", t[t.Pipe = 124] = "Pipe", t[t.CloseCurlyBrace = 125] = "CloseCurlyBrace", t[t.Tilde = 126] = "Tilde", t[t.NoBreakSpace = 160] = "NoBreakSpace", t[t.U_Combining_Grave_Accent = 768] = "U_Combining_Grave_Accent", t[t.U_Combining_Acute_Accent = 769] = "U_Combining_Acute_Accent", t[t.U_Combining_Circumflex_Accent = 770] = "U_Combining_Circumflex_Accent", t[t.U_Combining_Tilde = 771] = "U_Combining_Tilde", t[t.U_Combining_Macron = 772] = "U_Combining_Macron", t[t.U_Combining_Overline = 773] = "U_Combining_Overline", t[t.U_Combining_Breve = 774] = "U_Combining_Breve", t[t.U_Combining_Dot_Above = 775] = "U_Combining_Dot_Above", t[t.U_Combining_Diaeresis = 776] = "U_Combining_Diaeresis", t[t.U_Combining_Hook_Above = 777] = "U_Combining_Hook_Above", t[t.U_Combining_Ring_Above = 778] = "U_Combining_Ring_Above", t[t.U_Combining_Double_Acute_Accent = 779] = "U_Combining_Double_Acute_Accent", t[t.U_Combining_Caron = 780] = "U_Combining_Caron", t[t.U_Combining_Vertical_Line_Above = 781] = "U_Combining_Vertical_Line_Above", t[t.U_Combining_Double_Vertical_Line_Above = 782] = "U_Combining_Double_Vertical_Line_Above", t[t.U_Combining_Double_Grave_Accent = 783] = "U_Combining_Double_Grave_Accent", t[t.U_Combining_Candrabindu = 784] = "U_Combining_Candrabindu", t[t.U_Combining_Inverted_Breve = 785] = "U_Combining_Inverted_Breve", t[t.U_Combining_Turned_Comma_Above = 786] = "U_Combining_Turned_Comma_Above", t[t.U_Combining_Comma_Above = 787] = "U_Combining_Comma_Above", t[t.U_Combining_Reversed_Comma_Above = 788] = "U_Combining_Reversed_Comma_Above", t[t.U_Combining_Comma_Above_Right = 789] = "U_Combining_Comma_Above_Right", t[t.U_Combining_Grave_Accent_Below = 790] = "U_Combining_Grave_Accent_Below", t[t.U_Combining_Acute_Accent_Below = 791] = "U_Combining_Acute_Accent_Below", t[t.U_Combining_Left_Tack_Below = 792] = "U_Combining_Left_Tack_Below", t[t.U_Combining_Right_Tack_Below = 793] = "U_Combining_Right_Tack_Below", t[t.U_Combining_Left_Angle_Above = 794] = "U_Combining_Left_Angle_Above", t[t.U_Combining_Horn = 795] = "U_Combining_Horn", t[t.U_Combining_Left_Half_Ring_Below = 796] = "U_Combining_Left_Half_Ring_Below", t[t.U_Combining_Up_Tack_Below = 797] = "U_Combining_Up_Tack_Below", t[t.U_Combining_Down_Tack_Below = 798] = "U_Combining_Down_Tack_Below", t[t.U_Combining_Plus_Sign_Below = 799] = "U_Combining_Plus_Sign_Below", t[t.U_Combining_Minus_Sign_Below = 800] = "U_Combining_Minus_Sign_Below", t[t.U_Combining_Palatalized_Hook_Below = 801] = "U_Combining_Palatalized_Hook_Below", t[t.U_Combining_Retroflex_Hook_Below = 802] = "U_Combining_Retroflex_Hook_Below", t[t.U_Combining_Dot_Below = 803] = "U_Combining_Dot_Below", t[t.U_Combining_Diaeresis_Below = 804] = "U_Combining_Diaeresis_Below", t[t.U_Combining_Ring_Below = 805] = "U_Combining_Ring_Below", t[t.U_Combining_Comma_Below = 806] = "U_Combining_Comma_Below", t[t.U_Combining_Cedilla = 807] = "U_Combining_Cedilla", t[t.U_Combining_Ogonek = 808] = "U_Combining_Ogonek", t[t.U_Combining_Vertical_Line_Below = 809] = "U_Combining_Vertical_Line_Below", t[t.U_Combining_Bridge_Below = 810] = "U_Combining_Bridge_Below", t[t.U_Combining_Inverted_Double_Arch_Below = 811] = "U_Combining_Inverted_Double_Arch_Below", t[t.U_Combining_Caron_Below = 812] = "U_Combining_Caron_Below", t[t.U_Combining_Circumflex_Accent_Below = 813] = "U_Combining_Circumflex_Accent_Below", t[t.U_Combining_Breve_Below = 814] = "U_Combining_Breve_Below", t[t.U_Combining_Inverted_Breve_Below = 815] = "U_Combining_Inverted_Breve_Below", t[t.U_Combining_Tilde_Below = 816] = "U_Combining_Tilde_Below", t[t.U_Combining_Macron_Below = 817] = "U_Combining_Macron_Below", t[t.U_Combining_Low_Line = 818] = "U_Combining_Low_Line", t[t.U_Combining_Double_Low_Line = 819] = "U_Combining_Double_Low_Line", t[t.U_Combining_Tilde_Overlay = 820] = "U_Combining_Tilde_Overlay", t[t.U_Combining_Short_Stroke_Overlay = 821] = "U_Combining_Short_Stroke_Overlay", t[t.U_Combining_Long_Stroke_Overlay = 822] = "U_Combining_Long_Stroke_Overlay", t[t.U_Combining_Short_Solidus_Overlay = 823] = "U_Combining_Short_Solidus_Overlay", t[t.U_Combining_Long_Solidus_Overlay = 824] = "U_Combining_Long_Solidus_Overlay", t[t.U_Combining_Right_Half_Ring_Below = 825] = "U_Combining_Right_Half_Ring_Below", t[t.U_Combining_Inverted_Bridge_Below = 826] = "U_Combining_Inverted_Bridge_Below", t[t.U_Combining_Square_Below = 827] = "U_Combining_Square_Below", t[t.U_Combining_Seagull_Below = 828] = "U_Combining_Seagull_Below", t[t.U_Combining_X_Above = 829] = "U_Combining_X_Above", t[t.U_Combining_Vertical_Tilde = 830] = "U_Combining_Vertical_Tilde", t[t.U_Combining_Double_Overline = 831] = "U_Combining_Double_Overline", t[t.U_Combining_Grave_Tone_Mark = 832] = "U_Combining_Grave_Tone_Mark", t[t.U_Combining_Acute_Tone_Mark = 833] = "U_Combining_Acute_Tone_Mark", t[t.U_Combining_Greek_Perispomeni = 834] = "U_Combining_Greek_Perispomeni", t[t.U_Combining_Greek_Koronis = 835] = "U_Combining_Greek_Koronis", t[t.U_Combining_Greek_Dialytika_Tonos = 836] = "U_Combining_Greek_Dialytika_Tonos", t[t.U_Combining_Greek_Ypogegrammeni = 837] = "U_Combining_Greek_Ypogegrammeni", t[t.U_Combining_Bridge_Above = 838] = "U_Combining_Bridge_Above", t[t.U_Combining_Equals_Sign_Below = 839] = "U_Combining_Equals_Sign_Below", t[t.U_Combining_Double_Vertical_Line_Below = 840] = "U_Combining_Double_Vertical_Line_Below", t[t.U_Combining_Left_Angle_Below = 841] = "U_Combining_Left_Angle_Below", t[t.U_Combining_Not_Tilde_Above = 842] = "U_Combining_Not_Tilde_Above", t[t.U_Combining_Homothetic_Above = 843] = "U_Combining_Homothetic_Above", t[t.U_Combining_Almost_Equal_To_Above = 844] = "U_Combining_Almost_Equal_To_Above", t[t.U_Combining_Left_Right_Arrow_Below = 845] = "U_Combining_Left_Right_Arrow_Below", t[t.U_Combining_Upwards_Arrow_Below = 846] = "U_Combining_Upwards_Arrow_Below", t[t.U_Combining_Grapheme_Joiner = 847] = "U_Combining_Grapheme_Joiner", t[t.U_Combining_Right_Arrowhead_Above = 848] = "U_Combining_Right_Arrowhead_Above", t[t.U_Combining_Left_Half_Ring_Above = 849] = "U_Combining_Left_Half_Ring_Above", t[t.U_Combining_Fermata = 850] = "U_Combining_Fermata", t[t.U_Combining_X_Below = 851] = "U_Combining_X_Below", t[t.U_Combining_Left_Arrowhead_Below = 852] = "U_Combining_Left_Arrowhead_Below", t[t.U_Combining_Right_Arrowhead_Below = 853] = "U_Combining_Right_Arrowhead_Below", t[t.U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below = 854] = "U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below", t[t.U_Combining_Right_Half_Ring_Above = 855] = "U_Combining_Right_Half_Ring_Above", t[t.U_Combining_Dot_Above_Right = 856] = "U_Combining_Dot_Above_Right", t[t.U_Combining_Asterisk_Below = 857] = "U_Combining_Asterisk_Below", t[t.U_Combining_Double_Ring_Below = 858] = "U_Combining_Double_Ring_Below", t[t.U_Combining_Zigzag_Above = 859] = "U_Combining_Zigzag_Above", t[t.U_Combining_Double_Breve_Below = 860] = "U_Combining_Double_Breve_Below", t[t.U_Combining_Double_Breve = 861] = "U_Combining_Double_Breve", t[t.U_Combining_Double_Macron = 862] = "U_Combining_Double_Macron", t[t.U_Combining_Double_Macron_Below = 863] = "U_Combining_Double_Macron_Below", t[t.U_Combining_Double_Tilde = 864] = "U_Combining_Double_Tilde", t[t.U_Combining_Double_Inverted_Breve = 865] = "U_Combining_Double_Inverted_Breve", t[t.U_Combining_Double_Rightwards_Arrow_Below = 866] = "U_Combining_Double_Rightwards_Arrow_Below", t[t.U_Combining_Latin_Small_Letter_A = 867] = "U_Combining_Latin_Small_Letter_A", t[t.U_Combining_Latin_Small_Letter_E = 868] = "U_Combining_Latin_Small_Letter_E", t[t.U_Combining_Latin_Small_Letter_I = 869] = "U_Combining_Latin_Small_Letter_I", t[t.U_Combining_Latin_Small_Letter_O = 870] = "U_Combining_Latin_Small_Letter_O", t[t.U_Combining_Latin_Small_Letter_U = 871] = "U_Combining_Latin_Small_Letter_U", t[t.U_Combining_Latin_Small_Letter_C = 872] = "U_Combining_Latin_Small_Letter_C", t[t.U_Combining_Latin_Small_Letter_D = 873] = "U_Combining_Latin_Small_Letter_D", t[t.U_Combining_Latin_Small_Letter_H = 874] = "U_Combining_Latin_Small_Letter_H", t[t.U_Combining_Latin_Small_Letter_M = 875] = "U_Combining_Latin_Small_Letter_M", t[t.U_Combining_Latin_Small_Letter_R = 876] = "U_Combining_Latin_Small_Letter_R", t[t.U_Combining_Latin_Small_Letter_T = 877] = "U_Combining_Latin_Small_Letter_T", t[t.U_Combining_Latin_Small_Letter_V = 878] = "U_Combining_Latin_Small_Letter_V", t[t.U_Combining_Latin_Small_Letter_X = 879] = "U_Combining_Latin_Small_Letter_X", t[t.LINE_SEPARATOR = 8232] = "LINE_SEPARATOR", t[t.PARAGRAPH_SEPARATOR = 8233] = "PARAGRAPH_SEPARATOR", t[t.NEXT_LINE = 133] = "NEXT_LINE", t[t.U_CIRCUMFLEX = 94] = "U_CIRCUMFLEX", t[t.U_GRAVE_ACCENT = 96] = "U_GRAVE_ACCENT", t[t.U_DIAERESIS = 168] = "U_DIAERESIS", t[t.U_MACRON = 175] = "U_MACRON", t[t.U_ACUTE_ACCENT = 180] = "U_ACUTE_ACCENT", t[t.U_CEDILLA = 184] = "U_CEDILLA", t[t.U_MODIFIER_LETTER_LEFT_ARROWHEAD = 706] = "U_MODIFIER_LETTER_LEFT_ARROWHEAD", t[t.U_MODIFIER_LETTER_RIGHT_ARROWHEAD = 707] = "U_MODIFIER_LETTER_RIGHT_ARROWHEAD", t[t.U_MODIFIER_LETTER_UP_ARROWHEAD = 708] = "U_MODIFIER_LETTER_UP_ARROWHEAD", t[t.U_MODIFIER_LETTER_DOWN_ARROWHEAD = 709] = "U_MODIFIER_LETTER_DOWN_ARROWHEAD", t[t.U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING = 722] = "U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING", t[t.U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING = 723] = "U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING", t[t.U_MODIFIER_LETTER_UP_TACK = 724] = "U_MODIFIER_LETTER_UP_TACK", t[t.U_MODIFIER_LETTER_DOWN_TACK = 725] = "U_MODIFIER_LETTER_DOWN_TACK", t[t.U_MODIFIER_LETTER_PLUS_SIGN = 726] = "U_MODIFIER_LETTER_PLUS_SIGN", t[t.U_MODIFIER_LETTER_MINUS_SIGN = 727] = "U_MODIFIER_LETTER_MINUS_SIGN", t[t.U_BREVE = 728] = "U_BREVE", t[t.U_DOT_ABOVE = 729] = "U_DOT_ABOVE", t[t.U_RING_ABOVE = 730] = "U_RING_ABOVE", t[t.U_OGONEK = 731] = "U_OGONEK", t[t.U_SMALL_TILDE = 732] = "U_SMALL_TILDE", t[t.U_DOUBLE_ACUTE_ACCENT = 733] = "U_DOUBLE_ACUTE_ACCENT", t[t.U_MODIFIER_LETTER_RHOTIC_HOOK = 734] = "U_MODIFIER_LETTER_RHOTIC_HOOK", t[t.U_MODIFIER_LETTER_CROSS_ACCENT = 735] = "U_MODIFIER_LETTER_CROSS_ACCENT", t[t.U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR = 741] = "U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR", t[t.U_MODIFIER_LETTER_HIGH_TONE_BAR = 742] = "U_MODIFIER_LETTER_HIGH_TONE_BAR", t[t.U_MODIFIER_LETTER_MID_TONE_BAR = 743] = "U_MODIFIER_LETTER_MID_TONE_BAR", t[t.U_MODIFIER_LETTER_LOW_TONE_BAR = 744] = "U_MODIFIER_LETTER_LOW_TONE_BAR", t[t.U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR = 745] = "U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR", t[t.U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK = 746] = "U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK", t[t.U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK = 747] = "U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK", t[t.U_MODIFIER_LETTER_UNASPIRATED = 749] = "U_MODIFIER_LETTER_UNASPIRATED", t[t.U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD = 751] = "U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD", t[t.U_MODIFIER_LETTER_LOW_UP_ARROWHEAD = 752] = "U_MODIFIER_LETTER_LOW_UP_ARROWHEAD", t[t.U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD = 753] = "U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD", t[t.U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD = 754] = "U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD", t[t.U_MODIFIER_LETTER_LOW_RING = 755] = "U_MODIFIER_LETTER_LOW_RING", t[t.U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT = 756] = "U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT", t[t.U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT = 757] = "U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT", t[t.U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT = 758] = "U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT", t[t.U_MODIFIER_LETTER_LOW_TILDE = 759] = "U_MODIFIER_LETTER_LOW_TILDE", t[t.U_MODIFIER_LETTER_RAISED_COLON = 760] = "U_MODIFIER_LETTER_RAISED_COLON", t[t.U_MODIFIER_LETTER_BEGIN_HIGH_TONE = 761] = "U_MODIFIER_LETTER_BEGIN_HIGH_TONE", t[t.U_MODIFIER_LETTER_END_HIGH_TONE = 762] = "U_MODIFIER_LETTER_END_HIGH_TONE", t[t.U_MODIFIER_LETTER_BEGIN_LOW_TONE = 763] = "U_MODIFIER_LETTER_BEGIN_LOW_TONE", t[t.U_MODIFIER_LETTER_END_LOW_TONE = 764] = "U_MODIFIER_LETTER_END_LOW_TONE", t[t.U_MODIFIER_LETTER_SHELF = 765] = "U_MODIFIER_LETTER_SHELF", t[t.U_MODIFIER_LETTER_OPEN_SHELF = 766] = "U_MODIFIER_LETTER_OPEN_SHELF", t[t.U_MODIFIER_LETTER_LOW_LEFT_ARROW = 767] = "U_MODIFIER_LETTER_LOW_LEFT_ARROW", t[t.U_GREEK_LOWER_NUMERAL_SIGN = 885] = "U_GREEK_LOWER_NUMERAL_SIGN", t[t.U_GREEK_TONOS = 900] = "U_GREEK_TONOS", t[t.U_GREEK_DIALYTIKA_TONOS = 901] = "U_GREEK_DIALYTIKA_TONOS", t[t.U_GREEK_KORONIS = 8125] = "U_GREEK_KORONIS", t[t.U_GREEK_PSILI = 8127] = "U_GREEK_PSILI", t[t.U_GREEK_PERISPOMENI = 8128] = "U_GREEK_PERISPOMENI", t[t.U_GREEK_DIALYTIKA_AND_PERISPOMENI = 8129] = "U_GREEK_DIALYTIKA_AND_PERISPOMENI", t[t.U_GREEK_PSILI_AND_VARIA = 8141] = "U_GREEK_PSILI_AND_VARIA", t[t.U_GREEK_PSILI_AND_OXIA = 8142] = "U_GREEK_PSILI_AND_OXIA", t[t.U_GREEK_PSILI_AND_PERISPOMENI = 8143] = "U_GREEK_PSILI_AND_PERISPOMENI", t[t.U_GREEK_DASIA_AND_VARIA = 8157] = "U_GREEK_DASIA_AND_VARIA", t[t.U_GREEK_DASIA_AND_OXIA = 8158] = "U_GREEK_DASIA_AND_OXIA", t[t.U_GREEK_DASIA_AND_PERISPOMENI = 8159] = "U_GREEK_DASIA_AND_PERISPOMENI", t[t.U_GREEK_DIALYTIKA_AND_VARIA = 8173] = "U_GREEK_DIALYTIKA_AND_VARIA", t[t.U_GREEK_DIALYTIKA_AND_OXIA = 8174] = "U_GREEK_DIALYTIKA_AND_OXIA", t[t.U_GREEK_VARIA = 8175] = "U_GREEK_VARIA", t[t.U_GREEK_OXIA = 8189] = "U_GREEK_OXIA", t[t.U_GREEK_DASIA = 8190] = "U_GREEK_DASIA", t[t.U_IDEOGRAPHIC_FULL_STOP = 12290] = "U_IDEOGRAPHIC_FULL_STOP", t[t.U_LEFT_CORNER_BRACKET = 12300] = "U_LEFT_CORNER_BRACKET", t[t.U_RIGHT_CORNER_BRACKET = 12301] = "U_RIGHT_CORNER_BRACKET", t[t.U_LEFT_BLACK_LENTICULAR_BRACKET = 12304] = "U_LEFT_BLACK_LENTICULAR_BRACKET", t[t.U_RIGHT_BLACK_LENTICULAR_BRACKET = 12305] = "U_RIGHT_BLACK_LENTICULAR_BRACKET", t[t.U_OVERLINE = 8254] = "U_OVERLINE", t[t.UTF8_BOM = 65279] = "UTF8_BOM", t[t.U_FULLWIDTH_SEMICOLON = 65307] = "U_FULLWIDTH_SEMICOLON", t[t.U_FULLWIDTH_COMMA = 65292] = "U_FULLWIDTH_COMMA";
})(L || (L = {}));
var tt;
(function(t) {
  t[t.Uri = 1] = "Uri", t[t.Regexp = 2] = "Regexp", t[t.ScmResource = 3] = "ScmResource", t[t.ScmResourceGroup = 4] = "ScmResourceGroup", t[t.ScmProvider = 5] = "ScmProvider", t[t.CommentController = 6] = "CommentController", t[t.CommentThread = 7] = "CommentThread", t[t.CommentThreadInstance = 8] = "CommentThreadInstance", t[t.CommentThreadReply = 9] = "CommentThreadReply", t[t.CommentNode = 10] = "CommentNode", t[t.CommentThreadNode = 11] = "CommentThreadNode", t[t.TimelineActionContext = 12] = "TimelineActionContext", t[t.NotebookCellActionContext = 13] = "NotebookCellActionContext", t[t.NotebookActionContext = 14] = "NotebookActionContext", t[t.TerminalContext = 15] = "TerminalContext", t[t.TestItemContext = 16] = "TestItemContext", t[t.Date = 17] = "Date", t[t.TestMessageMenuArgs = 18] = "TestMessageMenuArgs", t[t.ChatViewContext = 19] = "ChatViewContext", t[t.LanguageModelToolResult = 20] = "LanguageModelToolResult", t[t.LanguageModelTextPart = 21] = "LanguageModelTextPart", t[t.LanguageModelPromptTsxPart = 22] = "LanguageModelPromptTsxPart", t[t.LanguageModelDataPart = 23] = "LanguageModelDataPart", t[t.ChatSessionContext = 24] = "ChatSessionContext", t[t.ChatResponsePullRequestPart = 25] = "ChatResponsePullRequestPart";
})(tt || (tt = {}));
function UA() {
  return globalThis._VSCODE_NLS_MESSAGES;
}
function d4() {
  return globalThis._VSCODE_NLS_LANGUAGE;
}
const $A = d4() === "pseudo" || typeof document < "u" && document.location && typeof document.location.hash == "string" && document.location.hash.indexOf("pseudo=true") >= 0;
function Lp(t, e) {
  let i;
  return e.length === 0 ? i = t : i = t.replace(/\{(\d+)\}/g, (n, r) => {
    const s = r[0], o = e[s];
    let a = n;
    return typeof o == "string" ? a = o : (typeof o == "number" || typeof o == "boolean" || o === void 0 || o === null) && (a = String(o)), a;
  }), $A && (i = "［" + i.replace(/[aouei]/g, "$&$&") + "］"), i;
}
function h(t, e, ...i) {
  return Lp(typeof t == "number" ? h4(t, e) : e, i);
}
function h4(t, e) {
  const i = UA()?.[t];
  if (typeof i != "string") {
    if (typeof e == "string")
      return e;
    throw new Error(`!!! NLS MISSING: ${t} !!!`);
  }
  return i;
}
function $_(t, e, ...i) {
  let n;
  typeof t == "number" ? n = h4(t, e) : n = e;
  const r = Lp(n, i);
  return {
    value: r,
    original: e === n ? r : Lp(e, i)
  };
}
const ho = "en";
let Hd = !1, Bd = !1, nd = !1, f4 = !1, yx = !1, xx = !1, p4 = !1, g4 = !1, Tf, Zf = ho, YE = ho, HA, os;
const Rs = globalThis;
let pn;
typeof Rs.vscode < "u" && typeof Rs.vscode.process < "u" ? pn = Rs.vscode.process : typeof process < "u" && typeof process?.versions?.node == "string" && (pn = process);
const BA = typeof pn?.versions?.electron == "string", WA = BA && pn?.type === "renderer";
if (typeof pn == "object") {
  Hd = pn.platform === "win32", Bd = pn.platform === "darwin", nd = pn.platform === "linux", nd && pn.env.SNAP && pn.env.SNAP_REVISION, p4 = !!pn.env.CI || !!pn.env.BUILD_ARTIFACTSTAGINGDIRECTORY || !!pn.env.GITHUB_WORKSPACE, Tf = ho, Zf = ho;
  const t = pn.env.VSCODE_NLS_CONFIG;
  if (t)
    try {
      const e = JSON.parse(t);
      Tf = e.userLocale, YE = e.osLocale, Zf = e.resolvedLanguage || ho, HA = e.languagePack?.translationsConfigFile;
    } catch {
    }
  f4 = !0;
} else typeof navigator == "object" && !WA ? (os = navigator.userAgent, Hd = os.indexOf("Windows") >= 0, Bd = os.indexOf("Macintosh") >= 0, xx = (os.indexOf("Macintosh") >= 0 || os.indexOf("iPad") >= 0 || os.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0, nd = os.indexOf("Linux") >= 0, g4 = os?.indexOf("Mobi") >= 0, yx = !0, Zf = d4() || ho, Tf = navigator.language.toLowerCase(), YE = Tf) : console.error("Unable to resolve platform.");
var dr;
(function(t) {
  t[t.Web = 0] = "Web", t[t.Mac = 1] = "Mac", t[t.Linux = 2] = "Linux", t[t.Windows = 3] = "Windows";
})(dr || (dr = {}));
function VA(t) {
  switch (t) {
    case dr.Web:
      return "Web";
    case dr.Mac:
      return "Mac";
    case dr.Linux:
      return "Linux";
    case dr.Windows:
      return "Windows";
  }
}
dr.Web;
Bd ? dr.Mac : Hd ? dr.Windows : nd && dr.Linux;
const ji = Hd, Rn = Bd, So = nd, m4 = f4, af = yx, Wd = yx && typeof Rs.importScripts == "function", zA = Wd ? Rs.origin : void 0, qA = xx, jA = g4, $o = p4, Zr = os, zs = Zf;
var XE;
(function(t) {
  function e() {
    return zs;
  }
  t.value = e;
  function i() {
    return zs.length === 2 ? zs === "en" : zs.length >= 3 ? zs[0] === "e" && zs[1] === "n" && zs[2] === "-" : !1;
  }
  t.isDefaultVariant = i;
  function n() {
    return zs === "en";
  }
  t.isDefault = n;
})(XE || (XE = {}));
const GA = typeof Rs.postMessage == "function" && !Rs.importScripts, _4 = (() => {
  if (GA) {
    const t = [];
    Rs.addEventListener("message", (i) => {
      if (i.data && i.data.vscodeScheduleAsyncWork)
        for (let n = 0, r = t.length; n < r; n++) {
          const s = t[n];
          if (s.id === i.data.vscodeScheduleAsyncWork) {
            t.splice(n, 1), s.callback();
            return;
          }
        }
    });
    let e = 0;
    return (i) => {
      const n = ++e;
      t.push({
        id: n,
        callback: i
      }), Rs.postMessage({ vscodeScheduleAsyncWork: n }, "*");
    };
  }
  return (t) => setTimeout(t);
})();
var zr;
(function(t) {
  t[t.Windows = 1] = "Windows", t[t.Macintosh = 2] = "Macintosh", t[t.Linux = 3] = "Linux";
})(zr || (zr = {}));
const Pf = Bd || xx ? zr.Macintosh : Hd ? zr.Windows : zr.Linux;
let ZE = !0, eS = !1;
function v4() {
  if (!eS) {
    eS = !0;
    const t = new Uint8Array(2);
    t[0] = 1, t[1] = 2, ZE = new Uint16Array(t.buffer)[0] === 513;
  }
  return ZE;
}
const Ex = !!(Zr && Zr.indexOf("Chrome") >= 0), QA = !!(Zr && Zr.indexOf("Firefox") >= 0), KA = !!(!Ex && Zr && Zr.indexOf("Safari") >= 0), w4 = !!(Zr && Zr.indexOf("Edg/") >= 0);
Zr && Zr.indexOf("Android") >= 0;
let Ea;
const O1 = globalThis.vscode;
if (typeof O1 < "u" && typeof O1.process < "u") {
  const t = O1.process;
  Ea = {
    get platform() {
      return t.platform;
    },
    get arch() {
      return t.arch;
    },
    get env() {
      return t.env;
    },
    cwd() {
      return t.cwd();
    }
  };
} else typeof process < "u" && typeof process?.versions?.node == "string" ? Ea = {
  get platform() {
    return process.platform;
  },
  get arch() {
    return process.arch;
  },
  get env() {
    return process.env;
  },
  cwd() {
    return process.env.VSCODE_CWD || process.cwd();
  }
} : Ea = {
  get platform() {
    return ji ? "win32" : Rn ? "darwin" : "linux";
  },
  get arch() {
  },
  get env() {
    return {};
  },
  cwd() {
    return "/";
  }
};
const $c = Ea.cwd, Vd = Ea.env, JA = Ea.platform;
Ea.arch;
const YA = 65, XA = 97, ZA = 90, eR = 122, Sa = 46, Si = 47, dn = 92, is = 58, tR = 63;
class b4 extends Error {
  constructor(e, i, n) {
    let r;
    typeof i == "string" && i.indexOf("not ") === 0 ? (r = "must not be", i = i.replace(/^not /, "")) : r = "must be";
    const s = e.indexOf(".") !== -1 ? "property" : "argument";
    let o = `The "${e}" ${s} ${r} of type ${i}`;
    o += `. Received type ${typeof n}`, super(o), this.code = "ERR_INVALID_ARG_TYPE";
  }
}
function iR(t, e) {
  if (t === null || typeof t != "object")
    throw new b4(e, "Object", t);
}
function ei(t, e) {
  if (typeof t != "string")
    throw new b4(e, "string", t);
}
const br = JA === "win32";
function Ge(t) {
  return t === Si || t === dn;
}
function xv(t) {
  return t === Si;
}
function ns(t) {
  return t >= YA && t <= ZA || t >= XA && t <= eR;
}
function Np(t, e, i, n) {
  let r = "", s = 0, o = -1, a = 0, l = 0;
  for (let c = 0; c <= t.length; ++c) {
    if (c < t.length)
      l = t.charCodeAt(c);
    else {
      if (n(l))
        break;
      l = Si;
    }
    if (n(l)) {
      if (!(o === c - 1 || a === 1)) if (a === 2) {
        if (r.length < 2 || s !== 2 || r.charCodeAt(r.length - 1) !== Sa || r.charCodeAt(r.length - 2) !== Sa) {
          if (r.length > 2) {
            const u = r.lastIndexOf(i);
            u === -1 ? (r = "", s = 0) : (r = r.slice(0, u), s = r.length - 1 - r.lastIndexOf(i)), o = c, a = 0;
            continue;
          } else if (r.length !== 0) {
            r = "", s = 0, o = c, a = 0;
            continue;
          }
        }
        e && (r += r.length > 0 ? `${i}..` : "..", s = 2);
      } else
        r.length > 0 ? r += `${i}${t.slice(o + 1, c)}` : r = t.slice(o + 1, c), s = c - o - 1;
      o = c, a = 0;
    } else l === Sa && a !== -1 ? ++a : a = -1;
  }
  return r;
}
function nR(t) {
  return t ? `${t[0] === "." ? "" : "."}${t}` : "";
}
function y4(t, e) {
  iR(e, "pathObject");
  const i = e.dir || e.root, n = e.base || `${e.name || ""}${nR(e.ext)}`;
  return i ? i === e.root ? `${i}${n}` : `${i}${t}${n}` : n;
}
const Ri = {
  resolve(...t) {
    let e = "", i = "", n = !1;
    for (let r = t.length - 1; r >= -1; r--) {
      let s;
      if (r >= 0) {
        if (s = t[r], ei(s, `paths[${r}]`), s.length === 0)
          continue;
      } else e.length === 0 ? s = $c() : (s = Vd[`=${e}`] || $c(), (s === void 0 || s.slice(0, 2).toLowerCase() !== e.toLowerCase() && s.charCodeAt(2) === dn) && (s = `${e}\\`));
      const o = s.length;
      let a = 0, l = "", c = !1;
      const u = s.charCodeAt(0);
      if (o === 1)
        Ge(u) && (a = 1, c = !0);
      else if (Ge(u))
        if (c = !0, Ge(s.charCodeAt(1))) {
          let d = 2, f = d;
          for (; d < o && !Ge(s.charCodeAt(d)); )
            d++;
          if (d < o && d !== f) {
            const g = s.slice(f, d);
            for (f = d; d < o && Ge(s.charCodeAt(d)); )
              d++;
            if (d < o && d !== f) {
              for (f = d; d < o && !Ge(s.charCodeAt(d)); )
                d++;
              (d === o || d !== f) && (l = `\\\\${g}\\${s.slice(f, d)}`, a = d);
            }
          }
        } else
          a = 1;
      else ns(u) && s.charCodeAt(1) === is && (l = s.slice(0, 2), a = 2, o > 2 && Ge(s.charCodeAt(2)) && (c = !0, a = 3));
      if (l.length > 0)
        if (e.length > 0) {
          if (l.toLowerCase() !== e.toLowerCase())
            continue;
        } else
          e = l;
      if (n) {
        if (e.length > 0)
          break;
      } else if (i = `${s.slice(a)}\\${i}`, n = c, c && e.length > 0)
        break;
    }
    return i = Np(i, !n, "\\", Ge), n ? `${e}\\${i}` : `${e}${i}` || ".";
  },
  normalize(t) {
    ei(t, "path");
    const e = t.length;
    if (e === 0)
      return ".";
    let i = 0, n, r = !1;
    const s = t.charCodeAt(0);
    if (e === 1)
      return xv(s) ? "\\" : t;
    if (Ge(s))
      if (r = !0, Ge(t.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !Ge(t.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          const c = t.slice(l, a);
          for (l = a; a < e && Ge(t.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !Ge(t.charCodeAt(a)); )
              a++;
            if (a === e)
              return `\\\\${c}\\${t.slice(l)}\\`;
            a !== l && (n = `\\\\${c}\\${t.slice(l, a)}`, i = a);
          }
        }
      } else
        i = 1;
    else ns(s) && t.charCodeAt(1) === is && (n = t.slice(0, 2), i = 2, e > 2 && Ge(t.charCodeAt(2)) && (r = !0, i = 3));
    let o = i < e ? Np(t.slice(i), !r, "\\", Ge) : "";
    if (o.length === 0 && !r && (o = "."), o.length > 0 && Ge(t.charCodeAt(e - 1)) && (o += "\\"), !r && n === void 0 && t.includes(":")) {
      if (o.length >= 2 && ns(o.charCodeAt(0)) && o.charCodeAt(1) === is)
        return `.\\${o}`;
      let a = t.indexOf(":");
      do
        if (a === e - 1 || Ge(t.charCodeAt(a + 1)))
          return `.\\${o}`;
      while ((a = t.indexOf(":", a + 1)) !== -1);
    }
    return n === void 0 ? r ? `\\${o}` : o : r ? `${n}\\${o}` : `${n}${o}`;
  },
  isAbsolute(t) {
    ei(t, "path");
    const e = t.length;
    if (e === 0)
      return !1;
    const i = t.charCodeAt(0);
    return Ge(i) || e > 2 && ns(i) && t.charCodeAt(1) === is && Ge(t.charCodeAt(2));
  },
  join(...t) {
    if (t.length === 0)
      return ".";
    let e, i;
    for (let s = 0; s < t.length; ++s) {
      const o = t[s];
      ei(o, "path"), o.length > 0 && (e === void 0 ? e = i = o : e += `\\${o}`);
    }
    if (e === void 0)
      return ".";
    let n = !0, r = 0;
    if (typeof i == "string" && Ge(i.charCodeAt(0))) {
      ++r;
      const s = i.length;
      s > 1 && Ge(i.charCodeAt(1)) && (++r, s > 2 && (Ge(i.charCodeAt(2)) ? ++r : n = !1));
    }
    if (n) {
      for (; r < e.length && Ge(e.charCodeAt(r)); )
        r++;
      r >= 2 && (e = `\\${e.slice(r)}`);
    }
    return Ri.normalize(e);
  },
  relative(t, e) {
    if (ei(t, "from"), ei(e, "to"), t === e)
      return "";
    const i = Ri.resolve(t), n = Ri.resolve(e);
    if (i === n || (t = i.toLowerCase(), e = n.toLowerCase(), t === e))
      return "";
    if (i.length !== t.length || n.length !== e.length) {
      const _ = i.split("\\"), w = n.split("\\");
      _[_.length - 1] === "" && _.pop(), w[w.length - 1] === "" && w.pop();
      const v = _.length, S = w.length, E = v < S ? v : S;
      let A;
      for (A = 0; A < E && _[A].toLowerCase() === w[A].toLowerCase(); A++)
        ;
      return A === 0 ? n : A === E ? S > E ? w.slice(A).join("\\") : v > E ? "..\\".repeat(v - 1 - A) + ".." : "" : "..\\".repeat(v - A) + w.slice(A).join("\\");
    }
    let r = 0;
    for (; r < t.length && t.charCodeAt(r) === dn; )
      r++;
    let s = t.length;
    for (; s - 1 > r && t.charCodeAt(s - 1) === dn; )
      s--;
    const o = s - r;
    let a = 0;
    for (; a < e.length && e.charCodeAt(a) === dn; )
      a++;
    let l = e.length;
    for (; l - 1 > a && e.charCodeAt(l - 1) === dn; )
      l--;
    const c = l - a, u = o < c ? o : c;
    let d = -1, f = 0;
    for (; f < u; f++) {
      const _ = t.charCodeAt(r + f);
      if (_ !== e.charCodeAt(a + f))
        break;
      _ === dn && (d = f);
    }
    if (f !== u) {
      if (d === -1)
        return n;
    } else {
      if (c > u) {
        if (e.charCodeAt(a + f) === dn)
          return n.slice(a + f + 1);
        if (f === 2)
          return n.slice(a + f);
      }
      o > u && (t.charCodeAt(r + f) === dn ? d = f : f === 2 && (d = 3)), d === -1 && (d = 0);
    }
    let g = "";
    for (f = r + d + 1; f <= s; ++f)
      (f === s || t.charCodeAt(f) === dn) && (g += g.length === 0 ? ".." : "\\..");
    return a += d, g.length > 0 ? `${g}${n.slice(a, l)}` : (n.charCodeAt(a) === dn && ++a, n.slice(a, l));
  },
  toNamespacedPath(t) {
    if (typeof t != "string" || t.length === 0)
      return t;
    const e = Ri.resolve(t);
    if (e.length <= 2)
      return t;
    if (e.charCodeAt(0) === dn) {
      if (e.charCodeAt(1) === dn) {
        const i = e.charCodeAt(2);
        if (i !== tR && i !== Sa)
          return `\\\\?\\UNC\\${e.slice(2)}`;
      }
    } else if (ns(e.charCodeAt(0)) && e.charCodeAt(1) === is && e.charCodeAt(2) === dn)
      return `\\\\?\\${e}`;
    return e;
  },
  dirname(t) {
    ei(t, "path");
    const e = t.length;
    if (e === 0)
      return ".";
    let i = -1, n = 0;
    const r = t.charCodeAt(0);
    if (e === 1)
      return Ge(r) ? t : ".";
    if (Ge(r)) {
      if (i = n = 1, Ge(t.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !Ge(t.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          for (l = a; a < e && Ge(t.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !Ge(t.charCodeAt(a)); )
              a++;
            if (a === e)
              return t;
            a !== l && (i = n = a + 1);
          }
        }
      }
    } else ns(r) && t.charCodeAt(1) === is && (i = e > 2 && Ge(t.charCodeAt(2)) ? 3 : 2, n = i);
    let s = -1, o = !0;
    for (let a = e - 1; a >= n; --a)
      if (Ge(t.charCodeAt(a))) {
        if (!o) {
          s = a;
          break;
        }
      } else
        o = !1;
    if (s === -1) {
      if (i === -1)
        return ".";
      s = i;
    }
    return t.slice(0, s);
  },
  basename(t, e) {
    e !== void 0 && ei(e, "suffix"), ei(t, "path");
    let i = 0, n = -1, r = !0, s;
    if (t.length >= 2 && ns(t.charCodeAt(0)) && t.charCodeAt(1) === is && (i = 2), e !== void 0 && e.length > 0 && e.length <= t.length) {
      if (e === t)
        return "";
      let o = e.length - 1, a = -1;
      for (s = t.length - 1; s >= i; --s) {
        const l = t.charCodeAt(s);
        if (Ge(l)) {
          if (!r) {
            i = s + 1;
            break;
          }
        } else
          a === -1 && (r = !1, a = s + 1), o >= 0 && (l === e.charCodeAt(o) ? --o === -1 && (n = s) : (o = -1, n = a));
      }
      return i === n ? n = a : n === -1 && (n = t.length), t.slice(i, n);
    }
    for (s = t.length - 1; s >= i; --s)
      if (Ge(t.charCodeAt(s))) {
        if (!r) {
          i = s + 1;
          break;
        }
      } else n === -1 && (r = !1, n = s + 1);
    return n === -1 ? "" : t.slice(i, n);
  },
  extname(t) {
    ei(t, "path");
    let e = 0, i = -1, n = 0, r = -1, s = !0, o = 0;
    t.length >= 2 && t.charCodeAt(1) === is && ns(t.charCodeAt(0)) && (e = n = 2);
    for (let a = t.length - 1; a >= e; --a) {
      const l = t.charCodeAt(a);
      if (Ge(l)) {
        if (!s) {
          n = a + 1;
          break;
        }
        continue;
      }
      r === -1 && (s = !1, r = a + 1), l === Sa ? i === -1 ? i = a : o !== 1 && (o = 1) : i !== -1 && (o = -1);
    }
    return i === -1 || r === -1 || o === 0 || o === 1 && i === r - 1 && i === n + 1 ? "" : t.slice(i, r);
  },
  format: y4.bind(null, "\\"),
  parse(t) {
    ei(t, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return e;
    const i = t.length;
    let n = 0, r = t.charCodeAt(0);
    if (i === 1)
      return Ge(r) ? (e.root = e.dir = t, e) : (e.base = e.name = t, e);
    if (Ge(r)) {
      if (n = 1, Ge(t.charCodeAt(1))) {
        let d = 2, f = d;
        for (; d < i && !Ge(t.charCodeAt(d)); )
          d++;
        if (d < i && d !== f) {
          for (f = d; d < i && Ge(t.charCodeAt(d)); )
            d++;
          if (d < i && d !== f) {
            for (f = d; d < i && !Ge(t.charCodeAt(d)); )
              d++;
            d === i ? n = d : d !== f && (n = d + 1);
          }
        }
      }
    } else if (ns(r) && t.charCodeAt(1) === is) {
      if (i <= 2)
        return e.root = e.dir = t, e;
      if (n = 2, Ge(t.charCodeAt(2))) {
        if (i === 3)
          return e.root = e.dir = t, e;
        n = 3;
      }
    }
    n > 0 && (e.root = t.slice(0, n));
    let s = -1, o = n, a = -1, l = !0, c = t.length - 1, u = 0;
    for (; c >= n; --c) {
      if (r = t.charCodeAt(c), Ge(r)) {
        if (!l) {
          o = c + 1;
          break;
        }
        continue;
      }
      a === -1 && (l = !1, a = c + 1), r === Sa ? s === -1 ? s = c : u !== 1 && (u = 1) : s !== -1 && (u = -1);
    }
    return a !== -1 && (s === -1 || u === 0 || u === 1 && s === a - 1 && s === o + 1 ? e.base = e.name = t.slice(o, a) : (e.name = t.slice(o, s), e.base = t.slice(o, a), e.ext = t.slice(s, a))), o > 0 && o !== n ? e.dir = t.slice(0, o - 1) : e.dir = e.root, e;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
}, rR = (() => {
  if (br) {
    const t = /\\/g;
    return () => {
      const e = $c().replace(t, "/");
      return e.slice(e.indexOf("/"));
    };
  }
  return () => $c();
})(), dt = {
  resolve(...t) {
    let e = "", i = !1;
    for (let n = t.length - 1; n >= 0 && !i; n--) {
      const r = t[n];
      ei(r, `paths[${n}]`), r.length !== 0 && (e = `${r}/${e}`, i = r.charCodeAt(0) === Si);
    }
    if (!i) {
      const n = rR();
      e = `${n}/${e}`, i = n.charCodeAt(0) === Si;
    }
    return e = Np(e, !i, "/", xv), i ? `/${e}` : e.length > 0 ? e : ".";
  },
  normalize(t) {
    if (ei(t, "path"), t.length === 0)
      return ".";
    const e = t.charCodeAt(0) === Si, i = t.charCodeAt(t.length - 1) === Si;
    return t = Np(t, !e, "/", xv), t.length === 0 ? e ? "/" : i ? "./" : "." : (i && (t += "/"), e ? `/${t}` : t);
  },
  isAbsolute(t) {
    return ei(t, "path"), t.length > 0 && t.charCodeAt(0) === Si;
  },
  join(...t) {
    if (t.length === 0)
      return ".";
    const e = [];
    for (let i = 0; i < t.length; ++i) {
      const n = t[i];
      ei(n, "path"), n.length > 0 && e.push(n);
    }
    return e.length === 0 ? "." : dt.normalize(e.join("/"));
  },
  relative(t, e) {
    if (ei(t, "from"), ei(e, "to"), t === e || (t = dt.resolve(t), e = dt.resolve(e), t === e))
      return "";
    const i = 1, n = t.length, r = n - i, s = 1, o = e.length - s, a = r < o ? r : o;
    let l = -1, c = 0;
    for (; c < a; c++) {
      const d = t.charCodeAt(i + c);
      if (d !== e.charCodeAt(s + c))
        break;
      d === Si && (l = c);
    }
    if (c === a)
      if (o > a) {
        if (e.charCodeAt(s + c) === Si)
          return e.slice(s + c + 1);
        if (c === 0)
          return e.slice(s + c);
      } else r > a && (t.charCodeAt(i + c) === Si ? l = c : c === 0 && (l = 0));
    let u = "";
    for (c = i + l + 1; c <= n; ++c)
      (c === n || t.charCodeAt(c) === Si) && (u += u.length === 0 ? ".." : "/..");
    return `${u}${e.slice(s + l)}`;
  },
  toNamespacedPath(t) {
    return t;
  },
  dirname(t) {
    if (ei(t, "path"), t.length === 0)
      return ".";
    const e = t.charCodeAt(0) === Si;
    let i = -1, n = !0;
    for (let r = t.length - 1; r >= 1; --r)
      if (t.charCodeAt(r) === Si) {
        if (!n) {
          i = r;
          break;
        }
      } else
        n = !1;
    return i === -1 ? e ? "/" : "." : e && i === 1 ? "//" : t.slice(0, i);
  },
  basename(t, e) {
    e !== void 0 && ei(e, "suffix"), ei(t, "path");
    let i = 0, n = -1, r = !0, s;
    if (e !== void 0 && e.length > 0 && e.length <= t.length) {
      if (e === t)
        return "";
      let o = e.length - 1, a = -1;
      for (s = t.length - 1; s >= 0; --s) {
        const l = t.charCodeAt(s);
        if (l === Si) {
          if (!r) {
            i = s + 1;
            break;
          }
        } else
          a === -1 && (r = !1, a = s + 1), o >= 0 && (l === e.charCodeAt(o) ? --o === -1 && (n = s) : (o = -1, n = a));
      }
      return i === n ? n = a : n === -1 && (n = t.length), t.slice(i, n);
    }
    for (s = t.length - 1; s >= 0; --s)
      if (t.charCodeAt(s) === Si) {
        if (!r) {
          i = s + 1;
          break;
        }
      } else n === -1 && (r = !1, n = s + 1);
    return n === -1 ? "" : t.slice(i, n);
  },
  extname(t) {
    ei(t, "path");
    let e = -1, i = 0, n = -1, r = !0, s = 0;
    for (let o = t.length - 1; o >= 0; --o) {
      const a = t[o];
      if (a === "/") {
        if (!r) {
          i = o + 1;
          break;
        }
        continue;
      }
      n === -1 && (r = !1, n = o + 1), a === "." ? e === -1 ? e = o : s !== 1 && (s = 1) : e !== -1 && (s = -1);
    }
    return e === -1 || n === -1 || s === 0 || s === 1 && e === n - 1 && e === i + 1 ? "" : t.slice(e, n);
  },
  format: y4.bind(null, "/"),
  parse(t) {
    ei(t, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return e;
    const i = t.charCodeAt(0) === Si;
    let n;
    i ? (e.root = "/", n = 1) : n = 0;
    let r = -1, s = 0, o = -1, a = !0, l = t.length - 1, c = 0;
    for (; l >= n; --l) {
      const u = t.charCodeAt(l);
      if (u === Si) {
        if (!a) {
          s = l + 1;
          break;
        }
        continue;
      }
      o === -1 && (a = !1, o = l + 1), u === Sa ? r === -1 ? r = l : c !== 1 && (c = 1) : r !== -1 && (c = -1);
    }
    if (o !== -1) {
      const u = s === 0 && i ? 1 : s;
      r === -1 || c === 0 || c === 1 && r === o - 1 && r === s + 1 ? e.base = e.name = t.slice(u, o) : (e.name = t.slice(u, r), e.base = t.slice(u, o), e.ext = t.slice(r, o));
    }
    return s > 0 ? e.dir = t.slice(0, s - 1) : i && (e.dir = "/"), e;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
dt.win32 = Ri.win32 = Ri;
dt.posix = Ri.posix = dt;
const Hc = br ? Ri.normalize : dt.normalize, Mp = br ? Ri.isAbsolute : dt.isAbsolute, Ev = br ? Ri.join : dt.join, sR = br ? Ri.resolve : dt.resolve, zd = br ? Ri.relative : dt.relative, cc = br ? Ri.dirname : dt.dirname, mn = br ? Ri.basename : dt.basename, Op = br ? Ri.extname : dt.extname;
br ? Ri.parse : dt.parse;
const Vn = br ? Ri.sep : dt.sep, oR = /^\w[\w\d+.-]*$/, aR = /^\//, lR = /^\/\//;
function cR(t, e) {
  if (!t.scheme && e)
    throw new Error(
      `[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`
    );
  if (t.scheme && !oR.test(t.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.");
  if (t.path) {
    if (t.authority) {
      if (!aR.test(t.path))
        throw new Error(
          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character'
        );
    } else if (lR.test(t.path))
      throw new Error(
        '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")'
      );
  }
}
function uR(t, e) {
  return !t && !e ? "file" : t;
}
function dR(t, e) {
  switch (t) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== ar && (e = ar + e) : e = ar;
      break;
  }
  return e;
}
const Tt = "", ar = "/", hR = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
class x {
  static isUri(e) {
    return e instanceof x ? !0 : !e || typeof e != "object" ? !1 : typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function";
  }
  constructor(e, i, n, r, s, o = !1) {
    typeof e == "object" ? (this.scheme = e.scheme || Tt, this.authority = e.authority || Tt, this.path = e.path || Tt, this.query = e.query || Tt, this.fragment = e.fragment || Tt) : (this.scheme = uR(e, o), this.authority = i || Tt, this.path = dR(this.scheme, n || Tt), this.query = r || Tt, this.fragment = s || Tt, cR(this, o));
  }
  get fsPath() {
    return Fp(this, !1);
  }
  with(e) {
    if (!e)
      return this;
    let { scheme: i, authority: n, path: r, query: s, fragment: o } = e;
    return i === void 0 ? i = this.scheme : i === null && (i = Tt), n === void 0 ? n = this.authority : n === null && (n = Tt), r === void 0 ? r = this.path : r === null && (r = Tt), s === void 0 ? s = this.query : s === null && (s = Tt), o === void 0 ? o = this.fragment : o === null && (o = Tt), i === this.scheme && n === this.authority && r === this.path && s === this.query && o === this.fragment ? this : new Sl(i, n, r, s, o);
  }
  static parse(e, i = !1) {
    const n = hR.exec(e);
    return n ? new Sl(
      n[2] || Tt,
      Af(n[4] || Tt),
      Af(n[5] || Tt),
      Af(n[7] || Tt),
      Af(n[9] || Tt),
      i
    ) : new Sl(Tt, Tt, Tt, Tt, Tt);
  }
  static file(e) {
    let i = Tt;
    if (ji && (e = e.replace(/\\/g, ar)), e[0] === ar && e[1] === ar) {
      const n = e.indexOf(ar, 2);
      n === -1 ? (i = e.substring(2), e = ar) : (i = e.substring(2, n), e = e.substring(n) || ar);
    }
    return new Sl("file", i, e, Tt, Tt);
  }
  static from(e, i) {
    return new Sl(
      e.scheme,
      e.authority,
      e.path,
      e.query,
      e.fragment,
      i
    );
  }
  static joinPath(e, ...i) {
    if (!e.path)
      throw new Error("[UriError]: cannot call joinPath on URI without path");
    let n;
    return ji && e.scheme === "file" ? n = x.file(Ri.join(Fp(e, !0), ...i)).path : n = dt.join(e.path, ...i), e.with({ path: n });
  }
  toString(e = !1) {
    return Dv(this, e);
  }
  toJSON() {
    return this;
  }
  static revive(e) {
    if (e) {
      if (e instanceof x)
        return e;
      {
        const i = new Sl(e);
        return i._formatted = e.external ?? null, i._fsPath = e._sep === x4 ? e.fsPath ?? null : null, i;
      }
    } else return e;
  }
  [Symbol.for("debug.description")]() {
    return `URI(${this.toString()})`;
  }
}
function Sv(t) {
  return !t || typeof t != "object" ? !1 : typeof t.scheme == "string" && (typeof t.authority == "string" || typeof t.authority > "u") && (typeof t.path == "string" || typeof t.path > "u") && (typeof t.query == "string" || typeof t.query > "u") && (typeof t.fragment == "string" || typeof t.fragment > "u");
}
const x4 = ji ? 1 : void 0;
class Sl extends x {
  constructor() {
    super(...arguments), this._formatted = null, this._fsPath = null;
  }
  get fsPath() {
    return this._fsPath || (this._fsPath = Fp(this, !1)), this._fsPath;
  }
  toString(e = !1) {
    return e ? Dv(this, !0) : (this._formatted || (this._formatted = Dv(this, !1)), this._formatted);
  }
  toJSON() {
    const e = {
      $mid: tt.Uri
    };
    return this._fsPath && (e.fsPath = this._fsPath, e._sep = x4), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
  }
}
const E4 = {
  [L.Colon]: "%3A",
  [L.Slash]: "%2F",
  [L.QuestionMark]: "%3F",
  [L.Hash]: "%23",
  [L.OpenSquareBracket]: "%5B",
  [L.CloseSquareBracket]: "%5D",
  [L.AtSign]: "%40",
  [L.ExclamationMark]: "%21",
  [L.DollarSign]: "%24",
  [L.Ampersand]: "%26",
  [L.SingleQuote]: "%27",
  [L.OpenParen]: "%28",
  [L.CloseParen]: "%29",
  [L.Asterisk]: "%2A",
  [L.Plus]: "%2B",
  [L.Comma]: "%2C",
  [L.Semicolon]: "%3B",
  [L.Equals]: "%3D",
  [L.Space]: "%20"
};
function tS(t, e, i) {
  let n, r = -1;
  for (let s = 0; s < t.length; s++) {
    const o = t.charCodeAt(s);
    if (o >= L.a && o <= L.z || o >= L.A && o <= L.Z || o >= L.Digit0 && o <= L.Digit9 || o === L.Dash || o === L.Period || o === L.Underline || o === L.Tilde || e && o === L.Slash || i && o === L.OpenSquareBracket || i && o === L.CloseSquareBracket || i && o === L.Colon)
      r !== -1 && (n += encodeURIComponent(t.substring(r, s)), r = -1), n !== void 0 && (n += t.charAt(s));
    else {
      n === void 0 && (n = t.substr(0, s));
      const a = E4[o];
      a !== void 0 ? (r !== -1 && (n += encodeURIComponent(t.substring(r, s)), r = -1), n += a) : r === -1 && (r = s);
    }
  }
  return r !== -1 && (n += encodeURIComponent(t.substring(r))), n !== void 0 ? n : t;
}
function fR(t) {
  let e;
  for (let i = 0; i < t.length; i++) {
    const n = t.charCodeAt(i);
    n === L.Hash || n === L.QuestionMark ? (e === void 0 && (e = t.substr(0, i)), e += E4[n]) : e !== void 0 && (e += t[i]);
  }
  return e !== void 0 ? e : t;
}
function Fp(t, e) {
  let i;
  return t.authority && t.path.length > 1 && t.scheme === "file" ? i = `//${t.authority}${t.path}` : t.path.charCodeAt(0) === L.Slash && (t.path.charCodeAt(1) >= L.A && t.path.charCodeAt(1) <= L.Z || t.path.charCodeAt(1) >= L.a && t.path.charCodeAt(1) <= L.z) && t.path.charCodeAt(2) === L.Colon ? e ? i = t.path.substr(1) : i = t.path[1].toLowerCase() + t.path.substr(2) : i = t.path, ji && (i = i.replace(/\//g, "\\")), i;
}
function Dv(t, e) {
  const i = e ? fR : tS;
  let n = "", { scheme: r, authority: s, path: o, query: a, fragment: l } = t;
  if (r && (n += r, n += ":"), (s || r === "file") && (n += ar, n += ar), s) {
    let c = s.indexOf("@");
    if (c !== -1) {
      const u = s.substr(0, c);
      s = s.substr(c + 1), c = u.lastIndexOf(":"), c === -1 ? n += i(u, !1, !1) : (n += i(u.substr(0, c), !1, !1), n += ":", n += i(u.substr(c + 1), !1, !0)), n += "@";
    }
    s = s.toLowerCase(), c = s.lastIndexOf(":"), c === -1 ? n += i(s, !1, !0) : (n += i(s.substr(0, c), !1, !0), n += s.substr(c));
  }
  if (o) {
    if (o.length >= 3 && o.charCodeAt(0) === L.Slash && o.charCodeAt(2) === L.Colon) {
      const c = o.charCodeAt(1);
      c >= L.A && c <= L.Z && (o = `/${String.fromCharCode(c + 32)}:${o.substr(3)}`);
    } else if (o.length >= 2 && o.charCodeAt(1) === L.Colon) {
      const c = o.charCodeAt(0);
      c >= L.A && c <= L.Z && (o = `${String.fromCharCode(c + 32)}:${o.substr(2)}`);
    }
    n += i(o, !0, !1);
  }
  return a && (n += "?", n += i(a, !1, !1)), l && (n += "#", n += e ? l : tS(l, !1, !1)), n;
}
function S4(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    return t.length > 3 ? t.substr(0, 3) + S4(t.substr(3)) : t;
  }
}
const iS = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function Af(t) {
  return t.match(iS) ? t.replace(iS, (e) => S4(e)) : t;
}
const f_ = class f_ {
  constructor(e) {
    this._proxyIdentifierBrand = void 0, this.sid = e, this.nid = ++f_.count;
  }
};
f_.count = 0;
let Up = f_;
const D4 = [];
function B(t) {
  const e = new Up(t);
  return D4[e.nid] = e, e;
}
function Rf(t) {
  return D4[t].sid;
}
class zi {
  constructor(e) {
    this.value = e;
  }
}
var nS;
(function(t) {
  t[t.Default = 0] = "Default", t[t.InCenter = 1] = "InCenter", t[t.InCenterIfOutsideViewport = 2] = "InCenterIfOutsideViewport", t[t.AtTop = 3] = "AtTop";
})(nS || (nS = {}));
var xn;
(function(t) {
  t[t.UnknownInput = 0] = "UnknownInput", t[t.TextInput = 1] = "TextInput", t[t.TextDiffInput = 2] = "TextDiffInput", t[t.TextMergeInput = 3] = "TextMergeInput", t[t.NotebookInput = 4] = "NotebookInput", t[t.NotebookDiffInput = 5] = "NotebookDiffInput", t[t.CustomEditorInput = 6] = "CustomEditorInput", t[t.WebviewEditorInput = 7] = "WebviewEditorInput", t[t.TerminalEditorInput = 8] = "TerminalEditorInput", t[t.InteractiveEditorInput = 9] = "InteractiveEditorInput", t[t.ChatEditorInput = 10] = "ChatEditorInput", t[t.MultiDiffEditorInput = 11] = "MultiDiffEditorInput";
})(xn || (xn = {}));
var Ds;
(function(t) {
  t[t.TAB_OPEN = 0] = "TAB_OPEN", t[t.TAB_CLOSE = 1] = "TAB_CLOSE", t[t.TAB_UPDATE = 2] = "TAB_UPDATE", t[t.TAB_MOVE = 3] = "TAB_MOVE";
})(Ds || (Ds = {}));
var rS;
(function(t) {
  t[t.Editable = 0] = "Editable", t[t.SupportsHotExit = 1] = "SupportsHotExit";
})(rS || (rS = {}));
var Vt;
(function(t) {
  t[t.Int8Array = 1] = "Int8Array", t[t.Uint8Array = 2] = "Uint8Array", t[t.Uint8ClampedArray = 3] = "Uint8ClampedArray", t[t.Int16Array = 4] = "Int16Array", t[t.Uint16Array = 5] = "Uint16Array", t[t.Int32Array = 6] = "Int32Array", t[t.Uint32Array = 7] = "Uint32Array", t[t.Float32Array = 8] = "Float32Array", t[t.Float64Array = 9] = "Float64Array", t[t.BigInt64Array = 10] = "BigInt64Array", t[t.BigUint64Array = 11] = "BigUint64Array";
})(Vt || (Vt = {}));
var sS;
(function(t) {
  t[t.Text = 1] = "Text", t[t.Error = 2] = "Error", t[t.Rich = 3] = "Rich";
})(sS || (sS = {}));
var oS;
(function(t) {
  t[t.Default = 0] = "Default", t[t.InCenter = 1] = "InCenter", t[t.InCenterIfOutsideViewport = 2] = "InCenterIfOutsideViewport", t[t.AtTop = 3] = "AtTop";
})(oS || (oS = {}));
var kv;
(function(t) {
  t[t.None = 0] = "None", t[t.Process = 1] = "Process", t[t.Output = 2] = "Output", t[t.Hybrid = 3] = "Hybrid";
})(kv || (kv = {}));
var Ue;
(function(t) {
  t.label = "a", t.kind = "b", t.detail = "c", t.documentation = "d", t.sortText = "e", t.filterText = "f", t.preselect = "g", t.insertText = "h", t.insertTextRules = "i", t.range = "j", t.commitCharacters = "k", t.additionalTextEdits = "l", t.kindModifier = "m", t.commandIdent = "n", t.commandId = "o", t.commandArguments = "p";
})(Ue || (Ue = {}));
var Ul;
(function(t) {
  t.defaultRanges = "a", t.completions = "b", t.isIncomplete = "c", t.duration = "d";
})(Ul || (Ul = {}));
var aS;
(function(t) {
  t[t.Workspace = 0] = "Workspace", t[t.TextDocument = 1] = "TextDocument";
})(aS || (aS = {}));
const ee = {
  MainThreadAuthentication: B("MainThreadAuthentication"),
  MainThreadBulkEdits: B("MainThreadBulkEdits"),
  MainThreadLanguageModels: B("MainThreadLanguageModels"),
  MainThreadEmbeddings: B("MainThreadEmbeddings"),
  MainThreadChatAgents2: B("MainThreadChatAgents2"),
  MainThreadCodeMapper: B("MainThreadCodeMapper"),
  MainThreadLanguageModelTools: B("MainThreadChatSkills"),
  MainThreadClipboard: B("MainThreadClipboard"),
  MainThreadCommands: B("MainThreadCommands"),
  MainThreadComments: B("MainThreadComments"),
  MainThreadConfiguration: B("MainThreadConfiguration"),
  MainThreadConsole: B("MainThreadConsole"),
  MainThreadDebugService: B("MainThreadDebugService"),
  MainThreadDecorations: B("MainThreadDecorations"),
  MainThreadDiagnostics: B("MainThreadDiagnostics"),
  MainThreadDialogs: B("MainThreadDiaglogs"),
  MainThreadDocuments: B("MainThreadDocuments"),
  MainThreadDocumentContentProviders: B("MainThreadDocumentContentProviders"),
  MainThreadTextEditors: B("MainThreadTextEditors"),
  MainThreadEditorInsets: B("MainThreadEditorInsets"),
  MainThreadEditorTabs: B("MainThreadEditorTabs"),
  MainThreadErrors: B("MainThreadErrors"),
  MainThreadTreeViews: B("MainThreadTreeViews"),
  MainThreadDownloadService: B("MainThreadDownloadService"),
  MainThreadLanguageFeatures: B("MainThreadLanguageFeatures"),
  MainThreadLanguages: B("MainThreadLanguages"),
  MainThreadLogger: B("MainThreadLogger"),
  MainThreadMessageService: B("MainThreadMessageService"),
  MainThreadOutputService: B("MainThreadOutputService"),
  MainThreadProgress: B("MainThreadProgress"),
  MainThreadQuickDiff: B("MainThreadQuickDiff"),
  MainThreadQuickOpen: B("MainThreadQuickOpen"),
  MainThreadStatusBar: B("MainThreadStatusBar"),
  MainThreadSecretState: B("MainThreadSecretState"),
  MainThreadStorage: B("MainThreadStorage"),
  MainThreadSpeech: B("MainThreadSpeechProvider"),
  MainThreadTelemetry: B("MainThreadTelemetry"),
  MainThreadTerminalService: B("MainThreadTerminalService"),
  MainThreadTerminalShellIntegration: B("MainThreadTerminalShellIntegration"),
  MainThreadWebviews: B("MainThreadWebviews"),
  MainThreadWebviewPanels: B("MainThreadWebviewPanels"),
  MainThreadWebviewViews: B("MainThreadWebviewViews"),
  MainThreadCustomEditors: B("MainThreadCustomEditors"),
  MainThreadUrls: B("MainThreadUrls"),
  MainThreadUriOpeners: B("MainThreadUriOpeners"),
  MainThreadProfileContentHandlers: B("MainThreadProfileContentHandlers"),
  MainThreadWorkspace: B("MainThreadWorkspace"),
  MainThreadFileSystem: B("MainThreadFileSystem"),
  MainThreadFileSystemEventService: B("MainThreadFileSystemEventService"),
  MainThreadExtensionService: B("MainThreadExtensionService"),
  MainThreadSCM: B("MainThreadSCM"),
  MainThreadSearch: B("MainThreadSearch"),
  MainThreadShare: B("MainThreadShare"),
  MainThreadTask: B("MainThreadTask"),
  MainThreadWindow: B("MainThreadWindow"),
  MainThreadLabelService: B("MainThreadLabelService"),
  MainThreadNotebook: B("MainThreadNotebook"),
  MainThreadNotebookDocuments: B("MainThreadNotebookDocumentsShape"),
  MainThreadNotebookEditors: B("MainThreadNotebookEditorsShape"),
  MainThreadNotebookKernels: B("MainThreadNotebookKernels"),
  MainThreadNotebookRenderers: B("MainThreadNotebookRenderers"),
  MainThreadInteractive: B("MainThreadInteractive"),
  MainThreadTheming: B("MainThreadTheming"),
  MainThreadTunnelService: B("MainThreadTunnelService"),
  MainThreadManagedSockets: B("MainThreadManagedSockets"),
  MainThreadTimeline: B("MainThreadTimeline"),
  MainThreadTesting: B("MainThreadTesting"),
  MainThreadLocalization: B("MainThreadLocalizationShape"),
  MainThreadMcp: B("MainThreadMcpShape"),
  MainThreadAiRelatedInformation: B("MainThreadAiRelatedInformation"),
  MainThreadAiEmbeddingVector: B("MainThreadAiEmbeddingVector"),
  MainThreadChatStatus: B("MainThreadChatStatus"),
  MainThreadAiSettingsSearch: B("MainThreadAiSettingsSearch"),
  MainThreadDataChannels: B("MainThreadDataChannels"),
  MainThreadChatSessions: B("MainThreadChatSessions"),
  MainThreadChatOutputRenderer: B("MainThreadChatOutputRenderer")
}, he = {
  ExtHostCodeMapper: B("ExtHostCodeMapper"),
  ExtHostCommands: B("ExtHostCommands"),
  ExtHostConfiguration: B("ExtHostConfiguration"),
  ExtHostDiagnostics: B("ExtHostDiagnostics"),
  ExtHostDebugService: B("ExtHostDebugService"),
  ExtHostDecorations: B("ExtHostDecorations"),
  ExtHostDocumentsAndEditors: B("ExtHostDocumentsAndEditors"),
  ExtHostDocuments: B("ExtHostDocuments"),
  ExtHostDocumentContentProviders: B("ExtHostDocumentContentProviders"),
  ExtHostDocumentSaveParticipant: B("ExtHostDocumentSaveParticipant"),
  ExtHostEditors: B("ExtHostEditors"),
  ExtHostTreeViews: B("ExtHostTreeViews"),
  ExtHostFileSystem: B("ExtHostFileSystem"),
  ExtHostFileSystemInfo: B("ExtHostFileSystemInfo"),
  ExtHostFileSystemEventService: B("ExtHostFileSystemEventService"),
  ExtHostLanguages: B("ExtHostLanguages"),
  ExtHostLanguageFeatures: B("ExtHostLanguageFeatures"),
  ExtHostQuickOpen: B("ExtHostQuickOpen"),
  ExtHostQuickDiff: B("ExtHostQuickDiff"),
  ExtHostStatusBar: B("ExtHostStatusBar"),
  ExtHostShare: B("ExtHostShare"),
  ExtHostExtensionService: B("ExtHostExtensionService"),
  ExtHostLogLevelServiceShape: B("ExtHostLogLevelServiceShape"),
  ExtHostTerminalService: B("ExtHostTerminalService"),
  ExtHostTerminalShellIntegration: B("ExtHostTerminalShellIntegration"),
  ExtHostSCM: B("ExtHostSCM"),
  ExtHostSearch: B("ExtHostSearch"),
  ExtHostTask: B("ExtHostTask"),
  ExtHostWorkspace: B("ExtHostWorkspace"),
  ExtHostWindow: B("ExtHostWindow"),
  ExtHostWebviews: B("ExtHostWebviews"),
  ExtHostWebviewPanels: B("ExtHostWebviewPanels"),
  ExtHostCustomEditors: B("ExtHostCustomEditors"),
  ExtHostWebviewViews: B("ExtHostWebviewViews"),
  ExtHostEditorInsets: B("ExtHostEditorInsets"),
  ExtHostEditorTabs: B("ExtHostEditorTabs"),
  ExtHostProgress: B("ExtHostProgress"),
  ExtHostComments: B("ExtHostComments"),
  ExtHostSecretState: B("ExtHostSecretState"),
  ExtHostStorage: B("ExtHostStorage"),
  ExtHostUrls: B("ExtHostUrls"),
  ExtHostUriOpeners: B("ExtHostUriOpeners"),
  ExtHostChatOutputRenderer: B("ExtHostChatOutputRenderer"),
  ExtHostProfileContentHandlers: B("ExtHostProfileContentHandlers"),
  ExtHostOutputService: B("ExtHostOutputService"),
  ExtHostLabelService: B("ExtHostLabelService"),
  ExtHostNotebook: B("ExtHostNotebook"),
  ExtHostNotebookDocuments: B("ExtHostNotebookDocuments"),
  ExtHostNotebookEditors: B("ExtHostNotebookEditors"),
  ExtHostNotebookKernels: B("ExtHostNotebookKernels"),
  ExtHostNotebookRenderers: B("ExtHostNotebookRenderers"),
  ExtHostNotebookDocumentSaveParticipant: B("ExtHostNotebookDocumentSaveParticipant"),
  ExtHostInteractive: B("ExtHostInteractive"),
  ExtHostChatAgents2: B("ExtHostChatAgents"),
  ExtHostLanguageModelTools: B("ExtHostChatSkills"),
  ExtHostChatProvider: B("ExtHostChatProvider"),
  ExtHostSpeech: B("ExtHostSpeech"),
  ExtHostEmbeddings: B("ExtHostEmbeddings"),
  ExtHostAiRelatedInformation: B("ExtHostAiRelatedInformation"),
  ExtHostAiEmbeddingVector: B("ExtHostAiEmbeddingVector"),
  ExtHostAiSettingsSearch: B("ExtHostAiSettingsSearch"),
  ExtHostTheming: B("ExtHostTheming"),
  ExtHostTunnelService: B("ExtHostTunnelService"),
  ExtHostManagedSockets: B("ExtHostManagedSockets"),
  ExtHostAuthentication: B("ExtHostAuthentication"),
  ExtHostTimeline: B("ExtHostTimeline"),
  ExtHostTesting: B("ExtHostTesting"),
  ExtHostTelemetry: B("ExtHostTelemetry"),
  ExtHostLocalization: B("ExtHostLocalization"),
  ExtHostMcp: B("ExtHostMcp"),
  ExtHostDataChannels: B("ExtHostDataChannels"),
  ExtHostChatSessions: B("ExtHostChatSessions")
}, k4 = Object.freeze(function(t, e) {
  const i = setTimeout(t.bind(e), 0);
  return { dispose() {
    clearTimeout(i);
  } };
});
var xt;
(function(t) {
  function e(i) {
    return i === t.None || i === t.Cancelled || i instanceof ep ? !0 : !i || typeof i != "object" ? !1 : typeof i.isCancellationRequested == "boolean" && typeof i.onCancellationRequested == "function";
  }
  t.isCancellationToken = e, t.None = Object.freeze({
    isCancellationRequested: !1,
    onCancellationRequested: It.None
  }), t.Cancelled = Object.freeze({
    isCancellationRequested: !0,
    onCancellationRequested: k4
  });
})(xt || (xt = {}));
class ep {
  constructor() {
    this._isCancelled = !1, this._emitter = null;
  }
  cancel() {
    this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? k4 : (this._emitter || (this._emitter = new N()), this._emitter.event);
  }
  dispose() {
    this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
}
class Pt {
  constructor(e) {
    this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
  }
  get token() {
    return this._token || (this._token = new ep()), this._token;
  }
  cancel() {
    this._token ? this._token instanceof ep && this._token.cancel() : this._token = xt.Cancelled;
  }
  dispose(e = !1) {
    e && this.cancel(), this._parentListener?.dispose(), this._token ? this._token instanceof ep && this._token.dispose() : this._token = xt.None;
  }
}
function pR(t) {
  return t;
}
class gR {
  constructor(e, i) {
    this.lastCache = void 0, this.lastArgKey = void 0, typeof e == "function" ? (this._fn = e, this._computeKey = pR) : (this._fn = i, this._computeKey = e.getCacheKey);
  }
  get(e) {
    const i = this._computeKey(e);
    return this.lastArgKey !== i && (this.lastArgKey = i, this.lastCache = this._fn(e)), this.lastCache;
  }
}
var Ii;
(function(t) {
  t[t.MAX_SAFE_SMALL_INTEGER = 1073741824] = "MAX_SAFE_SMALL_INTEGER", t[t.MIN_SAFE_SMALL_INTEGER = -1073741824] = "MIN_SAFE_SMALL_INTEGER", t[t.MAX_UINT_8 = 255] = "MAX_UINT_8", t[t.MAX_UINT_16 = 65535] = "MAX_UINT_16", t[t.MAX_UINT_32 = 4294967295] = "MAX_UINT_32", t[t.UNICODE_SUPPLEMENTARY_PLANE_BEGIN = 65536] = "UNICODE_SUPPLEMENTARY_PLANE_BEGIN";
})(Ii || (Ii = {}));
function lS(t) {
  return t < 0 ? 0 : t > Ii.MAX_UINT_8 ? Ii.MAX_UINT_8 : t | 0;
}
function Dl(t) {
  return t < 0 ? 0 : t > Ii.MAX_UINT_32 ? Ii.MAX_UINT_32 : t | 0;
}
function qd(t) {
  return !t || typeof t != "string" ? !0 : t.trim().length === 0;
}
const mR = /{([^}]+)}/g;
function cS(t, e) {
  return Object.keys(e).length === 0 ? t : t.replace(mR, (i, n) => e[n] ?? i);
}
function Ja(t) {
  return t.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function _R(t, e) {
  let i = 0, n = t.indexOf(e);
  for (; n !== -1; )
    i++, n = t.indexOf(e, n + e.length);
  return i;
}
function vR(t, e) {
  if (!t || !e)
    return t;
  const i = e.length;
  if (i === 0 || t.length === 0)
    return t;
  let n = 0;
  for (; t.indexOf(e, n) === n; )
    n = n + i;
  return t.substring(n);
}
function Iv(t, e) {
  if (!t || !e)
    return t;
  const i = e.length, n = t.length;
  if (i === 0 || n === 0)
    return t;
  let r = n, s = -1;
  for (; s = t.lastIndexOf(e, r - 1), !(s === -1 || s + i !== r); ) {
    if (s === 0)
      return "";
    r = s;
  }
  return t.substring(0, r);
}
function wR(t, e, i = {}) {
  if (!t)
    throw new Error("Cannot create regex from empty string");
  e || (t = Ja(t)), i.wholeWord && (/\B/.test(t.charAt(0)) || (t = "\\b" + t), /\B/.test(t.charAt(t.length - 1)) || (t = t + "\\b"));
  let n = "";
  return i.global && (n += "g"), i.matchCase || (n += "i"), i.multiline && (n += "m"), i.unicode && (n += "u"), new RegExp(t, n);
}
function I4(t) {
  return t.source === "^" || t.source === "^$" || t.source === "$" || t.source === "^\\s*$" ? !1 : !!(t.exec("") && t.lastIndex === 0);
}
function C4(t) {
  return t.split(/\r\n|\r|\n/);
}
function F1(t) {
  for (let e = 0, i = t.length; e < i; e++) {
    const n = t.charCodeAt(e);
    if (n !== L.Space && n !== L.Tab)
      return e;
  }
  return -1;
}
function bR(t, e = t.length - 1) {
  for (let i = e; i >= 0; i--) {
    const n = t.charCodeAt(i);
    if (n !== L.Space && n !== L.Tab)
      return i;
  }
  return -1;
}
function Ya(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function Sx(t, e, i = 0, n = t.length, r = 0, s = e.length) {
  for (; i < n && r < s; i++, r++) {
    const l = t.charCodeAt(i), c = e.charCodeAt(r);
    if (l < c)
      return -1;
    if (l > c)
      return 1;
  }
  const o = n - i, a = s - r;
  return o < a ? -1 : o > a ? 1 : 0;
}
function Cv(t, e) {
  return lf(t, e, 0, t.length, 0, e.length);
}
function lf(t, e, i = 0, n = t.length, r = 0, s = e.length) {
  for (; i < n && r < s; i++, r++) {
    let l = t.charCodeAt(i), c = e.charCodeAt(r);
    if (l === c)
      continue;
    if (l >= 128 || c >= 128)
      return Sx(t.toLowerCase(), e.toLowerCase(), i, n, r, s);
    uS(l) && (l -= 32), uS(c) && (c -= 32);
    const u = l - c;
    if (u !== 0)
      return u;
  }
  const o = n - i, a = s - r;
  return o < a ? -1 : o > a ? 1 : 0;
}
function uS(t) {
  return t >= L.a && t <= L.z;
}
function ca(t, e) {
  return t.length === e.length && lf(t, e) === 0;
}
function Dx(t, e) {
  const i = e.length;
  return e.length > t.length ? !1 : lf(t, e, 0, i) === 0;
}
function yR(t, e) {
  const i = Math.min(t.length, e.length);
  let n;
  for (n = 0; n < i; n++)
    if (t.charCodeAt(n) !== e.charCodeAt(n))
      return n;
  return i;
}
function kx(t) {
  return 55296 <= t && t <= 56319;
}
function T4(t) {
  return 56320 <= t && t <= 57343;
}
function P4(t, e) {
  return (t - 55296 << 10) + (e - 56320) + 65536;
}
function A4(t, e, i) {
  const n = t.charCodeAt(i);
  if (kx(n) && i + 1 < e) {
    const r = t.charCodeAt(i + 1);
    if (T4(r))
      return P4(n, r);
  }
  return n;
}
function xR(t, e) {
  const i = t.charCodeAt(e - 1);
  if (T4(i) && e > 1) {
    const n = t.charCodeAt(e - 2);
    if (kx(n))
      return P4(n, i);
  }
  return i;
}
class ER {
  get offset() {
    return this._offset;
  }
  constructor(e, i = 0) {
    this._str = e, this._len = e.length, this._offset = i;
  }
  setOffset(e) {
    this._offset = e;
  }
  prevCodePoint() {
    const e = xR(this._str, this._offset);
    return this._offset -= e >= Ii.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1, e;
  }
  nextCodePoint() {
    const e = A4(this._str, this._len, this._offset);
    return this._offset += e >= Ii.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1, e;
  }
  eol() {
    return this._offset >= this._len;
  }
}
class SR {
  get offset() {
    return this._iterator.offset;
  }
  constructor(e, i = 0) {
    this._iterator = new ER(e, i);
  }
  nextGraphemeLength() {
    const e = $p.getInstance(), i = this._iterator, n = i.offset;
    let r = e.getGraphemeBreakType(i.nextCodePoint());
    for (; !i.eol(); ) {
      const s = i.offset, o = e.getGraphemeBreakType(i.nextCodePoint());
      if (fS(r, o)) {
        i.setOffset(s);
        break;
      }
      r = o;
    }
    return i.offset - n;
  }
  prevGraphemeLength() {
    const e = $p.getInstance(), i = this._iterator, n = i.offset;
    let r = e.getGraphemeBreakType(i.prevCodePoint());
    for (; i.offset > 0; ) {
      const s = i.offset, o = e.getGraphemeBreakType(i.prevCodePoint());
      if (fS(o, r)) {
        i.setOffset(s);
        break;
      }
      r = o;
    }
    return n - i.offset;
  }
  eol() {
    return this._iterator.eol();
  }
}
function dS(t, e) {
  return new SR(t, e).nextGraphemeLength();
}
let U1;
function DR() {
  return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
}
function R4(t) {
  return U1 || (U1 = DR()), U1.test(t);
}
const kR = /^[\t\n\r\x20-\x7E]*$/;
function IR(t) {
  return kR.test(t);
}
const CR = /[\u2028\u2029]/;
function L4(t) {
  return CR.test(t);
}
const TR = String.fromCharCode(L.UTF8_BOM);
function PR(t) {
  return !!(t && t.length > 0 && t.charCodeAt(0) === L.UTF8_BOM);
}
function hS(t, e = !1) {
  return t ? (e && (t = t.replace(/\\./g, "")), t.toLowerCase() !== t) : !1;
}
function AR(t, e = 1) {
  if (e === 0)
    return "";
  let i = -1;
  do
    i = t.indexOf(`
`, i + 1), e--;
  while (e > 0 && i >= 0);
  return i === -1 ? t : (t[i - 1] === "\r" && i--, t.substr(0, i));
}
function fS(t, e) {
  return t === Ze.Other ? e !== Ze.Extend && e !== Ze.SpacingMark : t === Ze.CR && e === Ze.LF ? !1 : t === Ze.Control || t === Ze.CR || t === Ze.LF || e === Ze.Control || e === Ze.CR || e === Ze.LF ? !0 : !(t === Ze.L && (e === Ze.L || e === Ze.V || e === Ze.LV || e === Ze.LVT) || (t === Ze.LV || t === Ze.V) && (e === Ze.V || e === Ze.T) || (t === Ze.LVT || t === Ze.T) && e === Ze.T || e === Ze.Extend || e === Ze.ZWJ || e === Ze.SpacingMark || t === Ze.Prepend || t === Ze.ZWJ && e === Ze.Extended_Pictographic || t === Ze.Regional_Indicator && e === Ze.Regional_Indicator);
}
var Ze;
(function(t) {
  t[t.Other = 0] = "Other", t[t.Prepend = 1] = "Prepend", t[t.CR = 2] = "CR", t[t.LF = 3] = "LF", t[t.Control = 4] = "Control", t[t.Extend = 5] = "Extend", t[t.Regional_Indicator = 6] = "Regional_Indicator", t[t.SpacingMark = 7] = "SpacingMark", t[t.L = 8] = "L", t[t.V = 9] = "V", t[t.T = 10] = "T", t[t.LV = 11] = "LV", t[t.LVT = 12] = "LVT", t[t.ZWJ = 13] = "ZWJ", t[t.Extended_Pictographic = 14] = "Extended_Pictographic";
})(Ze || (Ze = {}));
const na = class na {
  static getInstance() {
    return na._INSTANCE || (na._INSTANCE = new na()), na._INSTANCE;
  }
  constructor() {
    this._data = RR();
  }
  getGraphemeBreakType(e) {
    if (e < 32)
      return e === L.LineFeed ? Ze.LF : e === L.CarriageReturn ? Ze.CR : Ze.Control;
    if (e < 127)
      return Ze.Other;
    const i = this._data, n = i.length / 3;
    let r = 1;
    for (; r <= n; )
      if (e < i[3 * r])
        r = 2 * r;
      else if (e > i[3 * r + 1])
        r = 2 * r + 1;
      else
        return i[3 * r + 2];
    return Ze.Other;
  }
};
na._INSTANCE = null;
let $p = na;
function RR() {
  return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
var pS;
(function(t) {
  t[t.zwj = 8205] = "zwj", t[t.emojiVariantSelector = 65039] = "emojiVariantSelector", t[t.enclosingKeyCap = 8419] = "enclosingKeyCap", t[t.space = 32] = "space";
})(pS || (pS = {}));
const Ir = class Ir {
  static getInstance(e) {
    return Ir.cache.get(Array.from(e));
  }
  static getLocales() {
    return Ir._locales.value;
  }
  constructor(e) {
    this.confusableDictionary = e;
  }
  isAmbiguous(e) {
    return this.confusableDictionary.has(e);
  }
  containsAmbiguousCharacter(e) {
    for (let i = 0; i < e.length; i++) {
      const n = e.codePointAt(i);
      if (typeof n == "number" && this.isAmbiguous(n))
        return !0;
    }
    return !1;
  }
  getPrimaryConfusable(e) {
    return this.confusableDictionary.get(e);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
};
Ir.ambiguousCharacterData = new Vi(() => JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,1523,96,8242,96,1370,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,118002,50,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,118003,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,118004,52,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,118005,53,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,118006,54,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,118007,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,118008,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,118009,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,117974,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,117975,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71913,67,71922,67,65315,67,8557,67,8450,67,8493,67,117976,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,117977,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,117978,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,117979,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,117980,71,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,117981,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,117983,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,117984,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,118001,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,117982,108,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,117985,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,117986,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,117987,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,118000,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,117988,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,117989,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,117990,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,117991,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,117992,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,117993,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,117994,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,117995,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71910,87,71919,87,117996,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,117997,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,117998,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,71909,90,66293,90,65338,90,8484,90,8488,90,117999,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65283,35,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"cs":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"es":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"fr":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"it":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ja":[8211,45,8218,44,65281,33,8216,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65292,44,65297,49,65307,59],"ko":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pt-BR":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ru":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"zh-hans":[160,32,65374,126,8218,44,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65297,49],"zh-hant":[8211,45,65374,126,8218,44,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89]}')), Ir.cache = new gR({ getCacheKey: JSON.stringify }, (e) => {
  function i(u) {
    const d = /* @__PURE__ */ new Map();
    for (let f = 0; f < u.length; f += 2)
      d.set(u[f], u[f + 1]);
    return d;
  }
  function n(u, d) {
    const f = new Map(u);
    for (const [g, _] of d)
      f.set(g, _);
    return f;
  }
  function r(u, d) {
    if (!u)
      return d;
    const f = /* @__PURE__ */ new Map();
    for (const [g, _] of u)
      d.has(g) && f.set(g, _);
    return f;
  }
  const s = Ir.ambiguousCharacterData.value;
  let o = e.filter((u) => !u.startsWith("_") && u in s);
  o.length === 0 && (o = ["_default"]);
  let a;
  for (const u of o) {
    const d = i(s[u]);
    a = r(a, d);
  }
  const l = i(s._common), c = n(l, a);
  return new Ir(c);
}), Ir._locales = new Vi(() => Object.keys(Ir.ambiguousCharacterData.value).filter((e) => !e.startsWith("_")));
let gS = Ir;
function qs(t) {
  return t === L.Slash || t === L.Backslash;
}
function N4(t) {
  return t.replace(/[\\/]/g, dt.sep);
}
function LR(t) {
  return t.indexOf("/") === -1 && (t = N4(t)), /^[a-zA-Z]:(\/|$)/.test(t) && (t = "/" + t), t;
}
function mS(t, e = dt.sep) {
  if (!t)
    return "";
  const i = t.length, n = t.charCodeAt(0);
  if (qs(n)) {
    if (qs(t.charCodeAt(1)) && !qs(t.charCodeAt(2))) {
      let s = 3;
      const o = s;
      for (; s < i && !qs(t.charCodeAt(s)); s++)
        ;
      if (o !== s && !qs(t.charCodeAt(s + 1))) {
        for (s += 1; s < i; s++)
          if (qs(t.charCodeAt(s)))
            return t.slice(0, s + 1).replace(/[\\/]/g, e);
      }
    }
    return e;
  } else if (M4(n) && t.charCodeAt(1) === L.Colon)
    return qs(t.charCodeAt(2)) ? t.slice(0, 2) + e : t.slice(0, 2);
  let r = t.indexOf("://");
  if (r !== -1) {
    for (r += 3; r < i; r++)
      if (qs(t.charCodeAt(r)))
        return t.slice(0, r + 1);
  }
  return "";
}
function Hp(t, e, i, n = Vn) {
  if (t === e)
    return !0;
  if (!t || !e || e.length > t.length)
    return !1;
  if (i) {
    if (!Dx(t, e))
      return !1;
    if (e.length === t.length)
      return !0;
    let s = e.length;
    return e.charAt(e.length - 1) === n && s--, t.charAt(s) === n;
  }
  return e.charAt(e.length - 1) !== n && (e += n), t.indexOf(e) === 0;
}
function M4(t) {
  return t >= L.A && t <= L.Z || t >= L.a && t <= L.z;
}
function NR(t, e = ji) {
  return e ? M4(t.charCodeAt(0)) && t.charCodeAt(1) === L.Colon : !1;
}
var de;
(function(t) {
  t.inMemory = "inmemory", t.vscode = "vscode", t.internal = "private", t.walkThrough = "walkThrough", t.walkThroughSnippet = "walkThroughSnippet", t.http = "http", t.https = "https", t.file = "file", t.mailto = "mailto", t.untitled = "untitled", t.data = "data", t.command = "command", t.vscodeRemote = "vscode-remote", t.vscodeRemoteResource = "vscode-remote-resource", t.vscodeManagedRemoteResource = "vscode-managed-remote-resource", t.vscodeUserData = "vscode-userdata", t.vscodeCustomEditor = "vscode-custom-editor", t.vscodeNotebookCell = "vscode-notebook-cell", t.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", t.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff", t.vscodeNotebookCellOutput = "vscode-notebook-cell-output", t.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff", t.vscodeNotebookMetadata = "vscode-notebook-metadata", t.vscodeInteractiveInput = "vscode-interactive-input", t.vscodeSettings = "vscode-settings", t.vscodeWorkspaceTrust = "vscode-workspace-trust", t.vscodeTerminal = "vscode-terminal", t.vscodeChatCodeBlock = "vscode-chat-code-block", t.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block", t.vscodeChatEditor = "vscode-chat-editor", t.vscodeChatInput = "chatSessionInput", t.vscodeChatSession = "vscode-chat-session", t.webviewPanel = "webview-panel", t.vscodeWebview = "vscode-webview", t.extension = "extension", t.vscodeFileResource = "vscode-file", t.tmp = "tmp", t.vsls = "vsls", t.vscodeSourceControl = "vscode-scm", t.commentsInput = "comment", t.codeSetting = "code-setting", t.outputChannel = "output", t.accessibleView = "accessible-view";
})(de || (de = {}));
function Tv(t, e) {
  return x.isUri(t) ? ca(t.scheme, e) : Dx(t, e + ":");
}
function MR(t, ...e) {
  return e.some((i) => Tv(t, i));
}
const OR = "tkn";
class FR {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null, this._serverRootPath = "/";
  }
  setPreferredWebSchema(e) {
    this._preferredWebSchema = e;
  }
  setDelegate(e) {
    this._delegate = e;
  }
  setServerRootPath(e, i) {
    this._serverRootPath = dt.join(i ?? "/", $R(e));
  }
  getServerRootPath() {
    return this._serverRootPath;
  }
  get _remoteResourcesPath() {
    return dt.join(this._serverRootPath, de.vscodeRemoteResource);
  }
  set(e, i, n) {
    this._hosts[e] = i, this._ports[e] = n;
  }
  setConnectionToken(e, i) {
    this._connectionTokens[e] = i;
  }
  getPreferredWebSchema() {
    return this._preferredWebSchema;
  }
  rewrite(e) {
    if (this._delegate)
      try {
        return this._delegate(e);
      } catch (a) {
        return Li(a), e;
      }
    const i = e.authority;
    let n = this._hosts[i];
    n && n.indexOf(":") !== -1 && n.indexOf("[") === -1 && (n = `[${n}]`);
    const r = this._ports[i], s = this._connectionTokens[i];
    let o = `path=${encodeURIComponent(e.path)}`;
    return typeof s == "string" && (o += `&${OR}=${encodeURIComponent(s)}`), x.from({
      scheme: af ? this._preferredWebSchema : de.vscodeRemoteResource,
      authority: `${n}:${r}`,
      path: this._remoteResourcesPath,
      query: o
    });
  }
}
const UR = new FR();
function $R(t) {
  return `${t.quality ?? "oss"}-${t.commit ?? "dev"}`;
}
const HR = "vscode-app", ic = class ic {
  constructor() {
    this.staticBrowserUris = new fi(), this.appResourcePathUrls = /* @__PURE__ */ new Map();
  }
  registerAppResourcePathUrl(e, i) {
    this.appResourcePathUrls.set(e, i);
  }
  toUrl(e) {
    let i = this.appResourcePathUrls.get(e);
    return typeof i == "function" && (i = i()), new URL(i ?? e, globalThis.location?.href ?? import.meta.url).toString();
  }
  asBrowserUri(e) {
    const i = this.toUri(e);
    return this.uriToBrowserUri(i);
  }
  uriToBrowserUri(e) {
    return e.scheme === de.vscodeRemote ? UR.rewrite(e) : e.scheme === de.file && (m4 || zA === `${de.vscodeFileResource}://${ic.FALLBACK_AUTHORITY}`) ? e.with({
      scheme: de.vscodeFileResource,
      authority: e.authority || ic.FALLBACK_AUTHORITY,
      query: null,
      fragment: null
    }) : this.staticBrowserUris.get(e) ?? e;
  }
  asFileUri(e) {
    const i = this.toUri(e);
    return this.uriToFileUri(i);
  }
  uriToFileUri(e) {
    return e.scheme === de.vscodeFileResource ? e.with({
      scheme: de.file,
      authority: e.authority !== ic.FALLBACK_AUTHORITY ? e.authority : null,
      query: null,
      fragment: null
    }) : e;
  }
  toUri(e) {
    if (x.isUri(e))
      return e;
    if (globalThis._VSCODE_FILE_ROOT) {
      const i = globalThis._VSCODE_FILE_ROOT;
      if (/^\w[\w\d+.-]*:\/\//.test(i))
        return x.joinPath(x.parse(i, !0), e);
      const n = Ev(i, e);
      return x.file(n);
    }
    return x.parse(this.toUrl(e));
  }
  registerStaticBrowserUri(e, i) {
    return this.staticBrowserUris.set(e, i), Ee(() => {
      this.staticBrowserUris.get(e) === i && this.staticBrowserUris.delete(e);
    });
  }
  getRegisteredBrowserUris() {
    return this.staticBrowserUris.keys();
  }
};
ic.FALLBACK_AUTHORITY = HR;
let Pv = ic;
new Pv();
var _S;
(function(t) {
  const e = /* @__PURE__ */ new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
  ]);
  t.CoopAndCoep = Object.freeze(e.get("3"));
  const i = "vscode-coi";
  function n(s) {
    let o;
    typeof s == "string" ? o = new URL(s).searchParams : s instanceof URL ? o = s.searchParams : x.isUri(s) && (o = new URL(s.toString(!0)).searchParams);
    const a = o?.get(i);
    if (a)
      return e.get(a);
  }
  t.getHeadersFromQuery = n;
  function r(s, o, a) {
    if (!globalThis.crossOriginIsolated)
      return;
    const l = o && a ? "3" : a ? "2" : "1";
    s instanceof URLSearchParams ? s.set(i, l) : s[i] = l;
  }
  t.addSearchParam = r;
})(_S || (_S = {}));
function Xn(t) {
  return Fp(t, !0);
}
class cf {
  constructor(e) {
    this._ignorePathCasing = e;
  }
  compare(e, i, n = !1) {
    return e === i ? 0 : Ya(this.getComparisonKey(e, n), this.getComparisonKey(i, n));
  }
  isEqual(e, i, n = !1) {
    return e === i ? !0 : !e || !i ? !1 : this.getComparisonKey(e, n) === this.getComparisonKey(i, n);
  }
  getComparisonKey(e, i = !1) {
    return e.with({
      path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0,
      fragment: i ? null : void 0
    }).toString();
  }
  ignorePathCasing(e) {
    return this._ignorePathCasing(e);
  }
  isEqualOrParent(e, i, n = !1) {
    if (e.scheme === i.scheme) {
      if (e.scheme === de.file)
        return Hp(Xn(e), Xn(i), this._ignorePathCasing(e)) && e.query === i.query && (n || e.fragment === i.fragment);
      if (vS(e.authority, i.authority))
        return Hp(e.path, i.path, this._ignorePathCasing(e), "/") && e.query === i.query && (n || e.fragment === i.fragment);
    }
    return !1;
  }
  joinPath(e, ...i) {
    return x.joinPath(e, ...i);
  }
  basenameOrAuthority(e) {
    return Fs(e) || e.authority;
  }
  basename(e) {
    return dt.basename(e.path);
  }
  extname(e) {
    return dt.extname(e.path);
  }
  dirname(e) {
    if (e.path.length === 0)
      return e;
    let i;
    return e.scheme === de.file ? i = x.file(cc(Xn(e))).path : (i = dt.dirname(e.path), e.authority && i.length && i.charCodeAt(0) !== L.Slash && (console.error(`dirname("${e.toString})) resulted in a relative path`), i = "/")), e.with({
      path: i
    });
  }
  normalizePath(e) {
    if (!e.path.length)
      return e;
    let i;
    return e.scheme === de.file ? i = x.file(Hc(Xn(e))).path : i = dt.normalize(e.path), e.with({
      path: i
    });
  }
  relativePath(e, i) {
    if (e.scheme !== i.scheme || !vS(e.authority, i.authority))
      return;
    if (e.scheme === de.file) {
      const s = zd(Xn(e), Xn(i));
      return ji ? N4(s) : s;
    }
    let n = e.path || "/";
    const r = i.path || "/";
    if (this._ignorePathCasing(e)) {
      let s = 0;
      for (const o = Math.min(n.length, r.length); s < o && !(n.charCodeAt(s) !== r.charCodeAt(s) && n.charAt(s).toLowerCase() !== r.charAt(s).toLowerCase()); s++)
        ;
      n = r.substr(0, s) + n.substr(s);
    }
    return dt.relative(n, r);
  }
  resolvePath(e, i) {
    if (e.scheme === de.file) {
      const n = x.file(sR(Xn(e), i));
      return e.with({
        authority: n.authority,
        path: n.path
      });
    }
    return i = LR(i), e.with({
      path: dt.resolve(e.path, i)
    });
  }
  isAbsolutePath(e) {
    return !!e.path && e.path[0] === "/";
  }
  isEqualAuthority(e, i) {
    return e === i || e !== void 0 && i !== void 0 && ca(e, i);
  }
  hasTrailingPathSeparator(e, i = Vn) {
    if (e.scheme === de.file) {
      const n = Xn(e);
      return n.length > mS(n).length && n[n.length - 1] === i;
    } else {
      const n = e.path;
      return n.length > 1 && n.charCodeAt(n.length - 1) === L.Slash && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath);
    }
  }
  removeTrailingPathSeparator(e, i = Vn) {
    return wS(e, i) ? e.with({ path: e.path.substr(0, e.path.length - 1) }) : e;
  }
  addTrailingPathSeparator(e, i = Vn) {
    let n = !1;
    if (e.scheme === de.file) {
      const r = Xn(e);
      n = r !== void 0 && r.length === mS(r).length && r[r.length - 1] === i;
    } else {
      i = "/";
      const r = e.path;
      n = r.length === 1 && r.charCodeAt(r.length - 1) === L.Slash;
    }
    return !n && !wS(e, i) ? e.with({ path: e.path + "/" }) : e;
  }
}
const ot = new cf(() => !1), BR = new cf((t) => t.scheme === de.file ? !So : !0), WR = new cf((t) => !0), uc = ot.isEqual.bind(ot);
ot.isEqualOrParent.bind(ot);
ot.getComparisonKey.bind(ot);
const Av = ot.basenameOrAuthority.bind(ot), Fs = ot.basename.bind(ot), VR = ot.extname.bind(ot), H_ = ot.dirname.bind(ot), wi = ot.joinPath.bind(ot);
ot.normalizePath.bind(ot);
const O4 = ot.relativePath.bind(ot);
ot.resolvePath.bind(ot);
const zR = ot.isAbsolutePath.bind(ot), vS = ot.isEqualAuthority.bind(ot), wS = ot.hasTrailingPathSeparator.bind(ot);
ot.removeTrailingPathSeparator.bind(ot);
ot.addTrailingPathSeparator.bind(ot);
var bS;
(function(t) {
  t.META_DATA_LABEL = "label", t.META_DATA_DESCRIPTION = "description", t.META_DATA_SIZE = "size", t.META_DATA_MIME = "mime";
  function e(i) {
    const n = /* @__PURE__ */ new Map();
    i.path.substring(i.path.indexOf(";") + 1, i.path.lastIndexOf(";")).split(";").forEach((o) => {
      const [a, l] = o.split(":");
      a && l && n.set(a, l);
    });
    const s = i.path.substring(0, i.path.indexOf(";"));
    return s && n.set(t.META_DATA_MIME, s), n;
  }
  t.parseMetaData = e;
})(bS || (bS = {}));
const qR = Symbol("MicrotaskDelay");
function Do(t) {
  return !!t && typeof t.then == "function";
}
function jR(t) {
  const e = new Pt(), i = t(e.token);
  let n = !1;
  const r = new Promise((s, o) => {
    const a = e.token.onCancellationRequested(() => {
      n = !0, a.dispose(), o(new zn());
    });
    Promise.resolve(i).then((l) => {
      a.dispose(), e.dispose(), n ? o4(l) && l.dispose() : s(l);
    }, (l) => {
      a.dispose(), e.dispose(), o(l);
    });
  });
  return new class {
    cancel() {
      e.cancel(), e.dispose();
    }
    then(s, o) {
      return r.then(s, o);
    }
    catch(s) {
      return this.then(void 0, s);
    }
    finally(s) {
      return r.finally(s);
    }
  }();
}
function GR(t, e, i) {
  return new Promise((n, r) => {
    const s = e.onCancellationRequested(() => {
      s.dispose(), n(i);
    });
    t.then(n, r).finally(() => s.dispose());
  });
}
function Ix(t, e) {
  return new Promise((i, n) => {
    const r = e.onCancellationRequested(() => {
      r.dispose(), n(new zn());
    });
    t.then(i, n).finally(() => r.dispose());
  });
}
function Ai(t) {
  return new Promise((e, i) => {
    const n = t();
    Do(n) ? n.then(e, i) : e(n);
  });
}
function QR() {
  let t, e;
  return { promise: new Promise((n, r) => {
    t = n, e = r;
  }), resolve: t, reject: e };
}
let KR = class {
  constructor() {
    this.isDisposed = !1, this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null;
  }
  queue(e) {
    if (this.isDisposed)
      return Promise.reject(new Error("Throttler is disposed"));
    if (this.activePromise) {
      if (this.queuedPromiseFactory = e, !this.queuedPromise) {
        const i = () => {
          if (this.queuedPromise = null, this.isDisposed)
            return;
          const n = this.queue(this.queuedPromiseFactory);
          return this.queuedPromiseFactory = null, n;
        };
        this.queuedPromise = new Promise((n) => {
          this.activePromise.then(i, i).then(n);
        });
      }
      return new Promise((i, n) => {
        this.queuedPromise.then(i, n);
      });
    }
    return this.activePromise = e(), new Promise((i, n) => {
      this.activePromise.then((r) => {
        this.activePromise = null, i(r);
      }, (r) => {
        this.activePromise = null, n(r);
      });
    });
  }
  dispose() {
    this.isDisposed = !0;
  }
};
class JR {
  constructor() {
    this.current = Promise.resolve(null);
  }
  queue(e) {
    return this.current = this.current.then(() => e(), () => e());
  }
}
class YR {
  constructor() {
    this.promiseMap = /* @__PURE__ */ new Map();
  }
  queue(e, i) {
    const r = (this.promiseMap.get(e) ?? Promise.resolve()).catch(() => {
    }).then(i).finally(() => {
      this.promiseMap.get(e) === r && this.promiseMap.delete(e);
    });
    return this.promiseMap.set(e, r), r;
  }
  keys() {
    return this.promiseMap.keys();
  }
}
const XR = (t, e) => {
  let i = !0;
  const n = setTimeout(() => {
    i = !1, e();
  }, t);
  return {
    isTriggered: () => i,
    dispose: () => {
      clearTimeout(n), i = !1;
    }
  };
}, ZR = (t) => {
  let e = !0;
  return queueMicrotask(() => {
    e && (e = !1, t());
  }), {
    isTriggered: () => e,
    dispose: () => {
      e = !1;
    }
  };
};
class e8 {
  constructor(e) {
    this.defaultDelay = e, this.deferred = null, this.completionPromise = null, this.doResolve = null, this.doReject = null, this.task = null;
  }
  trigger(e, i = this.defaultDelay) {
    this.task = e, this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise((r, s) => {
      this.doResolve = r, this.doReject = s;
    }).then(() => {
      if (this.completionPromise = null, this.doResolve = null, this.task) {
        const r = this.task;
        return this.task = null, r();
      }
    }));
    const n = () => {
      this.deferred = null, this.doResolve?.(null);
    };
    return this.deferred = i === qR ? ZR(n) : XR(i, n), this.completionPromise;
  }
  isTriggered() {
    return !!this.deferred?.isTriggered();
  }
  cancel() {
    this.cancelTimeout(), this.completionPromise && (this.doReject?.(new zn()), this.completionPromise = null);
  }
  cancelTimeout() {
    this.deferred?.dispose(), this.deferred = null;
  }
  dispose() {
    this.cancel();
  }
}
class F4 {
  constructor(e) {
    this.delayer = new e8(e), this.throttler = new KR();
  }
  trigger(e, i) {
    return this.delayer.trigger(() => this.throttler.queue(e), i);
  }
  isTriggered() {
    return this.delayer.isTriggered();
  }
  cancel() {
    this.delayer.cancel();
  }
  dispose() {
    this.delayer.dispose(), this.throttler.dispose();
  }
}
class Ur {
  constructor() {
    this._isOpen = !1, this._promise = new Promise((e, i) => {
      this._completePromise = e;
    });
  }
  isOpen() {
    return this._isOpen;
  }
  open() {
    this._isOpen = !0, this._completePromise(!0);
  }
  wait() {
    return this._promise;
  }
}
function qr(t, e) {
  return e ? new Promise((i, n) => {
    const r = setTimeout(() => {
      s.dispose(), i();
    }, t), s = e.onCancellationRequested(() => {
      clearTimeout(r), s.dispose(), n(new zn());
    });
  }) : jR((i) => qr(t, i));
}
function t8(t, e = 0, i) {
  const n = setTimeout(() => {
    t();
  }, e);
  return Ee(() => {
    clearTimeout(n);
  });
}
class i8 {
  constructor(e) {
    this._size = 0, this._isDisposed = !1, this.maxDegreeOfParalellism = e, this.outstandingPromises = [], this.runningPromises = 0, this._onDrained = new N();
  }
  whenIdle() {
    return this.size > 0 ? It.toPromise(this.onDrained) : Promise.resolve();
  }
  get onDrained() {
    return this._onDrained.event;
  }
  get size() {
    return this._size;
  }
  queue(e) {
    if (this._isDisposed)
      throw new Error("Object has been disposed");
    return this._size++, new Promise((i, n) => {
      this.outstandingPromises.push({ factory: e, c: i, e: n }), this.consume();
    });
  }
  consume() {
    for (; this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism; ) {
      const e = this.outstandingPromises.shift();
      this.runningPromises++;
      const i = e.factory();
      i.then(e.c, e.e), i.then(() => this.consumed(), () => this.consumed());
    }
  }
  consumed() {
    this._isDisposed || (this.runningPromises--, --this._size === 0 && this._onDrained.fire(), this.outstandingPromises.length > 0 && this.consume());
  }
  clear() {
    if (this._isDisposed)
      throw new Error("Object has been disposed");
    this.outstandingPromises.length = 0, this._size = this.runningPromises;
  }
  dispose() {
    this._isDisposed = !0, this.outstandingPromises.length = 0, this._size = 0, this._onDrained.dispose();
  }
}
class n8 extends i8 {
  constructor() {
    super(1);
  }
}
class r8 {
  constructor() {
    this.queues = /* @__PURE__ */ new Map(), this.drainers = /* @__PURE__ */ new Set(), this.drainListeners = void 0, this.drainListenerCount = 0;
  }
  async whenDrained() {
    if (this.isDrained())
      return;
    const e = new ko();
    return this.drainers.add(e), e.p;
  }
  isDrained() {
    for (const [, e] of this.queues)
      if (e.size > 0)
        return !1;
    return !0;
  }
  queueSize(e, i = ot) {
    const n = i.getComparisonKey(e);
    return this.queues.get(n)?.size ?? 0;
  }
  queueFor(e, i, n = ot) {
    const r = n.getComparisonKey(e);
    let s = this.queues.get(r);
    if (!s) {
      s = new n8();
      const o = this.drainListenerCount++, a = It.once(s.onDrained)(() => {
        s?.dispose(), this.queues.delete(r), this.onDidQueueDrain(), this.drainListeners?.deleteAndDispose(o), this.drainListeners?.size === 0 && (this.drainListeners.dispose(), this.drainListeners = void 0);
      });
      this.drainListeners || (this.drainListeners = new Ap()), this.drainListeners.set(o, a), this.queues.set(r, s);
    }
    return s.queue(i);
  }
  onDidQueueDrain() {
    this.isDrained() && this.releaseDrainers();
  }
  releaseDrainers() {
    for (const e of this.drainers)
      e.complete();
    this.drainers.clear();
  }
  dispose() {
    for (const [, e] of this.queues)
      e.dispose();
    this.queues.clear(), this.releaseDrainers(), this.drainListeners?.dispose();
  }
}
class s8 {
  constructor() {
    this.disposable = void 0, this.isDisposed = !1;
  }
  cancel() {
    this.disposable?.dispose(), this.disposable = void 0;
  }
  cancelAndSet(e, i, n = globalThis) {
    if (this.isDisposed)
      throw new rn("Calling 'cancelAndSet' on a disposed IntervalTimer");
    this.cancel();
    const r = n.setInterval(() => {
      e();
    }, i);
    this.disposable = Ee(() => {
      n.clearInterval(r), this.disposable = void 0;
    });
  }
  dispose() {
    this.cancel(), this.isDisposed = !0;
  }
}
class cl {
  constructor(e, i) {
    this.timeoutToken = void 0, this.runner = e, this.timeout = i, this.timeoutHandler = this.onTimeout.bind(this);
  }
  dispose() {
    this.cancel(), this.runner = null;
  }
  cancel() {
    this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = void 0);
  }
  schedule(e = this.timeout) {
    this.cancel(), this.timeoutToken = setTimeout(this.timeoutHandler, e);
  }
  get delay() {
    return this.timeout;
  }
  set delay(e) {
    this.timeout = e;
  }
  isScheduled() {
    return this.timeoutToken !== void 0;
  }
  flush() {
    this.isScheduled() && (this.cancel(), this.doRun());
  }
  onTimeout() {
    this.timeoutToken = void 0, this.runner && this.doRun();
  }
  doRun() {
    this.runner?.();
  }
}
let U4, tp;
(function() {
  const t = globalThis;
  typeof t.requestIdleCallback != "function" || typeof t.cancelIdleCallback != "function" ? tp = (e, i, n) => {
    _4(() => {
      if (r)
        return;
      const s = Date.now() + 15;
      i(Object.freeze({
        didTimeout: !0,
        timeRemaining() {
          return Math.max(0, s - Date.now());
        }
      }));
    });
    let r = !1;
    return {
      dispose() {
        r || (r = !0);
      }
    };
  } : tp = (e, i, n) => {
    const r = e.requestIdleCallback(i, typeof n == "number" ? { timeout: n } : void 0);
    let s = !1;
    return {
      dispose() {
        s || (s = !0, e.cancelIdleCallback(r));
      }
    };
  }, U4 = (e, i) => tp(globalThis, e, i);
})();
class o8 {
  constructor(e, i) {
    this._didRun = !1, this._executor = () => {
      try {
        this._value = i();
      } catch (n) {
        this._error = n;
      } finally {
        this._didRun = !0;
      }
    }, this._handle = tp(e, () => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (this._didRun || (this._handle.dispose(), this._executor()), this._error)
      throw this._error;
    return this._value;
  }
  get isInitialized() {
    return this._didRun;
  }
}
class a8 extends o8 {
  constructor(e) {
    super(globalThis, e);
  }
}
var Ko;
(function(t) {
  t[t.Resolved = 0] = "Resolved", t[t.Rejected = 1] = "Rejected";
})(Ko || (Ko = {}));
class ko {
  get isRejected() {
    return this.outcome?.outcome === Ko.Rejected;
  }
  get isResolved() {
    return this.outcome?.outcome === Ko.Resolved;
  }
  get isSettled() {
    return !!this.outcome;
  }
  get value() {
    return this.outcome?.outcome === Ko.Resolved ? this.outcome?.value : void 0;
  }
  constructor() {
    this.p = new Promise((e, i) => {
      this.completeCallback = e, this.errorCallback = i;
    });
  }
  complete(e) {
    return new Promise((i) => {
      this.completeCallback(e), this.outcome = { outcome: Ko.Resolved, value: e }, i();
    });
  }
  error(e) {
    return new Promise((i) => {
      this.errorCallback(e), this.outcome = { outcome: Ko.Rejected, value: e }, i();
    });
  }
  settleWith(e) {
    return e.then((i) => this.complete(i), (i) => this.error(i));
  }
  cancel() {
    return this.error(new zn());
  }
}
var Bc;
(function(t) {
  async function e(n) {
    let r;
    const s = await Promise.all(n.map((o) => o.then((a) => a, (a) => {
      r || (r = a);
    })));
    if (typeof r < "u")
      throw r;
    return s;
  }
  t.settled = e;
  function i(n) {
    return new Promise(async (r, s) => {
      try {
        await n(r, s);
      } catch (o) {
        s(o);
      }
    });
  }
  t.withAsyncBody = i;
})(Bc || (Bc = {}));
var Zn;
(function(t) {
  t[t.Initial = 0] = "Initial", t[t.DoneOK = 1] = "DoneOK", t[t.DoneError = 2] = "DoneError";
})(Zn || (Zn = {}));
const Yi = class Yi {
  static fromArray(e) {
    return new Yi((i) => {
      i.emitMany(e);
    });
  }
  static fromPromise(e) {
    return new Yi(async (i) => {
      i.emitMany(await e);
    });
  }
  static fromPromisesResolveOrder(e) {
    return new Yi(async (i) => {
      await Promise.all(e.map(async (n) => i.emitOne(await n)));
    });
  }
  static merge(e) {
    return new Yi(async (i) => {
      await Promise.all(e.map(async (n) => {
        for await (const r of n)
          i.emitOne(r);
      }));
    });
  }
  constructor(e, i) {
    this._state = Zn.Initial, this._results = [], this._error = null, this._onReturn = i, this._onStateChanged = new N(), queueMicrotask(async () => {
      const n = {
        emitOne: (r) => this.emitOne(r),
        emitMany: (r) => this.emitMany(r),
        reject: (r) => this.reject(r)
      };
      try {
        await Promise.resolve(e(n)), this.resolve();
      } catch (r) {
        this.reject(r);
      } finally {
        n.emitOne = void 0, n.emitMany = void 0, n.reject = void 0;
      }
    });
  }
  [Symbol.asyncIterator]() {
    let e = 0;
    return {
      next: async () => {
        do {
          if (this._state === Zn.DoneError)
            throw this._error;
          if (e < this._results.length)
            return { done: !1, value: this._results[e++] };
          if (this._state === Zn.DoneOK)
            return { done: !0, value: void 0 };
          await It.toPromise(this._onStateChanged.event);
        } while (!0);
      },
      return: async () => (this._onReturn?.(), { done: !0, value: void 0 })
    };
  }
  static map(e, i) {
    return new Yi(async (n) => {
      for await (const r of e)
        n.emitOne(i(r));
    });
  }
  map(e) {
    return Yi.map(this, e);
  }
  static filter(e, i) {
    return new Yi(async (n) => {
      for await (const r of e)
        i(r) && n.emitOne(r);
    });
  }
  filter(e) {
    return Yi.filter(this, e);
  }
  static coalesce(e) {
    return Yi.filter(e, (i) => !!i);
  }
  coalesce() {
    return Yi.coalesce(this);
  }
  static async toPromise(e) {
    const i = [];
    for await (const n of e)
      i.push(n);
    return i;
  }
  toPromise() {
    return Yi.toPromise(this);
  }
  emitOne(e) {
    this._state === Zn.Initial && (this._results.push(e), this._onStateChanged.fire());
  }
  emitMany(e) {
    this._state === Zn.Initial && (this._results = this._results.concat(e), this._onStateChanged.fire());
  }
  resolve() {
    this._state === Zn.Initial && (this._state = Zn.DoneOK, this._onStateChanged.fire());
  }
  reject(e) {
    this._state === Zn.Initial && (this._state = Zn.DoneError, this._error = e, this._onStateChanged.fire());
  }
};
Yi.EMPTY = Yi.fromArray([]);
let Xa = Yi;
class Rv {
  constructor(e) {
    this._deferred = new ko(), this._asyncIterable = new Xa((r) => {
      if (i) {
        r.reject(i);
        return;
      }
      return n && r.emitMany(n), this._errorFn = (s) => r.reject(s), this._emitOneFn = (s) => r.emitOne(s), this._emitManyFn = (s) => r.emitMany(s), this._deferred.p;
    }, e);
    let i, n;
    this._errorFn = (r) => {
      i || (i = r);
    }, this._emitOneFn = (r) => {
      n || (n = []), n.push(r);
    }, this._emitManyFn = (r) => {
      n ? r.forEach((s) => n.push(s)) : n = r.slice();
    };
  }
  get asyncIterable() {
    return this._asyncIterable;
  }
  resolve() {
    this._deferred.complete();
  }
  reject(e) {
    this._errorFn(e), this._deferred.complete();
  }
  emitOne(e) {
    this._emitOneFn(e);
  }
  emitMany(e) {
    this._emitManyFn(e);
  }
}
function $4(t, e, i, n) {
  if (!t || n > 200)
    return null;
  if (typeof t == "object") {
    if (t.$mid === tt.Uri)
      return i ? x.revive(e.transformIncoming(t)) : e.transformIncoming(t);
    if (t instanceof ue)
      return null;
    for (const r in t)
      if (Object.hasOwnProperty.call(t, r)) {
        const s = $4(t[r], e, i, n + 1);
        s !== null && (t[r] = s);
      }
  }
  return null;
}
function Nu(t, e) {
  const i = $4(t, e, !1, 0);
  return i === null ? t : i;
}
class H4 {
  constructor() {
    this._actual = null, this._actualOk = null, this._actualErr = null, this._hasValue = !1, this._value = null, this._hasErr = !1, this._err = null;
  }
  get [Symbol.toStringTag]() {
    return this.toString();
  }
  _ensureActual() {
    return this._actual || (this._actual = new Promise((e, i) => {
      this._actualOk = e, this._actualErr = i, this._hasValue && this._actualOk(this._value), this._hasErr && this._actualErr(this._err);
    })), this._actual;
  }
  resolveOk(e) {
    this._hasValue || this._hasErr || (this._hasValue = !0, this._value = e, this._actual && this._actualOk(e));
  }
  resolveErr(e) {
    this._hasValue || this._hasErr || (this._hasErr = !0, this._err = e, this._actual ? this._actualErr(e) : Li(e));
  }
  then(e, i) {
    return this._ensureActual().then(e, i);
  }
  catch(e) {
    return this._ensureActual().then(void 0, e);
  }
  finally(e) {
    return this._ensureActual().finally(e);
  }
}
class l8 extends H4 {
  constructor() {
    super(), this._hasErr = !0, this._err = new zn();
  }
}
var yS;
function Lv(t, e) {
  try {
    return JSON.stringify(t, e);
  } catch {
    return "null";
  }
}
const Cx = "$$ref$$", c8 = { [Cx]: -1 };
function xS(t, e = null, i = !1) {
  const n = [];
  return {
    jsonString: (i ? Lv : JSON.stringify)(t, (s, o) => {
      if (typeof o > "u")
        return c8;
      if (typeof o == "object") {
        if (o instanceof ue) {
          const a = n.push(o) - 1;
          return { [Cx]: a };
        }
        if (e)
          return e(s, o);
      }
      return o;
    }),
    referencedBuffers: n
  };
}
function B4(t, e, i) {
  return JSON.parse(t, (n, r) => {
    if (r) {
      const s = r[Cx];
      if (typeof s == "number")
        return e[s];
      if (i && r.$mid === tt.Uri)
        return i.transformIncoming(r);
    }
    return r;
  });
}
function ES(t, e) {
  return JSON.stringify(t, e);
}
function u8(t) {
  return t ? (e, i) => i && i.$mid === tt.Uri ? t.transformOutgoing(i) : i : null;
}
var $n;
(function(t) {
  t[t.LocalSide = 0] = "LocalSide", t[t.OtherSide = 1] = "OtherSide";
})($n || ($n = {}));
var rd;
(function(t) {
  t[t.Responsive = 0] = "Responsive", t[t.Unresponsive = 1] = "Unresponsive";
})(rd || (rd = {}));
const d8 = () => {
}, h8 = Symbol.for("rpcProtocol"), f8 = Symbol.for("rpcProxy"), Ld = class Ld extends ve {
  constructor(e, i = null, n = null) {
    super(), this[yS] = !0, this._onDidChangeResponsiveState = this._register(new N()), this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event, this._protocol = e, this._logger = i, this._uriTransformer = n, this._uriReplacer = u8(this._uriTransformer), this._isDisposed = !1, this._locals = [], this._proxies = [];
    for (let r = 0, s = Up.count; r < s; r++)
      this._locals[r] = null, this._proxies[r] = null;
    this._lastMessageId = 0, this._cancelInvokedHandlers = /* @__PURE__ */ Object.create(null), this._pendingRPCReplies = {}, this._responsiveState = rd.Responsive, this._unacknowledgedCount = 0, this._unresponsiveTime = 0, this._asyncCheckUresponsive = this._register(new cl(() => this._checkUnresponsive(), 1e3)), this._register(this._protocol.onMessage((r) => this._receiveOneMessage(r)));
  }
  dispose() {
    this._isDisposed = !0, Object.keys(this._pendingRPCReplies).forEach((e) => {
      const i = this._pendingRPCReplies[e];
      delete this._pendingRPCReplies[e], i.resolveErr(HE());
    }), super.dispose();
  }
  drain() {
    return typeof this._protocol.drain == "function" ? this._protocol.drain() : Promise.resolve();
  }
  _onWillSendRequest(e) {
    this._unacknowledgedCount === 0 && (this._unresponsiveTime = Date.now() + Ld.UNRESPONSIVE_TIME), this._unacknowledgedCount++, this._asyncCheckUresponsive.isScheduled() || this._asyncCheckUresponsive.schedule();
  }
  _onDidReceiveAcknowledge(e) {
    this._unresponsiveTime = Date.now() + Ld.UNRESPONSIVE_TIME, this._unacknowledgedCount--, this._unacknowledgedCount === 0 && this._asyncCheckUresponsive.cancel(), this._setResponsiveState(rd.Responsive);
  }
  _checkUnresponsive() {
    this._unacknowledgedCount !== 0 && (Date.now() > this._unresponsiveTime ? this._setResponsiveState(rd.Unresponsive) : this._asyncCheckUresponsive.schedule());
  }
  _setResponsiveState(e) {
    this._responsiveState !== e && (this._responsiveState = e, this._onDidChangeResponsiveState.fire(this._responsiveState));
  }
  get responsiveState() {
    return this._responsiveState;
  }
  transformIncomingURIs(e) {
    return this._uriTransformer ? Nu(e, this._uriTransformer) : e;
  }
  getProxy(e) {
    const { nid: i, sid: n } = e;
    return this._proxies[i] || (this._proxies[i] = this._createProxy(i, n)), this._proxies[i];
  }
  _createProxy(e, i) {
    const n = {
      get: (r, s) => (typeof s == "string" && !r[s] && s.charCodeAt(0) === L.DollarSign && (r[s] = (...o) => this._remoteCall(e, s, o)), s === f8 ? i : r[s])
    };
    return new Proxy(/* @__PURE__ */ Object.create(null), n);
  }
  set(e, i) {
    return this._locals[e.nid] = i, i;
  }
  assertRegistered(e) {
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i];
      if (!this._locals[r.nid])
        throw new Error(`Missing proxy instance ${r.sid}`);
    }
  }
  _receiveOneMessage(e) {
    if (this._isDisposed)
      return;
    const i = e.byteLength, n = Ot.read(e, 0), r = n.readUInt8(), s = n.readUInt32();
    switch (r) {
      case Dt.RequestJSONArgs:
      case Dt.RequestJSONArgsWithCancellation: {
        let { rpcId: o, method: a, args: l } = Un.deserializeRequestJSONArgs(n);
        this._uriTransformer && (l = Nu(l, this._uriTransformer)), this._receiveRequest(i, s, o, a, l, r === Dt.RequestJSONArgsWithCancellation);
        break;
      }
      case Dt.RequestMixedArgs:
      case Dt.RequestMixedArgsWithCancellation: {
        let { rpcId: o, method: a, args: l } = Un.deserializeRequestMixedArgs(n);
        this._uriTransformer && (l = Nu(l, this._uriTransformer)), this._receiveRequest(i, s, o, a, l, r === Dt.RequestMixedArgsWithCancellation);
        break;
      }
      case Dt.Acknowledged: {
        this._logger?.logIncoming(i, s, $n.LocalSide, "ack"), this._onDidReceiveAcknowledge(s);
        break;
      }
      case Dt.Cancel: {
        this._receiveCancel(i, s);
        break;
      }
      case Dt.ReplyOKEmpty: {
        this._receiveReply(i, s, void 0);
        break;
      }
      case Dt.ReplyOKJSON: {
        let o = Un.deserializeReplyOKJSON(n);
        this._uriTransformer && (o = Nu(o, this._uriTransformer)), this._receiveReply(i, s, o);
        break;
      }
      case Dt.ReplyOKJSONWithBuffers: {
        const o = Un.deserializeReplyOKJSONWithBuffers(n, this._uriTransformer);
        this._receiveReply(i, s, o);
        break;
      }
      case Dt.ReplyOKVSBuffer: {
        const o = Un.deserializeReplyOKVSBuffer(n);
        this._receiveReply(i, s, o);
        break;
      }
      case Dt.ReplyErrError: {
        let o = Un.deserializeReplyErrError(n);
        this._uriTransformer && (o = Nu(o, this._uriTransformer)), this._receiveReplyErr(i, s, o);
        break;
      }
      case Dt.ReplyErrEmpty: {
        this._receiveReplyErr(i, s, void 0);
        break;
      }
      default:
        console.error("received unexpected message"), console.error(e);
    }
  }
  _receiveRequest(e, i, n, r, s, o) {
    this._logger?.logIncoming(e, i, $n.OtherSide, `receiveRequest ${Rf(n)}.${r}(`, s);
    const a = String(i);
    let l, c;
    if (o) {
      const d = new Pt();
      s.push(d.token), l = this._invokeHandler(n, r, s), c = () => d.cancel();
    } else
      l = this._invokeHandler(n, r, s), c = d8;
    this._cancelInvokedHandlers[a] = c;
    const u = Un.serializeAcknowledged(i);
    this._logger?.logOutgoing(u.byteLength, i, $n.OtherSide, "ack"), this._protocol.send(u), l.then((d) => {
      delete this._cancelInvokedHandlers[a];
      const f = Un.serializeReplyOK(i, d, this._uriReplacer);
      this._logger?.logOutgoing(f.byteLength, i, $n.OtherSide, "reply:", d), this._protocol.send(f);
    }, (d) => {
      delete this._cancelInvokedHandlers[a];
      const f = Un.serializeReplyErr(i, d);
      this._logger?.logOutgoing(f.byteLength, i, $n.OtherSide, "replyErr:", d), this._protocol.send(f);
    });
  }
  _receiveCancel(e, i) {
    this._logger?.logIncoming(e, i, $n.OtherSide, "receiveCancel");
    const n = String(i);
    this._cancelInvokedHandlers[n]?.();
  }
  _receiveReply(e, i, n) {
    this._logger?.logIncoming(e, i, $n.LocalSide, "receiveReply:", n);
    const r = String(i);
    if (!this._pendingRPCReplies.hasOwnProperty(r))
      return;
    const s = this._pendingRPCReplies[r];
    delete this._pendingRPCReplies[r], s.resolveOk(n);
  }
  _receiveReplyErr(e, i, n) {
    this._logger?.logIncoming(e, i, $n.LocalSide, "receiveReplyErr:", n);
    const r = String(i);
    if (!this._pendingRPCReplies.hasOwnProperty(r))
      return;
    const s = this._pendingRPCReplies[r];
    delete this._pendingRPCReplies[r];
    let o;
    n && (n.$isError ? (o = new Error(), o.name = n.name, o.message = n.message, o.stack = n.stack) : o = n), s.resolveErr(o);
  }
  _invokeHandler(e, i, n) {
    try {
      return Promise.resolve(this._doInvokeHandler(e, i, n));
    } catch (r) {
      return Promise.reject(r);
    }
  }
  _doInvokeHandler(e, i, n) {
    const r = this._locals[e];
    if (!r)
      throw new Error("Unknown actor " + Rf(e));
    const s = r[i];
    if (typeof s != "function")
      throw new Error(
        "Unknown method " + i + " on actor " + Rf(e)
      );
    return s.apply(r, n);
  }
  _remoteCall(e, i, n) {
    if (this._isDisposed)
      return new l8();
    let r = null;
    if (n.length > 0 && xt.isCancellationToken(n[n.length - 1]) && (r = n.pop()), r && r.isCancellationRequested)
      return Promise.reject(HE());
    const s = Un.serializeRequestArguments(n, this._uriReplacer), o = ++this._lastMessageId, a = String(o), l = new H4(), c = new De();
    r && c.add(r.onCancellationRequested(() => {
      const d = Un.serializeCancel(o);
      this._logger?.logOutgoing(d.byteLength, o, $n.LocalSide, "cancel"), this._protocol.send(d);
    })), this._pendingRPCReplies[a] = new p8(l, c), this._onWillSendRequest(o);
    const u = Un.serializeRequest(o, e, i, s, !!r);
    return this._logger?.logOutgoing(u.byteLength, o, $n.LocalSide, `request: ${Rf(e)}.${i}(`, n), this._protocol.send(u), l;
  }
};
yS = h8, Ld.UNRESPONSIVE_TIME = 3 * 1e3;
let Nv = Ld;
class p8 {
  constructor(e, i) {
    this._promise = e, this._disposable = i;
  }
  resolveOk(e) {
    this._promise.resolveOk(e), this._disposable.dispose();
  }
  resolveErr(e) {
    this._promise.resolveErr(e), this._disposable.dispose();
  }
}
const Nd = class Nd {
  static alloc(e, i, n) {
    const r = new Nd(ue.alloc(n + 1 + 4), 0);
    return r.writeUInt8(e), r.writeUInt32(i), r;
  }
  static read(e, i) {
    return new Nd(e, i);
  }
  get buffer() {
    return this._buff;
  }
  constructor(e, i) {
    this._buff = e, this._offset = i;
  }
  static sizeUInt8() {
    return 1;
  }
  writeUInt8(e) {
    this._buff.writeUInt8(e, this._offset), this._offset += 1;
  }
  readUInt8() {
    const e = this._buff.readUInt8(this._offset);
    return this._offset += 1, e;
  }
  writeUInt32(e) {
    this._buff.writeUInt32BE(e, this._offset), this._offset += 4;
  }
  readUInt32() {
    const e = this._buff.readUInt32BE(this._offset);
    return this._offset += 4, e;
  }
  static sizeShortString(e) {
    return 1 + e.byteLength;
  }
  writeShortString(e) {
    this._buff.writeUInt8(e.byteLength, this._offset), this._offset += 1, this._buff.set(e, this._offset), this._offset += e.byteLength;
  }
  readShortString() {
    const e = this._buff.readUInt8(this._offset);
    this._offset += 1;
    const n = this._buff.slice(this._offset, this._offset + e).toString();
    return this._offset += e, n;
  }
  static sizeLongString(e) {
    return 4 + e.byteLength;
  }
  writeLongString(e) {
    this._buff.writeUInt32BE(e.byteLength, this._offset), this._offset += 4, this._buff.set(e, this._offset), this._offset += e.byteLength;
  }
  readLongString() {
    const e = this._buff.readUInt32BE(this._offset);
    this._offset += 4;
    const n = this._buff.slice(this._offset, this._offset + e).toString();
    return this._offset += e, n;
  }
  writeBuffer(e) {
    this._buff.writeUInt32BE(e.byteLength, this._offset), this._offset += 4, this._buff.set(e, this._offset), this._offset += e.byteLength;
  }
  static sizeVSBuffer(e) {
    return 4 + e.byteLength;
  }
  writeVSBuffer(e) {
    this._buff.writeUInt32BE(e.byteLength, this._offset), this._offset += 4, this._buff.set(e, this._offset), this._offset += e.byteLength;
  }
  readVSBuffer() {
    const e = this._buff.readUInt32BE(this._offset);
    this._offset += 4;
    const i = this._buff.slice(this._offset, this._offset + e);
    return this._offset += e, i;
  }
  static sizeMixedArray(e) {
    let i = 0;
    i += 1;
    for (let n = 0, r = e.length; n < r; n++) {
      const s = e[n];
      switch (i += 1, s.type) {
        case di.String:
          i += this.sizeLongString(s.value);
          break;
        case di.VSBuffer:
          i += this.sizeVSBuffer(s.value);
          break;
        case di.SerializedObjectWithBuffers:
          i += this.sizeUInt32, i += this.sizeLongString(s.value);
          for (let o = 0; o < s.buffers.length; ++o)
            i += this.sizeVSBuffer(s.buffers[o]);
          break;
      }
    }
    return i;
  }
  writeMixedArray(e) {
    this._buff.writeUInt8(e.length, this._offset), this._offset += 1;
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i];
      switch (r.type) {
        case di.String:
          this.writeUInt8(di.String), this.writeLongString(r.value);
          break;
        case di.VSBuffer:
          this.writeUInt8(di.VSBuffer), this.writeVSBuffer(r.value);
          break;
        case di.SerializedObjectWithBuffers:
          this.writeUInt8(di.SerializedObjectWithBuffers), this.writeUInt32(r.buffers.length), this.writeLongString(r.value);
          for (let s = 0; s < r.buffers.length; ++s)
            this.writeBuffer(r.buffers[s]);
          break;
        case di.Undefined:
          this.writeUInt8(di.Undefined);
          break;
      }
    }
  }
  readMixedArray() {
    const e = this._buff.readUInt8(this._offset);
    this._offset += 1;
    const i = new Array(e);
    for (let n = 0; n < e; n++)
      switch (this.readUInt8()) {
        case di.String:
          i[n] = this.readLongString();
          break;
        case di.VSBuffer:
          i[n] = this.readVSBuffer();
          break;
        case di.SerializedObjectWithBuffers: {
          const s = this.readUInt32(), o = this.readLongString(), a = [];
          for (let l = 0; l < s; ++l)
            a.push(this.readVSBuffer());
          i[n] = new zi(B4(o, a, null));
          break;
        }
        case di.Undefined:
          i[n] = void 0;
          break;
      }
    return i;
  }
};
Nd.sizeUInt32 = 4;
let Ot = Nd;
var $l;
(function(t) {
  t[t.Simple = 0] = "Simple", t[t.Mixed = 1] = "Mixed";
})($l || ($l = {}));
class Un {
  static _useMixedArgSerialization(e) {
    for (let i = 0, n = e.length; i < n; i++)
      if (e[i] instanceof ue || e[i] instanceof zi || typeof e[i] > "u")
        return !0;
    return !1;
  }
  static serializeRequestArguments(e, i) {
    if (this._useMixedArgSerialization(e)) {
      const n = [];
      for (let r = 0, s = e.length; r < s; r++) {
        const o = e[r];
        if (o instanceof ue)
          n[r] = { type: di.VSBuffer, value: o };
        else if (typeof o > "u")
          n[r] = { type: di.Undefined };
        else if (o instanceof zi) {
          const { jsonString: a, referencedBuffers: l } = xS(o.value, i);
          n[r] = { type: di.SerializedObjectWithBuffers, value: ue.fromString(a), buffers: l };
        } else
          n[r] = { type: di.String, value: ue.fromString(ES(o, i)) };
      }
      return {
        type: $l.Mixed,
        args: n
      };
    }
    return {
      type: $l.Simple,
      args: ES(e, i)
    };
  }
  static serializeRequest(e, i, n, r, s) {
    switch (r.type) {
      case $l.Simple:
        return this._requestJSONArgs(e, i, n, r.args, s);
      case $l.Mixed:
        return this._requestMixedArgs(e, i, n, r.args, s);
    }
  }
  static _requestJSONArgs(e, i, n, r, s) {
    const o = ue.fromString(n), a = ue.fromString(r);
    let l = 0;
    l += Ot.sizeUInt8(), l += Ot.sizeShortString(o), l += Ot.sizeLongString(a);
    const c = Ot.alloc(s ? Dt.RequestJSONArgsWithCancellation : Dt.RequestJSONArgs, e, l);
    return c.writeUInt8(i), c.writeShortString(o), c.writeLongString(a), c.buffer;
  }
  static deserializeRequestJSONArgs(e) {
    const i = e.readUInt8(), n = e.readShortString(), r = e.readLongString();
    return {
      rpcId: i,
      method: n,
      args: JSON.parse(r)
    };
  }
  static _requestMixedArgs(e, i, n, r, s) {
    const o = ue.fromString(n);
    let a = 0;
    a += Ot.sizeUInt8(), a += Ot.sizeShortString(o), a += Ot.sizeMixedArray(r);
    const l = Ot.alloc(s ? Dt.RequestMixedArgsWithCancellation : Dt.RequestMixedArgs, e, a);
    return l.writeUInt8(i), l.writeShortString(o), l.writeMixedArray(r), l.buffer;
  }
  static deserializeRequestMixedArgs(e) {
    const i = e.readUInt8(), n = e.readShortString(), r = e.readMixedArray(), s = new Array(r.length);
    for (let o = 0, a = r.length; o < a; o++) {
      const l = r[o];
      typeof l == "string" ? s[o] = JSON.parse(l) : s[o] = l;
    }
    return {
      rpcId: i,
      method: n,
      args: s
    };
  }
  static serializeAcknowledged(e) {
    return Ot.alloc(Dt.Acknowledged, e, 0).buffer;
  }
  static serializeCancel(e) {
    return Ot.alloc(Dt.Cancel, e, 0).buffer;
  }
  static serializeReplyOK(e, i, n) {
    if (typeof i > "u")
      return this._serializeReplyOKEmpty(e);
    if (i instanceof ue)
      return this._serializeReplyOKVSBuffer(e, i);
    if (i instanceof zi) {
      const { jsonString: r, referencedBuffers: s } = xS(i.value, n, !0);
      return this._serializeReplyOKJSONWithBuffers(e, r, s);
    } else
      return this._serializeReplyOKJSON(e, Lv(i, n));
  }
  static _serializeReplyOKEmpty(e) {
    return Ot.alloc(Dt.ReplyOKEmpty, e, 0).buffer;
  }
  static _serializeReplyOKVSBuffer(e, i) {
    let n = 0;
    n += Ot.sizeVSBuffer(i);
    const r = Ot.alloc(Dt.ReplyOKVSBuffer, e, n);
    return r.writeVSBuffer(i), r.buffer;
  }
  static deserializeReplyOKVSBuffer(e) {
    return e.readVSBuffer();
  }
  static _serializeReplyOKJSON(e, i) {
    const n = ue.fromString(i);
    let r = 0;
    r += Ot.sizeLongString(n);
    const s = Ot.alloc(Dt.ReplyOKJSON, e, r);
    return s.writeLongString(n), s.buffer;
  }
  static _serializeReplyOKJSONWithBuffers(e, i, n) {
    const r = ue.fromString(i);
    let s = 0;
    s += Ot.sizeUInt32, s += Ot.sizeLongString(r);
    for (const a of n)
      s += Ot.sizeVSBuffer(a);
    const o = Ot.alloc(Dt.ReplyOKJSONWithBuffers, e, s);
    o.writeUInt32(n.length), o.writeLongString(r);
    for (const a of n)
      o.writeBuffer(a);
    return o.buffer;
  }
  static deserializeReplyOKJSON(e) {
    const i = e.readLongString();
    return JSON.parse(i);
  }
  static deserializeReplyOKJSONWithBuffers(e, i) {
    const n = e.readUInt32(), r = e.readLongString(), s = [];
    for (let o = 0; o < n; ++o)
      s.push(e.readVSBuffer());
    return new zi(B4(r, s, i));
  }
  static serializeReplyErr(e, i) {
    const n = i ? Lv(Oc(i), null) : void 0;
    if (typeof n != "string")
      return this._serializeReplyErrEmpty(e);
    const r = ue.fromString(n);
    let s = 0;
    s += Ot.sizeLongString(r);
    const o = Ot.alloc(Dt.ReplyErrError, e, s);
    return o.writeLongString(r), o.buffer;
  }
  static deserializeReplyErrError(e) {
    const i = e.readLongString();
    return JSON.parse(i);
  }
  static _serializeReplyErrEmpty(e) {
    return Ot.alloc(Dt.ReplyErrEmpty, e, 0).buffer;
  }
}
var Dt;
(function(t) {
  t[t.RequestJSONArgs = 1] = "RequestJSONArgs", t[t.RequestJSONArgsWithCancellation = 2] = "RequestJSONArgsWithCancellation", t[t.RequestMixedArgs = 3] = "RequestMixedArgs", t[t.RequestMixedArgsWithCancellation = 4] = "RequestMixedArgsWithCancellation", t[t.Acknowledged = 5] = "Acknowledged", t[t.Cancel = 6] = "Cancel", t[t.ReplyOKEmpty = 7] = "ReplyOKEmpty", t[t.ReplyOKVSBuffer = 8] = "ReplyOKVSBuffer", t[t.ReplyOKJSON = 9] = "ReplyOKJSON", t[t.ReplyOKJSONWithBuffers = 10] = "ReplyOKJSONWithBuffers", t[t.ReplyErrError = 11] = "ReplyErrError", t[t.ReplyErrEmpty = 12] = "ReplyErrEmpty";
})(Dt || (Dt = {}));
var di;
(function(t) {
  t[t.String = 1] = "String", t[t.VSBuffer = 2] = "VSBuffer", t[t.SerializedObjectWithBuffers = 3] = "SerializedObjectWithBuffers", t[t.Undefined = 4] = "Undefined";
})(di || (di = {}));
function Tx(t) {
  if (!t)
    return;
  const e = t.indexOf("+");
  return e < 0 ? t : t.substr(0, e);
}
const g8 = [
  "AI",
  "Azure",
  "Chat",
  "Data Science",
  "Debuggers",
  "Extension Packs",
  "Education",
  "Formatters",
  "Keymaps",
  "Language Packs",
  "Linters",
  "Machine Learning",
  "Notebooks",
  "Programming Languages",
  "SCM Providers",
  "Snippets",
  "Testing",
  "Themes",
  "Visualization",
  "Other"
];
var SS;
(function(t) {
  t[t.System = 0] = "System", t[t.User = 1] = "User";
})(SS || (SS = {}));
var Mv;
(function(t) {
  t.WIN32_X64 = "win32-x64", t.WIN32_ARM64 = "win32-arm64", t.LINUX_X64 = "linux-x64", t.LINUX_ARM64 = "linux-arm64", t.LINUX_ARMHF = "linux-armhf", t.ALPINE_X64 = "alpine-x64", t.ALPINE_ARM64 = "alpine-arm64", t.DARWIN_X64 = "darwin-x64", t.DARWIN_ARM64 = "darwin-arm64", t.WEB = "web", t.UNIVERSAL = "universal", t.UNKNOWN = "unknown", t.UNDEFINED = "undefined";
})(Mv || (Mv = {}));
class ht {
  constructor(e) {
    this.value = e, this._lower = e.toLowerCase();
  }
  static equals(e, i) {
    if (typeof e > "u" || e === null)
      return typeof i > "u" || i === null;
    if (typeof i > "u" || i === null)
      return !1;
    if (typeof e == "string" || typeof i == "string") {
      const n = typeof e == "string" ? e : e.value, r = typeof i == "string" ? i : i.value;
      return ca(n, r);
    }
    return e._lower === i._lower;
  }
  static toKey(e) {
    return typeof e == "string" ? e.toLowerCase() : e._lower;
  }
}
class ul {
  get size() {
    return this._set.size;
  }
  constructor(e) {
    if (this._set = /* @__PURE__ */ new Set(), e)
      for (const i of e)
        this.add(i);
  }
  add(e) {
    this._set.add(ht.toKey(e));
  }
  delete(e) {
    return this._set.delete(ht.toKey(e));
  }
  has(e) {
    return this._set.has(ht.toKey(e));
  }
}
class Io {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  clear() {
    this._map.clear();
  }
  delete(e) {
    this._map.delete(ht.toKey(e));
  }
  get(e) {
    return this._map.get(ht.toKey(e));
  }
  has(e) {
    return this._map.has(ht.toKey(e));
  }
  set(e, i) {
    this._map.set(ht.toKey(e), i);
  }
  values() {
    return this._map.values();
  }
  forEach(e) {
    this._map.forEach(e);
  }
  [Symbol.iterator]() {
    return this._map[Symbol.iterator]();
  }
}
class W4 extends Error {
  constructor(e, i, n) {
    super(`Error in extension ${ht.toKey(e)}: ${n ?? i.message}`, { cause: i }), this.name = "ExtensionError", this.extension = e;
  }
}
var hr;
(function(t) {
  t.serviceIds = /* @__PURE__ */ new Map(), t.DI_TARGET = "$di$target", t.DI_DEPENDENCIES = "$di$dependencies";
  function e(i) {
    return i[t.DI_DEPENDENCIES] || [];
  }
  t.getServiceDependencies = e;
})(hr || (hr = {}));
const uf = pe("instantiationService");
function m8(t, e, i) {
  e[hr.DI_TARGET] === e ? e[hr.DI_DEPENDENCIES].push({ id: t, index: i }) : (e[hr.DI_DEPENDENCIES] = [{ id: t, index: i }], e[hr.DI_TARGET] = e);
}
function pe(t) {
  if (hr.serviceIds.has(t))
    return hr.serviceIds.get(t);
  const e = function(i, n, r) {
    if (arguments.length !== 3)
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    m8(e, i, r);
  };
  return e.toString = () => t, hr.serviceIds.set(t, e), e;
}
const nt = pe("logService"), Lo = pe("loggerService");
class lr {
  constructor(e, i = [], n = !1) {
    this.ctor = e, this.staticArguments = i, this.supportsDelayedInstantiation = n;
  }
}
const V4 = [];
var ft;
(function(t) {
  t[t.Eager = 0] = "Eager", t[t.Delayed = 1] = "Delayed";
})(ft || (ft = {}));
function gt(t, e, i) {
  e instanceof lr || (e = new lr(e, [], !!i)), V4.push([t, e]);
}
function _8() {
  return V4;
}
class Px {
  constructor(...e) {
    this._entries = /* @__PURE__ */ new Map();
    for (const [i, n] of e)
      this.set(i, n);
  }
  set(e, i) {
    const n = this._entries.get(e);
    return this._entries.set(e, i), n;
  }
  has(e) {
    return this._entries.has(e);
  }
  get(e) {
    return this._entries.get(e);
  }
}
const pi = pe("IExtHostInitDataService");
let v8 = class {
  constructor(e, i) {
    this.key = e, this.data = i, this.incoming = /* @__PURE__ */ new Map(), this.outgoing = /* @__PURE__ */ new Map();
  }
};
class DS {
  constructor(e) {
    this._hashFn = e, this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const e = [];
    for (const i of this._nodes.values())
      i.outgoing.size === 0 && e.push(i);
    return e;
  }
  insertEdge(e, i) {
    const n = this.lookupOrInsertNode(e), r = this.lookupOrInsertNode(i);
    n.outgoing.set(r.key, r), r.incoming.set(n.key, n);
  }
  removeNode(e) {
    const i = this._hashFn(e);
    this._nodes.delete(i);
    for (const n of this._nodes.values())
      n.outgoing.delete(i), n.incoming.delete(i);
  }
  lookupOrInsertNode(e) {
    const i = this._hashFn(e);
    let n = this._nodes.get(i);
    return n || (n = new v8(i, e), this._nodes.set(i, n)), n;
  }
  lookup(e) {
    return this._nodes.get(this._hashFn(e));
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const e = [];
    for (const [i, n] of this._nodes)
      e.push(`${i}
	(-> incoming)[${[...n.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...n.outgoing.keys()].join(",")}]
`);
    return e.join(`
`);
  }
  findCycleSlow() {
    for (const [e, i] of this._nodes) {
      const n = /* @__PURE__ */ new Set([e]), r = this._findCycle(i, n);
      if (r)
        return r;
    }
  }
  _findCycle(e, i) {
    for (const [n, r] of e.outgoing) {
      if (i.has(n))
        return [...i, n].join(" -> ");
      i.add(n);
      const s = this._findCycle(r, i);
      if (s)
        return s;
      i.delete(n);
    }
  }
}
const w8 = !1;
class kS extends Error {
  constructor(e) {
    super("cyclic dependency between services"), this.message = e.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: 
${e.toString()}`;
  }
}
class Bp {
  constructor(e = new Px(), i = !1, n, r = w8) {
    this._services = e, this._strict = i, this._parent = n, this._enableTracing = r, this._isDisposed = !1, this._servicesToMaybeDispose = /* @__PURE__ */ new Set(), this._children = /* @__PURE__ */ new Set(), this._activeInstantiations = /* @__PURE__ */ new Set(), this._services.set(uf, this), this._globalGraph = r ? n?._globalGraph ?? new DS((s) => s) : void 0;
  }
  dispose() {
    if (!this._isDisposed) {
      this._isDisposed = !0, Wn(this._children), this._children.clear();
      for (const e of this._servicesToMaybeDispose)
        o4(e) && e.dispose();
      this._servicesToMaybeDispose.clear();
    }
  }
  _throwIfDisposed() {
    if (this._isDisposed)
      throw new Error("InstantiationService has been disposed");
  }
  createChild(e, i) {
    this._throwIfDisposed();
    const n = this, r = new class extends Bp {
      dispose() {
        n._children.delete(r), super.dispose();
      }
    }(e, this._strict, this, this._enableTracing);
    return this._children.add(r), i?.add(r), r;
  }
  invokeFunction(e, ...i) {
    this._throwIfDisposed();
    const n = sd.traceInvocation(this._enableTracing, e);
    let r = !1;
    try {
      return e({
        get: (o) => {
          if (r)
            throw gx("service accessor is only valid during the invocation of its target method");
          const a = this._getOrCreateServiceInstance(o, n);
          if (!a)
            throw new Error(`[invokeFunction] unknown service '${o}'`);
          return a;
        }
      }, ...i);
    } finally {
      r = !0, n.stop();
    }
  }
  createInstance(e, ...i) {
    this._throwIfDisposed();
    let n, r;
    return e instanceof lr ? (n = sd.traceCreation(this._enableTracing, e.ctor), r = this._createInstance(e.ctor, e.staticArguments.concat(i), n)) : (n = sd.traceCreation(this._enableTracing, e), r = this._createInstance(e, i, n)), n.stop(), r;
  }
  _createInstance(e, i = [], n) {
    const r = hr.getServiceDependencies(e).sort((a, l) => a.index - l.index), s = [];
    for (const a of r) {
      const l = this._getOrCreateServiceInstance(a.id, n);
      l || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, !1), s.push(l);
    }
    const o = r.length > 0 ? r[0].index : i.length;
    if (i.length !== o) {
      console.trace(`[createInstance] First service dependency of ${e.name} at position ${o + 1} conflicts with ${i.length} static arguments`);
      const a = o - i.length;
      a > 0 ? i = i.concat(new Array(a)) : i = i.slice(0, o);
    }
    return Reflect.construct(e, i.concat(s));
  }
  _setCreatedServiceInstance(e, i) {
    if (this._services.get(e) instanceof lr)
      this._services.set(e, i);
    else if (this._parent)
      this._parent._setCreatedServiceInstance(e, i);
    else
      throw new Error("illegalState - setting UNKNOWN service instance");
  }
  _getServiceInstanceOrDescriptor(e) {
    const i = this._services.get(e);
    return !i && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : i;
  }
  _getOrCreateServiceInstance(e, i) {
    this._globalGraph && this._globalGraphImplicitDependency && this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(e));
    const n = this._getServiceInstanceOrDescriptor(e);
    return n instanceof lr ? this._safeCreateAndCacheServiceInstance(e, n, i.branch(e, !0)) : (i.branch(e, !1), n);
  }
  _safeCreateAndCacheServiceInstance(e, i, n) {
    if (this._activeInstantiations.has(e))
      throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
    this._activeInstantiations.add(e);
    try {
      return this._createAndCacheServiceInstance(e, i, n);
    } finally {
      this._activeInstantiations.delete(e);
    }
  }
  _createAndCacheServiceInstance(e, i, n) {
    const r = new DS((l) => l.id.toString());
    let s = 0;
    const o = [{ id: e, desc: i, _trace: n }], a = /* @__PURE__ */ new Set();
    for (; o.length; ) {
      const l = o.pop();
      if (!a.has(String(l.id))) {
        if (a.add(String(l.id)), r.lookupOrInsertNode(l), s++ > 1e3)
          throw new kS(r);
        for (const c of hr.getServiceDependencies(l.desc.ctor)) {
          const u = this._getServiceInstanceOrDescriptor(c.id);
          if (u || this._throwIfStrict(`[createInstance] ${e} depends on ${c.id} which is NOT registered.`, !0), this._globalGraph?.insertEdge(String(l.id), String(c.id)), u instanceof lr) {
            const d = { id: c.id, desc: u, _trace: l._trace.branch(c.id, !0) };
            r.lookup(d) || o.push(d), r.insertEdge(l, d);
          }
        }
      }
    }
    for (; ; ) {
      const l = r.roots();
      if (l.length === 0) {
        if (!r.isEmpty())
          throw new kS(r);
        break;
      }
      for (const { data: c } of l) {
        if (this._getServiceInstanceOrDescriptor(c.id) instanceof lr) {
          const d = this._createServiceInstanceWithOwner(c.id, c.desc.ctor, c.desc.staticArguments, c.desc.supportsDelayedInstantiation, c._trace);
          this._setCreatedServiceInstance(c.id, d);
        }
        r.removeNode(c);
      }
    }
    return this._getServiceInstanceOrDescriptor(e);
  }
  _createServiceInstanceWithOwner(e, i, n = [], r, s) {
    if (this._services.get(e) instanceof lr)
      return this._createServiceInstance(e, i, n, r, s, this._servicesToMaybeDispose);
    if (this._parent)
      return this._parent._createServiceInstanceWithOwner(e, i, n, r, s);
    throw new Error(`illegalState - creating UNKNOWN service instance ${i.name}`);
  }
  _createServiceInstance(e, i, n = [], r, s, o) {
    if (r) {
      const a = new Bp(void 0, this._strict, this, this._enableTracing);
      a._globalGraphImplicitDependency = String(e);
      const l = /* @__PURE__ */ new Map(), c = new a8(() => {
        const u = a._createInstance(i, n, s);
        for (const [d, f] of l) {
          const g = u[d];
          if (typeof g == "function")
            for (const _ of f)
              _.disposable = g.apply(u, _.listener);
        }
        return l.clear(), o.add(u), u;
      });
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(u, d) {
          if (!c.isInitialized && typeof d == "string" && (d.startsWith("onDid") || d.startsWith("onWill"))) {
            let _ = l.get(d);
            return _ || (_ = new Ro(), l.set(d, _)), (v, S, E) => {
              if (c.isInitialized)
                return c.value[d](v, S, E);
              {
                const A = { listener: [v, S, E], disposable: void 0 }, j = _.push(A);
                return Ee(() => {
                  j(), A.disposable?.dispose();
                });
              }
            };
          }
          if (d in u)
            return u[d];
          const f = c.value;
          let g = f[d];
          return typeof g != "function" || (g = g.bind(f), u[d] = g), g;
        },
        set(u, d, f) {
          return c.value[d] = f, !0;
        },
        getPrototypeOf(u) {
          return i.prototype;
        }
      });
    } else {
      const a = this._createInstance(i, n, s);
      return o.add(a), a;
    }
  }
  _throwIfStrict(e, i) {
    if (i && console.warn(e), this._strict)
      throw new Error(e);
  }
}
var Jo;
(function(t) {
  t[t.None = 0] = "None", t[t.Creation = 1] = "Creation", t[t.Invocation = 2] = "Invocation", t[t.Branch = 3] = "Branch";
})(Jo || (Jo = {}));
const fn = class fn {
  static traceInvocation(e, i) {
    return e ? new fn(Jo.Invocation, i.name || new Error().stack.split(`
`).slice(3, 4).join(`
`)) : fn._None;
  }
  static traceCreation(e, i) {
    return e ? new fn(Jo.Creation, i.name) : fn._None;
  }
  constructor(e, i) {
    this.type = e, this.name = i, this._start = Date.now(), this._dep = [];
  }
  branch(e, i) {
    const n = new fn(Jo.Branch, e.toString());
    return this._dep.push([e, i, n]), n;
  }
  stop() {
    const e = Date.now() - this._start;
    fn._totals += e;
    let i = !1;
    function n(s, o) {
      const a = [], l = new Array(s + 1).join("	");
      for (const [c, u, d] of o._dep)
        if (u && d) {
          i = !0, a.push(`${l}CREATES -> ${c}`);
          const f = n(s + 1, d);
          f && a.push(f);
        } else
          a.push(`${l}uses -> ${c}`);
      return a.join(`
`);
    }
    const r = [
      `${this.type === Jo.Creation ? "CREATE" : "CALL"} ${this.name}`,
      `${n(1, this)}`,
      `DONE, took ${e.toFixed(2)}ms (grand total ${fn._totals.toFixed(2)}ms)`
    ];
    (e > 2 || i) && fn.all.add(r.join(`
`));
  }
};
fn.all = /* @__PURE__ */ new Set(), fn._None = new class extends fn {
  constructor() {
    super(Jo.None, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}(), fn._totals = 0;
let sd = fn;
const Ye = pe("IExtHostRpcService");
class b8 {
  constructor(e) {
    this.getProxy = e.getProxy.bind(e), this.set = e.set.bind(e), this.dispose = e.dispose.bind(e), this.assertRegistered = e.assertRegistered.bind(e), this.drain = e.drain.bind(e);
  }
}
const B_ = pe("IURITransformerService");
class y8 {
  constructor(e) {
    e ? (this.transformIncoming = e.transformIncoming.bind(e), this.transformOutgoing = e.transformOutgoing.bind(e), this.transformOutgoingURI = e.transformOutgoingURI.bind(e), this.transformOutgoingScheme = e.transformOutgoingScheme.bind(e)) : (this.transformIncoming = (i) => i, this.transformOutgoing = (i) => i, this.transformOutgoingURI = (i) => i, this.transformOutgoingScheme = (i) => i);
  }
}
function W(t, e, i, n) {
  var r = arguments.length, s = r < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, i) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, i, n);
  else for (var a = t.length - 1; a >= 0; a--) (o = t[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, i, s) : o(e, i)) || s);
  return r > 3 && s && Object.defineProperty(e, i, s), s;
}
function M(t, e) {
  return function(i, n) {
    e(i, n, t);
  };
}
class x8 {
  constructor() {
    this._value = "", this._pos = 0;
  }
  reset(e) {
    return this._value = e, this._pos = 0, this;
  }
  next() {
    return this._pos += 1, this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(e) {
    const i = e.charCodeAt(0), n = this._value.charCodeAt(this._pos);
    return i - n;
  }
  value() {
    return this._value[this._pos];
  }
}
class E8 {
  constructor(e = !0) {
    this._caseSensitive = e;
  }
  reset(e) {
    return this._value = e, this._from = 0, this._to = 0, this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._value.length; this._to++)
      if (this._value.charCodeAt(this._to) === L.Period)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? Sx(e, this._value, 0, e.length, this._from, this._to) : lf(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class z4 {
  constructor(e = !0, i = !0) {
    this._splitOnBackslash = e, this._caseSensitive = i;
  }
  reset(e) {
    this._from = 0, this._to = 0, this._value = e, this._valueLen = e.length;
    for (let i = e.length - 1; i >= 0; i--, this._valueLen--) {
      const n = this._value.charCodeAt(i);
      if (!(n === L.Slash || this._splitOnBackslash && n === L.Backslash))
        break;
    }
    return this.next();
  }
  hasNext() {
    return this._to < this._valueLen;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._valueLen; this._to++) {
      const i = this._value.charCodeAt(this._to);
      if (i === L.Slash || this._splitOnBackslash && i === L.Backslash)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    }
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? Sx(e, this._value, 0, e.length, this._from, this._to) : lf(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
var vi;
(function(t) {
  t[t.Scheme = 1] = "Scheme", t[t.Authority = 2] = "Authority", t[t.Path = 3] = "Path", t[t.Query = 4] = "Query", t[t.Fragment = 5] = "Fragment";
})(vi || (vi = {}));
class q4 {
  constructor(e, i) {
    this._ignorePathCasing = e, this._ignoreQueryAndFragment = i, this._states = [], this._stateIdx = 0;
  }
  reset(e) {
    return this._value = e, this._states = [], this._value.scheme && this._states.push(vi.Scheme), this._value.authority && this._states.push(vi.Authority), this._value.path && (this._pathIterator = new z4(!1, !this._ignorePathCasing(e)), this._pathIterator.reset(e.path), this._pathIterator.value() && this._states.push(vi.Path)), this._ignoreQueryAndFragment(e) || (this._value.query && this._states.push(vi.Query), this._value.fragment && this._states.push(vi.Fragment)), this._stateIdx = 0, this;
  }
  next() {
    return this._states[this._stateIdx] === vi.Path && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1, this;
  }
  hasNext() {
    return this._states[this._stateIdx] === vi.Path && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(e) {
    if (this._states[this._stateIdx] === vi.Scheme)
      return Cv(e, this._value.scheme);
    if (this._states[this._stateIdx] === vi.Authority)
      return Cv(e, this._value.authority);
    if (this._states[this._stateIdx] === vi.Path)
      return this._pathIterator.cmp(e);
    if (this._states[this._stateIdx] === vi.Query)
      return Ya(e, this._value.query);
    if (this._states[this._stateIdx] === vi.Fragment)
      return Ya(e, this._value.fragment);
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === vi.Scheme)
      return this._value.scheme;
    if (this._states[this._stateIdx] === vi.Authority)
      return this._value.authority;
    if (this._states[this._stateIdx] === vi.Path)
      return this._pathIterator.value();
    if (this._states[this._stateIdx] === vi.Query)
      return this._value.query;
    if (this._states[this._stateIdx] === vi.Fragment)
      return this._value.fragment;
    throw new Error();
  }
}
const Md = class Md {
  static wrap(e) {
    return e === void 0 ? Md.Val : e;
  }
  static unwrap(e) {
    return e === Md.Val ? void 0 : e;
  }
};
Md.Val = Symbol("undefined_placeholder");
let us = Md;
class Lf {
  constructor() {
    this.height = 1, this.value = void 0, this.key = void 0, this.left = void 0, this.mid = void 0, this.right = void 0;
  }
  isEmpty() {
    return !this.left && !this.mid && !this.right && this.value === void 0;
  }
  rotateLeft() {
    const e = this.right;
    return this.right = e.left, e.left = this, this.updateHeight(), e.updateHeight(), e;
  }
  rotateRight() {
    const e = this.left;
    return this.left = e.right, e.right = this, this.updateHeight(), e.updateHeight(), e;
  }
  updateHeight() {
    this.height = 1 + Math.max(this.heightLeft, this.heightRight);
  }
  balanceFactor() {
    return this.heightRight - this.heightLeft;
  }
  get heightLeft() {
    return this.left?.height ?? 0;
  }
  get heightRight() {
    return this.right?.height ?? 0;
  }
}
var pt;
(function(t) {
  t[t.Left = -1] = "Left", t[t.Mid = 0] = "Mid", t[t.Right = 1] = "Right";
})(pt || (pt = {}));
class $r {
  static forUris(e = () => !1, i = () => !1) {
    return new $r(new q4(e, i));
  }
  static forPaths(e = !1) {
    return new $r(new z4(void 0, !e));
  }
  static forStrings() {
    return new $r(new x8());
  }
  static forConfigKeys() {
    return new $r(new E8());
  }
  constructor(e) {
    this._iter = e;
  }
  clear() {
    this._root = void 0;
  }
  fill(e, i) {
    if (i) {
      const n = i.slice(0);
      BE(n);
      for (const r of n)
        this.set(r, e);
    } else {
      const n = e.slice(0);
      BE(n);
      for (const r of n)
        this.set(r[0], r[1]);
    }
  }
  set(e, i) {
    const n = this._iter.reset(e);
    let r;
    this._root || (this._root = new Lf(), this._root.segment = n.value());
    const s = [];
    for (r = this._root; ; ) {
      const a = n.cmp(r.segment);
      if (a > 0)
        r.left || (r.left = new Lf(), r.left.segment = n.value()), s.push([pt.Left, r]), r = r.left;
      else if (a < 0)
        r.right || (r.right = new Lf(), r.right.segment = n.value()), s.push([pt.Right, r]), r = r.right;
      else if (n.hasNext())
        n.next(), r.mid || (r.mid = new Lf(), r.mid.segment = n.value()), s.push([pt.Mid, r]), r = r.mid;
      else
        break;
    }
    const o = us.unwrap(r.value);
    r.value = us.wrap(i), r.key = e;
    for (let a = s.length - 1; a >= 0; a--) {
      const l = s[a][1];
      l.updateHeight();
      const c = l.balanceFactor();
      if (c < -1 || c > 1) {
        const u = s[a][0], d = s[a + 1][0];
        if (u === pt.Right && d === pt.Right)
          s[a][1] = l.rotateLeft();
        else if (u === pt.Left && d === pt.Left)
          s[a][1] = l.rotateRight();
        else if (u === pt.Right && d === pt.Left)
          l.right = s[a + 1][1] = s[a + 1][1].rotateRight(), s[a][1] = l.rotateLeft();
        else if (u === pt.Left && d === pt.Right)
          l.left = s[a + 1][1] = s[a + 1][1].rotateLeft(), s[a][1] = l.rotateRight();
        else
          throw new Error();
        if (a > 0)
          switch (s[a - 1][0]) {
            case pt.Left:
              s[a - 1][1].left = s[a][1];
              break;
            case pt.Right:
              s[a - 1][1].right = s[a][1];
              break;
            case pt.Mid:
              s[a - 1][1].mid = s[a][1];
              break;
          }
        else
          this._root = s[0][1];
      }
    }
    return o;
  }
  get(e) {
    return us.unwrap(this._getNode(e)?.value);
  }
  _getNode(e) {
    const i = this._iter.reset(e);
    let n = this._root;
    for (; n; ) {
      const r = i.cmp(n.segment);
      if (r > 0)
        n = n.left;
      else if (r < 0)
        n = n.right;
      else if (i.hasNext())
        i.next(), n = n.mid;
      else
        break;
    }
    return n;
  }
  has(e) {
    const i = this._getNode(e);
    return !(i?.value === void 0 && i?.mid === void 0);
  }
  delete(e) {
    return this._delete(e, !1);
  }
  deleteSuperstr(e) {
    return this._delete(e, !0);
  }
  _delete(e, i) {
    const n = this._iter.reset(e), r = [];
    let s = this._root;
    for (; s; ) {
      const o = n.cmp(s.segment);
      if (o > 0)
        r.push([pt.Left, s]), s = s.left;
      else if (o < 0)
        r.push([pt.Right, s]), s = s.right;
      else if (n.hasNext())
        n.next(), r.push([pt.Mid, s]), s = s.mid;
      else
        break;
    }
    if (s) {
      if (i ? (s.left = void 0, s.mid = void 0, s.right = void 0, s.height = 1) : (s.key = void 0, s.value = void 0), !s.mid && !s.value)
        if (s.left && s.right) {
          const o = [[pt.Right, s]], a = this._min(s.right, o);
          if (a.key) {
            s.key = a.key, s.value = a.value, s.segment = a.segment;
            const l = a.right;
            if (o.length > 1) {
              const [u, d] = o[o.length - 1];
              switch (u) {
                case pt.Left:
                  d.left = l;
                  break;
                case pt.Mid:
                  wv(!1);
                case pt.Right:
                  wv(!1);
              }
            } else
              s.right = l;
            const c = this._balanceByStack(o);
            if (r.length > 0) {
              const [u, d] = r[r.length - 1];
              switch (u) {
                case pt.Left:
                  d.left = c;
                  break;
                case pt.Mid:
                  d.mid = c;
                  break;
                case pt.Right:
                  d.right = c;
                  break;
              }
            } else
              this._root = c;
          }
        } else {
          const o = s.left ?? s.right;
          if (r.length > 0) {
            const [a, l] = r[r.length - 1];
            switch (a) {
              case pt.Left:
                l.left = o;
                break;
              case pt.Mid:
                l.mid = o;
                break;
              case pt.Right:
                l.right = o;
                break;
            }
          } else
            this._root = o;
        }
      this._root = this._balanceByStack(r) ?? this._root;
    }
  }
  _min(e, i) {
    for (; e.left; )
      i.push([pt.Left, e]), e = e.left;
    return e;
  }
  _balanceByStack(e) {
    for (let i = e.length - 1; i >= 0; i--) {
      const n = e[i][1];
      n.updateHeight();
      const r = n.balanceFactor();
      if (r > 1 ? (n.right.balanceFactor() >= 0 || (n.right = n.right.rotateRight()), e[i][1] = n.rotateLeft()) : r < -1 && (n.left.balanceFactor() <= 0 || (n.left = n.left.rotateLeft()), e[i][1] = n.rotateRight()), i > 0)
        switch (e[i - 1][0]) {
          case pt.Left:
            e[i - 1][1].left = e[i][1];
            break;
          case pt.Right:
            e[i - 1][1].right = e[i][1];
            break;
          case pt.Mid:
            e[i - 1][1].mid = e[i][1];
            break;
        }
      else
        return e[0][1];
    }
  }
  findSubstr(e) {
    const i = this._iter.reset(e);
    let n = this._root, r;
    for (; n; ) {
      const s = i.cmp(n.segment);
      if (s > 0)
        n = n.left;
      else if (s < 0)
        n = n.right;
      else if (i.hasNext())
        i.next(), r = us.unwrap(n.value) || r, n = n.mid;
      else
        break;
    }
    return n && us.unwrap(n.value) || r;
  }
  findSuperstr(e) {
    return this._findSuperstrOrElement(e, !1);
  }
  _findSuperstrOrElement(e, i) {
    const n = this._iter.reset(e);
    let r = this._root;
    for (; r; ) {
      const s = n.cmp(r.segment);
      if (s > 0)
        r = r.left;
      else if (s < 0)
        r = r.right;
      else if (n.hasNext())
        n.next(), r = r.mid;
      else
        return r.mid ? this._entries(r.mid) : i ? us.unwrap(r.value) : void 0;
    }
  }
  hasElementOrSubtree(e) {
    return this._findSuperstrOrElement(e, !0) !== void 0;
  }
  forEach(e) {
    for (const [i, n] of this)
      e(n, i);
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  _entries(e) {
    const i = [];
    return this._dfsEntries(e, i), i[Symbol.iterator]();
  }
  _dfsEntries(e, i) {
    e && (e.left && this._dfsEntries(e.left, i), e.value !== void 0 && i.push([e.key, us.unwrap(e.value)]), e.mid && this._dfsEntries(e.mid, i), e.right && this._dfsEntries(e.right, i));
  }
  _isBalanced() {
    const e = (i) => {
      if (!i)
        return !0;
      const n = i.balanceFactor();
      return n < -1 || n > 1 ? !1 : e(i.left) && e(i.right);
    };
    return e(this._root);
  }
}
function yt(t) {
  if (!t || typeof t != "object" || t instanceof RegExp)
    return t;
  const e = Array.isArray(t) ? [] : {};
  return Object.entries(t).forEach(([i, n]) => {
    e[i] = n && typeof n == "object" ? yt(n) : n;
  }), e;
}
function Ov(t) {
  if (!t || typeof t != "object")
    return t;
  const e = [t];
  for (; e.length > 0; ) {
    const i = e.shift();
    for (const n in i)
      if (j4.call(i, n)) {
        const r = i[n];
        typeof r == "object" && !Object.isFrozen(r) && !nA(r) && e.push(r);
      }
  }
  return t;
}
const j4 = Object.prototype.hasOwnProperty;
function Wc(t, e) {
  return Fv(t, e, /* @__PURE__ */ new Set());
}
function Fv(t, e, i) {
  if (ni(t))
    return t;
  const n = e(t);
  if (typeof n < "u")
    return n;
  if (Array.isArray(t)) {
    const r = [];
    for (const s of t)
      r.push(Fv(s, e, i));
    return r;
  }
  if (ri(t)) {
    if (i.has(t))
      throw new Error("Cannot clone recursive data-structure");
    i.add(t);
    const r = {};
    for (const s in t)
      j4.call(t, s) && (r[s] = Fv(t[s], e, i));
    return i.delete(t), r;
  }
  return t;
}
function Za(t, e, i = !0) {
  return ri(t) ? (ri(e) && Object.keys(e).forEach((n) => {
    n in t ? i && (ri(t[n]) && ri(e[n]) ? Za(t[n], e[n], i) : t[n] = e[n]) : t[n] = e[n];
  }), t) : e;
}
function sn(t, e) {
  if (t === e)
    return !0;
  if (t == null || e === null || e === void 0 || typeof t != typeof e || typeof t != "object" || Array.isArray(t) !== Array.isArray(e))
    return !1;
  let i, n;
  if (Array.isArray(t)) {
    if (t.length !== e.length)
      return !1;
    for (i = 0; i < t.length; i++)
      if (!sn(t[i], e[i]))
        return !1;
  } else {
    const r = [];
    for (n in t)
      r.push(n);
    r.sort();
    const s = [];
    for (n in e)
      s.push(n);
    if (s.sort(), !sn(r, s))
      return !1;
    for (i = 0; i < r.length; i++)
      if (!sn(t[r[i]], e[r[i]]))
        return !1;
  }
  return !0;
}
function S8(t) {
  const e = /* @__PURE__ */ new Set();
  return JSON.stringify(t, (i, n) => {
    if (ri(n) || Array.isArray(n)) {
      if (e.has(n))
        return "[Circular]";
      e.add(n);
    }
    return typeof n == "bigint" ? `[BigInt ${n.toString()}]` : n;
  });
}
function IS(t, e) {
  const i = /* @__PURE__ */ Object.create(null);
  for (const [n, r] of Object.entries(t))
    e(n, r) && (i[n] = r);
  return i;
}
class D8 {
  constructor() {
    this._next = 0;
  }
  getNext() {
    return this._next++;
  }
}
var Da;
(function(t) {
  t[t.Unknown = 0] = "Unknown", t[t.File = 1] = "File", t[t.Directory = 2] = "Directory", t[t.SymbolicLink = 64] = "SymbolicLink";
})(Da || (Da = {}));
var Vc;
(function(t) {
  t[t.Readonly = 1] = "Readonly", t[t.Locked = 2] = "Locked";
})(Vc || (Vc = {}));
var Js;
(function(t) {
  t[t.UPDATED = 2] = "UPDATED", t[t.ADDED = 4] = "ADDED", t[t.DELETED = 8] = "DELETED";
})(Js || (Js = {}));
var Rr;
(function(t) {
  t[t.None = 0] = "None", t[t.FileReadWrite = 2] = "FileReadWrite", t[t.FileOpenReadWriteClose = 4] = "FileOpenReadWriteClose", t[t.FileReadStream = 16] = "FileReadStream", t[t.FileFolderCopy = 8] = "FileFolderCopy", t[t.PathCaseSensitive = 1024] = "PathCaseSensitive", t[t.Readonly = 2048] = "Readonly", t[t.Trash = 4096] = "Trash", t[t.FileWriteUnlock = 8192] = "FileWriteUnlock", t[t.FileAtomicRead = 16384] = "FileAtomicRead", t[t.FileAtomicWrite = 32768] = "FileAtomicWrite", t[t.FileAtomicDelete = 65536] = "FileAtomicDelete", t[t.FileClone = 131072] = "FileClone", t[t.FileRealpath = 262144] = "FileRealpath";
})(Rr || (Rr = {}));
var Me;
(function(t) {
  t.FileExists = "EntryExists", t.FileNotFound = "EntryNotFound", t.FileNotADirectory = "EntryNotADirectory", t.FileIsADirectory = "EntryIsADirectory", t.FileExceedsStorageQuota = "EntryExceedsStorageQuota", t.FileTooLarge = "EntryTooLarge", t.FileWriteLocked = "EntryWriteLocked", t.NoPermissions = "NoPermissions", t.Unavailable = "Unavailable", t.Unknown = "Unknown";
})(Me || (Me = {}));
class W_ extends Error {
  static create(e, i) {
    const n = new W_(e.toString(), i);
    return G4(n, i), n;
  }
  constructor(e, i) {
    super(e), this.code = i;
  }
}
function G4(t, e) {
  return t.name = e ? `${e} (FileSystemError)` : "FileSystemError", t;
}
function Wp(t) {
  if (!t)
    return Me.Unknown;
  if (t instanceof W_)
    return t.code;
  const e = /^(.+) \(FileSystemError\)$/.exec(t.name);
  if (!e)
    return Me.Unknown;
  switch (e[1]) {
    case Me.FileExists:
      return Me.FileExists;
    case Me.FileIsADirectory:
      return Me.FileIsADirectory;
    case Me.FileNotADirectory:
      return Me.FileNotADirectory;
    case Me.FileNotFound:
      return Me.FileNotFound;
    case Me.FileTooLarge:
      return Me.FileTooLarge;
    case Me.FileWriteLocked:
      return Me.FileWriteLocked;
    case Me.NoPermissions:
      return Me.NoPermissions;
    case Me.Unavailable:
      return Me.Unavailable;
  }
  return Me.Unknown;
}
function k8(t) {
  if (t instanceof Uv)
    return t.fileOperationResult;
  switch (Wp(t)) {
    case Me.FileNotFound:
      return Dn.FILE_NOT_FOUND;
    case Me.FileIsADirectory:
      return Dn.FILE_IS_DIRECTORY;
    case Me.FileNotADirectory:
      return Dn.FILE_NOT_DIRECTORY;
    case Me.FileWriteLocked:
      return Dn.FILE_WRITE_LOCKED;
    case Me.NoPermissions:
      return Dn.FILE_PERMISSION_DENIED;
    case Me.FileExists:
      return Dn.FILE_MOVE_CONFLICT;
    case Me.FileTooLarge:
      return Dn.FILE_TOO_LARGE;
    default:
      return Dn.FILE_OTHER_ERROR;
  }
}
var kr;
(function(t) {
  t[t.CREATE = 0] = "CREATE", t[t.DELETE = 1] = "DELETE", t[t.MOVE = 2] = "MOVE", t[t.COPY = 3] = "COPY", t[t.WRITE = 4] = "WRITE";
})(kr || (kr = {}));
var od;
(function(t) {
  t[t.UPDATED = 0] = "UPDATED", t[t.ADDED = 1] = "ADDED", t[t.DELETED = 2] = "DELETED";
})(od || (od = {}));
class Uv extends Error {
  constructor(e, i, n) {
    super(e), this.fileOperationResult = i, this.options = n;
  }
}
var Dn;
(function(t) {
  t[t.FILE_IS_DIRECTORY = 0] = "FILE_IS_DIRECTORY", t[t.FILE_NOT_FOUND = 1] = "FILE_NOT_FOUND", t[t.FILE_NOT_MODIFIED_SINCE = 2] = "FILE_NOT_MODIFIED_SINCE", t[t.FILE_MODIFIED_SINCE = 3] = "FILE_MODIFIED_SINCE", t[t.FILE_MOVE_CONFLICT = 4] = "FILE_MOVE_CONFLICT", t[t.FILE_WRITE_LOCKED = 5] = "FILE_WRITE_LOCKED", t[t.FILE_PERMISSION_DENIED = 6] = "FILE_PERMISSION_DENIED", t[t.FILE_TOO_LARGE = 7] = "FILE_TOO_LARGE", t[t.FILE_INVALID_PATH = 8] = "FILE_INVALID_PATH", t[t.FILE_NOT_DIRECTORY = 9] = "FILE_NOT_DIRECTORY", t[t.FILE_OTHER_ERROR = 10] = "FILE_OTHER_ERROR";
})(Dn || (Dn = {}));
var CS;
(function(t) {
  t[t.FILE = 0] = "FILE", t[t.FOLDER = 1] = "FOLDER", t[t.ROOT_FOLDER = 2] = "ROOT_FOLDER";
})(CS || (CS = {}));
const I8 = "";
function TS(t) {
  if (!(typeof t.size != "number" || typeof t.mtime != "number"))
    return t.mtime.toString(29) + t.size.toString(31);
}
const mi = class mi {
  static formatSize(e) {
    return xa(e) || (e = 0), e < mi.KB ? h(1908, "{0}B", e.toFixed(0)) : e < mi.MB ? h(1909, "{0}KB", (e / mi.KB).toFixed(2)) : e < mi.GB ? h(1910, "{0}MB", (e / mi.MB).toFixed(2)) : e < mi.TB ? h(1911, "{0}GB", (e / mi.GB).toFixed(2)) : h(1912, "{0}TB", (e / mi.TB).toFixed(2));
  }
};
mi.KB = 1024, mi.MB = mi.KB * mi.KB, mi.GB = mi.MB * mi.KB, mi.TB = mi.GB * mi.KB;
let PS = mi;
var jd;
(function(t) {
  t[t.Ignore = 0] = "Ignore", t[t.Info = 1] = "Info", t[t.Warning = 2] = "Warning", t[t.Error = 3] = "Error";
})(jd || (jd = {}));
(function(t) {
  const e = "error", i = "warning", n = "warn", r = "info", s = "ignore";
  function o(l) {
    return l ? ca(e, l) ? t.Error : ca(i, l) || ca(n, l) ? t.Warning : ca(r, l) ? t.Info : t.Ignore : t.Ignore;
  }
  t.fromValue = o;
  function a(l) {
    switch (l) {
      case t.Error:
        return e;
      case t.Warning:
        return i;
      case t.Info:
        return r;
      default:
        return s;
    }
  }
  t.toString = a;
})(jd || (jd = {}));
var Qt = jd, AS;
(function(t) {
  t[t.DEFAULT = 0] = "DEFAULT", t[t.OPTIONAL = 1] = "OPTIONAL", t[t.SILENT = 2] = "SILENT", t[t.URGENT = 3] = "URGENT";
})(AS || (AS = {}));
var RS;
(function(t) {
  t[t.WORKSPACE = 0] = "WORKSPACE", t[t.PROFILE = 1] = "PROFILE", t[t.APPLICATION = 2] = "APPLICATION";
})(RS || (RS = {}));
var LS;
(function(t) {
  t[t.OFF = 0] = "OFF", t[t.ERROR = 1] = "ERROR";
})(LS || (LS = {}));
function C8(t) {
  const e = t;
  return typeof e?.id == "string" && x.isUri(e.uri);
}
function T8(t) {
  const e = t;
  return typeof e?.id == "string" && x.isUri(e.configPath);
}
var Vp;
(function(t) {
  t[t.EMPTY = 1] = "EMPTY", t[t.FOLDER = 2] = "FOLDER", t[t.WORKSPACE = 3] = "WORKSPACE";
})(Vp || (Vp = {}));
let P8 = class {
  get folders() {
    return this._folders;
  }
  set folders(e) {
    this._folders = e, this.updateFoldersMap();
  }
  constructor(e, i, n, r, s) {
    this._id = e, this._transient = n, this._configuration = r, this.ignorePathCasing = s, this.foldersMap = $r.forUris(this.ignorePathCasing, () => !0), this.folders = i;
  }
  update(e) {
    this._id = e.id, this._configuration = e.configuration, this._transient = e.transient, this.ignorePathCasing = e.ignorePathCasing, this.folders = e.folders;
  }
  get id() {
    return this._id;
  }
  get transient() {
    return this._transient;
  }
  get configuration() {
    return this._configuration;
  }
  set configuration(e) {
    this._configuration = e;
  }
  getFolder(e) {
    return e && this.foldersMap.findSubstr(e) || null;
  }
  updateFoldersMap() {
    this.foldersMap = $r.forUris(this.ignorePathCasing, () => !0);
    for (const e of this.folders)
      this.foldersMap.set(e.uri, e);
  }
  toJSON() {
    return { id: this.id, folders: this.folders, transient: this.transient, configuration: this.configuration };
  }
};
class Q4 {
  constructor(e, i) {
    this.raw = i, this.uri = e.uri, this.index = e.index, this.name = e.name;
  }
  toResource(e) {
    return wi(this.uri, e);
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
}
function $1(t) {
  return new Q4(
    { uri: t, index: 0, name: Av(t) },
    { uri: t.toString() }
  );
}
const A8 = "code-workspace";
h(2419, "Code Workspace");
class R8 {
  constructor() {
    this._systemSchemes = new Set(Object.keys(de)), this._providerInfo = /* @__PURE__ */ new Map(), this.extUri = new cf((e) => {
      const i = this._providerInfo.get(e.scheme);
      return !(i === void 0 || i & Rr.PathCaseSensitive);
    });
  }
  $acceptProviderInfos(e, i) {
    i === null ? this._providerInfo.delete(e.scheme) : this._providerInfo.set(e.scheme, i);
  }
  isFreeScheme(e) {
    return !this._providerInfo.has(e) && !this._systemSchemes.has(e);
  }
  getCapabilities(e) {
    return this._providerInfo.get(e);
  }
}
const wu = pe("IExtHostFileSystemInfo"), on = function() {
  if (typeof crypto.randomUUID == "function")
    return crypto.randomUUID.bind(crypto);
  const t = new Uint8Array(16), e = [];
  for (let i = 0; i < 256; i++)
    e.push(i.toString(16).padStart(2, "0"));
  return function() {
    crypto.getRandomValues(t), t[6] = t[6] & 15 | 64, t[8] = t[8] & 63 | 128;
    let n = 0, r = "";
    return r += e[t[n++]], r += e[t[n++]], r += e[t[n++]], r += e[t[n++]], r += "-", r += e[t[n++]], r += e[t[n++]], r += "-", r += e[t[n++]], r += e[t[n++]], r += "-", r += e[t[n++]], r += e[t[n++]], r += "-", r += e[t[n++]], r += e[t[n++]], r += e[t[n++]], r += e[t[n++]], r += e[t[n++]], r += e[t[n++]], r;
  };
}(), $v = Object.freeze({
  create: (t) => Fl(t.map((e) => e.toString())).join(`\r
`),
  split: (t) => t.split(`\r
`),
  parse: (t) => $v.split(t).filter((e) => !e.startsWith("#"))
});
var NS;
(function(t) {
  t[t.InitialConsonant = 4352] = "InitialConsonant", t[t.Vowel = 4449] = "Vowel", t[t.FinalConsonant = 4520] = "FinalConsonant", t[t.CompatibilityJamo = 12593] = "CompatibilityJamo";
})(NS || (NS = {}));
var ne;
(function(t) {
  t[t.NUL = 0] = "NUL", t[t.A = 65] = "A", t[t.B = 66] = "B", t[t.C = 67] = "C", t[t.D = 68] = "D", t[t.E = 69] = "E", t[t.F = 70] = "F", t[t.G = 71] = "G", t[t.H = 72] = "H", t[t.I = 73] = "I", t[t.J = 74] = "J", t[t.K = 75] = "K", t[t.L = 76] = "L", t[t.M = 77] = "M", t[t.N = 78] = "N", t[t.O = 79] = "O", t[t.P = 80] = "P", t[t.Q = 81] = "Q", t[t.R = 82] = "R", t[t.S = 83] = "S", t[t.T = 84] = "T", t[t.U = 85] = "U", t[t.V = 86] = "V", t[t.W = 87] = "W", t[t.X = 88] = "X", t[t.Y = 89] = "Y", t[t.Z = 90] = "Z", t[t.a = 97] = "a", t[t.b = 98] = "b", t[t.c = 99] = "c", t[t.d = 100] = "d", t[t.e = 101] = "e", t[t.f = 102] = "f", t[t.g = 103] = "g", t[t.h = 104] = "h", t[t.i = 105] = "i", t[t.j = 106] = "j", t[t.k = 107] = "k", t[t.l = 108] = "l", t[t.m = 109] = "m", t[t.n = 110] = "n", t[t.o = 111] = "o", t[t.p = 112] = "p", t[t.q = 113] = "q", t[t.r = 114] = "r", t[t.s = 115] = "s", t[t.t = 116] = "t", t[t.u = 117] = "u", t[t.v = 118] = "v", t[t.w = 119] = "w", t[t.x = 120] = "x", t[t.y = 121] = "y", t[t.z = 122] = "z";
})(ne || (ne = {}));
var et;
(function(t) {
  t[t.fa = 24934] = "fa", t[t.fg = 26470] = "fg", t[t.fq = 29030] = "fq", t[t.fr = 29286] = "fr", t[t.ft = 29798] = "ft", t[t.fv = 30310] = "fv", t[t.fx = 30822] = "fx", t[t.hk = 27496] = "hk", t[t.hl = 27752] = "hl", t[t.ho = 28520] = "ho", t[t.ml = 27757] = "ml", t[t.nj = 27246] = "nj", t[t.nl = 27758] = "nl", t[t.np = 28782] = "np", t[t.qt = 29809] = "qt", t[t.rt = 29810] = "rt", t[t.sg = 26483] = "sg", t[t.sw = 30579] = "sw";
})(et || (et = {}));
new Uint8Array([
  ne.r,
  ne.R,
  ne.s,
  ne.e,
  ne.E,
  ne.f,
  ne.a,
  ne.q,
  ne.Q,
  ne.t,
  ne.T,
  ne.d,
  ne.w,
  ne.W,
  ne.c,
  ne.z,
  ne.x,
  ne.v,
  ne.g
]);
new Uint16Array([
  ne.k,
  ne.o,
  ne.i,
  ne.O,
  ne.j,
  ne.p,
  ne.u,
  ne.P,
  ne.h,
  et.hk,
  et.ho,
  et.hl,
  ne.y,
  ne.n,
  et.nj,
  et.np,
  et.nl,
  ne.b,
  ne.m,
  et.ml,
  ne.l
]);
new Uint16Array([
  ne.r,
  ne.R,
  et.rt,
  ne.s,
  et.sw,
  et.sg,
  ne.e,
  ne.f,
  et.fr,
  et.fa,
  et.fq,
  et.ft,
  et.fx,
  et.fv,
  et.fg,
  ne.a,
  ne.q,
  et.qt,
  ne.t,
  ne.T,
  ne.d,
  ne.w,
  ne.c,
  ne.z,
  ne.x,
  ne.v,
  ne.g
]);
new Uint16Array([
  ne.r,
  ne.R,
  et.rt,
  ne.s,
  et.sw,
  et.sg,
  ne.e,
  ne.E,
  ne.f,
  et.fr,
  et.fa,
  et.fq,
  et.ft,
  et.fx,
  et.fv,
  et.fg,
  ne.a,
  ne.q,
  ne.Q,
  et.qt,
  ne.t,
  ne.T,
  ne.d,
  ne.w,
  ne.W,
  ne.c,
  ne.z,
  ne.x,
  ne.v,
  ne.g,
  ne.k,
  ne.o,
  ne.i,
  ne.O,
  ne.j,
  ne.p,
  ne.u,
  ne.P,
  ne.h,
  et.hk,
  et.ho,
  et.hl,
  ne.y,
  ne.n,
  et.nj,
  et.np,
  et.nl,
  ne.b,
  ne.m,
  et.ml,
  ne.l
]);
function K4(...t) {
  return function(e, i) {
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n](e, i);
      if (s)
        return s;
    }
    return null;
  };
}
Y4.bind(void 0, !1);
const J4 = Y4.bind(void 0, !0);
function Y4(t, e, i) {
  if (!i || i.length < e.length)
    return null;
  let n;
  return t ? n = Dx(i, e) : n = i.indexOf(e) === 0, n ? e.length > 0 ? [{ start: 0, end: e.length }] : [] : null;
}
function L8(t, e) {
  const i = e.toLowerCase().indexOf(t.toLowerCase());
  return i === -1 ? null : [{ start: i, end: i + t.length }];
}
function N8(t, e) {
  return Hv(t.toLowerCase(), e.toLowerCase(), 0, 0);
}
function Hv(t, e, i, n) {
  if (i === t.length)
    return [];
  if (n === e.length)
    return null;
  if (t[i] === e[n]) {
    let r = null;
    return (r = Hv(t, e, i + 1, n + 1)) ? Z4({ start: n, end: n + 1 }, r) : null;
  }
  return Hv(t, e, i, n + 1);
}
function Ax(t) {
  return L.a <= t && t <= L.z;
}
function V_(t) {
  return L.A <= t && t <= L.Z;
}
function Rx(t) {
  return L.Digit0 <= t && t <= L.Digit9;
}
function M8(t) {
  return t === L.Space || t === L.Tab || t === L.LineFeed || t === L.CarriageReturn;
}
const O8 = /* @__PURE__ */ new Set();
"()[]{}<>`'\"-/;:,.?!".split("").forEach((t) => O8.add(t.charCodeAt(0)));
function X4(t) {
  return Ax(t) || V_(t) || Rx(t);
}
function Z4(t, e) {
  return e.length === 0 ? e = [t] : t.end === e[0].start ? e[0].start = t.start : e.unshift(t), e;
}
function eT(t, e) {
  for (let i = e; i < t.length; i++) {
    const n = t.charCodeAt(i);
    if (V_(n) || Rx(n) || i > 0 && !X4(t.charCodeAt(i - 1)))
      return i;
  }
  return t.length;
}
function Bv(t, e, i, n) {
  if (i === t.length)
    return [];
  if (n === e.length)
    return null;
  if (t[i] !== e[n].toLowerCase())
    return null;
  {
    let r = null, s = n + 1;
    for (r = Bv(t, e, i + 1, n + 1); !r && (s = eT(e, s)) < e.length; )
      r = Bv(t, e, i + 1, s), s++;
    return r === null ? null : Z4({ start: n, end: n + 1 }, r);
  }
}
function F8(t) {
  let e = 0, i = 0, n = 0, r = 0, s = 0;
  for (let u = 0; u < t.length; u++)
    s = t.charCodeAt(u), V_(s) && e++, Ax(s) && i++, X4(s) && n++, Rx(s) && r++;
  const o = e / t.length, a = i / t.length, l = n / t.length, c = r / t.length;
  return { upperPercent: o, lowerPercent: a, alphaPercent: l, numericPercent: c };
}
function U8(t) {
  const { upperPercent: e, lowerPercent: i } = t;
  return i === 0 && e > 0.6;
}
function $8(t) {
  const { upperPercent: e, lowerPercent: i, alphaPercent: n, numericPercent: r } = t;
  return i > 0.2 && e < 0.8 && n > 0.6 && r < 0.2;
}
function H8(t) {
  let e = 0, i = 0, n = 0, r = 0;
  for (let s = 0; s < t.length; s++)
    n = t.charCodeAt(s), V_(n) && e++, Ax(n) && i++, M8(n) && r++;
  return (e === 0 || i === 0) && r === 0 ? t.length <= 30 : e <= 5;
}
function tT(t, e) {
  if (!e || (e = e.trim(), e.length === 0) || !H8(t))
    return null;
  e.length > 60 && (e = e.substring(0, 60));
  const i = F8(e);
  if (!$8(i)) {
    if (!U8(i))
      return null;
    e = e.toLowerCase();
  }
  let n = null, r = 0;
  for (t = t.toLowerCase(); r < e.length && (n = Bv(t, e, 0, r)) === null; )
    r = eT(e, r + 1);
  return n;
}
K4(J4, tT, L8);
K4(J4, tT, N8);
new _x(1e4);
const MS = 128;
function Lx() {
  const t = [], e = [];
  for (let i = 0; i <= MS; i++)
    e[i] = 0;
  for (let i = 0; i <= MS; i++)
    t.push(e.slice(0));
  return t;
}
Lx();
Lx();
Lx();
var OS;
(function(t) {
  t[t.Diag = 1] = "Diag", t[t.Left = 2] = "Left", t[t.LeftLeft = 3] = "LeftLeft";
})(OS || (OS = {}));
var FS;
(function(t) {
  t.Default = [-100, 0];
  function e(i) {
    return !i || i.length === 2 && i[0] === -100 && i[1] === 0;
  }
  t.isDefault = e;
})(FS || (FS = {}));
const Wv = /* @__PURE__ */ Object.create(null);
function p(t, e) {
  if (it(e)) {
    const i = Wv[e];
    if (i === void 0)
      throw new Error(`${t} references an unknown codicon: ${e}`);
    e = i;
  }
  return Wv[t] = e, { id: t };
}
function B8() {
  return Wv;
}
const W8 = {
  add: p("add", 6e4),
  plus: p("plus", 6e4),
  gistNew: p("gist-new", 6e4),
  repoCreate: p("repo-create", 6e4),
  lightbulb: p("lightbulb", 60001),
  lightBulb: p("light-bulb", 60001),
  repo: p("repo", 60002),
  repoDelete: p("repo-delete", 60002),
  gistFork: p("gist-fork", 60003),
  repoForked: p("repo-forked", 60003),
  gitPullRequest: p("git-pull-request", 60004),
  gitPullRequestAbandoned: p("git-pull-request-abandoned", 60004),
  recordKeys: p("record-keys", 60005),
  keyboard: p("keyboard", 60005),
  tag: p("tag", 60006),
  gitPullRequestLabel: p("git-pull-request-label", 60006),
  tagAdd: p("tag-add", 60006),
  tagRemove: p("tag-remove", 60006),
  person: p("person", 60007),
  personFollow: p("person-follow", 60007),
  personOutline: p("person-outline", 60007),
  personFilled: p("person-filled", 60007),
  gitBranch: p("git-branch", 60008),
  gitBranchCreate: p("git-branch-create", 60008),
  gitBranchDelete: p("git-branch-delete", 60008),
  sourceControl: p("source-control", 60008),
  mirror: p("mirror", 60009),
  mirrorPublic: p("mirror-public", 60009),
  star: p("star", 60010),
  starAdd: p("star-add", 60010),
  starDelete: p("star-delete", 60010),
  starEmpty: p("star-empty", 60010),
  comment: p("comment", 60011),
  commentAdd: p("comment-add", 60011),
  alert: p("alert", 60012),
  warning: p("warning", 60012),
  search: p("search", 60013),
  searchSave: p("search-save", 60013),
  logOut: p("log-out", 60014),
  signOut: p("sign-out", 60014),
  logIn: p("log-in", 60015),
  signIn: p("sign-in", 60015),
  eye: p("eye", 60016),
  eyeUnwatch: p("eye-unwatch", 60016),
  eyeWatch: p("eye-watch", 60016),
  circleFilled: p("circle-filled", 60017),
  primitiveDot: p("primitive-dot", 60017),
  closeDirty: p("close-dirty", 60017),
  debugBreakpoint: p("debug-breakpoint", 60017),
  debugBreakpointDisabled: p("debug-breakpoint-disabled", 60017),
  debugHint: p("debug-hint", 60017),
  terminalDecorationSuccess: p("terminal-decoration-success", 60017),
  primitiveSquare: p("primitive-square", 60018),
  edit: p("edit", 60019),
  pencil: p("pencil", 60019),
  info: p("info", 60020),
  issueOpened: p("issue-opened", 60020),
  gistPrivate: p("gist-private", 60021),
  gitForkPrivate: p("git-fork-private", 60021),
  lock: p("lock", 60021),
  mirrorPrivate: p("mirror-private", 60021),
  close: p("close", 60022),
  removeClose: p("remove-close", 60022),
  x: p("x", 60022),
  repoSync: p("repo-sync", 60023),
  sync: p("sync", 60023),
  clone: p("clone", 60024),
  desktopDownload: p("desktop-download", 60024),
  beaker: p("beaker", 60025),
  microscope: p("microscope", 60025),
  vm: p("vm", 60026),
  deviceDesktop: p("device-desktop", 60026),
  file: p("file", 60027),
  fileText: p("file-text", 60027),
  more: p("more", 60028),
  ellipsis: p("ellipsis", 60028),
  kebabHorizontal: p("kebab-horizontal", 60028),
  mailReply: p("mail-reply", 60029),
  reply: p("reply", 60029),
  organization: p("organization", 60030),
  organizationFilled: p("organization-filled", 60030),
  organizationOutline: p("organization-outline", 60030),
  newFile: p("new-file", 60031),
  fileAdd: p("file-add", 60031),
  newFolder: p("new-folder", 60032),
  fileDirectoryCreate: p("file-directory-create", 60032),
  trash: p("trash", 60033),
  trashcan: p("trashcan", 60033),
  history: p("history", 60034),
  clock: p("clock", 60034),
  folder: p("folder", 60035),
  fileDirectory: p("file-directory", 60035),
  symbolFolder: p("symbol-folder", 60035),
  logoGithub: p("logo-github", 60036),
  markGithub: p("mark-github", 60036),
  github: p("github", 60036),
  terminal: p("terminal", 60037),
  console: p("console", 60037),
  repl: p("repl", 60037),
  zap: p("zap", 60038),
  symbolEvent: p("symbol-event", 60038),
  error: p("error", 60039),
  stop: p("stop", 60039),
  variable: p("variable", 60040),
  symbolVariable: p("symbol-variable", 60040),
  array: p("array", 60042),
  symbolArray: p("symbol-array", 60042),
  symbolModule: p("symbol-module", 60043),
  symbolPackage: p("symbol-package", 60043),
  symbolNamespace: p("symbol-namespace", 60043),
  symbolObject: p("symbol-object", 60043),
  symbolMethod: p("symbol-method", 60044),
  symbolFunction: p("symbol-function", 60044),
  symbolConstructor: p("symbol-constructor", 60044),
  symbolBoolean: p("symbol-boolean", 60047),
  symbolNull: p("symbol-null", 60047),
  symbolNumeric: p("symbol-numeric", 60048),
  symbolNumber: p("symbol-number", 60048),
  symbolStructure: p("symbol-structure", 60049),
  symbolStruct: p("symbol-struct", 60049),
  symbolParameter: p("symbol-parameter", 60050),
  symbolTypeParameter: p("symbol-type-parameter", 60050),
  symbolKey: p("symbol-key", 60051),
  symbolText: p("symbol-text", 60051),
  symbolReference: p("symbol-reference", 60052),
  goToFile: p("go-to-file", 60052),
  symbolEnum: p("symbol-enum", 60053),
  symbolValue: p("symbol-value", 60053),
  symbolRuler: p("symbol-ruler", 60054),
  symbolUnit: p("symbol-unit", 60054),
  activateBreakpoints: p("activate-breakpoints", 60055),
  archive: p("archive", 60056),
  arrowBoth: p("arrow-both", 60057),
  arrowDown: p("arrow-down", 60058),
  arrowLeft: p("arrow-left", 60059),
  arrowRight: p("arrow-right", 60060),
  arrowSmallDown: p("arrow-small-down", 60061),
  arrowSmallLeft: p("arrow-small-left", 60062),
  arrowSmallRight: p("arrow-small-right", 60063),
  arrowSmallUp: p("arrow-small-up", 60064),
  arrowUp: p("arrow-up", 60065),
  bell: p("bell", 60066),
  bold: p("bold", 60067),
  book: p("book", 60068),
  bookmark: p("bookmark", 60069),
  debugBreakpointConditionalUnverified: p("debug-breakpoint-conditional-unverified", 60070),
  debugBreakpointConditional: p("debug-breakpoint-conditional", 60071),
  debugBreakpointConditionalDisabled: p("debug-breakpoint-conditional-disabled", 60071),
  debugBreakpointDataUnverified: p("debug-breakpoint-data-unverified", 60072),
  debugBreakpointData: p("debug-breakpoint-data", 60073),
  debugBreakpointDataDisabled: p("debug-breakpoint-data-disabled", 60073),
  debugBreakpointLogUnverified: p("debug-breakpoint-log-unverified", 60074),
  debugBreakpointLog: p("debug-breakpoint-log", 60075),
  debugBreakpointLogDisabled: p("debug-breakpoint-log-disabled", 60075),
  briefcase: p("briefcase", 60076),
  broadcast: p("broadcast", 60077),
  browser: p("browser", 60078),
  bug: p("bug", 60079),
  calendar: p("calendar", 60080),
  caseSensitive: p("case-sensitive", 60081),
  check: p("check", 60082),
  checklist: p("checklist", 60083),
  chevronDown: p("chevron-down", 60084),
  chevronLeft: p("chevron-left", 60085),
  chevronRight: p("chevron-right", 60086),
  chevronUp: p("chevron-up", 60087),
  chromeClose: p("chrome-close", 60088),
  chromeMaximize: p("chrome-maximize", 60089),
  chromeMinimize: p("chrome-minimize", 60090),
  chromeRestore: p("chrome-restore", 60091),
  circleOutline: p("circle-outline", 60092),
  circle: p("circle", 60092),
  debugBreakpointUnverified: p("debug-breakpoint-unverified", 60092),
  terminalDecorationIncomplete: p("terminal-decoration-incomplete", 60092),
  circleSlash: p("circle-slash", 60093),
  circuitBoard: p("circuit-board", 60094),
  clearAll: p("clear-all", 60095),
  clippy: p("clippy", 60096),
  closeAll: p("close-all", 60097),
  cloudDownload: p("cloud-download", 60098),
  cloudUpload: p("cloud-upload", 60099),
  code: p("code", 60100),
  collapseAll: p("collapse-all", 60101),
  colorMode: p("color-mode", 60102),
  commentDiscussion: p("comment-discussion", 60103),
  creditCard: p("credit-card", 60105),
  dash: p("dash", 60108),
  dashboard: p("dashboard", 60109),
  database: p("database", 60110),
  debugContinue: p("debug-continue", 60111),
  debugDisconnect: p("debug-disconnect", 60112),
  debugPause: p("debug-pause", 60113),
  debugRestart: p("debug-restart", 60114),
  debugStart: p("debug-start", 60115),
  debugStepInto: p("debug-step-into", 60116),
  debugStepOut: p("debug-step-out", 60117),
  debugStepOver: p("debug-step-over", 60118),
  debugStop: p("debug-stop", 60119),
  debug: p("debug", 60120),
  deviceCameraVideo: p("device-camera-video", 60121),
  deviceCamera: p("device-camera", 60122),
  deviceMobile: p("device-mobile", 60123),
  diffAdded: p("diff-added", 60124),
  diffIgnored: p("diff-ignored", 60125),
  diffModified: p("diff-modified", 60126),
  diffRemoved: p("diff-removed", 60127),
  diffRenamed: p("diff-renamed", 60128),
  diff: p("diff", 60129),
  diffSidebyside: p("diff-sidebyside", 60129),
  discard: p("discard", 60130),
  editorLayout: p("editor-layout", 60131),
  emptyWindow: p("empty-window", 60132),
  exclude: p("exclude", 60133),
  extensions: p("extensions", 60134),
  eyeClosed: p("eye-closed", 60135),
  fileBinary: p("file-binary", 60136),
  fileCode: p("file-code", 60137),
  fileMedia: p("file-media", 60138),
  filePdf: p("file-pdf", 60139),
  fileSubmodule: p("file-submodule", 60140),
  fileSymlinkDirectory: p("file-symlink-directory", 60141),
  fileSymlinkFile: p("file-symlink-file", 60142),
  fileZip: p("file-zip", 60143),
  files: p("files", 60144),
  filter: p("filter", 60145),
  flame: p("flame", 60146),
  foldDown: p("fold-down", 60147),
  foldUp: p("fold-up", 60148),
  fold: p("fold", 60149),
  folderActive: p("folder-active", 60150),
  folderOpened: p("folder-opened", 60151),
  gear: p("gear", 60152),
  gift: p("gift", 60153),
  gistSecret: p("gist-secret", 60154),
  gist: p("gist", 60155),
  gitCommit: p("git-commit", 60156),
  gitCompare: p("git-compare", 60157),
  compareChanges: p("compare-changes", 60157),
  gitMerge: p("git-merge", 60158),
  githubAction: p("github-action", 60159),
  githubAlt: p("github-alt", 60160),
  globe: p("globe", 60161),
  grabber: p("grabber", 60162),
  graph: p("graph", 60163),
  gripper: p("gripper", 60164),
  heart: p("heart", 60165),
  home: p("home", 60166),
  horizontalRule: p("horizontal-rule", 60167),
  hubot: p("hubot", 60168),
  inbox: p("inbox", 60169),
  issueReopened: p("issue-reopened", 60171),
  issues: p("issues", 60172),
  italic: p("italic", 60173),
  jersey: p("jersey", 60174),
  json: p("json", 60175),
  kebabVertical: p("kebab-vertical", 60176),
  key: p("key", 60177),
  law: p("law", 60178),
  lightbulbAutofix: p("lightbulb-autofix", 60179),
  linkExternal: p("link-external", 60180),
  link: p("link", 60181),
  listOrdered: p("list-ordered", 60182),
  listUnordered: p("list-unordered", 60183),
  liveShare: p("live-share", 60184),
  loading: p("loading", 60185),
  location: p("location", 60186),
  mailRead: p("mail-read", 60187),
  mail: p("mail", 60188),
  markdown: p("markdown", 60189),
  megaphone: p("megaphone", 60190),
  mention: p("mention", 60191),
  milestone: p("milestone", 60192),
  gitPullRequestMilestone: p("git-pull-request-milestone", 60192),
  mortarBoard: p("mortar-board", 60193),
  move: p("move", 60194),
  multipleWindows: p("multiple-windows", 60195),
  mute: p("mute", 60196),
  noNewline: p("no-newline", 60197),
  note: p("note", 60198),
  octoface: p("octoface", 60199),
  openPreview: p("open-preview", 60200),
  package: p("package", 60201),
  paintcan: p("paintcan", 60202),
  pin: p("pin", 60203),
  play: p("play", 60204),
  run: p("run", 60204),
  plug: p("plug", 60205),
  preserveCase: p("preserve-case", 60206),
  preview: p("preview", 60207),
  project: p("project", 60208),
  pulse: p("pulse", 60209),
  question: p("question", 60210),
  quote: p("quote", 60211),
  radioTower: p("radio-tower", 60212),
  reactions: p("reactions", 60213),
  references: p("references", 60214),
  refresh: p("refresh", 60215),
  regex: p("regex", 60216),
  remoteExplorer: p("remote-explorer", 60217),
  remote: p("remote", 60218),
  remove: p("remove", 60219),
  replaceAll: p("replace-all", 60220),
  replace: p("replace", 60221),
  repoClone: p("repo-clone", 60222),
  repoForcePush: p("repo-force-push", 60223),
  repoPull: p("repo-pull", 60224),
  repoPush: p("repo-push", 60225),
  report: p("report", 60226),
  requestChanges: p("request-changes", 60227),
  rocket: p("rocket", 60228),
  rootFolderOpened: p("root-folder-opened", 60229),
  rootFolder: p("root-folder", 60230),
  rss: p("rss", 60231),
  ruby: p("ruby", 60232),
  saveAll: p("save-all", 60233),
  saveAs: p("save-as", 60234),
  save: p("save", 60235),
  screenFull: p("screen-full", 60236),
  screenNormal: p("screen-normal", 60237),
  searchStop: p("search-stop", 60238),
  server: p("server", 60240),
  settingsGear: p("settings-gear", 60241),
  settings: p("settings", 60242),
  shield: p("shield", 60243),
  smiley: p("smiley", 60244),
  sortPrecedence: p("sort-precedence", 60245),
  splitHorizontal: p("split-horizontal", 60246),
  splitVertical: p("split-vertical", 60247),
  squirrel: p("squirrel", 60248),
  starFull: p("star-full", 60249),
  starHalf: p("star-half", 60250),
  symbolClass: p("symbol-class", 60251),
  symbolColor: p("symbol-color", 60252),
  symbolConstant: p("symbol-constant", 60253),
  symbolEnumMember: p("symbol-enum-member", 60254),
  symbolField: p("symbol-field", 60255),
  symbolFile: p("symbol-file", 60256),
  symbolInterface: p("symbol-interface", 60257),
  symbolKeyword: p("symbol-keyword", 60258),
  symbolMisc: p("symbol-misc", 60259),
  symbolOperator: p("symbol-operator", 60260),
  symbolProperty: p("symbol-property", 60261),
  wrench: p("wrench", 60261),
  wrenchSubaction: p("wrench-subaction", 60261),
  symbolSnippet: p("symbol-snippet", 60262),
  tasklist: p("tasklist", 60263),
  telescope: p("telescope", 60264),
  textSize: p("text-size", 60265),
  threeBars: p("three-bars", 60266),
  thumbsdown: p("thumbsdown", 60267),
  thumbsup: p("thumbsup", 60268),
  tools: p("tools", 60269),
  triangleDown: p("triangle-down", 60270),
  triangleLeft: p("triangle-left", 60271),
  triangleRight: p("triangle-right", 60272),
  triangleUp: p("triangle-up", 60273),
  twitter: p("twitter", 60274),
  unfold: p("unfold", 60275),
  unlock: p("unlock", 60276),
  unmute: p("unmute", 60277),
  unverified: p("unverified", 60278),
  verified: p("verified", 60279),
  versions: p("versions", 60280),
  vmActive: p("vm-active", 60281),
  vmOutline: p("vm-outline", 60282),
  vmRunning: p("vm-running", 60283),
  watch: p("watch", 60284),
  whitespace: p("whitespace", 60285),
  wholeWord: p("whole-word", 60286),
  window: p("window", 60287),
  wordWrap: p("word-wrap", 60288),
  zoomIn: p("zoom-in", 60289),
  zoomOut: p("zoom-out", 60290),
  listFilter: p("list-filter", 60291),
  listFlat: p("list-flat", 60292),
  listSelection: p("list-selection", 60293),
  selection: p("selection", 60293),
  listTree: p("list-tree", 60294),
  debugBreakpointFunctionUnverified: p("debug-breakpoint-function-unverified", 60295),
  debugBreakpointFunction: p("debug-breakpoint-function", 60296),
  debugBreakpointFunctionDisabled: p("debug-breakpoint-function-disabled", 60296),
  debugStackframeActive: p("debug-stackframe-active", 60297),
  circleSmallFilled: p("circle-small-filled", 60298),
  debugStackframeDot: p("debug-stackframe-dot", 60298),
  terminalDecorationMark: p("terminal-decoration-mark", 60298),
  debugStackframe: p("debug-stackframe", 60299),
  debugStackframeFocused: p("debug-stackframe-focused", 60299),
  debugBreakpointUnsupported: p("debug-breakpoint-unsupported", 60300),
  symbolString: p("symbol-string", 60301),
  debugReverseContinue: p("debug-reverse-continue", 60302),
  debugStepBack: p("debug-step-back", 60303),
  debugRestartFrame: p("debug-restart-frame", 60304),
  debugAlt: p("debug-alt", 60305),
  callIncoming: p("call-incoming", 60306),
  callOutgoing: p("call-outgoing", 60307),
  menu: p("menu", 60308),
  expandAll: p("expand-all", 60309),
  feedback: p("feedback", 60310),
  gitPullRequestReviewer: p("git-pull-request-reviewer", 60310),
  groupByRefType: p("group-by-ref-type", 60311),
  ungroupByRefType: p("ungroup-by-ref-type", 60312),
  account: p("account", 60313),
  gitPullRequestAssignee: p("git-pull-request-assignee", 60313),
  bellDot: p("bell-dot", 60314),
  debugConsole: p("debug-console", 60315),
  library: p("library", 60316),
  output: p("output", 60317),
  runAll: p("run-all", 60318),
  syncIgnored: p("sync-ignored", 60319),
  pinned: p("pinned", 60320),
  githubInverted: p("github-inverted", 60321),
  serverProcess: p("server-process", 60322),
  serverEnvironment: p("server-environment", 60323),
  pass: p("pass", 60324),
  issueClosed: p("issue-closed", 60324),
  stopCircle: p("stop-circle", 60325),
  playCircle: p("play-circle", 60326),
  record: p("record", 60327),
  debugAltSmall: p("debug-alt-small", 60328),
  vmConnect: p("vm-connect", 60329),
  cloud: p("cloud", 60330),
  merge: p("merge", 60331),
  export: p("export", 60332),
  graphLeft: p("graph-left", 60333),
  magnet: p("magnet", 60334),
  notebook: p("notebook", 60335),
  redo: p("redo", 60336),
  checkAll: p("check-all", 60337),
  pinnedDirty: p("pinned-dirty", 60338),
  passFilled: p("pass-filled", 60339),
  circleLargeFilled: p("circle-large-filled", 60340),
  circleLarge: p("circle-large", 60341),
  circleLargeOutline: p("circle-large-outline", 60341),
  combine: p("combine", 60342),
  gather: p("gather", 60342),
  table: p("table", 60343),
  variableGroup: p("variable-group", 60344),
  typeHierarchy: p("type-hierarchy", 60345),
  typeHierarchySub: p("type-hierarchy-sub", 60346),
  typeHierarchySuper: p("type-hierarchy-super", 60347),
  gitPullRequestCreate: p("git-pull-request-create", 60348),
  runAbove: p("run-above", 60349),
  runBelow: p("run-below", 60350),
  notebookTemplate: p("notebook-template", 60351),
  debugRerun: p("debug-rerun", 60352),
  workspaceTrusted: p("workspace-trusted", 60353),
  workspaceUntrusted: p("workspace-untrusted", 60354),
  workspaceUnknown: p("workspace-unknown", 60355),
  terminalCmd: p("terminal-cmd", 60356),
  terminalDebian: p("terminal-debian", 60357),
  terminalLinux: p("terminal-linux", 60358),
  terminalPowershell: p("terminal-powershell", 60359),
  terminalTmux: p("terminal-tmux", 60360),
  terminalUbuntu: p("terminal-ubuntu", 60361),
  terminalBash: p("terminal-bash", 60362),
  arrowSwap: p("arrow-swap", 60363),
  copy: p("copy", 60364),
  personAdd: p("person-add", 60365),
  filterFilled: p("filter-filled", 60366),
  wand: p("wand", 60367),
  debugLineByLine: p("debug-line-by-line", 60368),
  inspect: p("inspect", 60369),
  layers: p("layers", 60370),
  layersDot: p("layers-dot", 60371),
  layersActive: p("layers-active", 60372),
  compass: p("compass", 60373),
  compassDot: p("compass-dot", 60374),
  compassActive: p("compass-active", 60375),
  azure: p("azure", 60376),
  issueDraft: p("issue-draft", 60377),
  gitPullRequestClosed: p("git-pull-request-closed", 60378),
  gitPullRequestDraft: p("git-pull-request-draft", 60379),
  debugAll: p("debug-all", 60380),
  debugCoverage: p("debug-coverage", 60381),
  runErrors: p("run-errors", 60382),
  folderLibrary: p("folder-library", 60383),
  debugContinueSmall: p("debug-continue-small", 60384),
  beakerStop: p("beaker-stop", 60385),
  graphLine: p("graph-line", 60386),
  graphScatter: p("graph-scatter", 60387),
  pieChart: p("pie-chart", 60388),
  bracket: p("bracket", 60175),
  bracketDot: p("bracket-dot", 60389),
  bracketError: p("bracket-error", 60390),
  lockSmall: p("lock-small", 60391),
  azureDevops: p("azure-devops", 60392),
  verifiedFilled: p("verified-filled", 60393),
  newline: p("newline", 60394),
  layout: p("layout", 60395),
  layoutActivitybarLeft: p("layout-activitybar-left", 60396),
  layoutActivitybarRight: p("layout-activitybar-right", 60397),
  layoutPanelLeft: p("layout-panel-left", 60398),
  layoutPanelCenter: p("layout-panel-center", 60399),
  layoutPanelJustify: p("layout-panel-justify", 60400),
  layoutPanelRight: p("layout-panel-right", 60401),
  layoutPanel: p("layout-panel", 60402),
  layoutSidebarLeft: p("layout-sidebar-left", 60403),
  layoutSidebarRight: p("layout-sidebar-right", 60404),
  layoutStatusbar: p("layout-statusbar", 60405),
  layoutMenubar: p("layout-menubar", 60406),
  layoutCentered: p("layout-centered", 60407),
  target: p("target", 60408),
  indent: p("indent", 60409),
  recordSmall: p("record-small", 60410),
  errorSmall: p("error-small", 60411),
  terminalDecorationError: p("terminal-decoration-error", 60411),
  arrowCircleDown: p("arrow-circle-down", 60412),
  arrowCircleLeft: p("arrow-circle-left", 60413),
  arrowCircleRight: p("arrow-circle-right", 60414),
  arrowCircleUp: p("arrow-circle-up", 60415),
  layoutSidebarRightOff: p("layout-sidebar-right-off", 60416),
  layoutPanelOff: p("layout-panel-off", 60417),
  layoutSidebarLeftOff: p("layout-sidebar-left-off", 60418),
  blank: p("blank", 60419),
  heartFilled: p("heart-filled", 60420),
  map: p("map", 60421),
  mapHorizontal: p("map-horizontal", 60421),
  foldHorizontal: p("fold-horizontal", 60421),
  mapFilled: p("map-filled", 60422),
  mapHorizontalFilled: p("map-horizontal-filled", 60422),
  foldHorizontalFilled: p("fold-horizontal-filled", 60422),
  circleSmall: p("circle-small", 60423),
  bellSlash: p("bell-slash", 60424),
  bellSlashDot: p("bell-slash-dot", 60425),
  commentUnresolved: p("comment-unresolved", 60426),
  gitPullRequestGoToChanges: p("git-pull-request-go-to-changes", 60427),
  gitPullRequestNewChanges: p("git-pull-request-new-changes", 60428),
  searchFuzzy: p("search-fuzzy", 60429),
  commentDraft: p("comment-draft", 60430),
  send: p("send", 60431),
  sparkle: p("sparkle", 60432),
  insert: p("insert", 60433),
  mic: p("mic", 60434),
  thumbsdownFilled: p("thumbsdown-filled", 60435),
  thumbsupFilled: p("thumbsup-filled", 60436),
  coffee: p("coffee", 60437),
  snake: p("snake", 60438),
  game: p("game", 60439),
  vr: p("vr", 60440),
  chip: p("chip", 60441),
  piano: p("piano", 60442),
  music: p("music", 60443),
  micFilled: p("mic-filled", 60444),
  repoFetch: p("repo-fetch", 60445),
  copilot: p("copilot", 60446),
  lightbulbSparkle: p("lightbulb-sparkle", 60447),
  robot: p("robot", 60448),
  sparkleFilled: p("sparkle-filled", 60449),
  diffSingle: p("diff-single", 60450),
  diffMultiple: p("diff-multiple", 60451),
  surroundWith: p("surround-with", 60452),
  share: p("share", 60453),
  gitStash: p("git-stash", 60454),
  gitStashApply: p("git-stash-apply", 60455),
  gitStashPop: p("git-stash-pop", 60456),
  vscode: p("vscode", 60457),
  vscodeInsiders: p("vscode-insiders", 60458),
  codeOss: p("code-oss", 60459),
  runCoverage: p("run-coverage", 60460),
  runAllCoverage: p("run-all-coverage", 60461),
  coverage: p("coverage", 60462),
  githubProject: p("github-project", 60463),
  mapVertical: p("map-vertical", 60464),
  foldVertical: p("fold-vertical", 60464),
  mapVerticalFilled: p("map-vertical-filled", 60465),
  foldVerticalFilled: p("fold-vertical-filled", 60465),
  goToSearch: p("go-to-search", 60466),
  percentage: p("percentage", 60467),
  sortPercentage: p("sort-percentage", 60467),
  attach: p("attach", 60468),
  goToEditingSession: p("go-to-editing-session", 60469),
  editSession: p("edit-session", 60470),
  codeReview: p("code-review", 60471),
  copilotWarning: p("copilot-warning", 60472),
  python: p("python", 60473),
  copilotLarge: p("copilot-large", 60474),
  copilotWarningLarge: p("copilot-warning-large", 60475),
  keyboardTab: p("keyboard-tab", 60476),
  copilotBlocked: p("copilot-blocked", 60477),
  copilotNotConnected: p("copilot-not-connected", 60478),
  flag: p("flag", 60479),
  lightbulbEmpty: p("lightbulb-empty", 60480),
  symbolMethodArrow: p("symbol-method-arrow", 60481),
  copilotUnavailable: p("copilot-unavailable", 60482),
  repoPinned: p("repo-pinned", 60483),
  keyboardTabAbove: p("keyboard-tab-above", 60484),
  keyboardTabBelow: p("keyboard-tab-below", 60485),
  gitPullRequestDone: p("git-pull-request-done", 60486),
  mcp: p("mcp", 60487),
  extensionsLarge: p("extensions-large", 60488),
  layoutPanelDock: p("layout-panel-dock", 60489),
  layoutSidebarLeftDock: p("layout-sidebar-left-dock", 60490),
  layoutSidebarRightDock: p("layout-sidebar-right-dock", 60491),
  copilotInProgress: p("copilot-in-progress", 60492),
  copilotError: p("copilot-error", 60493),
  copilotSuccess: p("copilot-success", 60494),
  chatSparkle: p("chat-sparkle", 60495),
  searchSparkle: p("search-sparkle", 60496),
  editSparkle: p("edit-sparkle", 60497),
  copilotSnooze: p("copilot-snooze", 60498),
  sendToRemoteAgent: p("send-to-remote-agent", 60499)
}, V8 = {
  dialogError: p("dialog-error", "error"),
  dialogWarning: p("dialog-warning", "warning"),
  dialogInfo: p("dialog-info", "info"),
  dialogClose: p("dialog-close", "close"),
  treeItemExpanded: p("tree-item-expanded", "chevron-down"),
  treeFilterOnTypeOn: p("tree-filter-on-type-on", "list-filter"),
  treeFilterOnTypeOff: p("tree-filter-on-type-off", "list-selection"),
  treeFilterClear: p("tree-filter-clear", "close"),
  treeItemLoading: p("tree-item-loading", "loading"),
  menuSelection: p("menu-selection", "check"),
  menuSubmenu: p("menu-submenu", "chevron-right"),
  menuBarMore: p("menubar-more", "more"),
  scrollbarButtonLeft: p("scrollbar-button-left", "triangle-left"),
  scrollbarButtonRight: p("scrollbar-button-right", "triangle-right"),
  scrollbarButtonUp: p("scrollbar-button-up", "triangle-up"),
  scrollbarButtonDown: p("scrollbar-button-down", "triangle-down"),
  toolBarMore: p("toolbar-more", "more"),
  quickInputBack: p("quick-input-back", "arrow-left"),
  dropDownButton: p("drop-down-button", 60084),
  symbolCustomColor: p("symbol-customcolor", 60252),
  exportIcon: p("export", 60332),
  workspaceUnspecified: p("workspace-unspecified", 60355),
  newLine: p("newline", 60394),
  thumbsDownFilled: p("thumbsdown-filled", 60435),
  thumbsUpFilled: p("thumbsup-filled", 60436),
  gitFetch: p("git-fetch", 60445),
  lightbulbSparkleAutofix: p("lightbulb-sparkle-autofix", 60447),
  debugBreakpointPending: p("debug-breakpoint-pending", 60377)
}, ge = {
  ...W8,
  ...V8
};
var zc;
(function(t) {
  function e(i) {
    return !!i && typeof i == "object" && typeof i.id == "string";
  }
  t.isThemeColor = e;
})(zc || (zc = {}));
var oi;
(function(t) {
  t.iconNameSegment = "[A-Za-z0-9]+", t.iconNameExpression = "[A-Za-z0-9-]+", t.iconModifierExpression = "~[A-Za-z]+", t.iconNameCharacter = "[A-Za-z0-9~-]";
  const e = new RegExp(
    `^(${t.iconNameExpression})(${t.iconModifierExpression})?$`
  );
  function i(f) {
    const g = e.exec(f.id);
    if (!g)
      return i(ge.error);
    const [, _, w] = g, v = ["codicon", "codicon-" + _];
    return w && v.push("codicon-modifier-" + w.substring(1)), v;
  }
  t.asClassNameArray = i;
  function n(f) {
    return i(f).join(" ");
  }
  t.asClassName = n;
  function r(f) {
    return "." + i(f).join(".");
  }
  t.asCSSSelector = r;
  function s(f) {
    return !!f && typeof f == "object" && typeof f.id == "string" && (typeof f.color > "u" || zc.isThemeColor(f.color));
  }
  t.isThemeIcon = s;
  const o = new RegExp(
    `^\\$\\((${t.iconNameExpression}(?:${t.iconModifierExpression})?)\\)$`
  );
  function a(f) {
    const g = o.exec(f);
    if (!g)
      return;
    const [, _] = g;
    return { id: _ };
  }
  t.fromString = a;
  function l(f) {
    return { id: f };
  }
  t.fromId = l;
  function c(f, g) {
    let _ = f.id;
    const w = _.lastIndexOf("~");
    return w !== -1 && (_ = _.substring(0, w)), g && (_ = `${_}~${g}`), { id: _ };
  }
  t.modify = c;
  function u(f) {
    const g = f.id.lastIndexOf("~");
    if (g !== -1)
      return f.id.substring(g + 1);
  }
  t.getModifier = u;
  function d(f, g) {
    return f.id === g.id && f.color?.id === g.color?.id;
  }
  t.isEqual = d;
})(oi || (oi = {}));
const Nx = new RegExp(
  `\\$\\(${oi.iconNameExpression}(?:${oi.iconModifierExpression})?\\)`,
  "g"
), z8 = new RegExp(`(\\\\)?${Nx.source}`, "g");
function q8(t) {
  return t.replace(z8, (e, i) => i ? e : `\\${e}`);
}
new RegExp(`\\\\${Nx.source}`, "g");
new RegExp(`(\\s)?(\\\\)?${Nx.source}(\\s)?`, "g");
new RegExp(`\\$\\(${oi.iconNameCharacter}+\\)`, "g");
var zp;
(function(t) {
  t[t.Paragraph = 0] = "Paragraph", t[t.Break = 1] = "Break";
})(zp || (zp = {}));
let Gd = class iT {
  static lift(e) {
    const i = new iT(e.value, e);
    return i.uris = e.uris, i.baseUri = e.baseUri ? x.revive(e.baseUri) : void 0, i;
  }
  constructor(e = "", i = !1) {
    if (this.value = e, typeof this.value != "string")
      throw ze("value");
    typeof i == "boolean" ? (this.isTrusted = i, this.supportThemeIcons = !1, this.supportHtml = !1) : (this.isTrusted = i.isTrusted ?? void 0, this.supportThemeIcons = i.supportThemeIcons ?? !1, this.supportHtml = i.supportHtml ?? !1);
  }
  appendText(e, i = zp.Paragraph) {
    return this.value += j8(this.supportThemeIcons ? q8(e) : e).replace(/([ \t]+)/g, (n, r) => "&nbsp;".repeat(r.length)).replace(/\>/gm, "\\>").replace(/\n/g, i === zp.Break ? `\\
` : `

`), this;
  }
  appendMarkdown(e) {
    return this.value += e, this;
  }
  appendCodeblock(e, i) {
    return this.value += `
${G8(i, e)}
`, this;
  }
  appendLink(e, i, n) {
    return this.value += "[", this.value += this._escape(i, "]"), this.value += "](", this.value += this._escape(String(e), ")"), n && (this.value += ` "${this._escape(this._escape(n, '"'), ")")}"`), this.value += ")", this;
  }
  _escape(e, i) {
    const n = new RegExp(Ja(i), "g");
    return e.replace(n, (r, s) => e.charAt(s - 1) !== "\\" ? `\\${r}` : r);
  }
};
function dl(t) {
  return t instanceof Gd ? !0 : t && typeof t == "object" ? typeof t.value == "string" && (typeof t.isTrusted == "boolean" || typeof t.isTrusted == "object" || t.isTrusted === void 0) && (typeof t.supportThemeIcons == "boolean" || t.supportThemeIcons === void 0) : !1;
}
function j8(t) {
  return t.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&");
}
function G8(t, e) {
  const i = t.match(/^`+/gm)?.reduce((r, s) => r.length > s.length ? r : s).length ?? 0, n = i >= 3 ? i + 1 : 3;
  return [
    `${"`".repeat(n)}${e}`,
    t,
    `${"`".repeat(n)}`
  ].join(`
`);
}
function Q8(t) {
  const e = [], i = t.split("|").map((r) => r.trim());
  t = i[0];
  const n = i[1];
  if (n) {
    const r = /height=(\d+)/.exec(n), s = /width=(\d+)/.exec(n), o = r ? r[1] : "", a = s ? s[1] : "", l = isFinite(parseInt(a)), c = isFinite(parseInt(o));
    l && e.push(`width="${a}"`), c && e.push(`height="${o}"`);
  }
  return { href: t, dimensions: e };
}
function Mx() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null
  };
}
let hl = Mx();
function nT(t) {
  hl = t;
}
const rT = /[&<>"']/, K8 = new RegExp(rT.source, "g"), sT = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, J8 = new RegExp(sT.source, "g"), Y8 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, US = (t) => Y8[t];
function kn(t, e) {
  if (e) {
    if (rT.test(t))
      return t.replace(K8, US);
  } else if (sT.test(t))
    return t.replace(J8, US);
  return t;
}
const X8 = /(^|[^\[])\^/g;
function Ct(t, e) {
  let i = typeof t == "string" ? t : t.source;
  e = e || "";
  const n = {
    replace: (r, s) => {
      let o = typeof s == "string" ? s : s.source;
      return o = o.replace(X8, "$1"), i = i.replace(r, o), n;
    },
    getRegex: () => new RegExp(i, e)
  };
  return n;
}
function $S(t) {
  try {
    t = encodeURI(t).replace(/%25/g, "%");
  } catch {
    return null;
  }
  return t;
}
const ad = { exec: () => null };
function HS(t, e) {
  const i = t.replace(/\|/g, (s, o, a) => {
    let l = !1, c = o;
    for (; --c >= 0 && a[c] === "\\"; )
      l = !l;
    return l ? "|" : " |";
  }), n = i.split(/ \|/);
  let r = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n[n.length - 1].trim() && n.pop(), e)
    if (n.length > e)
      n.splice(e);
    else
      for (; n.length < e; )
        n.push("");
  for (; r < n.length; r++)
    n[r] = n[r].trim().replace(/\\\|/g, "|");
  return n;
}
function Mu(t, e, i) {
  const n = t.length;
  if (n === 0)
    return "";
  let r = 0;
  for (; r < n && t.charAt(n - r - 1) === e; )
    r++;
  return t.slice(0, n - r);
}
function Z8(t, e) {
  if (t.indexOf(e[1]) === -1)
    return -1;
  let i = 0;
  for (let n = 0; n < t.length; n++)
    if (t[n] === "\\")
      n++;
    else if (t[n] === e[0])
      i++;
    else if (t[n] === e[1] && (i--, i < 0))
      return n;
  return -1;
}
function BS(t, e, i, n) {
  const r = e.href, s = e.title ? kn(e.title) : null, o = t[1].replace(/\\([\[\]])/g, "$1");
  if (t[0].charAt(0) !== "!") {
    n.state.inLink = !0;
    const a = {
      type: "link",
      raw: i,
      href: r,
      title: s,
      text: o,
      tokens: n.inlineTokens(o)
    };
    return n.state.inLink = !1, a;
  }
  return {
    type: "image",
    raw: i,
    href: r,
    title: s,
    text: kn(o)
  };
}
function eL(t, e) {
  const i = t.match(/^(\s+)(?:```)/);
  if (i === null)
    return e;
  const n = i[1];
  return e.split(`
`).map((r) => {
    const s = r.match(/^\s+/);
    if (s === null)
      return r;
    const [o] = s;
    return o.length >= n.length ? r.slice(n.length) : r;
  }).join(`
`);
}
class qp {
  options;
  rules;
  // set by the lexer
  lexer;
  // set by the lexer
  constructor(e) {
    this.options = e || hl;
  }
  space(e) {
    const i = this.rules.block.newline.exec(e);
    if (i && i[0].length > 0)
      return {
        type: "space",
        raw: i[0]
      };
  }
  code(e) {
    const i = this.rules.block.code.exec(e);
    if (i) {
      const n = i[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: i[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? n : Mu(n, `
`)
      };
    }
  }
  fences(e) {
    const i = this.rules.block.fences.exec(e);
    if (i) {
      const n = i[0], r = eL(n, i[3] || "");
      return {
        type: "code",
        raw: n,
        lang: i[2] ? i[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : i[2],
        text: r
      };
    }
  }
  heading(e) {
    const i = this.rules.block.heading.exec(e);
    if (i) {
      let n = i[2].trim();
      if (/#$/.test(n)) {
        const r = Mu(n, "#");
        (this.options.pedantic || !r || / $/.test(r)) && (n = r.trim());
      }
      return {
        type: "heading",
        raw: i[0],
        depth: i[1].length,
        text: n,
        tokens: this.lexer.inline(n)
      };
    }
  }
  hr(e) {
    const i = this.rules.block.hr.exec(e);
    if (i)
      return {
        type: "hr",
        raw: Mu(i[0], `
`)
      };
  }
  blockquote(e) {
    const i = this.rules.block.blockquote.exec(e);
    if (i) {
      let n = Mu(i[0], `
`).split(`
`), r = "", s = "";
      const o = [];
      for (; n.length > 0; ) {
        let a = !1;
        const l = [];
        let c;
        for (c = 0; c < n.length; c++)
          if (/^ {0,3}>/.test(n[c]))
            l.push(n[c]), a = !0;
          else if (!a)
            l.push(n[c]);
          else
            break;
        n = n.slice(c);
        const u = l.join(`
`), d = u.replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, `
    $1`).replace(/^ {0,3}>[ \t]?/gm, "");
        r = r ? `${r}
${u}` : u, s = s ? `${s}
${d}` : d;
        const f = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(d, o, !0), this.lexer.state.top = f, n.length === 0)
          break;
        const g = o[o.length - 1];
        if (g?.type === "code")
          break;
        if (g?.type === "blockquote") {
          const _ = g, w = _.raw + `
` + n.join(`
`), v = this.blockquote(w);
          o[o.length - 1] = v, r = r.substring(0, r.length - _.raw.length) + v.raw, s = s.substring(0, s.length - _.text.length) + v.text;
          break;
        } else if (g?.type === "list") {
          const _ = g, w = _.raw + `
` + n.join(`
`), v = this.list(w);
          o[o.length - 1] = v, r = r.substring(0, r.length - g.raw.length) + v.raw, s = s.substring(0, s.length - _.raw.length) + v.raw, n = w.substring(o[o.length - 1].raw.length).split(`
`);
          continue;
        }
      }
      return {
        type: "blockquote",
        raw: r,
        tokens: o,
        text: s
      };
    }
  }
  list(e) {
    let i = this.rules.block.list.exec(e);
    if (i) {
      let n = i[1].trim();
      const r = n.length > 1, s = {
        type: "list",
        raw: "",
        ordered: r,
        start: r ? +n.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r ? n : "[*+-]");
      const o = new RegExp(`^( {0,3}${n})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let a = !1;
      for (; e; ) {
        let l = !1, c = "", u = "";
        if (!(i = o.exec(e)) || this.rules.block.hr.test(e))
          break;
        c = i[0], e = e.substring(c.length);
        let d = i[2].split(`
`, 1)[0].replace(/^\t+/, (S) => " ".repeat(3 * S.length)), f = e.split(`
`, 1)[0], g = !d.trim(), _ = 0;
        if (this.options.pedantic ? (_ = 2, u = d.trimStart()) : g ? _ = i[1].length + 1 : (_ = i[2].search(/[^ ]/), _ = _ > 4 ? 1 : _, u = d.slice(_), _ += i[1].length), g && /^ *$/.test(f) && (c += f + `
`, e = e.substring(f.length + 1), l = !0), !l) {
          const S = new RegExp(`^ {0,${Math.min(3, _ - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), E = new RegExp(`^ {0,${Math.min(3, _ - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), A = new RegExp(`^ {0,${Math.min(3, _ - 1)}}(?:\`\`\`|~~~)`), j = new RegExp(`^ {0,${Math.min(3, _ - 1)}}#`);
          for (; e; ) {
            const V = e.split(`
`, 1)[0];
            if (f = V, this.options.pedantic && (f = f.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), A.test(f) || j.test(f) || S.test(f) || E.test(e))
              break;
            if (f.search(/[^ ]/) >= _ || !f.trim())
              u += `
` + f.slice(_);
            else {
              if (g || d.search(/[^ ]/) >= 4 || A.test(d) || j.test(d) || E.test(d))
                break;
              u += `
` + f;
            }
            !g && !f.trim() && (g = !0), c += V + `
`, e = e.substring(V.length + 1), d = f.slice(_);
          }
        }
        s.loose || (a ? s.loose = !0 : /\n *\n *$/.test(c) && (a = !0));
        let w = null, v;
        this.options.gfm && (w = /^\[[ xX]\] /.exec(u), w && (v = w[0] !== "[ ] ", u = u.replace(/^\[[ xX]\] +/, ""))), s.items.push({
          type: "list_item",
          raw: c,
          task: !!w,
          checked: v,
          loose: !1,
          text: u,
          tokens: []
        }), s.raw += c;
      }
      s.items[s.items.length - 1].raw = s.items[s.items.length - 1].raw.trimEnd(), s.items[s.items.length - 1].text = s.items[s.items.length - 1].text.trimEnd(), s.raw = s.raw.trimEnd();
      for (let l = 0; l < s.items.length; l++)
        if (this.lexer.state.top = !1, s.items[l].tokens = this.lexer.blockTokens(s.items[l].text, []), !s.loose) {
          const c = s.items[l].tokens.filter((d) => d.type === "space"), u = c.length > 0 && c.some((d) => /\n.*\n/.test(d.raw));
          s.loose = u;
        }
      if (s.loose)
        for (let l = 0; l < s.items.length; l++)
          s.items[l].loose = !0;
      return s;
    }
  }
  html(e) {
    const i = this.rules.block.html.exec(e);
    if (i)
      return {
        type: "html",
        block: !0,
        raw: i[0],
        pre: i[1] === "pre" || i[1] === "script" || i[1] === "style",
        text: i[0]
      };
  }
  def(e) {
    const i = this.rules.block.def.exec(e);
    if (i) {
      const n = i[1].toLowerCase().replace(/\s+/g, " "), r = i[2] ? i[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", s = i[3] ? i[3].substring(1, i[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : i[3];
      return {
        type: "def",
        tag: n,
        raw: i[0],
        href: r,
        title: s
      };
    }
  }
  table(e) {
    const i = this.rules.block.table.exec(e);
    if (!i || !/[:|]/.test(i[2]))
      return;
    const n = HS(i[1]), r = i[2].replace(/^\||\| *$/g, "").split("|"), s = i[3] && i[3].trim() ? i[3].replace(/\n[ \t]*$/, "").split(`
`) : [], o = {
      type: "table",
      raw: i[0],
      header: [],
      align: [],
      rows: []
    };
    if (n.length === r.length) {
      for (const a of r)
        /^ *-+: *$/.test(a) ? o.align.push("right") : /^ *:-+: *$/.test(a) ? o.align.push("center") : /^ *:-+ *$/.test(a) ? o.align.push("left") : o.align.push(null);
      for (let a = 0; a < n.length; a++)
        o.header.push({
          text: n[a],
          tokens: this.lexer.inline(n[a]),
          header: !0,
          align: o.align[a]
        });
      for (const a of s)
        o.rows.push(HS(a, o.header.length).map((l, c) => ({
          text: l,
          tokens: this.lexer.inline(l),
          header: !1,
          align: o.align[c]
        })));
      return o;
    }
  }
  lheading(e) {
    const i = this.rules.block.lheading.exec(e);
    if (i)
      return {
        type: "heading",
        raw: i[0],
        depth: i[2].charAt(0) === "=" ? 1 : 2,
        text: i[1],
        tokens: this.lexer.inline(i[1])
      };
  }
  paragraph(e) {
    const i = this.rules.block.paragraph.exec(e);
    if (i) {
      const n = i[1].charAt(i[1].length - 1) === `
` ? i[1].slice(0, -1) : i[1];
      return {
        type: "paragraph",
        raw: i[0],
        text: n,
        tokens: this.lexer.inline(n)
      };
    }
  }
  text(e) {
    const i = this.rules.block.text.exec(e);
    if (i)
      return {
        type: "text",
        raw: i[0],
        text: i[0],
        tokens: this.lexer.inline(i[0])
      };
  }
  escape(e) {
    const i = this.rules.inline.escape.exec(e);
    if (i)
      return {
        type: "escape",
        raw: i[0],
        text: kn(i[1])
      };
  }
  tag(e) {
    const i = this.rules.inline.tag.exec(e);
    if (i)
      return !this.lexer.state.inLink && /^<a /i.test(i[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(i[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(i[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(i[0]) && (this.lexer.state.inRawBlock = !1), {
        type: "html",
        raw: i[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: !1,
        text: i[0]
      };
  }
  link(e) {
    const i = this.rules.inline.link.exec(e);
    if (i) {
      const n = i[2].trim();
      if (!this.options.pedantic && /^</.test(n)) {
        if (!/>$/.test(n))
          return;
        const o = Mu(n.slice(0, -1), "\\");
        if ((n.length - o.length) % 2 === 0)
          return;
      } else {
        const o = Z8(i[2], "()");
        if (o > -1) {
          const l = (i[0].indexOf("!") === 0 ? 5 : 4) + i[1].length + o;
          i[2] = i[2].substring(0, o), i[0] = i[0].substring(0, l).trim(), i[3] = "";
        }
      }
      let r = i[2], s = "";
      if (this.options.pedantic) {
        const o = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(r);
        o && (r = o[1], s = o[3]);
      } else
        s = i[3] ? i[3].slice(1, -1) : "";
      return r = r.trim(), /^</.test(r) && (this.options.pedantic && !/>$/.test(n) ? r = r.slice(1) : r = r.slice(1, -1)), BS(i, {
        href: r && r.replace(this.rules.inline.anyPunctuation, "$1"),
        title: s && s.replace(this.rules.inline.anyPunctuation, "$1")
      }, i[0], this.lexer);
    }
  }
  reflink(e, i) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      const r = (n[2] || n[1]).replace(/\s+/g, " "), s = i[r.toLowerCase()];
      if (!s) {
        const o = n[0].charAt(0);
        return {
          type: "text",
          raw: o,
          text: o
        };
      }
      return BS(n, s, n[0], this.lexer);
    }
  }
  emStrong(e, i, n = "") {
    let r = this.rules.inline.emStrongLDelim.exec(e);
    if (!r || r[3] && n.match(/[\p{L}\p{N}]/u))
      return;
    if (!(r[1] || r[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
      const o = [...r[0]].length - 1;
      let a, l, c = o, u = 0;
      const d = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (d.lastIndex = 0, i = i.slice(-1 * e.length + o); (r = d.exec(i)) != null; ) {
        if (a = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !a)
          continue;
        if (l = [...a].length, r[3] || r[4]) {
          c += l;
          continue;
        } else if ((r[5] || r[6]) && o % 3 && !((o + l) % 3)) {
          u += l;
          continue;
        }
        if (c -= l, c > 0)
          continue;
        l = Math.min(l, l + c + u);
        const f = [...r[0]][0].length, g = e.slice(0, o + r.index + f + l);
        if (Math.min(o, l) % 2) {
          const w = g.slice(1, -1);
          return {
            type: "em",
            raw: g,
            text: w,
            tokens: this.lexer.inlineTokens(w)
          };
        }
        const _ = g.slice(2, -2);
        return {
          type: "strong",
          raw: g,
          text: _,
          tokens: this.lexer.inlineTokens(_)
        };
      }
    }
  }
  codespan(e) {
    const i = this.rules.inline.code.exec(e);
    if (i) {
      let n = i[2].replace(/\n/g, " ");
      const r = /[^ ]/.test(n), s = /^ /.test(n) && / $/.test(n);
      return r && s && (n = n.substring(1, n.length - 1)), n = kn(n, !0), {
        type: "codespan",
        raw: i[0],
        text: n
      };
    }
  }
  br(e) {
    const i = this.rules.inline.br.exec(e);
    if (i)
      return {
        type: "br",
        raw: i[0]
      };
  }
  del(e) {
    const i = this.rules.inline.del.exec(e);
    if (i)
      return {
        type: "del",
        raw: i[0],
        text: i[2],
        tokens: this.lexer.inlineTokens(i[2])
      };
  }
  autolink(e) {
    const i = this.rules.inline.autolink.exec(e);
    if (i) {
      let n, r;
      return i[2] === "@" ? (n = kn(i[1]), r = "mailto:" + n) : (n = kn(i[1]), r = n), {
        type: "link",
        raw: i[0],
        text: n,
        href: r,
        tokens: [
          {
            type: "text",
            raw: n,
            text: n
          }
        ]
      };
    }
  }
  url(e) {
    let i;
    if (i = this.rules.inline.url.exec(e)) {
      let n, r;
      if (i[2] === "@")
        n = kn(i[0]), r = "mailto:" + n;
      else {
        let s;
        do
          s = i[0], i[0] = this.rules.inline._backpedal.exec(i[0])?.[0] ?? "";
        while (s !== i[0]);
        n = kn(i[0]), i[1] === "www." ? r = "http://" + i[0] : r = i[0];
      }
      return {
        type: "link",
        raw: i[0],
        text: n,
        href: r,
        tokens: [
          {
            type: "text",
            raw: n,
            text: n
          }
        ]
      };
    }
  }
  inlineText(e) {
    const i = this.rules.inline.text.exec(e);
    if (i) {
      let n;
      return this.lexer.state.inRawBlock ? n = i[0] : n = kn(i[0]), {
        type: "text",
        raw: i[0],
        text: n
      };
    }
  }
}
const tL = /^(?: *(?:\n|$))+/, iL = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, nL = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, df = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, rL = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, oT = /(?:[*+-]|\d{1,9}[.)])/, aT = Ct(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, oT).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex(), Ox = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, sL = /^[^\n]+/, Fx = /(?!\s*\])(?:\\.|[^\[\]\\])+/, oL = Ct(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", Fx).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), aL = Ct(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, oT).getRegex(), z_ = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Ux = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, lL = Ct("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", Ux).replace("tag", z_).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), lT = Ct(Ox).replace("hr", df).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", z_).getRegex(), cL = Ct(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", lT).getRegex(), $x = {
  blockquote: cL,
  code: iL,
  def: oL,
  fences: nL,
  heading: rL,
  hr: df,
  html: lL,
  lheading: aT,
  list: aL,
  newline: tL,
  paragraph: lT,
  table: ad,
  text: sL
}, WS = Ct("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", df).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", z_).getRegex(), uL = {
  ...$x,
  table: WS,
  paragraph: Ct(Ox).replace("hr", df).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", WS).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", z_).getRegex()
}, dL = {
  ...$x,
  html: Ct(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Ux).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: ad,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: Ct(Ox).replace("hr", df).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", aT).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, cT = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, hL = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, uT = /^( {2,}|\\)\n(?!\s*$)/, fL = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, hf = "\\p{P}\\p{S}", pL = Ct(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, hf).getRegex(), gL = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, mL = Ct(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, hf).getRegex(), _L = Ct("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, hf).getRegex(), vL = Ct("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, hf).getRegex(), wL = Ct(/\\([punct])/, "gu").replace(/punct/g, hf).getRegex(), bL = Ct(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), yL = Ct(Ux).replace("(?:-->|$)", "-->").getRegex(), xL = Ct("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", yL).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), jp = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, EL = Ct(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", jp).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), dT = Ct(/^!?\[(label)\]\[(ref)\]/).replace("label", jp).replace("ref", Fx).getRegex(), hT = Ct(/^!?\[(ref)\](?:\[\])?/).replace("ref", Fx).getRegex(), SL = Ct("reflink|nolink(?!\\()", "g").replace("reflink", dT).replace("nolink", hT).getRegex(), Hx = {
  _backpedal: ad,
  // only used for GFM url
  anyPunctuation: wL,
  autolink: bL,
  blockSkip: gL,
  br: uT,
  code: hL,
  del: ad,
  emStrongLDelim: mL,
  emStrongRDelimAst: _L,
  emStrongRDelimUnd: vL,
  escape: cT,
  link: EL,
  nolink: hT,
  punctuation: pL,
  reflink: dT,
  reflinkSearch: SL,
  tag: xL,
  text: fL,
  url: ad
}, DL = {
  ...Hx,
  link: Ct(/^!?\[(label)\]\((.*?)\)/).replace("label", jp).getRegex(),
  reflink: Ct(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", jp).getRegex()
}, Vv = {
  ...Hx,
  escape: Ct(cT).replace("])", "~|])").getRegex(),
  url: Ct(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, kL = {
  ...Vv,
  br: Ct(uT).replace("{2,}", "*").getRegex(),
  text: Ct(Vv.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, Nf = {
  normal: $x,
  gfm: uL,
  pedantic: dL
}, Ou = {
  normal: Hx,
  gfm: Vv,
  breaks: kL,
  pedantic: DL
};
class Hr {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || hl, this.options.tokenizer = this.options.tokenizer || new qp(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const i = {
      block: Nf.normal,
      inline: Ou.normal
    };
    this.options.pedantic ? (i.block = Nf.pedantic, i.inline = Ou.pedantic) : this.options.gfm && (i.block = Nf.gfm, this.options.breaks ? i.inline = Ou.breaks : i.inline = Ou.gfm), this.tokenizer.rules = i;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block: Nf,
      inline: Ou
    };
  }
  /**
   * Static Lex Method
   */
  static lex(e, i) {
    return new Hr(i).lex(e);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(e, i) {
    return new Hr(i).inlineTokens(e);
  }
  /**
   * Preprocessing
   */
  lex(e) {
    e = e.replace(/\r\n|\r/g, `
`), this.blockTokens(e, this.tokens);
    for (let i = 0; i < this.inlineQueue.length; i++) {
      const n = this.inlineQueue[i];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, i = [], n = !1) {
    this.options.pedantic ? e = e.replace(/\t/g, "    ").replace(/^ +$/gm, "") : e = e.replace(/^( *)(\t+)/gm, (a, l, c) => l + "    ".repeat(c.length));
    let r, s, o;
    for (; e; )
      if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((a) => (r = a.call({ lexer: this }, e, i)) ? (e = e.substring(r.raw.length), i.push(r), !0) : !1))) {
        if (r = this.tokenizer.space(e)) {
          e = e.substring(r.raw.length), r.raw.length === 1 && i.length > 0 ? i[i.length - 1].raw += `
` : i.push(r);
          continue;
        }
        if (r = this.tokenizer.code(e)) {
          e = e.substring(r.raw.length), s = i[i.length - 1], s && (s.type === "paragraph" || s.type === "text") ? (s.raw += `
` + r.raw, s.text += `
` + r.text, this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : i.push(r);
          continue;
        }
        if (r = this.tokenizer.fences(e)) {
          e = e.substring(r.raw.length), i.push(r);
          continue;
        }
        if (r = this.tokenizer.heading(e)) {
          e = e.substring(r.raw.length), i.push(r);
          continue;
        }
        if (r = this.tokenizer.hr(e)) {
          e = e.substring(r.raw.length), i.push(r);
          continue;
        }
        if (r = this.tokenizer.blockquote(e)) {
          e = e.substring(r.raw.length), i.push(r);
          continue;
        }
        if (r = this.tokenizer.list(e)) {
          e = e.substring(r.raw.length), i.push(r);
          continue;
        }
        if (r = this.tokenizer.html(e)) {
          e = e.substring(r.raw.length), i.push(r);
          continue;
        }
        if (r = this.tokenizer.def(e)) {
          e = e.substring(r.raw.length), s = i[i.length - 1], s && (s.type === "paragraph" || s.type === "text") ? (s.raw += `
` + r.raw, s.text += `
` + r.raw, this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = {
            href: r.href,
            title: r.title
          });
          continue;
        }
        if (r = this.tokenizer.table(e)) {
          e = e.substring(r.raw.length), i.push(r);
          continue;
        }
        if (r = this.tokenizer.lheading(e)) {
          e = e.substring(r.raw.length), i.push(r);
          continue;
        }
        if (o = e, this.options.extensions && this.options.extensions.startBlock) {
          let a = 1 / 0;
          const l = e.slice(1);
          let c;
          this.options.extensions.startBlock.forEach((u) => {
            c = u.call({ lexer: this }, l), typeof c == "number" && c >= 0 && (a = Math.min(a, c));
          }), a < 1 / 0 && a >= 0 && (o = e.substring(0, a + 1));
        }
        if (this.state.top && (r = this.tokenizer.paragraph(o))) {
          s = i[i.length - 1], n && s?.type === "paragraph" ? (s.raw += `
` + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : i.push(r), n = o.length !== e.length, e = e.substring(r.raw.length);
          continue;
        }
        if (r = this.tokenizer.text(e)) {
          e = e.substring(r.raw.length), s = i[i.length - 1], s && s.type === "text" ? (s.raw += `
` + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : i.push(r);
          continue;
        }
        if (e) {
          const a = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(a);
            break;
          } else
            throw new Error(a);
        }
      }
    return this.state.top = !0, i;
  }
  inline(e, i = []) {
    return this.inlineQueue.push({ src: e, tokens: i }), i;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(e, i = []) {
    let n, r, s, o = e, a, l, c;
    if (this.tokens.links) {
      const u = Object.keys(this.tokens.links);
      if (u.length > 0)
        for (; (a = this.tokenizer.rules.inline.reflinkSearch.exec(o)) != null; )
          u.includes(a[0].slice(a[0].lastIndexOf("[") + 1, -1)) && (o = o.slice(0, a.index) + "[" + "a".repeat(a[0].length - 2) + "]" + o.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (a = this.tokenizer.rules.inline.blockSkip.exec(o)) != null; )
      o = o.slice(0, a.index) + "[" + "a".repeat(a[0].length - 2) + "]" + o.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (a = this.tokenizer.rules.inline.anyPunctuation.exec(o)) != null; )
      o = o.slice(0, a.index) + "++" + o.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; e; )
      if (l || (c = ""), l = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((u) => (n = u.call({ lexer: this }, e, i)) ? (e = e.substring(n.raw.length), i.push(n), !0) : !1))) {
        if (n = this.tokenizer.escape(e)) {
          e = e.substring(n.raw.length), i.push(n);
          continue;
        }
        if (n = this.tokenizer.tag(e)) {
          e = e.substring(n.raw.length), r = i[i.length - 1], r && n.type === "text" && r.type === "text" ? (r.raw += n.raw, r.text += n.text) : i.push(n);
          continue;
        }
        if (n = this.tokenizer.link(e)) {
          e = e.substring(n.raw.length), i.push(n);
          continue;
        }
        if (n = this.tokenizer.reflink(e, this.tokens.links)) {
          e = e.substring(n.raw.length), r = i[i.length - 1], r && n.type === "text" && r.type === "text" ? (r.raw += n.raw, r.text += n.text) : i.push(n);
          continue;
        }
        if (n = this.tokenizer.emStrong(e, o, c)) {
          e = e.substring(n.raw.length), i.push(n);
          continue;
        }
        if (n = this.tokenizer.codespan(e)) {
          e = e.substring(n.raw.length), i.push(n);
          continue;
        }
        if (n = this.tokenizer.br(e)) {
          e = e.substring(n.raw.length), i.push(n);
          continue;
        }
        if (n = this.tokenizer.del(e)) {
          e = e.substring(n.raw.length), i.push(n);
          continue;
        }
        if (n = this.tokenizer.autolink(e)) {
          e = e.substring(n.raw.length), i.push(n);
          continue;
        }
        if (!this.state.inLink && (n = this.tokenizer.url(e))) {
          e = e.substring(n.raw.length), i.push(n);
          continue;
        }
        if (s = e, this.options.extensions && this.options.extensions.startInline) {
          let u = 1 / 0;
          const d = e.slice(1);
          let f;
          this.options.extensions.startInline.forEach((g) => {
            f = g.call({ lexer: this }, d), typeof f == "number" && f >= 0 && (u = Math.min(u, f));
          }), u < 1 / 0 && u >= 0 && (s = e.substring(0, u + 1));
        }
        if (n = this.tokenizer.inlineText(s)) {
          e = e.substring(n.raw.length), n.raw.slice(-1) !== "_" && (c = n.raw.slice(-1)), l = !0, r = i[i.length - 1], r && r.type === "text" ? (r.raw += n.raw, r.text += n.text) : i.push(n);
          continue;
        }
        if (e) {
          const u = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(u);
            break;
          } else
            throw new Error(u);
        }
      }
    return i;
  }
}
class Gp {
  options;
  parser;
  // set by the parser
  constructor(e) {
    this.options = e || hl;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: i, escaped: n }) {
    const r = (i || "").match(/^\S*/)?.[0], s = e.replace(/\n$/, "") + `
`;
    return r ? '<pre><code class="language-' + kn(r) + '">' + (n ? s : kn(s, !0)) + `</code></pre>
` : "<pre><code>" + (n ? s : kn(s, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  heading({ tokens: e, depth: i }) {
    return `<h${i}>${this.parser.parseInline(e)}</h${i}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    const i = e.ordered, n = e.start;
    let r = "";
    for (let a = 0; a < e.items.length; a++) {
      const l = e.items[a];
      r += this.listitem(l);
    }
    const s = i ? "ol" : "ul", o = i && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + s + o + `>
` + r + "</" + s + `>
`;
  }
  listitem(e) {
    let i = "";
    if (e.task) {
      const n = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens.length > 0 && e.tokens[0].type === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + e.tokens[0].tokens[0].text)) : e.tokens.unshift({
        type: "text",
        raw: n + " ",
        text: n + " "
      }) : i += n + " ";
    }
    return i += this.parser.parse(e.tokens, !!e.loose), `<li>${i}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let i = "", n = "";
    for (let s = 0; s < e.header.length; s++)
      n += this.tablecell(e.header[s]);
    i += this.tablerow({ text: n });
    let r = "";
    for (let s = 0; s < e.rows.length; s++) {
      const o = e.rows[s];
      n = "";
      for (let a = 0; a < o.length; a++)
        n += this.tablecell(o[a]);
      r += this.tablerow({ text: n });
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + i + `</thead>
` + r + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    const i = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + i + `</${n}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${e}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: i, tokens: n }) {
    const r = this.parser.parseInline(n), s = $S(e);
    if (s === null)
      return r;
    e = s;
    let o = '<a href="' + e + '"';
    return i && (o += ' title="' + i + '"'), o += ">" + r + "</a>", o;
  }
  image({ href: e, title: i, text: n }) {
    const r = $S(e);
    if (r === null)
      return n;
    e = r;
    let s = `<img src="${e}" alt="${n}"`;
    return i && (s += ` title="${i}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : e.text;
  }
}
class Bx {
  // no need for block level renderers
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
}
class Br {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || hl, this.options.renderer = this.options.renderer || new Gp(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new Bx();
  }
  /**
   * Static Parse Method
   */
  static parse(e, i) {
    return new Br(i).parse(e);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(e, i) {
    return new Br(i).parseInline(e);
  }
  /**
   * Parse Loop
   */
  parse(e, i = !0) {
    let n = "";
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[s.type]) {
        const a = s, l = this.options.extensions.renderers[a.type].call({ parser: this }, a);
        if (l !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(a.type)) {
          n += l || "";
          continue;
        }
      }
      const o = s;
      switch (o.type) {
        case "space": {
          n += this.renderer.space(o);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(o);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(o);
          continue;
        }
        case "code": {
          n += this.renderer.code(o);
          continue;
        }
        case "table": {
          n += this.renderer.table(o);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(o);
          continue;
        }
        case "list": {
          n += this.renderer.list(o);
          continue;
        }
        case "html": {
          n += this.renderer.html(o);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(o);
          continue;
        }
        case "text": {
          let a = o, l = this.renderer.text(a);
          for (; r + 1 < e.length && e[r + 1].type === "text"; )
            a = e[++r], l += `
` + this.renderer.text(a);
          i ? n += this.renderer.paragraph({
            type: "paragraph",
            raw: l,
            text: l,
            tokens: [{ type: "text", raw: l, text: l }]
          }) : n += l;
          continue;
        }
        default: {
          const a = 'Token with "' + o.type + '" type was not found.';
          if (this.options.silent)
            return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return n;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(e, i) {
    i = i || this.renderer;
    let n = "";
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[s.type]) {
        const a = this.options.extensions.renderers[s.type].call({ parser: this }, s);
        if (a !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(s.type)) {
          n += a || "";
          continue;
        }
      }
      const o = s;
      switch (o.type) {
        case "escape": {
          n += i.text(o);
          break;
        }
        case "html": {
          n += i.html(o);
          break;
        }
        case "link": {
          n += i.link(o);
          break;
        }
        case "image": {
          n += i.image(o);
          break;
        }
        case "strong": {
          n += i.strong(o);
          break;
        }
        case "em": {
          n += i.em(o);
          break;
        }
        case "codespan": {
          n += i.codespan(o);
          break;
        }
        case "br": {
          n += i.br(o);
          break;
        }
        case "del": {
          n += i.del(o);
          break;
        }
        case "text": {
          n += i.text(o);
          break;
        }
        default: {
          const a = 'Token with "' + o.type + '" type was not found.';
          if (this.options.silent)
            return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return n;
  }
}
class ip {
  options;
  constructor(e) {
    this.options = e || hl;
  }
  static passThroughHooks = /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess",
    "processAllTokens"
  ]);
  /**
   * Process markdown before marked
   */
  preprocess(e) {
    return e;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(e) {
    return e;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(e) {
    return e;
  }
}
class IL {
  defaults = Mx();
  options = this.setOptions;
  parse = this.parseMarkdown(Hr.lex, Br.parse);
  parseInline = this.parseMarkdown(Hr.lexInline, Br.parseInline);
  Parser = Br;
  Renderer = Gp;
  TextRenderer = Bx;
  Lexer = Hr;
  Tokenizer = qp;
  Hooks = ip;
  constructor(...e) {
    this.use(...e);
  }
  /**
   * Run callback for every token
   */
  walkTokens(e, i) {
    let n = [];
    for (const r of e)
      switch (n = n.concat(i.call(this, r)), r.type) {
        case "table": {
          const s = r;
          for (const o of s.header)
            n = n.concat(this.walkTokens(o.tokens, i));
          for (const o of s.rows)
            for (const a of o)
              n = n.concat(this.walkTokens(a.tokens, i));
          break;
        }
        case "list": {
          const s = r;
          n = n.concat(this.walkTokens(s.items, i));
          break;
        }
        default: {
          const s = r;
          this.defaults.extensions?.childTokens?.[s.type] ? this.defaults.extensions.childTokens[s.type].forEach((o) => {
            const a = s[o].flat(1 / 0);
            n = n.concat(this.walkTokens(a, i));
          }) : s.tokens && (n = n.concat(this.walkTokens(s.tokens, i)));
        }
      }
    return n;
  }
  use(...e) {
    const i = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      const r = { ...n };
      if (r.async = this.defaults.async || r.async || !1, n.extensions && (n.extensions.forEach((s) => {
        if (!s.name)
          throw new Error("extension name required");
        if ("renderer" in s) {
          const o = i.renderers[s.name];
          o ? i.renderers[s.name] = function(...a) {
            let l = s.renderer.apply(this, a);
            return l === !1 && (l = o.apply(this, a)), l;
          } : i.renderers[s.name] = s.renderer;
        }
        if ("tokenizer" in s) {
          if (!s.level || s.level !== "block" && s.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          const o = i[s.level];
          o ? o.unshift(s.tokenizer) : i[s.level] = [s.tokenizer], s.start && (s.level === "block" ? i.startBlock ? i.startBlock.push(s.start) : i.startBlock = [s.start] : s.level === "inline" && (i.startInline ? i.startInline.push(s.start) : i.startInline = [s.start]));
        }
        "childTokens" in s && s.childTokens && (i.childTokens[s.name] = s.childTokens);
      }), r.extensions = i), n.renderer) {
        const s = this.defaults.renderer || new Gp(this.defaults);
        for (const o in n.renderer) {
          if (!(o in s))
            throw new Error(`renderer '${o}' does not exist`);
          if (["options", "parser"].includes(o))
            continue;
          const a = o, l = n.renderer[a], c = s[a];
          s[a] = (...u) => {
            let d = l.apply(s, u);
            return d === !1 && (d = c.apply(s, u)), d || "";
          };
        }
        r.renderer = s;
      }
      if (n.tokenizer) {
        const s = this.defaults.tokenizer || new qp(this.defaults);
        for (const o in n.tokenizer) {
          if (!(o in s))
            throw new Error(`tokenizer '${o}' does not exist`);
          if (["options", "rules", "lexer"].includes(o))
            continue;
          const a = o, l = n.tokenizer[a], c = s[a];
          s[a] = (...u) => {
            let d = l.apply(s, u);
            return d === !1 && (d = c.apply(s, u)), d;
          };
        }
        r.tokenizer = s;
      }
      if (n.hooks) {
        const s = this.defaults.hooks || new ip();
        for (const o in n.hooks) {
          if (!(o in s))
            throw new Error(`hook '${o}' does not exist`);
          if (o === "options")
            continue;
          const a = o, l = n.hooks[a], c = s[a];
          ip.passThroughHooks.has(o) ? s[a] = (u) => {
            if (this.defaults.async)
              return Promise.resolve(l.call(s, u)).then((f) => c.call(s, f));
            const d = l.call(s, u);
            return c.call(s, d);
          } : s[a] = (...u) => {
            let d = l.apply(s, u);
            return d === !1 && (d = c.apply(s, u)), d;
          };
        }
        r.hooks = s;
      }
      if (n.walkTokens) {
        const s = this.defaults.walkTokens, o = n.walkTokens;
        r.walkTokens = function(a) {
          let l = [];
          return l.push(o.call(this, a)), s && (l = l.concat(s.call(this, a))), l;
        };
      }
      this.defaults = { ...this.defaults, ...r };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, i) {
    return Hr.lex(e, i ?? this.defaults);
  }
  parser(e, i) {
    return Br.parse(e, i ?? this.defaults);
  }
  parseMarkdown(e, i) {
    return (r, s) => {
      const o = { ...s }, a = { ...this.defaults, ...o }, l = this.onError(!!a.silent, !!a.async);
      if (this.defaults.async === !0 && o.async === !1)
        return l(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof r > "u" || r === null)
        return l(new Error("marked(): input parameter is undefined or null"));
      if (typeof r != "string")
        return l(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(r) + ", string expected"));
      if (a.hooks && (a.hooks.options = a), a.async)
        return Promise.resolve(a.hooks ? a.hooks.preprocess(r) : r).then((c) => e(c, a)).then((c) => a.hooks ? a.hooks.processAllTokens(c) : c).then((c) => a.walkTokens ? Promise.all(this.walkTokens(c, a.walkTokens)).then(() => c) : c).then((c) => i(c, a)).then((c) => a.hooks ? a.hooks.postprocess(c) : c).catch(l);
      try {
        a.hooks && (r = a.hooks.preprocess(r));
        let c = e(r, a);
        a.hooks && (c = a.hooks.processAllTokens(c)), a.walkTokens && this.walkTokens(c, a.walkTokens);
        let u = i(c, a);
        return a.hooks && (u = a.hooks.postprocess(u)), u;
      } catch (c) {
        return l(c);
      }
    };
  }
  onError(e, i) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        const r = "<p>An error occurred:</p><pre>" + kn(n.message + "", !0) + "</pre>";
        return i ? Promise.resolve(r) : r;
      }
      if (i)
        return Promise.reject(n);
      throw n;
    };
  }
}
const el = new IL();
function Et(t, e) {
  return el.parse(t, e);
}
Et.options = Et.setOptions = function(t) {
  return el.setOptions(t), Et.defaults = el.defaults, nT(Et.defaults), Et;
};
Et.getDefaults = Mx;
Et.defaults = hl;
Et.use = function(...t) {
  return el.use(...t), Et.defaults = el.defaults, nT(Et.defaults), Et;
};
Et.walkTokens = function(t, e) {
  return el.walkTokens(t, e);
};
Et.parseInline = el.parseInline;
Et.Parser = Br;
Et.parser = Br.parse;
Et.Renderer = Gp;
Et.TextRenderer = Bx;
Et.Lexer = Hr;
Et.lexer = Hr.lex;
Et.Tokenizer = qp;
Et.Hooks = ip;
Et.parse = Et;
Et.options;
Et.setOptions;
Et.use;
Et.walkTokens;
Et.parseInline;
Br.parse;
Hr.lex;
function CL(t) {
  return JSON.stringify(t, TL);
}
function fT(t) {
  let e = JSON.parse(t);
  return e = Fi(e), e;
}
function TL(t, e) {
  return e instanceof RegExp ? {
    $mid: tt.Regexp,
    source: e.source,
    flags: e.flags
  } : e;
}
function Fi(t, e = 0) {
  if (!t || e > 200)
    return t;
  if (typeof t == "object") {
    switch (t.$mid) {
      case tt.Uri:
        return x.revive(t);
      case tt.Regexp:
        return new RegExp(t.source, t.flags);
      case tt.Date:
        return new Date(t.source);
    }
    if (t instanceof ue || t instanceof Uint8Array)
      return t;
    if (Array.isArray(t))
      for (let i = 0; i < t.length; ++i)
        t[i] = Fi(t[i], e + 1);
    else
      for (const i in t)
        Object.hasOwnProperty.call(t, i) && (t[i] = Fi(t[i], e + 1));
  }
  return t;
}
const gr = Object.freeze({
  text: "text/plain",
  binary: "application/octet-stream",
  unknown: "application/unknown",
  markdown: "text/markdown",
  latex: "text/latex",
  uriList: "text/uri-list",
  html: "text/html"
}), PL = /^(.+)\/(.+?)(;.+)?$/;
function pT(t, e) {
  const i = PL.exec(t);
  return i ? `${i[1].toLowerCase()}/${i[2].toLowerCase()}${i[3] ?? ""}` : e ? void 0 : t;
}
const Hi = Symbol("unset");
class AL {
  constructor() {
    this.root = new H1(), this._size = 0;
  }
  get size() {
    return this._size;
  }
  get nodes() {
    return this.root.children?.values() || Oi.empty();
  }
  get entries() {
    return this.root.children?.entries() || Oi.empty();
  }
  insert(e, i, n) {
    this.opNode(e, (r) => r._value = i, n);
  }
  mutate(e, i) {
    this.opNode(e, (n) => n._value = i(n._value === Hi ? void 0 : n._value));
  }
  mutatePath(e, i) {
    this.opNode(e, () => {
    }, (n) => i(n));
  }
  delete(e) {
    const i = this.getPathToKey(e);
    if (!i)
      return;
    let n = i.length - 1;
    const r = i[n].node._value;
    if (r !== Hi) {
      for (this._size--, i[n].node._value = Hi; n > 0; n--) {
        const { node: s, part: o } = i[n];
        if (s.children?.size || s._value !== Hi)
          break;
        i[n - 1].node.children.delete(o);
      }
      return r;
    }
  }
  *deleteRecursive(e) {
    const i = this.getPathToKey(e);
    if (!i)
      return;
    const n = i[i.length - 1].node;
    for (let r = i.length - 1; r > 0; r--) {
      const s = i[r - 1];
      if (s.node.children.delete(i[r].part), s.node.children.size > 0 || s.node._value !== Hi)
        break;
    }
    for (const r of VS(n))
      r._value !== Hi && (this._size--, yield r._value);
    n === this.root && (this.root._value = Hi, this.root.children = void 0);
  }
  find(e) {
    let i = this.root;
    for (const n of e) {
      const r = i.children?.get(n);
      if (!r)
        return;
      i = r;
    }
    return i._value === Hi ? void 0 : i._value;
  }
  hasKeyOrParent(e) {
    let i = this.root;
    for (const n of e) {
      const r = i.children?.get(n);
      if (!r)
        return !1;
      if (r._value !== Hi)
        return !0;
      i = r;
    }
    return !1;
  }
  hasKeyOrChildren(e) {
    let i = this.root;
    for (const n of e) {
      const r = i.children?.get(n);
      if (!r)
        return !1;
      i = r;
    }
    return !0;
  }
  hasKey(e) {
    let i = this.root;
    for (const n of e) {
      const r = i.children?.get(n);
      if (!r)
        return !1;
      i = r;
    }
    return i._value !== Hi;
  }
  getPathToKey(e) {
    const i = [{ part: "", node: this.root }];
    let n = 0;
    for (const r of e) {
      const s = i[n].node.children?.get(r);
      if (!s)
        return;
      i.push({ part: r, node: s }), n++;
    }
    return i;
  }
  opNode(e, i, n) {
    let r = this.root;
    for (const a of e) {
      if (r.children)
        if (r.children.has(a))
          r = r.children.get(a);
        else {
          const l = new H1();
          r.children.set(a, l), r = l;
        }
      else {
        const l = new H1();
        r.children = /* @__PURE__ */ new Map([[a, l]]), r = l;
      }
      n?.(r);
    }
    const s = r._value === Hi ? 0 : 1;
    i(r);
    const o = r._value === Hi ? 0 : 1;
    this._size += o - s;
  }
  *values() {
    for (const { _value: e } of VS(this.root))
      e !== Hi && (yield e);
  }
}
function* VS(t) {
  const e = [t];
  for (; e.length > 0; ) {
    const i = e.pop();
    if (yield i, i.children)
      for (const n of i.children.values())
        e.push(n);
  }
}
class H1 {
  constructor() {
    this._value = Hi;
  }
  get value() {
    return this._value === Hi ? void 0 : this._value;
  }
  set value(e) {
    this._value = e === void 0 ? Hi : e;
  }
}
var ka;
(function(t) {
  t[t.Auto = 1] = "Auto", t[t.Hidden = 2] = "Hidden", t[t.Visible = 3] = "Visible";
})(ka || (ka = {}));
const zS = {
  bracketPairColorizationOptions: {
    enabled: !0,
    independentColorPoolPerBracketType: !1
  }
}, gT = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function RL(t = "") {
  let e = "(-?\\d*\\.\\d\\w*)|([^";
  for (const i of gT)
    t.indexOf(i) >= 0 || (e += "\\" + i);
  return e += "\\s]+)", new RegExp(e, "g");
}
const LL = RL();
function mT(t) {
  let e = LL;
  if (t && t instanceof RegExp)
    if (t.global)
      e = t;
    else {
      let i = "g";
      t.ignoreCase && (i += "i"), t.multiline && (i += "m"), t.unicode && (i += "u"), e = new RegExp(t.source, i);
    }
  return e.lastIndex = 0, e;
}
const _T = new Ro();
_T.unshift({
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
});
function vT(t, e, i, n, r) {
  if (e = mT(e), r || (r = Oi.first(_T)), i.length > r.maxLen) {
    let c = t - r.maxLen / 2;
    return c < 0 ? c = 0 : n += c, i = i.substring(c, t + r.maxLen / 2), vT(t, e, i, n, r);
  }
  const s = Date.now(), o = t - 1 - n;
  let a = -1, l = null;
  for (let c = 1; !(Date.now() - s >= r.timeBudget); c++) {
    const u = o - r.windowSize * c;
    e.lastIndex = Math.max(0, u);
    const d = NL(e, i, o, a);
    if (!d && l || (l = d, u <= 0))
      break;
    a = u;
  }
  if (l) {
    const c = {
      word: l[0],
      startColumn: n + 1 + l.index,
      endColumn: n + 1 + l.index + l[0].length
    };
    return e.lastIndex = 0, c;
  }
  return null;
}
function NL(t, e, i, n) {
  let r;
  for (; r = t.exec(e); ) {
    const s = r.index || 0;
    if (s <= i && t.lastIndex >= i)
      return r;
    if (n > 0 && s > n)
      return null;
  }
  return null;
}
var te;
(function(t) {
  t[t.LParen = 0] = "LParen", t[t.RParen = 1] = "RParen", t[t.Neg = 2] = "Neg", t[t.Eq = 3] = "Eq", t[t.NotEq = 4] = "NotEq", t[t.Lt = 5] = "Lt", t[t.LtEq = 6] = "LtEq", t[t.Gt = 7] = "Gt", t[t.GtEq = 8] = "GtEq", t[t.RegexOp = 9] = "RegexOp", t[t.RegexStr = 10] = "RegexStr", t[t.True = 11] = "True", t[t.False = 12] = "False", t[t.In = 13] = "In", t[t.Not = 14] = "Not", t[t.And = 15] = "And", t[t.Or = 16] = "Or", t[t.Str = 17] = "Str", t[t.QuotedStr = 18] = "QuotedStr", t[t.Error = 19] = "Error", t[t.EOF = 20] = "EOF";
})(te || (te = {}));
function B1(...t) {
  switch (t.length) {
    case 1:
      return h(1766, "Did you mean {0}?", t[0]);
    case 2:
      return h(1767, "Did you mean {0} or {1}?", t[0], t[1]);
    case 3:
      return h(1768, "Did you mean {0}, {1} or {2}?", t[0], t[1], t[2]);
    default:
      return;
  }
}
const ML = h(1769, "Did you forget to open or close the quote?"), OL = h(
  1770,
  "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'."
), nc = class nc {
  constructor() {
    this._input = "", this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
  }
  static getLexeme(e) {
    switch (e.type) {
      case te.LParen:
        return "(";
      case te.RParen:
        return ")";
      case te.Neg:
        return "!";
      case te.Eq:
        return e.isTripleEq ? "===" : "==";
      case te.NotEq:
        return e.isTripleEq ? "!==" : "!=";
      case te.Lt:
        return "<";
      case te.LtEq:
        return "<=";
      case te.Gt:
        return ">=";
      case te.GtEq:
        return ">=";
      case te.RegexOp:
        return "=~";
      case te.RegexStr:
        return e.lexeme;
      case te.True:
        return "true";
      case te.False:
        return "false";
      case te.In:
        return "in";
      case te.Not:
        return "not";
      case te.And:
        return "&&";
      case te.Or:
        return "||";
      case te.Str:
        return e.lexeme;
      case te.QuotedStr:
        return e.lexeme;
      case te.Error:
        return e.lexeme;
      case te.EOF:
        return "EOF";
      default:
        throw gx(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`);
    }
  }
  get errors() {
    return this._errors;
  }
  reset(e) {
    return this._input = e, this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this;
  }
  scan() {
    for (; !this._isAtEnd(); )
      switch (this._start = this._current, this._advance()) {
        case L.OpenParen:
          this._addToken(te.LParen);
          break;
        case L.CloseParen:
          this._addToken(te.RParen);
          break;
        case L.ExclamationMark:
          if (this._match(L.Equals)) {
            const i = this._match(L.Equals);
            this._tokens.push({ type: te.NotEq, offset: this._start, isTripleEq: i });
          } else
            this._addToken(te.Neg);
          break;
        case L.SingleQuote:
          this._quotedString();
          break;
        case L.Slash:
          this._regex();
          break;
        case L.Equals:
          if (this._match(L.Equals)) {
            const i = this._match(L.Equals);
            this._tokens.push({ type: te.Eq, offset: this._start, isTripleEq: i });
          } else this._match(L.Tilde) ? this._addToken(te.RegexOp) : this._error(B1("==", "=~"));
          break;
        case L.LessThan:
          this._addToken(this._match(L.Equals) ? te.LtEq : te.Lt);
          break;
        case L.GreaterThan:
          this._addToken(this._match(L.Equals) ? te.GtEq : te.Gt);
          break;
        case L.Ampersand:
          this._match(L.Ampersand) ? this._addToken(te.And) : this._error(B1("&&"));
          break;
        case L.Pipe:
          this._match(L.Pipe) ? this._addToken(te.Or) : this._error(B1("||"));
          break;
        case L.Space:
        case L.CarriageReturn:
        case L.Tab:
        case L.LineFeed:
        case L.NoBreakSpace:
          break;
        default:
          this._string();
      }
    return this._start = this._current, this._addToken(te.EOF), Array.from(this._tokens);
  }
  _match(e) {
    return this._isAtEnd() || this._input.charCodeAt(this._current) !== e ? !1 : (this._current++, !0);
  }
  _advance() {
    return this._input.charCodeAt(this._current++);
  }
  _peek() {
    return this._isAtEnd() ? L.Null : this._input.charCodeAt(this._current);
  }
  _addToken(e) {
    this._tokens.push({ type: e, offset: this._start });
  }
  _error(e) {
    const i = this._start, n = this._input.substring(this._start, this._current), r = { type: te.Error, offset: this._start, lexeme: n };
    this._errors.push({ offset: i, lexeme: n, additionalInfo: e }), this._tokens.push(r);
  }
  _string() {
    this.stringRe.lastIndex = this._start;
    const e = this.stringRe.exec(this._input);
    if (e) {
      this._current = this._start + e[0].length;
      const i = this._input.substring(this._start, this._current), n = nc._keywords.get(i);
      n ? this._addToken(n) : this._tokens.push({ type: te.Str, lexeme: i, offset: this._start });
    }
  }
  _quotedString() {
    for (; this._peek() !== L.SingleQuote && !this._isAtEnd(); )
      this._advance();
    if (this._isAtEnd()) {
      this._error(ML);
      return;
    }
    this._advance(), this._tokens.push({ type: te.QuotedStr, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
  }
  _regex() {
    let e = this._current, i = !1, n = !1;
    for (; ; ) {
      if (e >= this._input.length) {
        this._current = e, this._error(OL);
        return;
      }
      const s = this._input.charCodeAt(e);
      if (i)
        i = !1;
      else if (s === L.Slash && !n) {
        e++;
        break;
      } else s === L.OpenSquareBracket ? n = !0 : s === L.Backslash ? i = !0 : s === L.CloseSquareBracket && (n = !1);
      e++;
    }
    for (; e < this._input.length && nc._regexFlags.has(this._input.charCodeAt(e)); )
      e++;
    this._current = e;
    const r = this._input.substring(this._start, this._current);
    this._tokens.push({ type: te.RegexStr, lexeme: r, offset: this._start });
  }
  _isAtEnd() {
    return this._current >= this._input.length;
  }
};
nc._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((e) => e.charCodeAt(0))), nc._keywords = /* @__PURE__ */ new Map([
  ["not", te.Not],
  ["in", te.In],
  ["false", te.False],
  ["true", te.True]
]);
let Yo = nc;
const Ei = /* @__PURE__ */ new Map();
Ei.set("false", !1);
Ei.set("true", !0);
Ei.set("isMac", Rn);
Ei.set("isLinux", So);
Ei.set("isWindows", ji);
Ei.set("isWeb", af);
Ei.set("isMacNative", Rn && !af);
Ei.set("isEdge", w4);
Ei.set("isFirefox", QA);
Ei.set("isChrome", Ex);
Ei.set("isSafari", KA);
const FL = Object.prototype.hasOwnProperty;
var Nt;
(function(t) {
  t[t.False = 0] = "False", t[t.True = 1] = "True", t[t.Defined = 2] = "Defined", t[t.Not = 3] = "Not", t[t.Equals = 4] = "Equals", t[t.NotEquals = 5] = "NotEquals", t[t.And = 6] = "And", t[t.Regex = 7] = "Regex", t[t.NotRegex = 8] = "NotRegex", t[t.Or = 9] = "Or", t[t.In = 10] = "In", t[t.NotIn = 11] = "NotIn", t[t.Greater = 12] = "Greater", t[t.GreaterEquals = 13] = "GreaterEquals", t[t.Smaller = 14] = "Smaller", t[t.SmallerEquals = 15] = "SmallerEquals";
})(Nt || (Nt = {}));
const UL = {
  regexParsingWithErrorRecovery: !0
}, $L = h(1746, "Empty context key expression"), HL = h(
  1747,
  "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively."
), BL = h(1748, "'in' after 'not'."), qS = h(1749, "closing parenthesis ')'"), WL = h(1750, "Unexpected token"), VL = h(1751, "Did you forget to put && or || before the token?"), zL = h(1752, "Unexpected end of expression"), qL = h(1753, "Did you forget to put a context key?"), ra = class ra {
  get lexingErrors() {
    return this._scanner.errors;
  }
  get parsingErrors() {
    return this._parsingErrors;
  }
  constructor(e = UL) {
    this._config = e, this._scanner = new Yo(), this._tokens = [], this._current = 0, this._parsingErrors = [], this._flagsGYRe = /g|y/g;
  }
  parse(e) {
    if (e === "") {
      this._parsingErrors.push({ message: $L, offset: 0, lexeme: "", additionalInfo: HL });
      return;
    }
    this._tokens = this._scanner.reset(e).scan(), this._current = 0, this._parsingErrors = [];
    try {
      const i = this._expr();
      if (!this._isAtEnd()) {
        const n = this._peek(), r = n.type === te.Str ? VL : void 0;
        throw this._parsingErrors.push({ message: WL, offset: n.offset, lexeme: Yo.getLexeme(n), additionalInfo: r }), ra._parseError;
      }
      return i;
    } catch (i) {
      if (i !== ra._parseError)
        throw i;
      return;
    }
  }
  _expr() {
    return this._or();
  }
  _or() {
    const e = [this._and()];
    for (; this._matchOne(te.Or); ) {
      const i = this._and();
      e.push(i);
    }
    return e.length === 1 ? e[0] : Gt.or(...e);
  }
  _and() {
    const e = [this._term()];
    for (; this._matchOne(te.And); ) {
      const i = this._term();
      e.push(i);
    }
    return e.length === 1 ? e[0] : Gt.and(...e);
  }
  _term() {
    if (this._matchOne(te.Neg)) {
      const e = this._peek();
      switch (e.type) {
        case te.True:
          return this._advance(), Ui.INSTANCE;
        case te.False:
          return this._advance(), Gi.INSTANCE;
        case te.LParen: {
          this._advance();
          const i = this._expr();
          return this._consume(te.RParen, qS), i?.negate();
        }
        case te.Str:
          return this._advance(), pl.create(e.lexeme);
        default:
          throw this._errExpectedButGot("KEY | true | false | '(' expression ')'", e);
      }
    }
    return this._primary();
  }
  _primary() {
    const e = this._peek();
    switch (e.type) {
      case te.True:
        return this._advance(), Gt.true();
      case te.False:
        return this._advance(), Gt.false();
      case te.LParen: {
        this._advance();
        const i = this._expr();
        return this._consume(te.RParen, qS), i;
      }
      case te.Str: {
        const i = e.lexeme;
        if (this._advance(), this._matchOne(te.RegexOp)) {
          const r = this._peek();
          if (!this._config.regexParsingWithErrorRecovery) {
            if (this._advance(), r.type !== te.RegexStr)
              throw this._errExpectedButGot("REGEX", r);
            const s = r.lexeme, o = s.lastIndexOf("/"), a = o === s.length - 1 ? void 0 : this._removeFlagsGY(s.substring(o + 1));
            let l;
            try {
              l = new RegExp(s.substring(1, o), a);
            } catch {
              throw this._errExpectedButGot("REGEX", r);
            }
            return Qd.create(i, l);
          }
          switch (r.type) {
            case te.RegexStr:
            case te.Error: {
              const s = [r.lexeme];
              this._advance();
              let o = this._peek(), a = 0;
              for (let f = 0; f < r.lexeme.length; f++)
                r.lexeme.charCodeAt(f) === L.OpenParen ? a++ : r.lexeme.charCodeAt(f) === L.CloseParen && a--;
              for (; !this._isAtEnd() && o.type !== te.And && o.type !== te.Or; ) {
                switch (o.type) {
                  case te.LParen:
                    a++;
                    break;
                  case te.RParen:
                    a--;
                    break;
                  case te.RegexStr:
                  case te.QuotedStr:
                    for (let f = 0; f < o.lexeme.length; f++)
                      o.lexeme.charCodeAt(f) === L.OpenParen ? a++ : r.lexeme.charCodeAt(f) === L.CloseParen && a--;
                }
                if (a < 0)
                  break;
                s.push(Yo.getLexeme(o)), this._advance(), o = this._peek();
              }
              const l = s.join(""), c = l.lastIndexOf("/"), u = c === l.length - 1 ? void 0 : this._removeFlagsGY(l.substring(c + 1));
              let d;
              try {
                d = new RegExp(l.substring(1, c), u);
              } catch {
                throw this._errExpectedButGot("REGEX", r);
              }
              return Gt.regex(i, d);
            }
            case te.QuotedStr: {
              const s = r.lexeme;
              this._advance();
              let o = null;
              if (!qd(s)) {
                const a = s.indexOf("/"), l = s.lastIndexOf("/");
                if (a !== l && a >= 0) {
                  const c = s.slice(a + 1, l), u = s[l + 1] === "i" ? "i" : "";
                  try {
                    o = new RegExp(c, u);
                  } catch {
                    throw this._errExpectedButGot("REGEX", r);
                  }
                }
              }
              if (o === null)
                throw this._errExpectedButGot("REGEX", r);
              return Qd.create(i, o);
            }
            default:
              throw this._errExpectedButGot("REGEX", this._peek());
          }
        }
        if (this._matchOne(te.Not)) {
          this._consume(te.In, BL);
          const r = this._value();
          return Gt.notIn(i, r);
        }
        switch (this._peek().type) {
          case te.Eq: {
            this._advance();
            const r = this._value();
            if (this._previous().type === te.QuotedStr)
              return Gt.equals(i, r);
            switch (r) {
              case "true":
                return Gt.has(i);
              case "false":
                return Gt.not(i);
              default:
                return Gt.equals(i, r);
            }
          }
          case te.NotEq: {
            this._advance();
            const r = this._value();
            if (this._previous().type === te.QuotedStr)
              return Gt.notEquals(i, r);
            switch (r) {
              case "true":
                return Gt.not(i);
              case "false":
                return Gt.has(i);
              default:
                return Gt.notEquals(i, r);
            }
          }
          case te.Lt:
            return this._advance(), mf.create(i, this._value());
          case te.LtEq:
            return this._advance(), _f.create(i, this._value());
          case te.Gt:
            return this._advance(), bu.create(i, this._value());
          case te.GtEq:
            return this._advance(), gf.create(i, this._value());
          case te.In:
            return this._advance(), Gt.in(i, this._value());
          default:
            return Gt.has(i);
        }
      }
      case te.EOF:
        throw this._parsingErrors.push({ message: zL, offset: e.offset, lexeme: "", additionalInfo: qL }), ra._parseError;
      default:
        throw this._errExpectedButGot(`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
    }
  }
  _value() {
    const e = this._peek();
    switch (e.type) {
      case te.Str:
      case te.QuotedStr:
        return this._advance(), e.lexeme;
      case te.True:
        return this._advance(), "true";
      case te.False:
        return this._advance(), "false";
      case te.In:
        return this._advance(), "in";
      default:
        return "";
    }
  }
  _removeFlagsGY(e) {
    return e.replaceAll(this._flagsGYRe, "");
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _matchOne(e) {
    return this._check(e) ? (this._advance(), !0) : !1;
  }
  _advance() {
    return this._isAtEnd() || this._current++, this._previous();
  }
  _consume(e, i) {
    if (this._check(e))
      return this._advance();
    throw this._errExpectedButGot(i, this._peek());
  }
  _errExpectedButGot(e, i, n) {
    const r = h(1754, `Expected: {0}
Received: '{1}'.`, e, Yo.getLexeme(i)), s = i.offset, o = Yo.getLexeme(i);
    return this._parsingErrors.push({ message: r, offset: s, lexeme: o, additionalInfo: n }), ra._parseError;
  }
  _check(e) {
    return this._peek().type === e;
  }
  _peek() {
    return this._tokens[this._current];
  }
  _isAtEnd() {
    return this._peek().type === te.EOF;
  }
};
ra._parseError = new Error();
let Qp = ra;
const OE = class OE {
  static false() {
    return Ui.INSTANCE;
  }
  static true() {
    return Gi.INSTANCE;
  }
  static has(e) {
    return fl.create(e);
  }
  static equals(e, i) {
    return ff.create(e, i);
  }
  static notEquals(e, i) {
    return pf.create(e, i);
  }
  static regex(e, i) {
    return Qd.create(e, i);
  }
  static in(e, i) {
    return q_.create(e, i);
  }
  static notIn(e, i) {
    return j_.create(e, i);
  }
  static not(e) {
    return pl.create(e);
  }
  static and(...e) {
    return so.create(e, null, !0);
  }
  static or(...e) {
    return Ar.create(e, null, !0);
  }
  static greater(e, i) {
    return bu.create(e, i);
  }
  static greaterEquals(e, i) {
    return gf.create(e, i);
  }
  static smaller(e, i) {
    return mf.create(e, i);
  }
  static smallerEquals(e, i) {
    return _f.create(e, i);
  }
  static deserialize(e) {
    return e == null ? void 0 : this._parser.parse(e);
  }
};
OE._parser = new Qp({ regexParsingWithErrorRecovery: !1 });
let Gt = OE;
function jL(t) {
  const e = new Qp({ regexParsingWithErrorRecovery: !1 });
  return t.map((i) => (e.parse(i), e.lexingErrors.length > 0 ? e.lexingErrors.map((n) => ({
    errorMessage: n.additionalInfo ? h(1755, "Unexpected token. Hint: {0}", n.additionalInfo) : h(1756, "Unexpected token."),
    offset: n.offset,
    length: n.lexeme.length
  })) : e.parsingErrors.length > 0 ? e.parsingErrors.map((n) => ({
    errorMessage: n.additionalInfo ? `${n.message}. ${n.additionalInfo}` : n.message,
    offset: n.offset,
    length: n.lexeme.length
  })) : []));
}
function ld(t, e) {
  return t.cmp(e);
}
const p_ = class p_ {
  constructor() {
    this.type = Nt.False;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !1;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  map(e) {
    return this;
  }
  negate() {
    return Gi.INSTANCE;
  }
};
p_.INSTANCE = new p_();
let Ui = p_;
const g_ = class g_ {
  constructor() {
    this.type = Nt.True;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !0;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  map(e) {
    return this;
  }
  negate() {
    return Ui.INSTANCE;
  }
};
g_.INSTANCE = new g_();
let Gi = g_;
class fl {
  static create(e, i = null) {
    const n = Ei.get(e);
    return typeof n == "boolean" ? n ? Gi.INSTANCE : Ui.INSTANCE : new fl(e, i);
  }
  constructor(e, i) {
    this.key = e, this.negated = i, this.type = Nt.Defined;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : bT(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = Ei.get(this.key);
    return typeof e == "boolean" ? e ? Gi.INSTANCE : Ui.INSTANCE : this;
  }
  evaluate(e) {
    return !!e.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  map(e) {
    return e.mapDefined(this.key);
  }
  negate() {
    return this.negated || (this.negated = pl.create(this.key, this)), this.negated;
  }
}
class ff {
  static create(e, i, n = null) {
    if (typeof i == "boolean")
      return i ? fl.create(e, n) : pl.create(e, n);
    const r = Ei.get(e);
    return typeof r == "boolean" ? i === (r ? "true" : "false") ? Gi.INSTANCE : Ui.INSTANCE : new ff(e, i, n);
  }
  constructor(e, i, n) {
    this.key = e, this.value = i, this.negated = n, this.type = Nt.Equals;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : gl(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = Ei.get(this.key);
    if (typeof e == "boolean") {
      const i = e ? "true" : "false";
      return this.value === i ? Gi.INSTANCE : Ui.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) == this.value;
  }
  serialize() {
    return `${this.key} == '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  map(e) {
    return e.mapEquals(this.key, this.value);
  }
  negate() {
    return this.negated || (this.negated = pf.create(this.key, this.value, this)), this.negated;
  }
}
class q_ {
  static create(e, i) {
    return new q_(e, i);
  }
  constructor(e, i) {
    this.key = e, this.valueKey = i, this.type = Nt.In, this.negated = null;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : gl(this.key, this.valueKey, e.key, e.valueKey);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const i = e.getValue(this.valueKey), n = e.getValue(this.key);
    return Array.isArray(i) ? i.includes(n) : typeof n == "string" && typeof i == "object" && i !== null ? FL.call(i, n) : !1;
  }
  serialize() {
    return `${this.key} in '${this.valueKey}'`;
  }
  keys() {
    return [this.key, this.valueKey];
  }
  map(e) {
    return e.mapIn(this.key, this.valueKey);
  }
  negate() {
    return this.negated || (this.negated = j_.create(this.key, this.valueKey)), this.negated;
  }
}
class j_ {
  static create(e, i) {
    return new j_(e, i);
  }
  constructor(e, i) {
    this.key = e, this.valueKey = i, this.type = Nt.NotIn, this._negated = q_.create(e, i);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._negated.cmp(e._negated);
  }
  equals(e) {
    return e.type === this.type ? this._negated.equals(e._negated) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._negated.evaluate(e);
  }
  serialize() {
    return `${this.key} not in '${this.valueKey}'`;
  }
  keys() {
    return this._negated.keys();
  }
  map(e) {
    return e.mapNotIn(this.key, this.valueKey);
  }
  negate() {
    return this._negated;
  }
}
class pf {
  static create(e, i, n = null) {
    if (typeof i == "boolean")
      return i ? pl.create(e, n) : fl.create(e, n);
    const r = Ei.get(e);
    return typeof r == "boolean" ? i === (r ? "true" : "false") ? Ui.INSTANCE : Gi.INSTANCE : new pf(e, i, n);
  }
  constructor(e, i, n) {
    this.key = e, this.value = i, this.negated = n, this.type = Nt.NotEquals;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : gl(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = Ei.get(this.key);
    if (typeof e == "boolean") {
      const i = e ? "true" : "false";
      return this.value === i ? Ui.INSTANCE : Gi.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) != this.value;
  }
  serialize() {
    return `${this.key} != '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  map(e) {
    return e.mapNotEquals(this.key, this.value);
  }
  negate() {
    return this.negated || (this.negated = ff.create(this.key, this.value, this)), this.negated;
  }
}
class pl {
  static create(e, i = null) {
    const n = Ei.get(e);
    return typeof n == "boolean" ? n ? Ui.INSTANCE : Gi.INSTANCE : new pl(e, i);
  }
  constructor(e, i) {
    this.key = e, this.negated = i, this.type = Nt.Not;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : bT(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = Ei.get(this.key);
    return typeof e == "boolean" ? e ? Ui.INSTANCE : Gi.INSTANCE : this;
  }
  evaluate(e) {
    return !e.getValue(this.key);
  }
  serialize() {
    return `!${this.key}`;
  }
  keys() {
    return [this.key];
  }
  map(e) {
    return e.mapNot(this.key);
  }
  negate() {
    return this.negated || (this.negated = fl.create(this.key, this)), this.negated;
  }
}
function G_(t, e) {
  if (typeof t == "string") {
    const i = parseFloat(t);
    isNaN(i) || (t = i);
  }
  return typeof t == "string" || typeof t == "number" ? e(t) : Ui.INSTANCE;
}
class bu {
  static create(e, i, n = null) {
    return G_(i, (r) => new bu(e, r, n));
  }
  constructor(e, i, n) {
    this.key = e, this.value = i, this.negated = n, this.type = Nt.Greater;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : gl(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) > this.value;
  }
  serialize() {
    return `${this.key} > ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  map(e) {
    return e.mapGreater(this.key, this.value);
  }
  negate() {
    return this.negated || (this.negated = _f.create(this.key, this.value, this)), this.negated;
  }
}
class gf {
  static create(e, i, n = null) {
    return G_(i, (r) => new gf(e, r, n));
  }
  constructor(e, i, n) {
    this.key = e, this.value = i, this.negated = n, this.type = Nt.GreaterEquals;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : gl(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) >= this.value;
  }
  serialize() {
    return `${this.key} >= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  map(e) {
    return e.mapGreaterEquals(this.key, this.value);
  }
  negate() {
    return this.negated || (this.negated = mf.create(this.key, this.value, this)), this.negated;
  }
}
class mf {
  static create(e, i, n = null) {
    return G_(i, (r) => new mf(e, r, n));
  }
  constructor(e, i, n) {
    this.key = e, this.value = i, this.negated = n, this.type = Nt.Smaller;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : gl(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) < this.value;
  }
  serialize() {
    return `${this.key} < ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  map(e) {
    return e.mapSmaller(this.key, this.value);
  }
  negate() {
    return this.negated || (this.negated = gf.create(this.key, this.value, this)), this.negated;
  }
}
class _f {
  static create(e, i, n = null) {
    return G_(i, (r) => new _f(e, r, n));
  }
  constructor(e, i, n) {
    this.key = e, this.value = i, this.negated = n, this.type = Nt.SmallerEquals;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : gl(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) <= this.value;
  }
  serialize() {
    return `${this.key} <= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  map(e) {
    return e.mapSmallerEquals(this.key, this.value);
  }
  negate() {
    return this.negated || (this.negated = bu.create(this.key, this.value, this)), this.negated;
  }
}
class Qd {
  static create(e, i) {
    return new Qd(e, i);
  }
  constructor(e, i) {
    this.key = e, this.regexp = i, this.type = Nt.Regex, this.negated = null;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.key < e.key)
      return -1;
    if (this.key > e.key)
      return 1;
    const i = this.regexp ? this.regexp.source : "", n = e.regexp ? e.regexp.source : "";
    return i < n ? -1 : i > n ? 1 : 0;
  }
  equals(e) {
    if (e.type === this.type) {
      const i = this.regexp ? this.regexp.source : "", n = e.regexp ? e.regexp.source : "";
      return this.key === e.key && i === n;
    }
    return !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const i = e.getValue(this.key);
    return this.regexp ? this.regexp.test(i) : !1;
  }
  serialize() {
    const e = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/";
    return `${this.key} =~ ${e}`;
  }
  keys() {
    return [this.key];
  }
  map(e) {
    return e.mapRegex(this.key, this.regexp);
  }
  negate() {
    return this.negated || (this.negated = Kp.create(this)), this.negated;
  }
}
class Kp {
  static create(e) {
    return new Kp(e);
  }
  constructor(e) {
    this._actual = e, this.type = Nt.NotRegex;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
  }
  equals(e) {
    return e.type === this.type ? this._actual.equals(e._actual) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._actual.evaluate(e);
  }
  serialize() {
    return `!(${this._actual.serialize()})`;
  }
  keys() {
    return this._actual.keys();
  }
  map(e) {
    return new Kp(this._actual.map(e));
  }
  negate() {
    return this._actual;
  }
}
function wT(t) {
  let e = null;
  for (let i = 0, n = t.length; i < n; i++) {
    const r = t[i].substituteConstants();
    if (t[i] !== r && e === null) {
      e = [];
      for (let s = 0; s < i; s++)
        e[s] = t[s];
    }
    e !== null && (e[i] = r);
  }
  return e === null ? t : e;
}
class so {
  static create(e, i, n) {
    return so._normalizeArr(e, i, n);
  }
  constructor(e, i) {
    this.expr = e, this.negated = i, this.type = Nt.And;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let i = 0, n = this.expr.length; i < n; i++) {
      const r = ld(this.expr[i], e.expr[i]);
      if (r !== 0)
        return r;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let i = 0, n = this.expr.length; i < n; i++)
        if (!this.expr[i].equals(e.expr[i]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = wT(this.expr);
    return e === this.expr ? this : so.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let i = 0, n = this.expr.length; i < n; i++)
      if (!this.expr[i].evaluate(e))
        return !1;
    return !0;
  }
  static _normalizeArr(e, i, n) {
    const r = [];
    let s = !1;
    for (const o of e)
      if (o) {
        if (o.type === Nt.True) {
          s = !0;
          continue;
        }
        if (o.type === Nt.False)
          return Ui.INSTANCE;
        if (o.type === Nt.And) {
          r.push(...o.expr);
          continue;
        }
        r.push(o);
      }
    if (r.length === 0 && s)
      return Gi.INSTANCE;
    if (r.length !== 0) {
      if (r.length === 1)
        return r[0];
      r.sort(ld);
      for (let o = 1; o < r.length; o++)
        r[o - 1].equals(r[o]) && (r.splice(o, 1), o--);
      if (r.length === 1)
        return r[0];
      for (; r.length > 1; ) {
        const o = r[r.length - 1];
        if (o.type !== Nt.Or)
          break;
        r.pop();
        const a = r.pop(), l = r.length === 0, c = Ar.create(o.expr.map(
          (u) => so.create([u, a], null, n)
        ), null, l);
        c && (r.push(c), r.sort(ld));
      }
      if (r.length === 1)
        return r[0];
      if (n) {
        for (let o = 0; o < r.length; o++)
          for (let a = o + 1; a < r.length; a++)
            if (r[o].negate().equals(r[a]))
              return Ui.INSTANCE;
        if (r.length === 1)
          return r[0];
      }
      return new so(r, i);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const e = [];
    for (const i of this.expr)
      e.push(...i.keys());
    return e;
  }
  map(e) {
    return new so(this.expr.map((i) => i.map(e)), null);
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const i of this.expr)
        e.push(i.negate());
      this.negated = Ar.create(e, this, !0);
    }
    return this.negated;
  }
}
class Ar {
  static create(e, i, n) {
    return Ar._normalizeArr(e, i, n);
  }
  constructor(e, i) {
    this.expr = e, this.negated = i, this.type = Nt.Or;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let i = 0, n = this.expr.length; i < n; i++) {
      const r = ld(this.expr[i], e.expr[i]);
      if (r !== 0)
        return r;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let i = 0, n = this.expr.length; i < n; i++)
        if (!this.expr[i].equals(e.expr[i]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = wT(this.expr);
    return e === this.expr ? this : Ar.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let i = 0, n = this.expr.length; i < n; i++)
      if (this.expr[i].evaluate(e))
        return !0;
    return !1;
  }
  static _normalizeArr(e, i, n) {
    let r = [], s = !1;
    if (e) {
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        if (l) {
          if (l.type === Nt.False) {
            s = !0;
            continue;
          }
          if (l.type === Nt.True)
            return Gi.INSTANCE;
          if (l.type === Nt.Or) {
            r = r.concat(l.expr);
            continue;
          }
          r.push(l);
        }
      }
      if (r.length === 0 && s)
        return Ui.INSTANCE;
      r.sort(ld);
    }
    if (r.length !== 0) {
      if (r.length === 1)
        return r[0];
      for (let o = 1; o < r.length; o++)
        r[o - 1].equals(r[o]) && (r.splice(o, 1), o--);
      if (r.length === 1)
        return r[0];
      if (n) {
        for (let o = 0; o < r.length; o++)
          for (let a = o + 1; a < r.length; a++)
            if (r[o].negate().equals(r[a]))
              return Gi.INSTANCE;
        if (r.length === 1)
          return r[0];
      }
      return new Ar(r, i);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const e = [];
    for (const i of this.expr)
      e.push(...i.keys());
    return e;
  }
  map(e) {
    return new Ar(this.expr.map((i) => i.map(e)), null);
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const i of this.expr)
        e.push(i.negate());
      for (; e.length > 1; ) {
        const i = e.shift(), n = e.shift(), r = [];
        for (const s of jS(i))
          for (const o of jS(n))
            r.push(so.create([s, o], null, !1));
        e.unshift(Ar.create(r, null, !1));
      }
      this.negated = Ar.create(e, this, !0);
    }
    return this.negated;
  }
}
const rc = class rc extends fl {
  static all() {
    return rc._info.values();
  }
  constructor(e, i, n) {
    super(e, null), this._defaultValue = i, typeof n == "object" ? rc._info.push({ ...n, key: e }) : n !== !0 && rc._info.push({ key: e, description: n, type: i != null ? typeof i : void 0 });
  }
  bindTo(e) {
    return e.createKey(this.key, this._defaultValue);
  }
  getValue(e) {
    return e.getContextKeyValue(this.key);
  }
  toNegated() {
    return this.negate();
  }
  isEqualTo(e) {
    return ff.create(this.key, e);
  }
  notEqualsTo(e) {
    return pf.create(this.key, e);
  }
  greater(e) {
    return bu.create(this.key, e);
  }
};
rc._info = [];
let T = rc;
function bT(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function gl(t, e, i, n) {
  return t < i ? -1 : t > i ? 1 : e < n ? -1 : e > n ? 1 : 0;
}
function jS(t) {
  return t.type === Nt.Or ? t.expr : [t];
}
var ur;
(function(t) {
  t[t.Unknown = 0] = "Unknown", t[t.Disabled = 1] = "Disabled", t[t.Enabled = 2] = "Enabled";
})(ur || (ur = {}));
new T("accessibilityModeEnabled", !1);
var oo;
(function(t) {
  t[t.None = 0] = "None", t[t.Keep = 1] = "Keep", t[t.Brackets = 2] = "Brackets", t[t.Advanced = 3] = "Advanced", t[t.Full = 4] = "Full";
})(oo || (oo = {}));
const GL = 8;
class QL {
  constructor() {
    this.stableMinimapLayoutInput = null, this.stableFitMaxMinimapScale = 0, this.stableFitRemainingWidth = 0;
  }
}
class mt {
  constructor(e, i, n, r) {
    this.id = e, this.name = i, this.defaultValue = n, this.schema = r;
  }
  applyUpdate(e, i) {
    return Q_(e, i);
  }
  compute(e, i, n) {
    return n;
  }
}
class np {
  constructor(e, i) {
    this.newValue = e, this.didChange = i;
  }
}
function Q_(t, e) {
  if (typeof t != "object" || typeof e != "object" || !t || !e)
    return new np(e, t !== e);
  if (Array.isArray(t) || Array.isArray(e)) {
    const n = Array.isArray(t) && Array.isArray(e) && An(t, e);
    return new np(e, !n);
  }
  let i = !1;
  for (const n in e)
    if (e.hasOwnProperty(n)) {
      const r = Q_(t[n], e[n]);
      r.didChange && (t[n] = r.newValue, i = !0);
    }
  return new np(t, i);
}
class No {
  constructor(e) {
    this.schema = void 0, this.id = e, this.name = "_never_", this.defaultValue = void 0;
  }
  applyUpdate(e, i) {
    return Q_(e, i);
  }
  validate(e) {
    return this.defaultValue;
  }
}
class yu {
  constructor(e, i, n, r) {
    this.id = e, this.name = i, this.defaultValue = n, this.schema = r;
  }
  applyUpdate(e, i) {
    return Q_(e, i);
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : e;
  }
  compute(e, i, n) {
    return n;
  }
}
function se(t, e) {
  return typeof t > "u" ? e : t === "false" ? !1 : !!t;
}
class xe extends yu {
  constructor(e, i, n, r = void 0) {
    typeof r < "u" && (r.type = "boolean", r.default = n), super(e, i, n, r);
  }
  validate(e) {
    return se(e, this.defaultValue);
  }
}
function KL(t, e, i, n) {
  if (typeof t > "u")
    return e;
  let r = parseInt(t, 10);
  return isNaN(r) ? e : (r = Math.max(i, r), r = Math.min(n, r), r | 0);
}
class Ke extends yu {
  static clampedInt(e, i, n, r) {
    return KL(e, i, n, r);
  }
  constructor(e, i, n, r, s, o = void 0) {
    typeof o < "u" && (o.type = "integer", o.default = n, o.minimum = r, o.maximum = s), super(e, i, n, o), this.minimum = r, this.maximum = s;
  }
  validate(e) {
    return Ke.clampedInt(e, this.defaultValue, this.minimum, this.maximum);
  }
}
class Bn extends yu {
  static clamp(e, i, n) {
    return e < i ? i : e > n ? n : e;
  }
  static float(e, i) {
    if (typeof e == "number")
      return e;
    if (typeof e > "u")
      return i;
    const n = parseFloat(e);
    return isNaN(n) ? i : n;
  }
  constructor(e, i, n, r, s, o, a) {
    typeof s < "u" && (s.type = "number", s.default = n, s.minimum = o, s.maximum = a), super(e, i, n, s), this.validationFn = r, this.minimum = o, this.maximum = a;
  }
  validate(e) {
    return this.validationFn(Bn.float(e, this.defaultValue));
  }
}
class Ti extends yu {
  static string(e, i) {
    return typeof e != "string" ? i : e;
  }
  constructor(e, i, n, r = void 0) {
    typeof r < "u" && (r.type = "string", r.default = n), super(e, i, n, r);
  }
  validate(e) {
    return Ti.string(e, this.defaultValue);
  }
}
function vt(t, e, i, n) {
  return typeof t != "string" || i.indexOf(t) === -1 ? e : t;
}
class _t extends yu {
  constructor(e, i, n, r, s = void 0) {
    typeof s < "u" && (s.type = "string", s.enum = r, s.default = n), super(e, i, n, s), this._allowedValues = r;
  }
  validate(e) {
    return vt(e, this.defaultValue, this._allowedValues);
  }
}
class Fu extends mt {
  constructor(e, i, n, r, s, o, a = void 0) {
    typeof a < "u" && (a.type = "string", a.enum = s, a.default = r), super(e, i, n, a), this._allowedValues = s, this._convert = o;
  }
  validate(e) {
    return typeof e != "string" ? this.defaultValue : this._allowedValues.indexOf(e) === -1 ? this.defaultValue : this._convert(e);
  }
}
function JL(t) {
  switch (t) {
    case "none":
      return oo.None;
    case "keep":
      return oo.Keep;
    case "brackets":
      return oo.Brackets;
    case "advanced":
      return oo.Advanced;
    case "full":
      return oo.Full;
  }
}
class YL extends mt {
  constructor() {
    super(R.accessibilitySupport, "accessibilitySupport", ur.Unknown, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        h(266, "Use platform APIs to detect when a Screen Reader is attached."),
        h(267, "Optimize for usage with a Screen Reader."),
        h(268, "Assume a screen reader is not attached.")
      ],
      default: "auto",
      tags: ["accessibility"],
      description: h(
        269,
        "Controls if the UI should run in a mode where it is optimized for screen readers."
      )
    });
  }
  validate(e) {
    switch (e) {
      case "auto":
        return ur.Unknown;
      case "off":
        return ur.Disabled;
      case "on":
        return ur.Enabled;
    }
    return this.defaultValue;
  }
  compute(e, i, n) {
    return n === ur.Unknown ? e.accessibilitySupport : n;
  }
}
class XL extends mt {
  constructor() {
    const e = {
      insertSpace: !0,
      ignoreEmptyLines: !0
    };
    super(R.comments, "comments", e, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: e.insertSpace,
        description: h(270, "Controls whether a space character is inserted when commenting.")
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: e.ignoreEmptyLines,
        description: h(
          271,
          "Controls if empty lines should be ignored with toggle, add or remove actions for line comments."
        )
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      insertSpace: se(i.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: se(i.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
}
var ao;
(function(t) {
  t[t.Hidden = 0] = "Hidden", t[t.Blink = 1] = "Blink", t[t.Smooth = 2] = "Smooth", t[t.Phase = 3] = "Phase", t[t.Expand = 4] = "Expand", t[t.Solid = 5] = "Solid";
})(ao || (ao = {}));
function ZL(t) {
  switch (t) {
    case "blink":
      return ao.Blink;
    case "smooth":
      return ao.Smooth;
    case "phase":
      return ao.Phase;
    case "expand":
      return ao.Expand;
    case "solid":
      return ao.Solid;
  }
}
var cr;
(function(t) {
  t[t.Line = 1] = "Line", t[t.Block = 2] = "Block", t[t.Underline = 3] = "Underline", t[t.LineThin = 4] = "LineThin", t[t.BlockOutline = 5] = "BlockOutline", t[t.UnderlineThin = 6] = "UnderlineThin";
})(cr || (cr = {}));
function GS(t) {
  switch (t) {
    case "line":
      return cr.Line;
    case "block":
      return cr.Block;
    case "underline":
      return cr.Underline;
    case "line-thin":
      return cr.LineThin;
    case "block-outline":
      return cr.BlockOutline;
    case "underline-thin":
      return cr.UnderlineThin;
  }
}
class e7 extends No {
  constructor() {
    super(R.editorClassName);
  }
  compute(e, i, n) {
    const r = ["monaco-editor"];
    return i.get(R.extraEditorClassName) && r.push(i.get(R.extraEditorClassName)), e.extraEditorClassName && r.push(e.extraEditorClassName), i.get(R.mouseStyle) === "default" ? r.push("mouse-default") : i.get(R.mouseStyle) === "copy" && r.push("mouse-copy"), i.get(R.showUnused) && r.push("showUnused"), i.get(R.showDeprecated) && r.push("showDeprecated"), r.join(" ");
  }
}
class t7 extends xe {
  constructor() {
    super(R.emptySelectionClipboard, "emptySelectionClipboard", !0, { description: h(
      272,
      "Controls whether copying without a selection copies the current line."
    ) });
  }
  compute(e, i, n) {
    return n && e.emptySelectionClipboard;
  }
}
class i7 extends mt {
  constructor() {
    const e = {
      cursorMoveOnType: !0,
      findOnType: !0,
      seedSearchStringFromSelection: "always",
      autoFindInSelection: "never",
      globalFindClipboard: !1,
      addExtraSpaceOnTop: !0,
      loop: !0,
      history: "workspace",
      replaceHistory: "workspace"
    };
    super(R.find, "find", e, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: e.cursorMoveOnType,
        description: h(
          273,
          "Controls whether the cursor should jump to find matches while typing."
        )
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "string",
        enum: ["never", "always", "selection"],
        default: e.seedSearchStringFromSelection,
        enumDescriptions: [
          h(274, "Never seed search string from the editor selection."),
          h(
            275,
            "Always seed search string from the editor selection, including word at cursor position."
          ),
          h(276, "Only seed search string from the editor selection.")
        ],
        description: h(
          277,
          "Controls whether the search string in the Find Widget is seeded from the editor selection."
        )
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: e.autoFindInSelection,
        enumDescriptions: [
          h(278, "Never turn on Find in Selection automatically (default)."),
          h(279, "Always turn on Find in Selection automatically."),
          h(
            280,
            "Turn on Find in Selection automatically when multiple lines of content are selected."
          )
        ],
        description: h(
          281,
          "Controls the condition for turning on Find in Selection automatically."
        )
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: e.globalFindClipboard,
        description: h(
          282,
          "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."
        ),
        included: Rn
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: e.addExtraSpaceOnTop,
        description: h(
          283,
          "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible."
        )
      },
      "editor.find.loop": {
        type: "boolean",
        default: e.loop,
        description: h(
          284,
          "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found."
        )
      },
      "editor.find.history": {
        type: "string",
        enum: ["never", "workspace"],
        default: "workspace",
        enumDescriptions: [
          h(285, "Do not store search history from the find widget."),
          h(286, "Store search history across the active workspace")
        ],
        description: h(287, "Controls how the find widget history should be stored")
      },
      "editor.find.replaceHistory": {
        type: "string",
        enum: ["never", "workspace"],
        default: "workspace",
        enumDescriptions: [
          h(288, "Do not store history from the replace widget."),
          h(289, "Store replace history across the active workspace")
        ],
        description: h(290, "Controls how the replace widget history should be stored")
      },
      "editor.find.findOnType": {
        type: "boolean",
        default: e.findOnType,
        description: h(291, "Controls whether the Find Widget should search as you type.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      cursorMoveOnType: se(i.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      findOnType: se(i.findOnType, this.defaultValue.findOnType),
      seedSearchStringFromSelection: typeof e.seedSearchStringFromSelection == "boolean" ? e.seedSearchStringFromSelection ? "always" : "never" : vt(i.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
      autoFindInSelection: typeof e.autoFindInSelection == "boolean" ? e.autoFindInSelection ? "always" : "never" : vt(i.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: se(i.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: se(i.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: se(i.loop, this.defaultValue.loop),
      history: vt(i.history, this.defaultValue.history, ["never", "workspace"]),
      replaceHistory: vt(i.replaceHistory, this.defaultValue.replaceHistory, ["never", "workspace"])
    };
  }
}
const ms = class ms extends mt {
  constructor() {
    super(R.fontLigatures, "fontLigatures", ms.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: h(
            292,
            "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property."
          )
        },
        {
          type: "string",
          description: h(
            293,
            "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures."
          )
        }
      ],
      description: h(
        294,
        "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."
      ),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" || e.length === 0 ? ms.OFF : e === "true" ? ms.ON : e : e ? ms.ON : ms.OFF;
  }
};
ms.OFF = '"liga" off, "calt" off', ms.ON = '"liga" on, "calt" on';
let zv = ms;
const _s = class _s extends mt {
  constructor() {
    super(R.fontVariations, "fontVariations", _s.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: h(
            295,
            "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property."
          )
        },
        {
          type: "string",
          description: h(
            296,
            "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings."
          )
        }
      ],
      description: h(
        297,
        "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."
      ),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" ? _s.OFF : e === "true" ? _s.TRANSLATE : e : e ? _s.TRANSLATE : _s.OFF;
  }
  compute(e, i, n) {
    return e.fontInfo.fontVariationSettings;
  }
};
_s.OFF = "normal", _s.TRANSLATE = "translate";
let qv = _s;
class n7 extends No {
  constructor() {
    super(R.fontInfo);
  }
  compute(e, i, n) {
    return e.fontInfo;
  }
}
class r7 extends No {
  constructor() {
    super(R.effectiveCursorStyle);
  }
  compute(e, i, n) {
    return e.inputMode === "overtype" ? i.get(R.overtypeCursorStyle) : i.get(R.cursorStyle);
  }
}
class s7 extends No {
  constructor() {
    super(R.effectiveEditContext);
  }
  compute(e, i) {
    return e.editContextSupported && i.get(R.editContext);
  }
}
class o7 extends No {
  constructor() {
    super(R.effectiveAllowVariableFonts);
  }
  compute(e, i) {
    return e.accessibilitySupport === ur.Enabled ? i.get(R.allowVariableFontsInAccessibilityMode) : i.get(R.allowVariableFonts);
  }
}
class a7 extends yu {
  constructor() {
    super(R.fontSize, "fontSize", Ls.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: Ls.fontSize,
      description: h(298, "Controls the font size in pixels.")
    });
  }
  validate(e) {
    const i = Bn.float(e, this.defaultValue);
    return i === 0 ? Ls.fontSize : Bn.clamp(i, 6, 100);
  }
  compute(e, i, n) {
    return e.fontInfo.fontSize;
  }
}
const Cr = class Cr extends mt {
  constructor() {
    super(R.fontWeight, "fontWeight", Ls.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: Cr.MINIMUM_VALUE,
          maximum: Cr.MAXIMUM_VALUE,
          errorMessage: h(
            299,
            'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.'
          )
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: Cr.SUGGESTION_VALUES
        }
      ],
      default: Ls.fontWeight,
      description: h(
        300,
        'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.'
      )
    });
  }
  validate(e) {
    return e === "normal" || e === "bold" ? e : String(Ke.clampedInt(e, Ls.fontWeight, Cr.MINIMUM_VALUE, Cr.MAXIMUM_VALUE));
  }
};
Cr.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"], Cr.MINIMUM_VALUE = 1, Cr.MAXIMUM_VALUE = 1e3;
let jv = Cr;
class l7 extends mt {
  constructor() {
    const e = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      multipleTests: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: "",
      alternativeTestsCommand: ""
    }, i = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: e.multiple,
      enumDescriptions: [
        h(301, "Show Peek view of the results (default)"),
        h(302, "Go to the primary result and show a Peek view"),
        h(303, "Go to the primary result and enable Peek-less navigation to others")
      ]
    }, n = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
    super(R.gotoLocation, "gotoLocation", e, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: h(
          304,
          "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead."
        )
      },
      "editor.gotoLocation.multipleDefinitions": {
        description: h(
          305,
          "Controls the behavior the 'Go to Definition'-command when multiple target locations exist."
        ),
        ...i
      },
      "editor.gotoLocation.multipleTypeDefinitions": {
        description: h(
          306,
          "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist."
        ),
        ...i
      },
      "editor.gotoLocation.multipleDeclarations": {
        description: h(
          307,
          "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist."
        ),
        ...i
      },
      "editor.gotoLocation.multipleImplementations": {
        description: h(
          308,
          "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist."
        ),
        ...i
      },
      "editor.gotoLocation.multipleReferences": {
        description: h(
          309,
          "Controls the behavior the 'Go to References'-command when multiple target locations exist."
        ),
        ...i
      },
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: e.alternativeDefinitionCommand,
        enum: n,
        description: h(
          310,
          "Alternative command id that is being executed when the result of 'Go to Definition' is the current location."
        )
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: e.alternativeTypeDefinitionCommand,
        enum: n,
        description: h(
          311,
          "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location."
        )
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: e.alternativeDeclarationCommand,
        enum: n,
        description: h(
          312,
          "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location."
        )
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: e.alternativeImplementationCommand,
        enum: n,
        description: h(
          313,
          "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location."
        )
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: e.alternativeReferenceCommand,
        enum: n,
        description: h(
          314,
          "Alternative command id that is being executed when the result of 'Go to Reference' is the current location."
        )
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      multiple: vt(i.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: i.multipleDefinitions ?? vt(i.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: i.multipleTypeDefinitions ?? vt(i.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: i.multipleDeclarations ?? vt(i.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: i.multipleImplementations ?? vt(i.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: i.multipleReferences ?? vt(i.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTests: i.multipleTests ?? vt(i.multipleTests, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: Ti.string(i.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: Ti.string(i.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: Ti.string(i.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: Ti.string(i.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: Ti.string(i.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),
      alternativeTestsCommand: Ti.string(i.alternativeTestsCommand, this.defaultValue.alternativeTestsCommand)
    };
  }
}
class c7 extends mt {
  constructor() {
    const e = {
      enabled: !0,
      delay: 300,
      hidingDelay: 300,
      sticky: !0,
      above: !0
    };
    super(R.hover, "hover", e, {
      "editor.hover.enabled": {
        type: "boolean",
        default: e.enabled,
        description: h(315, "Controls whether the hover is shown.")
      },
      "editor.hover.delay": {
        type: "number",
        default: e.delay,
        minimum: 0,
        maximum: 1e4,
        description: h(316, "Controls the delay in milliseconds after which the hover is shown.")
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: e.sticky,
        description: h(
          317,
          "Controls whether the hover should remain visible when mouse is moved over it."
        )
      },
      "editor.hover.hidingDelay": {
        type: "integer",
        minimum: 0,
        default: e.hidingDelay,
        description: h(
          318,
          "Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled."
        )
      },
      "editor.hover.above": {
        type: "boolean",
        default: e.above,
        description: h(319, "Prefer showing hovers above the line, if there's space.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      enabled: se(i.enabled, this.defaultValue.enabled),
      delay: Ke.clampedInt(i.delay, this.defaultValue.delay, 0, 1e4),
      sticky: se(i.sticky, this.defaultValue.sticky),
      hidingDelay: Ke.clampedInt(i.hidingDelay, this.defaultValue.hidingDelay, 0, 6e5),
      above: se(i.above, this.defaultValue.above)
    };
  }
}
var Hl;
(function(t) {
  t[t.None = 0] = "None", t[t.Text = 1] = "Text", t[t.Blocks = 2] = "Blocks";
})(Hl || (Hl = {}));
class cd extends No {
  constructor() {
    super(R.layoutInfo);
  }
  compute(e, i, n) {
    return cd.computeLayout(i, {
      memory: e.memory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight,
      isDominatedByLongLines: e.isDominatedByLongLines,
      lineHeight: e.fontInfo.lineHeight,
      viewLineCount: e.viewLineCount,
      lineNumbersDigitCount: e.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: e.fontInfo.maxDigitWidth,
      pixelRatio: e.pixelRatio,
      glyphMarginDecorationLaneCount: e.glyphMarginDecorationLaneCount
    });
  }
  static computeContainedMinimapLineCount(e) {
    const i = e.height / e.lineHeight, n = Math.floor(e.paddingTop / e.lineHeight);
    let r = Math.floor(e.paddingBottom / e.lineHeight);
    e.scrollBeyondLastLine && (r = Math.max(r, i - 1));
    const s = (n + e.viewLineCount + r) / (e.pixelRatio * e.height), o = Math.floor(e.viewLineCount / s);
    return { typicalViewportLineCount: i, extraLinesBeforeFirstLine: n, extraLinesBeyondLastLine: r, desiredRatio: s, minimapLineCount: o };
  }
  static _computeMinimapLayout(e, i) {
    const n = e.outerWidth, r = e.outerHeight, s = e.pixelRatio;
    if (!e.minimap.enabled)
      return {
        renderMinimap: Hl.None,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: !1,
        minimapIsSampling: !1,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(s * r),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: r
      };
    const o = i.stableMinimapLayoutInput, a = o && e.outerHeight === o.outerHeight && e.lineHeight === o.lineHeight && e.typicalHalfwidthCharacterWidth === o.typicalHalfwidthCharacterWidth && e.pixelRatio === o.pixelRatio && e.scrollBeyondLastLine === o.scrollBeyondLastLine && e.paddingTop === o.paddingTop && e.paddingBottom === o.paddingBottom && e.minimap.enabled === o.minimap.enabled && e.minimap.side === o.minimap.side && e.minimap.size === o.minimap.size && e.minimap.showSlider === o.minimap.showSlider && e.minimap.renderCharacters === o.minimap.renderCharacters && e.minimap.maxColumn === o.minimap.maxColumn && e.minimap.scale === o.minimap.scale && e.verticalScrollbarWidth === o.verticalScrollbarWidth && e.isViewportWrapping === o.isViewportWrapping, l = e.lineHeight, c = e.typicalHalfwidthCharacterWidth, u = e.scrollBeyondLastLine, d = e.minimap.renderCharacters;
    let f = s >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale;
    const g = e.minimap.maxColumn, _ = e.minimap.size, w = e.minimap.side, v = e.verticalScrollbarWidth, S = e.viewLineCount, E = e.remainingWidth, A = e.isViewportWrapping, j = d ? 2 : 3;
    let V = Math.floor(s * r);
    const le = V / s;
    let Q = !1, re = !1, K = j * f, ye = f / s, Fe = 1;
    if (_ === "fill" || _ === "fit") {
      const { typicalViewportLineCount: Le, extraLinesBeforeFirstLine: Be, extraLinesBeyondLastLine: qe, desiredRatio: St, minimapLineCount: Jt } = cd.computeContainedMinimapLineCount({
        viewLineCount: S,
        scrollBeyondLastLine: u,
        paddingTop: e.paddingTop,
        paddingBottom: e.paddingBottom,
        height: r,
        lineHeight: l,
        pixelRatio: s
      });
      if (S / Jt > 1)
        Q = !0, re = !0, f = 1, K = 1, ye = f / s;
      else {
        let $t = !1, ln = f + 1;
        if (_ === "fit") {
          const gi = Math.ceil((Be + S + qe) * K);
          A && a && E <= i.stableFitRemainingWidth ? ($t = !0, ln = i.stableFitMaxMinimapScale) : $t = gi > V;
        }
        if (_ === "fill" || $t) {
          Q = !0;
          const gi = f;
          K = Math.min(l * s, Math.max(1, Math.floor(1 / St))), A && a && E <= i.stableFitRemainingWidth && (ln = i.stableFitMaxMinimapScale), f = Math.min(ln, Math.max(1, Math.floor(K / j))), f > gi && (Fe = Math.min(2, f / gi)), ye = f / s / Fe, V = Math.ceil(Math.max(Le, Be + S + qe) * K), A ? (i.stableMinimapLayoutInput = e, i.stableFitRemainingWidth = E, i.stableFitMaxMinimapScale = f) : (i.stableMinimapLayoutInput = null, i.stableFitRemainingWidth = 0);
        }
      }
    }
    const Te = Math.floor(g * ye), X = Math.min(Te, Math.max(0, Math.floor((E - v - 2) * ye / (c + ye))) + GL);
    let Y = Math.floor(s * X);
    const Z = Y / s;
    Y = Math.floor(Y * Fe);
    const ie = d ? Hl.Text : Hl.Blocks, ce = w === "left" ? 0 : n - X - v;
    return {
      renderMinimap: ie,
      minimapLeft: ce,
      minimapWidth: X,
      minimapHeightIsEditorHeight: Q,
      minimapIsSampling: re,
      minimapScale: f,
      minimapLineHeight: K,
      minimapCanvasInnerWidth: Y,
      minimapCanvasInnerHeight: V,
      minimapCanvasOuterWidth: Z,
      minimapCanvasOuterHeight: le
    };
  }
  static computeLayout(e, i) {
    const n = i.outerWidth | 0, r = i.outerHeight | 0, s = i.lineHeight | 0, o = i.lineNumbersDigitCount | 0, a = i.typicalHalfwidthCharacterWidth, l = i.maxDigitWidth, c = i.pixelRatio, u = i.viewLineCount, d = e.get(R.wordWrapOverride2), f = d === "inherit" ? e.get(R.wordWrapOverride1) : d, g = f === "inherit" ? e.get(R.wordWrap) : f, _ = e.get(R.wordWrapColumn), w = i.isDominatedByLongLines, v = e.get(R.glyphMargin), S = e.get(R.lineNumbers).renderType !== Mi.Off, E = e.get(R.lineNumbersMinChars), A = e.get(R.scrollBeyondLastLine), j = e.get(R.padding), V = e.get(R.minimap), le = e.get(R.scrollbar), Q = le.verticalScrollbarSize, re = le.verticalHasArrows, K = le.arrowSize, ye = le.horizontalScrollbarSize, Fe = e.get(R.folding), Te = e.get(R.showFoldingControls) !== "never";
    let X = e.get(R.lineDecorationsWidth);
    Fe && Te && (X += 16);
    let Y = 0;
    if (S) {
      const Gn = Math.max(o, E);
      Y = Math.round(Gn * l);
    }
    let Z = 0;
    v && (Z = s * i.glyphMarginDecorationLaneCount);
    let ie = 0, ce = ie + Z, Le = ce + Y, Be = Le + X;
    const qe = n - Z - Y - X;
    let St = !1, Jt = !1, ct = -1;
    e.get(R.accessibilitySupport) === ur.Enabled && f === "inherit" && w ? (St = !0, Jt = !0) : g === "on" || g === "bounded" ? Jt = !0 : g === "wordWrapColumn" && (ct = _);
    const $t = cd._computeMinimapLayout({
      outerWidth: n,
      outerHeight: r,
      lineHeight: s,
      typicalHalfwidthCharacterWidth: a,
      pixelRatio: c,
      scrollBeyondLastLine: A,
      paddingTop: j.top,
      paddingBottom: j.bottom,
      minimap: V,
      verticalScrollbarWidth: Q,
      viewLineCount: u,
      remainingWidth: qe,
      isViewportWrapping: Jt
    }, i.memory || new QL());
    $t.renderMinimap !== Hl.None && $t.minimapLeft === 0 && (ie += $t.minimapWidth, ce += $t.minimapWidth, Le += $t.minimapWidth, Be += $t.minimapWidth);
    const ln = qe - $t.minimapWidth, gi = Math.max(1, Math.floor((ln - Q - 2) / a)), yr = re ? K : 0;
    return Jt && (ct = Math.max(1, gi), g === "bounded" && (ct = Math.min(ct, _))), {
      width: n,
      height: r,
      glyphMarginLeft: ie,
      glyphMarginWidth: Z,
      glyphMarginDecorationLaneCount: i.glyphMarginDecorationLaneCount,
      lineNumbersLeft: ce,
      lineNumbersWidth: Y,
      decorationsLeft: Le,
      decorationsWidth: X,
      contentLeft: Be,
      contentWidth: ln,
      minimap: $t,
      viewportColumn: gi,
      isWordWrapMinified: St,
      isViewportWrapping: Jt,
      wrappingColumn: ct,
      verticalScrollbarWidth: Q,
      horizontalScrollbarHeight: ye,
      overviewRuler: {
        top: yr,
        width: Q,
        height: r - 2 * yr,
        right: 0
      }
    };
  }
}
class u7 extends mt {
  constructor() {
    super(R.wrappingStrategy, "wrappingStrategy", "simple", {
      "editor.wrappingStrategy": {
        enumDescriptions: [
          h(
            320,
            "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."
          ),
          h(
            321,
            "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases."
          )
        ],
        type: "string",
        enum: ["simple", "advanced"],
        default: "simple",
        description: h(
          322,
          "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience."
        )
      }
    });
  }
  validate(e) {
    return vt(e, "simple", ["simple", "advanced"]);
  }
  compute(e, i, n) {
    return i.get(R.accessibilitySupport) === ur.Enabled ? "advanced" : n;
  }
}
var ds;
(function(t) {
  t.Off = "off", t.OnCode = "onCode", t.On = "on";
})(ds || (ds = {}));
class d7 extends mt {
  constructor() {
    const e = { enabled: ds.OnCode };
    super(R.lightbulb, "lightbulb", e, {
      "editor.lightbulb.enabled": {
        type: "string",
        enum: [ds.Off, ds.OnCode, ds.On],
        default: e.enabled,
        enumDescriptions: [
          h(323, "Disable the code action menu."),
          h(324, "Show the code action menu when the cursor is on lines with code."),
          h(
            325,
            "Show the code action menu when the cursor is on lines with code or on empty lines."
          )
        ],
        description: h(326, "Enables the Code Action lightbulb in the editor.")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: vt(e.enabled, this.defaultValue.enabled, [ds.Off, ds.OnCode, ds.On])
    };
  }
}
class h7 extends mt {
  constructor() {
    const e = { enabled: !0, maxLineCount: 5, defaultModel: "outlineModel", scrollWithEditor: !0 };
    super(R.stickyScroll, "stickyScroll", e, {
      "editor.stickyScroll.enabled": {
        type: "boolean",
        default: e.enabled,
        description: h(
          327,
          "Shows the nested current scopes during the scroll at the top of the editor."
        )
      },
      "editor.stickyScroll.maxLineCount": {
        type: "number",
        default: e.maxLineCount,
        minimum: 1,
        maximum: 20,
        description: h(328, "Defines the maximum number of sticky lines to show.")
      },
      "editor.stickyScroll.defaultModel": {
        type: "string",
        enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
        default: e.defaultModel,
        description: h(
          329,
          "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases."
        )
      },
      "editor.stickyScroll.scrollWithEditor": {
        type: "boolean",
        default: e.scrollWithEditor,
        description: h(
          330,
          "Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar."
        )
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      enabled: se(i.enabled, this.defaultValue.enabled),
      maxLineCount: Ke.clampedInt(i.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
      defaultModel: vt(i.defaultModel, this.defaultValue.defaultModel, ["outlineModel", "foldingProviderModel", "indentationModel"]),
      scrollWithEditor: se(i.scrollWithEditor, this.defaultValue.scrollWithEditor)
    };
  }
}
class f7 extends mt {
  constructor() {
    const e = { enabled: "on", fontSize: 0, fontFamily: "", padding: !1, maximumLength: 43 };
    super(R.inlayHints, "inlayHints", e, {
      "editor.inlayHints.enabled": {
        type: "string",
        default: e.enabled,
        description: h(331, "Enables the inlay hints in the editor."),
        enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
        markdownEnumDescriptions: [
          h(332, "Inlay hints are enabled"),
          h(
            333,
            "Inlay hints are showing by default and hide when holding {0}",
            Rn ? "Ctrl+Option" : "Ctrl+Alt"
          ),
          h(
            334,
            "Inlay hints are hidden by default and show when holding {0}",
            Rn ? "Ctrl+Option" : "Ctrl+Alt"
          ),
          h(335, "Inlay hints are disabled")
        ]
      },
      "editor.inlayHints.fontSize": {
        type: "number",
        default: e.fontSize,
        markdownDescription: h(
          336,
          "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.",
          "`#editor.fontSize#`",
          "`5`"
        )
      },
      "editor.inlayHints.fontFamily": {
        type: "string",
        default: e.fontFamily,
        markdownDescription: h(
          337,
          "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.",
          "`#editor.fontFamily#`"
        )
      },
      "editor.inlayHints.padding": {
        type: "boolean",
        default: e.padding,
        description: h(338, "Enables the padding around the inlay hints in the editor.")
      },
      "editor.inlayHints.maximumLength": {
        type: "number",
        default: e.maximumLength,
        markdownDescription: h(
          339,
          "Maximum overall length of inlay hints, for a single line, before they get truncated by the editor. Set to `0` to never truncate"
        )
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return typeof i.enabled == "boolean" && (i.enabled = i.enabled ? "on" : "off"), {
      enabled: vt(i.enabled, this.defaultValue.enabled, ["on", "off", "offUnlessPressed", "onUnlessPressed"]),
      fontSize: Ke.clampedInt(i.fontSize, this.defaultValue.fontSize, 0, 100),
      fontFamily: Ti.string(i.fontFamily, this.defaultValue.fontFamily),
      padding: se(i.padding, this.defaultValue.padding),
      maximumLength: Ke.clampedInt(i.maximumLength, this.defaultValue.maximumLength, 0, Number.MAX_SAFE_INTEGER)
    };
  }
}
class p7 extends mt {
  constructor() {
    super(R.lineDecorationsWidth, "lineDecorationsWidth", 10);
  }
  validate(e) {
    return typeof e == "string" && /^\d+(\.\d+)?ch$/.test(e) ? -parseFloat(e.substring(0, e.length - 2)) : Ke.clampedInt(e, this.defaultValue, 0, 1e3);
  }
  compute(e, i, n) {
    return n < 0 ? Ke.clampedInt(-n * e.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3) : n;
  }
}
class g7 extends Bn {
  constructor() {
    super(R.lineHeight, "lineHeight", Ls.lineHeight, (e) => Bn.clamp(e, 0, 150), { markdownDescription: h(
      340,
      `Controls the line height. 
 - Use 0 to automatically compute the line height from the font size.
 - Values between 0 and 8 will be used as a multiplier with the font size.
 - Values greater than or equal to 8 will be used as effective values.`
    ) }, 0, 150);
  }
  compute(e, i, n) {
    return e.fontInfo.lineHeight;
  }
}
class m7 extends mt {
  constructor() {
    const e = {
      enabled: !0,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      autohide: "none",
      renderCharacters: !0,
      maxColumn: 120,
      scale: 1,
      showRegionSectionHeaders: !0,
      showMarkSectionHeaders: !0,
      markSectionHeaderRegex: "\\bMARK:\\s*(?<separator>-?)\\s*(?<label>.*)$",
      sectionHeaderFontSize: 9,
      sectionHeaderLetterSpacing: 1
    };
    super(R.minimap, "minimap", e, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: e.enabled,
        description: h(341, "Controls whether the minimap is shown.")
      },
      "editor.minimap.autohide": {
        type: "string",
        enum: ["none", "mouseover", "scroll"],
        enumDescriptions: [
          h(342, "The minimap is always shown."),
          h(
            343,
            "The minimap is hidden when mouse is not over the minimap and shown when mouse is over the minimap."
          ),
          h(344, "The minimap is only shown when the editor is scrolled")
        ],
        default: e.autohide,
        description: h(345, "Controls whether the minimap is hidden automatically.")
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          h(
            346,
            "The minimap has the same size as the editor contents (and might scroll)."
          ),
          h(
            347,
            "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."
          ),
          h(
            348,
            "The minimap will shrink as necessary to never be larger than the editor (no scrolling)."
          )
        ],
        default: e.size,
        description: h(349, "Controls the size of the minimap.")
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: e.side,
        description: h(350, "Controls the side where to render the minimap.")
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: e.showSlider,
        description: h(351, "Controls when the minimap slider is shown.")
      },
      "editor.minimap.scale": {
        type: "number",
        default: e.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: h(352, "Scale of content drawn in the minimap: 1, 2 or 3.")
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: e.renderCharacters,
        description: h(353, "Render the actual characters on a line as opposed to color blocks.")
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: e.maxColumn,
        description: h(
          354,
          "Limit the width of the minimap to render at most a certain number of columns."
        )
      },
      "editor.minimap.showRegionSectionHeaders": {
        type: "boolean",
        default: e.showRegionSectionHeaders,
        description: h(
          355,
          "Controls whether named regions are shown as section headers in the minimap."
        )
      },
      "editor.minimap.showMarkSectionHeaders": {
        type: "boolean",
        default: e.showMarkSectionHeaders,
        description: h(
          356,
          "Controls whether MARK: comments are shown as section headers in the minimap."
        )
      },
      "editor.minimap.markSectionHeaderRegex": {
        type: "string",
        default: e.markSectionHeaderRegex,
        description: h(
          357,
          "Defines the regular expression used to find section headers in comments. The regex must contain a named match group `label` (written as `(?<label>.+)`) that encapsulates the section header, otherwise it will not work. Optionally you can include another match group named `separator`. Use \\n in the pattern to match multi-line headers."
        )
      },
      "editor.minimap.sectionHeaderFontSize": {
        type: "number",
        default: e.sectionHeaderFontSize,
        description: h(358, "Controls the font size of section headers in the minimap.")
      },
      "editor.minimap.sectionHeaderLetterSpacing": {
        type: "number",
        default: e.sectionHeaderLetterSpacing,
        description: h(
          359,
          "Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes."
        )
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    let n = this.defaultValue.markSectionHeaderRegex;
    const r = e.markSectionHeaderRegex;
    if (typeof r == "string")
      try {
        new RegExp(r, "d"), n = r;
      } catch {
      }
    return {
      enabled: se(i.enabled, this.defaultValue.enabled),
      autohide: vt(i.autohide, this.defaultValue.autohide, ["none", "mouseover", "scroll"]),
      size: vt(i.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: vt(i.side, this.defaultValue.side, ["right", "left"]),
      showSlider: vt(i.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: se(i.renderCharacters, this.defaultValue.renderCharacters),
      scale: Ke.clampedInt(i.scale, 1, 1, 3),
      maxColumn: Ke.clampedInt(i.maxColumn, this.defaultValue.maxColumn, 1, 1e4),
      showRegionSectionHeaders: se(i.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),
      showMarkSectionHeaders: se(i.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),
      markSectionHeaderRegex: n,
      sectionHeaderFontSize: Bn.clamp(i.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize, 4, 32),
      sectionHeaderLetterSpacing: Bn.clamp(i.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing, 0, 5)
    };
  }
}
function _7(t) {
  return t === "ctrlCmd" ? Rn ? "metaKey" : "ctrlKey" : "altKey";
}
class v7 extends mt {
  constructor() {
    super(R.padding, "padding", { top: 0, bottom: 0 }, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: h(
          360,
          "Controls the amount of space between the top edge of the editor and the first line."
        )
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: h(
          361,
          "Controls the amount of space between the bottom edge of the editor and the last line."
        )
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      top: Ke.clampedInt(i.top, 0, 0, 1e3),
      bottom: Ke.clampedInt(i.bottom, 0, 0, 1e3)
    };
  }
}
class w7 extends mt {
  constructor() {
    const e = {
      enabled: !0,
      cycle: !0
    };
    super(R.parameterHints, "parameterHints", e, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: e.enabled,
        description: h(
          362,
          "Enables a pop-up that shows parameter documentation and type information as you type."
        )
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: e.cycle,
        description: h(
          363,
          "Controls whether the parameter hints menu cycles or closes when reaching the end of the list."
        )
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      enabled: se(i.enabled, this.defaultValue.enabled),
      cycle: se(i.cycle, this.defaultValue.cycle)
    };
  }
}
class b7 extends No {
  constructor() {
    super(R.pixelRatio);
  }
  compute(e, i, n) {
    return e.pixelRatio;
  }
}
class y7 extends mt {
  constructor() {
    super(R.placeholder, "placeholder", void 0);
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e : this.defaultValue;
  }
}
class x7 extends mt {
  constructor() {
    const e = {
      other: "on",
      comments: "off",
      strings: "off"
    }, i = [
      { type: "boolean" },
      {
        type: "string",
        enum: ["on", "inline", "off"],
        enumDescriptions: [h(364, "Quick suggestions show inside the suggest widget"), h(365, "Quick suggestions show as ghost text"), h(366, "Quick suggestions are disabled")]
      }
    ];
    super(R.quickSuggestions, "quickSuggestions", e, {
      type: "object",
      additionalProperties: !1,
      properties: {
        strings: {
          anyOf: i,
          default: e.strings,
          description: h(367, "Enable quick suggestions inside strings.")
        },
        comments: {
          anyOf: i,
          default: e.comments,
          description: h(368, "Enable quick suggestions inside comments.")
        },
        other: {
          anyOf: i,
          default: e.other,
          description: h(369, "Enable quick suggestions outside of strings and comments.")
        }
      },
      default: e,
      markdownDescription: h(
        370,
        "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the {0}-setting which controls if suggestions are triggered by special characters.",
        "`#editor.suggestOnTriggerCharacters#`"
      )
    }), this.defaultValue = e;
  }
  validate(e) {
    if (typeof e == "boolean") {
      const c = e ? "on" : "off";
      return { comments: c, strings: c, other: c };
    }
    if (!e || typeof e != "object")
      return this.defaultValue;
    const { other: i, comments: n, strings: r } = e, s = ["on", "inline", "off"];
    let o, a, l;
    return typeof i == "boolean" ? o = i ? "on" : "off" : o = vt(i, this.defaultValue.other, s), typeof n == "boolean" ? a = n ? "on" : "off" : a = vt(n, this.defaultValue.comments, s), typeof r == "boolean" ? l = r ? "on" : "off" : l = vt(r, this.defaultValue.strings, s), {
      other: o,
      comments: a,
      strings: l
    };
  }
}
var Mi;
(function(t) {
  t[t.Off = 0] = "Off", t[t.On = 1] = "On", t[t.Relative = 2] = "Relative", t[t.Interval = 3] = "Interval", t[t.Custom = 4] = "Custom";
})(Mi || (Mi = {}));
class E7 extends mt {
  constructor() {
    super(R.lineNumbers, "lineNumbers", { renderType: Mi.On, renderFn: null }, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        h(371, "Line numbers are not rendered."),
        h(372, "Line numbers are rendered as absolute number."),
        h(373, "Line numbers are rendered as distance in lines to cursor position."),
        h(374, "Line numbers are rendered every 10 lines.")
      ],
      default: "on",
      description: h(375, "Controls the display of line numbers.")
    });
  }
  validate(e) {
    let i = this.defaultValue.renderType, n = this.defaultValue.renderFn;
    return typeof e < "u" && (typeof e == "function" ? (i = Mi.Custom, n = e) : e === "interval" ? i = Mi.Interval : e === "relative" ? i = Mi.Relative : e === "on" ? i = Mi.On : i = Mi.Off), {
      renderType: i,
      renderFn: n
    };
  }
}
class S7 extends mt {
  constructor() {
    const e = [], i = { type: "number", description: h(
      376,
      "Number of monospace characters at which this editor ruler will render."
    ) };
    super(R.rulers, "rulers", e, {
      type: "array",
      items: {
        anyOf: [
          i,
          {
            type: [
              "object"
            ],
            properties: {
              column: i,
              color: {
                type: "string",
                description: h(377, "Color of this editor ruler."),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: e,
      description: h(
        378,
        "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty."
      )
    });
  }
  validate(e) {
    if (Array.isArray(e)) {
      const i = [];
      for (const n of e)
        if (typeof n == "number")
          i.push({
            column: Ke.clampedInt(n, 0, 0, 1e4),
            color: null
          });
        else if (n && typeof n == "object") {
          const r = n;
          i.push({
            column: Ke.clampedInt(r.column, 0, 0, 1e4),
            color: r.color
          });
        }
      return i.sort((n, r) => n.column - r.column), i;
    }
    return this.defaultValue;
  }
}
class D7 extends mt {
  constructor() {
    super(R.readOnlyMessage, "readOnlyMessage", void 0);
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : e;
  }
}
function QS(t, e) {
  if (typeof t != "string")
    return e;
  switch (t) {
    case "hidden":
      return ka.Hidden;
    case "visible":
      return ka.Visible;
    default:
      return ka.Auto;
  }
}
class k7 extends mt {
  constructor() {
    const e = {
      vertical: ka.Auto,
      horizontal: ka.Auto,
      arrowSize: 11,
      useShadows: !0,
      verticalHasArrows: !1,
      horizontalHasArrows: !1,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: !0,
      alwaysConsumeMouseWheel: !0,
      scrollByPage: !1,
      ignoreHorizontalScrollbarInContentHeight: !1
    };
    super(R.scrollbar, "scrollbar", e, {
      "editor.scrollbar.vertical": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          h(379, "The vertical scrollbar will be visible only when necessary."),
          h(380, "The vertical scrollbar will always be visible."),
          h(381, "The vertical scrollbar will always be hidden.")
        ],
        default: "auto",
        description: h(382, "Controls the visibility of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontal": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          h(383, "The horizontal scrollbar will be visible only when necessary."),
          h(384, "The horizontal scrollbar will always be visible."),
          h(385, "The horizontal scrollbar will always be hidden.")
        ],
        default: "auto",
        description: h(386, "Controls the visibility of the horizontal scrollbar.")
      },
      "editor.scrollbar.verticalScrollbarSize": {
        type: "number",
        default: e.verticalScrollbarSize,
        description: h(387, "The width of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontalScrollbarSize": {
        type: "number",
        default: e.horizontalScrollbarSize,
        description: h(388, "The height of the horizontal scrollbar.")
      },
      "editor.scrollbar.scrollByPage": {
        type: "boolean",
        default: e.scrollByPage,
        description: h(389, "Controls whether clicks scroll by page or jump to click position.")
      },
      "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
        type: "boolean",
        default: e.ignoreHorizontalScrollbarInContentHeight,
        description: h(
          390,
          "When set, the horizontal scrollbar will not increase the size of the editor's content."
        )
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e, n = Ke.clampedInt(i.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3), r = Ke.clampedInt(i.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: Ke.clampedInt(i.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: QS(i.vertical, this.defaultValue.vertical),
      horizontal: QS(i.horizontal, this.defaultValue.horizontal),
      useShadows: se(i.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: se(i.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: se(i.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: se(i.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: se(i.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize: n,
      horizontalSliderSize: Ke.clampedInt(i.horizontalSliderSize, n, 0, 1e3),
      verticalScrollbarSize: r,
      verticalSliderSize: Ke.clampedInt(i.verticalSliderSize, r, 0, 1e3),
      scrollByPage: se(i.scrollByPage, this.defaultValue.scrollByPage),
      ignoreHorizontalScrollbarInContentHeight: se(i.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight)
    };
  }
}
const Kn = "inUntrustedWorkspace", Ho = {
  allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
  invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
  nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
  ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
  includeComments: "editor.unicodeHighlight.includeComments",
  includeStrings: "editor.unicodeHighlight.includeStrings",
  allowedLocales: "editor.unicodeHighlight.allowedLocales"
};
class I7 extends mt {
  constructor() {
    const e = {
      nonBasicASCII: Kn,
      invisibleCharacters: !0,
      ambiguousCharacters: !0,
      includeComments: Kn,
      includeStrings: !0,
      allowedCharacters: {},
      allowedLocales: { _os: !0, _vscode: !0 }
    };
    super(R.unicodeHighlighting, "unicodeHighlight", e, {
      [Ho.nonBasicASCII]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, Kn],
        default: e.nonBasicASCII,
        description: h(
          391,
          "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII."
        )
      },
      [Ho.invisibleCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.invisibleCharacters,
        description: h(
          392,
          "Controls whether characters that just reserve space or have no width at all are highlighted."
        )
      },
      [Ho.ambiguousCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.ambiguousCharacters,
        description: h(
          393,
          "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale."
        )
      },
      [Ho.includeComments]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, Kn],
        default: e.includeComments,
        description: h(
          394,
          "Controls whether characters in comments should also be subject to Unicode highlighting."
        )
      },
      [Ho.includeStrings]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, Kn],
        default: e.includeStrings,
        description: h(
          395,
          "Controls whether characters in strings should also be subject to Unicode highlighting."
        )
      },
      [Ho.allowedCharacters]: {
        restricted: !0,
        type: "object",
        default: e.allowedCharacters,
        description: h(396, "Defines allowed characters that are not being highlighted."),
        additionalProperties: {
          type: "boolean"
        }
      },
      [Ho.allowedLocales]: {
        restricted: !0,
        type: "object",
        additionalProperties: {
          type: "boolean"
        },
        default: e.allowedLocales,
        description: h(
          397,
          "Unicode characters that are common in allowed locales are not being highlighted."
        )
      }
    });
  }
  applyUpdate(e, i) {
    let n = !1;
    i.allowedCharacters && e && (sn(e.allowedCharacters, i.allowedCharacters) || (e = { ...e, allowedCharacters: i.allowedCharacters }, n = !0)), i.allowedLocales && e && (sn(e.allowedLocales, i.allowedLocales) || (e = { ...e, allowedLocales: i.allowedLocales }, n = !0));
    const r = super.applyUpdate(e, i);
    return n ? new np(r.newValue, !0) : r;
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      nonBasicASCII: dc(i.nonBasicASCII, Kn, [!0, !1, Kn]),
      invisibleCharacters: se(i.invisibleCharacters, this.defaultValue.invisibleCharacters),
      ambiguousCharacters: se(i.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
      includeComments: dc(i.includeComments, Kn, [!0, !1, Kn]),
      includeStrings: dc(i.includeStrings, Kn, [!0, !1, Kn]),
      allowedCharacters: this.validateBooleanMap(e.allowedCharacters, this.defaultValue.allowedCharacters),
      allowedLocales: this.validateBooleanMap(e.allowedLocales, this.defaultValue.allowedLocales)
    };
  }
  validateBooleanMap(e, i) {
    if (typeof e != "object" || !e)
      return i;
    const n = {};
    for (const [r, s] of Object.entries(e))
      s === !0 && (n[r] = !0);
    return n;
  }
}
class C7 extends mt {
  constructor() {
    const e = {
      enabled: !0,
      mode: "subwordSmart",
      showToolbar: "onHover",
      suppressSuggestions: !1,
      keepOnBlur: !1,
      fontFamily: "default",
      syntaxHighlightingEnabled: !0,
      edits: {
        enabled: !0,
        showCollapsed: !1,
        renderSideBySide: "auto",
        allowCodeShifting: "always"
      },
      experimental: {
        suppressInlineSuggestions: "",
        triggerCommandOnProviderChange: !1
      }
    };
    super(R.inlineSuggest, "inlineSuggest", e, {
      "editor.inlineSuggest.enabled": {
        type: "boolean",
        default: e.enabled,
        description: h(
          398,
          "Controls whether to automatically show inline suggestions in the editor."
        )
      },
      "editor.inlineSuggest.showToolbar": {
        type: "string",
        default: e.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          h(
            399,
            "Show the inline suggestion toolbar whenever an inline suggestion is shown."
          ),
          h(
            400,
            "Show the inline suggestion toolbar when hovering over an inline suggestion."
          ),
          h(401, "Never show the inline suggestion toolbar.")
        ],
        description: h(402, "Controls when to show the inline suggestion toolbar.")
      },
      "editor.inlineSuggest.syntaxHighlightingEnabled": {
        type: "boolean",
        default: e.syntaxHighlightingEnabled,
        description: h(
          403,
          "Controls whether to show syntax highlighting for inline suggestions in the editor."
        )
      },
      "editor.inlineSuggest.suppressSuggestions": {
        type: "boolean",
        default: e.suppressSuggestions,
        description: h(
          404,
          "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available."
        )
      },
      "editor.inlineSuggest.experimental.suppressInlineSuggestions": {
        type: "string",
        default: e.experimental.suppressInlineSuggestions,
        tags: ["experimental"],
        description: h(
          405,
          "Suppresses inline completions for specified extension IDs -- comma separated."
        ),
        experiment: {
          mode: "startup"
        }
      },
      "editor.inlineSuggest.experimental.triggerCommandOnProviderChange": {
        type: "boolean",
        default: e.experimental.triggerCommandOnProviderChange,
        tags: ["experimental"],
        description: h(
          406,
          "Controls whether to trigger a command when the inline suggestion provider changes."
        ),
        experiment: {
          mode: "startup"
        }
      },
      "editor.inlineSuggest.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: h(407, "Controls the font family of the inline suggestions.")
      },
      "editor.inlineSuggest.edits.allowCodeShifting": {
        type: "string",
        default: e.edits.allowCodeShifting,
        description: h(
          408,
          "Controls whether showing a suggestion will shift the code to make space for the suggestion inline."
        ),
        enum: ["always", "horizontal", "never"],
        tags: ["nextEditSuggestions"]
      },
      "editor.inlineSuggest.edits.renderSideBySide": {
        type: "string",
        default: e.edits.renderSideBySide,
        description: h(409, "Controls whether larger suggestions can be shown side by side."),
        enum: ["auto", "never"],
        enumDescriptions: [
          h(
            410,
            "Larger suggestions will show side by side if there is enough space, otherwise they will be shown below."
          ),
          h(
            411,
            "Larger suggestions are never shown side by side and will always be shown below."
          )
        ],
        tags: ["nextEditSuggestions"]
      },
      "editor.inlineSuggest.edits.showCollapsed": {
        type: "boolean",
        default: e.edits.showCollapsed,
        description: h(
          412,
          "Controls whether the suggestion will show as collapsed until jumping to it."
        ),
        tags: ["nextEditSuggestions"]
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      enabled: se(i.enabled, this.defaultValue.enabled),
      mode: vt(i.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
      showToolbar: vt(i.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      suppressSuggestions: se(i.suppressSuggestions, this.defaultValue.suppressSuggestions),
      keepOnBlur: se(i.keepOnBlur, this.defaultValue.keepOnBlur),
      fontFamily: Ti.string(i.fontFamily, this.defaultValue.fontFamily),
      syntaxHighlightingEnabled: se(i.syntaxHighlightingEnabled, this.defaultValue.syntaxHighlightingEnabled),
      edits: {
        enabled: se(i.edits?.enabled, this.defaultValue.edits.enabled),
        showCollapsed: se(i.edits?.showCollapsed, this.defaultValue.edits.showCollapsed),
        allowCodeShifting: vt(i.edits?.allowCodeShifting, this.defaultValue.edits.allowCodeShifting, ["always", "horizontal", "never"]),
        renderSideBySide: vt(i.edits?.renderSideBySide, this.defaultValue.edits.renderSideBySide, ["never", "auto"])
      },
      experimental: {
        suppressInlineSuggestions: Ti.string(i.experimental?.suppressInlineSuggestions, this.defaultValue.experimental.suppressInlineSuggestions),
        triggerCommandOnProviderChange: se(i.experimental?.triggerCommandOnProviderChange, this.defaultValue.experimental.triggerCommandOnProviderChange)
      }
    };
  }
}
class T7 extends mt {
  constructor() {
    const e = {
      enabled: zS.bracketPairColorizationOptions.enabled,
      independentColorPoolPerBracketType: zS.bracketPairColorizationOptions.independentColorPoolPerBracketType
    };
    super(R.bracketPairColorization, "bracketPairColorization", e, {
      "editor.bracketPairColorization.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: h(
          413,
          "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.",
          "`#workbench.colorCustomizations#`"
        )
      },
      "editor.bracketPairColorization.independentColorPoolPerBracketType": {
        type: "boolean",
        default: e.independentColorPoolPerBracketType,
        description: h(
          414,
          "Controls whether each bracket type has its own independent color pool."
        )
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      enabled: se(i.enabled, this.defaultValue.enabled),
      independentColorPoolPerBracketType: se(i.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
    };
  }
}
class P7 extends mt {
  constructor() {
    const e = {
      bracketPairs: !1,
      bracketPairsHorizontal: "active",
      highlightActiveBracketPair: !0,
      indentation: !0,
      highlightActiveIndentation: !0
    };
    super(R.guides, "guides", e, {
      "editor.guides.bracketPairs": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          h(415, "Enables bracket pair guides."),
          h(416, "Enables bracket pair guides only for the active bracket pair."),
          h(417, "Disables bracket pair guides.")
        ],
        default: e.bracketPairs,
        description: h(418, "Controls whether bracket pair guides are enabled or not.")
      },
      "editor.guides.bracketPairsHorizontal": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          h(
            419,
            "Enables horizontal guides as addition to vertical bracket pair guides."
          ),
          h(420, "Enables horizontal guides only for the active bracket pair."),
          h(421, "Disables horizontal bracket pair guides.")
        ],
        default: e.bracketPairsHorizontal,
        description: h(422, "Controls whether horizontal bracket pair guides are enabled or not.")
      },
      "editor.guides.highlightActiveBracketPair": {
        type: "boolean",
        default: e.highlightActiveBracketPair,
        description: h(
          423,
          "Controls whether the editor should highlight the active bracket pair."
        )
      },
      "editor.guides.indentation": {
        type: "boolean",
        default: e.indentation,
        description: h(424, "Controls whether the editor should render indent guides.")
      },
      "editor.guides.highlightActiveIndentation": {
        type: ["boolean", "string"],
        enum: [!0, "always", !1],
        enumDescriptions: [
          h(425, "Highlights the active indent guide."),
          h(
            426,
            "Highlights the active indent guide even if bracket guides are highlighted."
          ),
          h(427, "Do not highlight the active indent guide.")
        ],
        default: e.highlightActiveIndentation,
        description: h(
          428,
          "Controls whether the editor should highlight the active indent guide."
        )
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      bracketPairs: dc(i.bracketPairs, this.defaultValue.bracketPairs, [!0, !1, "active"]),
      bracketPairsHorizontal: dc(i.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [!0, !1, "active"]),
      highlightActiveBracketPair: se(i.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
      indentation: se(i.indentation, this.defaultValue.indentation),
      highlightActiveIndentation: dc(i.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [!0, !1, "always"])
    };
  }
}
function dc(t, e, i) {
  const n = i.indexOf(t);
  return n === -1 ? e : i[n];
}
class A7 extends mt {
  constructor() {
    const e = {
      insertMode: "insert",
      filterGraceful: !0,
      snippetsPreventQuickSuggestions: !1,
      localityBonus: !1,
      shareSuggestSelections: !1,
      selectionMode: "always",
      showIcons: !0,
      showStatusBar: !1,
      preview: !1,
      previewMode: "subwordSmart",
      showInlineDetails: !0,
      showMethods: !0,
      showFunctions: !0,
      showConstructors: !0,
      showDeprecated: !0,
      matchOnWordStartOnly: !0,
      showFields: !0,
      showVariables: !0,
      showClasses: !0,
      showStructs: !0,
      showInterfaces: !0,
      showModules: !0,
      showProperties: !0,
      showEvents: !0,
      showOperators: !0,
      showUnits: !0,
      showValues: !0,
      showConstants: !0,
      showEnums: !0,
      showEnumMembers: !0,
      showKeywords: !0,
      showWords: !0,
      showColors: !0,
      showFiles: !0,
      showReferences: !0,
      showFolders: !0,
      showTypeParameters: !0,
      showSnippets: !0,
      showUsers: !0,
      showIssues: !0
    };
    super(R.suggest, "suggest", e, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          h(429, "Insert suggestion without overwriting text right of the cursor."),
          h(430, "Insert suggestion and overwrite text right of the cursor.")
        ],
        default: e.insertMode,
        description: h(
          431,
          "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature."
        )
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: e.filterGraceful,
        description: h(
          432,
          "Controls whether filtering and sorting suggestions accounts for small typos."
        )
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: e.localityBonus,
        description: h(
          433,
          "Controls whether sorting favors words that appear close to the cursor."
        )
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: e.shareSuggestSelections,
        markdownDescription: h(
          434,
          "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`)."
        )
      },
      "editor.suggest.selectionMode": {
        type: "string",
        enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
        enumDescriptions: [
          h(
            435,
            "Always select a suggestion when automatically triggering IntelliSense."
          ),
          h(
            436,
            "Never select a suggestion when automatically triggering IntelliSense."
          ),
          h(
            437,
            "Select a suggestion only when triggering IntelliSense from a trigger character."
          ),
          h(438, "Select a suggestion only when triggering IntelliSense as you type.")
        ],
        default: e.selectionMode,
        markdownDescription: h(
          439,
          "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions ({0} and {1}) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.",
          "`#editor.quickSuggestions#`",
          "`#editor.suggestOnTriggerCharacters#`"
        )
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: e.snippetsPreventQuickSuggestions,
        description: h(440, "Controls whether an active snippet prevents quick suggestions.")
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: e.showIcons,
        description: h(441, "Controls whether to show or hide icons in suggestions.")
      },
      "editor.suggest.showStatusBar": {
        type: "boolean",
        default: e.showStatusBar,
        description: h(
          442,
          "Controls the visibility of the status bar at the bottom of the suggest widget."
        )
      },
      "editor.suggest.preview": {
        type: "boolean",
        default: e.preview,
        description: h(443, "Controls whether to preview the suggestion outcome in the editor.")
      },
      "editor.suggest.showInlineDetails": {
        type: "boolean",
        default: e.showInlineDetails,
        description: h(
          444,
          "Controls whether suggest details show inline with the label or only in the details widget."
        )
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        deprecationMessage: h(445, "This setting is deprecated. The suggest widget can now be resized.")
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: h(
          446,
          "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead."
        )
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: !0,
        markdownDescription: h(447, "When enabled IntelliSense shows `method`-suggestions.")
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: !0,
        markdownDescription: h(448, "When enabled IntelliSense shows `function`-suggestions.")
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: !0,
        markdownDescription: h(449, "When enabled IntelliSense shows `constructor`-suggestions.")
      },
      "editor.suggest.showDeprecated": {
        type: "boolean",
        default: !0,
        markdownDescription: h(450, "When enabled IntelliSense shows `deprecated`-suggestions.")
      },
      "editor.suggest.matchOnWordStartOnly": {
        type: "boolean",
        default: !0,
        markdownDescription: h(
          451,
          "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality."
        )
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: !0,
        markdownDescription: h(452, "When enabled IntelliSense shows `field`-suggestions.")
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: !0,
        markdownDescription: h(453, "When enabled IntelliSense shows `variable`-suggestions.")
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: !0,
        markdownDescription: h(454, "When enabled IntelliSense shows `class`-suggestions.")
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: !0,
        markdownDescription: h(455, "When enabled IntelliSense shows `struct`-suggestions.")
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: !0,
        markdownDescription: h(456, "When enabled IntelliSense shows `interface`-suggestions.")
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: !0,
        markdownDescription: h(457, "When enabled IntelliSense shows `module`-suggestions.")
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: !0,
        markdownDescription: h(458, "When enabled IntelliSense shows `property`-suggestions.")
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: !0,
        markdownDescription: h(459, "When enabled IntelliSense shows `event`-suggestions.")
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: !0,
        markdownDescription: h(460, "When enabled IntelliSense shows `operator`-suggestions.")
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: !0,
        markdownDescription: h(461, "When enabled IntelliSense shows `unit`-suggestions.")
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: !0,
        markdownDescription: h(462, "When enabled IntelliSense shows `value`-suggestions.")
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: !0,
        markdownDescription: h(463, "When enabled IntelliSense shows `constant`-suggestions.")
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: !0,
        markdownDescription: h(464, "When enabled IntelliSense shows `enum`-suggestions.")
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: !0,
        markdownDescription: h(465, "When enabled IntelliSense shows `enumMember`-suggestions.")
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: !0,
        markdownDescription: h(466, "When enabled IntelliSense shows `keyword`-suggestions.")
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: !0,
        markdownDescription: h(467, "When enabled IntelliSense shows `text`-suggestions.")
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: !0,
        markdownDescription: h(468, "When enabled IntelliSense shows `color`-suggestions.")
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: !0,
        markdownDescription: h(469, "When enabled IntelliSense shows `file`-suggestions.")
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: !0,
        markdownDescription: h(470, "When enabled IntelliSense shows `reference`-suggestions.")
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: !0,
        markdownDescription: h(471, "When enabled IntelliSense shows `customcolor`-suggestions.")
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: !0,
        markdownDescription: h(472, "When enabled IntelliSense shows `folder`-suggestions.")
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: !0,
        markdownDescription: h(473, "When enabled IntelliSense shows `typeParameter`-suggestions.")
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: !0,
        markdownDescription: h(474, "When enabled IntelliSense shows `snippet`-suggestions.")
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: !0,
        markdownDescription: h(475, "When enabled IntelliSense shows `user`-suggestions.")
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: !0,
        markdownDescription: h(476, "When enabled IntelliSense shows `issues`-suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      insertMode: vt(i.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: se(i.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: se(i.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: se(i.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: se(i.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      selectionMode: vt(i.selectionMode, this.defaultValue.selectionMode, ["always", "never", "whenQuickSuggestion", "whenTriggerCharacter"]),
      showIcons: se(i.showIcons, this.defaultValue.showIcons),
      showStatusBar: se(i.showStatusBar, this.defaultValue.showStatusBar),
      preview: se(i.preview, this.defaultValue.preview),
      previewMode: vt(i.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
      showInlineDetails: se(i.showInlineDetails, this.defaultValue.showInlineDetails),
      showMethods: se(i.showMethods, this.defaultValue.showMethods),
      showFunctions: se(i.showFunctions, this.defaultValue.showFunctions),
      showConstructors: se(i.showConstructors, this.defaultValue.showConstructors),
      showDeprecated: se(i.showDeprecated, this.defaultValue.showDeprecated),
      matchOnWordStartOnly: se(i.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
      showFields: se(i.showFields, this.defaultValue.showFields),
      showVariables: se(i.showVariables, this.defaultValue.showVariables),
      showClasses: se(i.showClasses, this.defaultValue.showClasses),
      showStructs: se(i.showStructs, this.defaultValue.showStructs),
      showInterfaces: se(i.showInterfaces, this.defaultValue.showInterfaces),
      showModules: se(i.showModules, this.defaultValue.showModules),
      showProperties: se(i.showProperties, this.defaultValue.showProperties),
      showEvents: se(i.showEvents, this.defaultValue.showEvents),
      showOperators: se(i.showOperators, this.defaultValue.showOperators),
      showUnits: se(i.showUnits, this.defaultValue.showUnits),
      showValues: se(i.showValues, this.defaultValue.showValues),
      showConstants: se(i.showConstants, this.defaultValue.showConstants),
      showEnums: se(i.showEnums, this.defaultValue.showEnums),
      showEnumMembers: se(i.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: se(i.showKeywords, this.defaultValue.showKeywords),
      showWords: se(i.showWords, this.defaultValue.showWords),
      showColors: se(i.showColors, this.defaultValue.showColors),
      showFiles: se(i.showFiles, this.defaultValue.showFiles),
      showReferences: se(i.showReferences, this.defaultValue.showReferences),
      showFolders: se(i.showFolders, this.defaultValue.showFolders),
      showTypeParameters: se(i.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: se(i.showSnippets, this.defaultValue.showSnippets),
      showUsers: se(i.showUsers, this.defaultValue.showUsers),
      showIssues: se(i.showIssues, this.defaultValue.showIssues)
    };
  }
}
class R7 extends mt {
  constructor() {
    super(R.smartSelect, "smartSelect", {
      selectLeadingAndTrailingWhitespace: !0,
      selectSubwords: !0
    }, {
      "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
        description: h(477, "Whether leading and trailing whitespace should always be selected."),
        default: !0,
        type: "boolean"
      },
      "editor.smartSelect.selectSubwords": {
        description: h(
          478,
          "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."
        ),
        default: !0,
        type: "boolean"
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      selectLeadingAndTrailingWhitespace: se(e.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
      selectSubwords: se(e.selectSubwords, this.defaultValue.selectSubwords)
    };
  }
}
class L7 extends mt {
  constructor() {
    const e = [];
    super(R.wordSegmenterLocales, "wordSegmenterLocales", e, {
      anyOf: [
        {
          type: "string"
        },
        {
          type: "array",
          items: {
            type: "string"
          }
        }
      ],
      description: h(
        479,
        "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."
      ),
      type: "array",
      items: {
        type: "string"
      },
      default: e
    });
  }
  validate(e) {
    if (typeof e == "string" && (e = [e]), Array.isArray(e)) {
      const i = [];
      for (const n of e)
        if (typeof n == "string")
          try {
            Intl.Segmenter.supportedLocalesOf(n).length > 0 && i.push(n);
          } catch {
          }
      return i;
    }
    return this.defaultValue;
  }
}
var hs;
(function(t) {
  t[t.None = 0] = "None", t[t.Same = 1] = "Same", t[t.Indent = 2] = "Indent", t[t.DeepIndent = 3] = "DeepIndent";
})(hs || (hs = {}));
class N7 extends mt {
  constructor() {
    super(R.wrappingIndent, "wrappingIndent", hs.Same, {
      "editor.wrappingIndent": {
        type: "string",
        enum: ["none", "same", "indent", "deepIndent"],
        enumDescriptions: [
          h(480, "No indentation. Wrapped lines begin at column 1."),
          h(481, "Wrapped lines get the same indentation as the parent."),
          h(482, "Wrapped lines get +1 indentation toward the parent."),
          h(483, "Wrapped lines get +2 indentation toward the parent.")
        ],
        description: h(484, "Controls the indentation of wrapped lines."),
        default: "same"
      }
    });
  }
  validate(e) {
    switch (e) {
      case "none":
        return hs.None;
      case "same":
        return hs.Same;
      case "indent":
        return hs.Indent;
      case "deepIndent":
        return hs.DeepIndent;
    }
    return hs.Same;
  }
  compute(e, i, n) {
    return i.get(R.accessibilitySupport) === ur.Enabled ? hs.None : n;
  }
}
class M7 extends No {
  constructor() {
    super(R.wrappingInfo);
  }
  compute(e, i, n) {
    const r = i.get(R.layoutInfo);
    return {
      isDominatedByLongLines: e.isDominatedByLongLines,
      isWordWrapMinified: r.isWordWrapMinified,
      isViewportWrapping: r.isViewportWrapping,
      wrappingColumn: r.wrappingColumn
    };
  }
}
class O7 extends mt {
  constructor() {
    const e = { enabled: !0, showDropSelector: "afterDrop" };
    super(R.dropIntoEditor, "dropIntoEditor", e, {
      "editor.dropIntoEditor.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: h(
          485,
          "Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor)."
        )
      },
      "editor.dropIntoEditor.showDropSelector": {
        type: "string",
        markdownDescription: h(
          486,
          "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."
        ),
        enum: [
          "afterDrop",
          "never"
        ],
        enumDescriptions: [
          h(
            487,
            "Show the drop selector widget after a file is dropped into the editor."
          ),
          h(
            488,
            "Never show the drop selector widget. Instead the default drop provider is always used."
          )
        ],
        default: "afterDrop"
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      enabled: se(i.enabled, this.defaultValue.enabled),
      showDropSelector: vt(i.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"])
    };
  }
}
class F7 extends mt {
  constructor() {
    const e = { enabled: !0, showPasteSelector: "afterPaste" };
    super(R.pasteAs, "pasteAs", e, {
      "editor.pasteAs.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: h(489, "Controls whether you can paste content in different ways.")
      },
      "editor.pasteAs.showPasteSelector": {
        type: "string",
        markdownDescription: h(
          490,
          "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."
        ),
        enum: [
          "afterPaste",
          "never"
        ],
        enumDescriptions: [
          h(
            491,
            "Show the paste selector widget after content is pasted into the editor."
          ),
          h(
            492,
            "Never show the paste selector widget. Instead the default pasting behavior is always used."
          )
        ],
        default: "afterPaste"
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const i = e;
    return {
      enabled: se(i.enabled, this.defaultValue.enabled),
      showPasteSelector: vt(i.showPasteSelector, this.defaultValue.showPasteSelector, ["afterPaste", "never"])
    };
  }
}
const U7 = "Consolas, 'Courier New', monospace", $7 = "Menlo, Monaco, 'Courier New', monospace", H7 = "'Droid Sans Mono', 'monospace', monospace", Ls = {
  fontFamily: Rn ? $7 : ji ? U7 : H7,
  fontWeight: "normal",
  fontSize: Rn ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
}, B7 = [];
function U(t) {
  return B7[t.id] = t, t;
}
var R;
(function(t) {
  t[t.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", t[t.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", t[t.accessibilitySupport = 2] = "accessibilitySupport", t[t.accessibilityPageSize = 3] = "accessibilityPageSize", t[t.allowOverflow = 4] = "allowOverflow", t[t.allowVariableLineHeights = 5] = "allowVariableLineHeights", t[t.allowVariableFonts = 6] = "allowVariableFonts", t[t.allowVariableFontsInAccessibilityMode = 7] = "allowVariableFontsInAccessibilityMode", t[t.ariaLabel = 8] = "ariaLabel", t[t.ariaRequired = 9] = "ariaRequired", t[t.autoClosingBrackets = 10] = "autoClosingBrackets", t[t.autoClosingComments = 11] = "autoClosingComments", t[t.screenReaderAnnounceInlineSuggestion = 12] = "screenReaderAnnounceInlineSuggestion", t[t.autoClosingDelete = 13] = "autoClosingDelete", t[t.autoClosingOvertype = 14] = "autoClosingOvertype", t[t.autoClosingQuotes = 15] = "autoClosingQuotes", t[t.autoIndent = 16] = "autoIndent", t[t.autoIndentOnPaste = 17] = "autoIndentOnPaste", t[t.autoIndentOnPasteWithinString = 18] = "autoIndentOnPasteWithinString", t[t.automaticLayout = 19] = "automaticLayout", t[t.autoSurround = 20] = "autoSurround", t[t.bracketPairColorization = 21] = "bracketPairColorization", t[t.guides = 22] = "guides", t[t.codeLens = 23] = "codeLens", t[t.codeLensFontFamily = 24] = "codeLensFontFamily", t[t.codeLensFontSize = 25] = "codeLensFontSize", t[t.colorDecorators = 26] = "colorDecorators", t[t.colorDecoratorsLimit = 27] = "colorDecoratorsLimit", t[t.columnSelection = 28] = "columnSelection", t[t.comments = 29] = "comments", t[t.contextmenu = 30] = "contextmenu", t[t.copyWithSyntaxHighlighting = 31] = "copyWithSyntaxHighlighting", t[t.cursorBlinking = 32] = "cursorBlinking", t[t.cursorSmoothCaretAnimation = 33] = "cursorSmoothCaretAnimation", t[t.cursorStyle = 34] = "cursorStyle", t[t.cursorSurroundingLines = 35] = "cursorSurroundingLines", t[t.cursorSurroundingLinesStyle = 36] = "cursorSurroundingLinesStyle", t[t.cursorWidth = 37] = "cursorWidth", t[t.cursorHeight = 38] = "cursorHeight", t[t.disableLayerHinting = 39] = "disableLayerHinting", t[t.disableMonospaceOptimizations = 40] = "disableMonospaceOptimizations", t[t.domReadOnly = 41] = "domReadOnly", t[t.dragAndDrop = 42] = "dragAndDrop", t[t.dropIntoEditor = 43] = "dropIntoEditor", t[t.editContext = 44] = "editContext", t[t.emptySelectionClipboard = 45] = "emptySelectionClipboard", t[t.experimentalGpuAcceleration = 46] = "experimentalGpuAcceleration", t[t.experimentalWhitespaceRendering = 47] = "experimentalWhitespaceRendering", t[t.extraEditorClassName = 48] = "extraEditorClassName", t[t.fastScrollSensitivity = 49] = "fastScrollSensitivity", t[t.find = 50] = "find", t[t.fixedOverflowWidgets = 51] = "fixedOverflowWidgets", t[t.folding = 52] = "folding", t[t.foldingStrategy = 53] = "foldingStrategy", t[t.foldingHighlight = 54] = "foldingHighlight", t[t.foldingImportsByDefault = 55] = "foldingImportsByDefault", t[t.foldingMaximumRegions = 56] = "foldingMaximumRegions", t[t.unfoldOnClickAfterEndOfLine = 57] = "unfoldOnClickAfterEndOfLine", t[t.fontFamily = 58] = "fontFamily", t[t.fontInfo = 59] = "fontInfo", t[t.fontLigatures = 60] = "fontLigatures", t[t.fontSize = 61] = "fontSize", t[t.fontWeight = 62] = "fontWeight", t[t.fontVariations = 63] = "fontVariations", t[t.formatOnPaste = 64] = "formatOnPaste", t[t.formatOnType = 65] = "formatOnType", t[t.glyphMargin = 66] = "glyphMargin", t[t.gotoLocation = 67] = "gotoLocation", t[t.hideCursorInOverviewRuler = 68] = "hideCursorInOverviewRuler", t[t.hover = 69] = "hover", t[t.inDiffEditor = 70] = "inDiffEditor", t[t.inlineSuggest = 71] = "inlineSuggest", t[t.letterSpacing = 72] = "letterSpacing", t[t.lightbulb = 73] = "lightbulb", t[t.lineDecorationsWidth = 74] = "lineDecorationsWidth", t[t.lineHeight = 75] = "lineHeight", t[t.lineNumbers = 76] = "lineNumbers", t[t.lineNumbersMinChars = 77] = "lineNumbersMinChars", t[t.linkedEditing = 78] = "linkedEditing", t[t.links = 79] = "links", t[t.matchBrackets = 80] = "matchBrackets", t[t.minimap = 81] = "minimap", t[t.mouseStyle = 82] = "mouseStyle", t[t.mouseWheelScrollSensitivity = 83] = "mouseWheelScrollSensitivity", t[t.mouseWheelZoom = 84] = "mouseWheelZoom", t[t.multiCursorMergeOverlapping = 85] = "multiCursorMergeOverlapping", t[t.multiCursorModifier = 86] = "multiCursorModifier", t[t.multiCursorPaste = 87] = "multiCursorPaste", t[t.multiCursorLimit = 88] = "multiCursorLimit", t[t.occurrencesHighlight = 89] = "occurrencesHighlight", t[t.occurrencesHighlightDelay = 90] = "occurrencesHighlightDelay", t[t.overtypeCursorStyle = 91] = "overtypeCursorStyle", t[t.overtypeOnPaste = 92] = "overtypeOnPaste", t[t.overviewRulerBorder = 93] = "overviewRulerBorder", t[t.overviewRulerLanes = 94] = "overviewRulerLanes", t[t.padding = 95] = "padding", t[t.pasteAs = 96] = "pasteAs", t[t.parameterHints = 97] = "parameterHints", t[t.peekWidgetDefaultFocus = 98] = "peekWidgetDefaultFocus", t[t.placeholder = 99] = "placeholder", t[t.definitionLinkOpensInPeek = 100] = "definitionLinkOpensInPeek", t[t.quickSuggestions = 101] = "quickSuggestions", t[t.quickSuggestionsDelay = 102] = "quickSuggestionsDelay", t[t.readOnly = 103] = "readOnly", t[t.readOnlyMessage = 104] = "readOnlyMessage", t[t.renameOnType = 105] = "renameOnType", t[t.renderRichScreenReaderContent = 106] = "renderRichScreenReaderContent", t[t.renderControlCharacters = 107] = "renderControlCharacters", t[t.renderFinalNewline = 108] = "renderFinalNewline", t[t.renderLineHighlight = 109] = "renderLineHighlight", t[t.renderLineHighlightOnlyWhenFocus = 110] = "renderLineHighlightOnlyWhenFocus", t[t.renderValidationDecorations = 111] = "renderValidationDecorations", t[t.renderWhitespace = 112] = "renderWhitespace", t[t.revealHorizontalRightPadding = 113] = "revealHorizontalRightPadding", t[t.roundedSelection = 114] = "roundedSelection", t[t.rulers = 115] = "rulers", t[t.scrollbar = 116] = "scrollbar", t[t.scrollBeyondLastColumn = 117] = "scrollBeyondLastColumn", t[t.scrollBeyondLastLine = 118] = "scrollBeyondLastLine", t[t.scrollPredominantAxis = 119] = "scrollPredominantAxis", t[t.selectionClipboard = 120] = "selectionClipboard", t[t.selectionHighlight = 121] = "selectionHighlight", t[t.selectionHighlightMaxLength = 122] = "selectionHighlightMaxLength", t[t.selectionHighlightMultiline = 123] = "selectionHighlightMultiline", t[t.selectOnLineNumbers = 124] = "selectOnLineNumbers", t[t.showFoldingControls = 125] = "showFoldingControls", t[t.showUnused = 126] = "showUnused", t[t.snippetSuggestions = 127] = "snippetSuggestions", t[t.smartSelect = 128] = "smartSelect", t[t.smoothScrolling = 129] = "smoothScrolling", t[t.stickyScroll = 130] = "stickyScroll", t[t.stickyTabStops = 131] = "stickyTabStops", t[t.stopRenderingLineAfter = 132] = "stopRenderingLineAfter", t[t.suggest = 133] = "suggest", t[t.suggestFontSize = 134] = "suggestFontSize", t[t.suggestLineHeight = 135] = "suggestLineHeight", t[t.suggestOnTriggerCharacters = 136] = "suggestOnTriggerCharacters", t[t.suggestSelection = 137] = "suggestSelection", t[t.tabCompletion = 138] = "tabCompletion", t[t.tabIndex = 139] = "tabIndex", t[t.trimWhitespaceOnDelete = 140] = "trimWhitespaceOnDelete", t[t.unicodeHighlighting = 141] = "unicodeHighlighting", t[t.unusualLineTerminators = 142] = "unusualLineTerminators", t[t.useShadowDOM = 143] = "useShadowDOM", t[t.useTabStops = 144] = "useTabStops", t[t.wordBreak = 145] = "wordBreak", t[t.wordSegmenterLocales = 146] = "wordSegmenterLocales", t[t.wordSeparators = 147] = "wordSeparators", t[t.wordWrap = 148] = "wordWrap", t[t.wordWrapBreakAfterCharacters = 149] = "wordWrapBreakAfterCharacters", t[t.wordWrapBreakBeforeCharacters = 150] = "wordWrapBreakBeforeCharacters", t[t.wordWrapColumn = 151] = "wordWrapColumn", t[t.wordWrapOverride1 = 152] = "wordWrapOverride1", t[t.wordWrapOverride2 = 153] = "wordWrapOverride2", t[t.wrappingIndent = 154] = "wrappingIndent", t[t.wrappingStrategy = 155] = "wrappingStrategy", t[t.showDeprecated = 156] = "showDeprecated", t[t.inertialScroll = 157] = "inertialScroll", t[t.inlayHints = 158] = "inlayHints", t[t.wrapOnEscapedLineFeeds = 159] = "wrapOnEscapedLineFeeds", t[t.effectiveCursorStyle = 160] = "effectiveCursorStyle", t[t.editorClassName = 161] = "editorClassName", t[t.pixelRatio = 162] = "pixelRatio", t[t.tabFocusMode = 163] = "tabFocusMode", t[t.layoutInfo = 164] = "layoutInfo", t[t.wrappingInfo = 165] = "wrappingInfo", t[t.defaultColorDecorators = 166] = "defaultColorDecorators", t[t.colorDecoratorsActivatedOn = 167] = "colorDecoratorsActivatedOn", t[t.inlineCompletionsAccessibilityVerbose = 168] = "inlineCompletionsAccessibilityVerbose", t[t.effectiveEditContext = 169] = "effectiveEditContext", t[t.scrollOnMiddleClick = 170] = "scrollOnMiddleClick", t[t.effectiveAllowVariableFonts = 171] = "effectiveAllowVariableFonts";
})(R || (R = {}));
U(new xe(
  R.acceptSuggestionOnCommitCharacter,
  "acceptSuggestionOnCommitCharacter",
  !0,
  { markdownDescription: h(
    493,
    "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character."
  ) }
)), U(new _t(
  R.acceptSuggestionOnEnter,
  "acceptSuggestionOnEnter",
  "on",
  ["on", "smart", "off"],
  {
    markdownEnumDescriptions: [
      "",
      h(
        494,
        "Only accept a suggestion with `Enter` when it makes a textual change."
      ),
      ""
    ],
    markdownDescription: h(
      495,
      "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions."
    )
  }
)), U(new YL()), U(new Ke(
  R.accessibilityPageSize,
  "accessibilityPageSize",
  500,
  1,
  Ii.MAX_SAFE_SMALL_INTEGER,
  {
    description: h(
      496,
      "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."
    ),
    tags: ["accessibility"]
  }
)), U(new xe(R.allowOverflow, "allowOverflow", !0)), U(new xe(R.allowVariableLineHeights, "allowVariableLineHeights", !0, {
  description: h(
    497,
    "Controls whether to allow using variable line heights in the editor."
  )
})), U(new xe(R.allowVariableFonts, "allowVariableFonts", !0, {
  description: h(498, "Controls whether to allow using variable fonts in the editor.")
})), U(new xe(
  R.allowVariableFontsInAccessibilityMode,
  "allowVariableFontsInAccessibilityMode",
  !1,
  {
    description: h(
      499,
      "Controls whether to allow using variable fonts in the editor in the accessibility mode."
    ),
    tags: ["accessibility"]
  }
)), U(new Ti(R.ariaLabel, "ariaLabel", h(500, "Editor content"))), U(new xe(R.ariaRequired, "ariaRequired", !1, void 0)), U(new xe(
  R.screenReaderAnnounceInlineSuggestion,
  "screenReaderAnnounceInlineSuggestion",
  !0,
  {
    description: h(
      501,
      "Control whether inline suggestions are announced by a screen reader."
    ),
    tags: ["accessibility"]
  }
)), U(new _t(
  R.autoClosingBrackets,
  "autoClosingBrackets",
  "languageDefined",
  ["always", "languageDefined", "beforeWhitespace", "never"],
  {
    enumDescriptions: [
      "",
      h(
        502,
        "Use language configurations to determine when to autoclose brackets."
      ),
      h(
        503,
        "Autoclose brackets only when the cursor is to the left of whitespace."
      ),
      ""
    ],
    description: h(
      504,
      "Controls whether the editor should automatically close brackets after the user adds an opening bracket."
    )
  }
)), U(new _t(
  R.autoClosingComments,
  "autoClosingComments",
  "languageDefined",
  ["always", "languageDefined", "beforeWhitespace", "never"],
  {
    enumDescriptions: [
      "",
      h(
        505,
        "Use language configurations to determine when to autoclose comments."
      ),
      h(
        506,
        "Autoclose comments only when the cursor is to the left of whitespace."
      ),
      ""
    ],
    description: h(
      507,
      "Controls whether the editor should automatically close comments after the user adds an opening comment."
    )
  }
)), U(new _t(
  R.autoClosingDelete,
  "autoClosingDelete",
  "auto",
  ["always", "auto", "never"],
  {
    enumDescriptions: [
      "",
      h(
        508,
        "Remove adjacent closing quotes or brackets only if they were automatically inserted."
      ),
      ""
    ],
    description: h(
      509,
      "Controls whether the editor should remove adjacent closing quotes or brackets when deleting."
    )
  }
)), U(new _t(
  R.autoClosingOvertype,
  "autoClosingOvertype",
  "auto",
  ["always", "auto", "never"],
  {
    enumDescriptions: [
      "",
      h(
        510,
        "Type over closing quotes or brackets only if they were automatically inserted."
      ),
      ""
    ],
    description: h(
      511,
      "Controls whether the editor should type over closing quotes or brackets."
    )
  }
)), U(new _t(
  R.autoClosingQuotes,
  "autoClosingQuotes",
  "languageDefined",
  ["always", "languageDefined", "beforeWhitespace", "never"],
  {
    enumDescriptions: [
      "",
      h(512, "Use language configurations to determine when to autoclose quotes."),
      h(513, "Autoclose quotes only when the cursor is to the left of whitespace."),
      ""
    ],
    description: h(
      514,
      "Controls whether the editor should automatically close quotes after the user adds an opening quote."
    )
  }
)), U(new Fu(
  R.autoIndent,
  "autoIndent",
  oo.Full,
  "full",
  ["none", "keep", "brackets", "advanced", "full"],
  JL,
  {
    enumDescriptions: [
      h(515, "The editor will not insert indentation automatically."),
      h(516, "The editor will keep the current line's indentation."),
      h(
        517,
        "The editor will keep the current line's indentation and honor language defined brackets."
      ),
      h(
        518,
        "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."
      ),
      h(
        519,
        "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages."
      )
    ],
    description: h(
      520,
      "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines."
    )
  }
)), U(new xe(
  R.autoIndentOnPaste,
  "autoIndentOnPaste",
  !1,
  { description: h(
    521,
    "Controls whether the editor should automatically auto-indent the pasted content."
  ) }
)), U(new xe(
  R.autoIndentOnPasteWithinString,
  "autoIndentOnPasteWithinString",
  !0,
  { description: h(
    522,
    "Controls whether the editor should automatically auto-indent the pasted content when pasted within a string. This takes effect when autoIndentOnPaste is true."
  ) }
)), U(new xe(R.automaticLayout, "automaticLayout", !1)), U(new _t(
  R.autoSurround,
  "autoSurround",
  "languageDefined",
  ["languageDefined", "quotes", "brackets", "never"],
  {
    enumDescriptions: [
      h(
        523,
        "Use language configurations to determine when to automatically surround selections."
      ),
      h(524, "Surround with quotes but not brackets."),
      h(525, "Surround with brackets but not quotes."),
      ""
    ],
    description: h(
      526,
      "Controls whether the editor should automatically surround selections when typing quotes or brackets."
    )
  }
)), U(new T7()), U(new P7()), U(new xe(
  R.stickyTabStops,
  "stickyTabStops",
  !1,
  { description: h(
    527,
    "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops."
  ) }
)), U(new xe(R.codeLens, "codeLens", !0, { description: h(528, "Controls whether the editor shows CodeLens.") })), U(new Ti(
  R.codeLensFontFamily,
  "codeLensFontFamily",
  "",
  { description: h(529, "Controls the font family for CodeLens.") }
)), U(new Ke(R.codeLensFontSize, "codeLensFontSize", 0, 0, 100, {
  type: "number",
  default: 0,
  minimum: 0,
  maximum: 100,
  markdownDescription: h(
    530,
    "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used."
  )
})), U(new xe(
  R.colorDecorators,
  "colorDecorators",
  !0,
  { description: h(
    531,
    "Controls whether the editor should render the inline color decorators and color picker."
  ) }
)), U(new _t(
  R.colorDecoratorsActivatedOn,
  "colorDecoratorsActivatedOn",
  "clickAndHover",
  ["clickAndHover", "hover", "click"],
  {
    enumDescriptions: [
      h(
        532,
        "Make the color picker appear both on click and hover of the color decorator"
      ),
      h(533, "Make the color picker appear on hover of the color decorator"),
      h(534, "Make the color picker appear on click of the color decorator")
    ],
    description: h(
      535,
      "Controls the condition to make a color picker appear from a color decorator."
    )
  }
)), U(new Ke(
  R.colorDecoratorsLimit,
  "colorDecoratorsLimit",
  500,
  1,
  1e6,
  {
    markdownDescription: h(
      536,
      "Controls the max number of color decorators that can be rendered in an editor at once."
    )
  }
)), U(new xe(
  R.columnSelection,
  "columnSelection",
  !1,
  { description: h(
    537,
    "Enable that the selection with the mouse and keys is doing column selection."
  ) }
)), U(new XL()), U(new xe(R.contextmenu, "contextmenu", !0)), U(new xe(
  R.copyWithSyntaxHighlighting,
  "copyWithSyntaxHighlighting",
  !0,
  { description: h(
    538,
    "Controls whether syntax highlighting should be copied into the clipboard."
  ) }
)), U(new Fu(
  R.cursorBlinking,
  "cursorBlinking",
  ao.Blink,
  "blink",
  ["blink", "smooth", "phase", "expand", "solid"],
  ZL,
  { description: h(539, "Control the cursor animation style.") }
)), U(new _t(
  R.cursorSmoothCaretAnimation,
  "cursorSmoothCaretAnimation",
  "off",
  ["off", "explicit", "on"],
  {
    enumDescriptions: [
      h(540, "Smooth caret animation is disabled."),
      h(
        541,
        "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."
      ),
      h(542, "Smooth caret animation is always enabled.")
    ],
    description: h(543, "Controls whether the smooth caret animation should be enabled.")
  }
)), U(new Fu(
  R.cursorStyle,
  "cursorStyle",
  cr.Line,
  "line",
  ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"],
  GS,
  { description: h(544, "Controls the cursor style in insert input mode.") }
)), U(new Fu(
  R.overtypeCursorStyle,
  "overtypeCursorStyle",
  cr.Block,
  "block",
  ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"],
  GS,
  { description: h(545, "Controls the cursor style in overtype input mode.") }
)), U(new Ke(
  R.cursorSurroundingLines,
  "cursorSurroundingLines",
  0,
  0,
  Ii.MAX_SAFE_SMALL_INTEGER,
  { description: h(
    546,
    "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors."
  ) }
)), U(new _t(
  R.cursorSurroundingLinesStyle,
  "cursorSurroundingLinesStyle",
  "default",
  ["default", "all"],
  {
    enumDescriptions: [
      h(
        547,
        "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."
      ),
      h(548, "`cursorSurroundingLines` is enforced always.")
    ],
    markdownDescription: h(549, "Controls when `#editor.cursorSurroundingLines#` should be enforced.")
  }
)), U(new Ke(
  R.cursorWidth,
  "cursorWidth",
  0,
  0,
  Ii.MAX_SAFE_SMALL_INTEGER,
  { markdownDescription: h(
    550,
    "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`."
  ) }
)), U(new Ke(
  R.cursorHeight,
  "cursorHeight",
  0,
  0,
  Ii.MAX_SAFE_SMALL_INTEGER,
  { markdownDescription: h(
    551,
    "Controls the height of the cursor when `#editor.cursorStyle#` is set to `line`. Cursor's max height depends on line height."
  ) }
)), U(new xe(R.disableLayerHinting, "disableLayerHinting", !1)), U(new xe(
  R.disableMonospaceOptimizations,
  "disableMonospaceOptimizations",
  !1
)), U(new xe(R.domReadOnly, "domReadOnly", !1)), U(new xe(
  R.dragAndDrop,
  "dragAndDrop",
  !0,
  { description: h(
    552,
    "Controls whether the editor should allow moving selections via drag and drop."
  ) }
)), U(new t7()), U(new O7()), U(new xe(R.editContext, "editContext", !0, {
  description: h(
    553,
    "Sets whether the EditContext API should be used instead of the text area to power input in the editor."
  ),
  included: Ex || w4 || m4
})), U(new xe(
  R.renderRichScreenReaderContent,
  "renderRichScreenReaderContent",
  !1,
  {
    description: h(
      554,
      "Whether to render rich screen reader content when the `editor.editContext` is enabled."
    )
  }
)), U(new h7()), U(new _t(
  R.experimentalGpuAcceleration,
  "experimentalGpuAcceleration",
  "off",
  ["off", "on"],
  {
    tags: ["experimental"],
    enumDescriptions: [
      h(555, "Use regular DOM-based rendering."),
      h(556, "Use GPU acceleration.")
    ],
    description: h(
      557,
      "Controls whether to use the experimental GPU acceleration to render the editor."
    )
  }
)), U(new _t(
  R.experimentalWhitespaceRendering,
  "experimentalWhitespaceRendering",
  "svg",
  ["svg", "font", "off"],
  {
    enumDescriptions: [
      h(558, "Use a new rendering method with svgs."),
      h(559, "Use a new rendering method with font characters."),
      h(560, "Use the stable rendering method.")
    ],
    description: h(
      561,
      "Controls whether whitespace is rendered with a new, experimental method."
    )
  }
)), U(new Ti(R.extraEditorClassName, "extraEditorClassName", "")), U(new Bn(
  R.fastScrollSensitivity,
  "fastScrollSensitivity",
  5,
  (t) => t <= 0 ? 5 : t,
  { markdownDescription: h(562, "Scrolling speed multiplier when pressing `Alt`.") }
)), U(new i7()), U(new xe(R.fixedOverflowWidgets, "fixedOverflowWidgets", !1)), U(new xe(R.folding, "folding", !0, { description: h(563, "Controls whether the editor has code folding enabled.") })), U(new _t(
  R.foldingStrategy,
  "foldingStrategy",
  "auto",
  ["auto", "indentation"],
  {
    enumDescriptions: [
      h(
        564,
        "Use a language-specific folding strategy if available, else the indentation-based one."
      ),
      h(565, "Use the indentation-based folding strategy.")
    ],
    description: h(566, "Controls the strategy for computing folding ranges.")
  }
)), U(new xe(
  R.foldingHighlight,
  "foldingHighlight",
  !0,
  { description: h(567, "Controls whether the editor should highlight folded ranges.") }
)), U(new xe(
  R.foldingImportsByDefault,
  "foldingImportsByDefault",
  !1,
  { description: h(568, "Controls whether the editor automatically collapses import ranges.") }
)), U(new Ke(
  R.foldingMaximumRegions,
  "foldingMaximumRegions",
  5e3,
  10,
  65e3,
  { description: h(
    569,
    "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions."
  ) }
)), U(new xe(
  R.unfoldOnClickAfterEndOfLine,
  "unfoldOnClickAfterEndOfLine",
  !1,
  { description: h(
    570,
    "Controls whether clicking on the empty content after a folded line will unfold the line."
  ) }
)), U(new Ti(
  R.fontFamily,
  "fontFamily",
  Ls.fontFamily,
  { description: h(571, "Controls the font family.") }
)), U(new n7()), U(new zv()), U(new a7()), U(new jv()), U(new qv()), U(new xe(
  R.formatOnPaste,
  "formatOnPaste",
  !1,
  { description: h(
    572,
    "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document."
  ) }
)), U(new xe(
  R.formatOnType,
  "formatOnType",
  !1,
  { description: h(
    573,
    "Controls whether the editor should automatically format the line after typing."
  ) }
)), U(new xe(
  R.glyphMargin,
  "glyphMargin",
  !0,
  { description: h(
    574,
    "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging."
  ) }
)), U(new l7()), U(new xe(
  R.hideCursorInOverviewRuler,
  "hideCursorInOverviewRuler",
  !1,
  { description: h(575, "Controls whether the cursor should be hidden in the overview ruler.") }
)), U(new c7()), U(new xe(R.inDiffEditor, "inDiffEditor", !1)), U(new xe(
  R.inertialScroll,
  "inertialScroll",
  !1,
  { description: h(576, "Make scrolling inertial - mostly useful with touchpad on linux.") }
)), U(new Bn(
  R.letterSpacing,
  "letterSpacing",
  Ls.letterSpacing,
  (t) => Bn.clamp(t, -5, 20),
  { description: h(577, "Controls the letter spacing in pixels.") }
)), U(new d7()), U(new p7()), U(new g7()), U(new E7()), U(new Ke(R.lineNumbersMinChars, "lineNumbersMinChars", 5, 1, 300)), U(new xe(
  R.linkedEditing,
  "linkedEditing",
  !1,
  { description: h(
    578,
    "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing."
  ) }
)), U(new xe(R.links, "links", !0, { description: h(
  579,
  "Controls whether the editor should detect links and make them clickable."
) })), U(new _t(
  R.matchBrackets,
  "matchBrackets",
  "always",
  ["always", "near", "never"],
  { description: h(580, "Highlight matching brackets.") }
)), U(new m7()), U(new _t(R.mouseStyle, "mouseStyle", "text", ["text", "default", "copy"])), U(new Bn(
  R.mouseWheelScrollSensitivity,
  "mouseWheelScrollSensitivity",
  1,
  (t) => t === 0 ? 1 : t,
  { markdownDescription: h(
    581,
    "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events."
  ) }
)), U(new xe(R.mouseWheelZoom, "mouseWheelZoom", !1, {
  markdownDescription: Rn ? h(
    582,
    "Zoom the font of the editor when using mouse wheel and holding `Cmd`."
  ) : h(
    583,
    "Zoom the font of the editor when using mouse wheel and holding `Ctrl`."
  )
})), U(new xe(
  R.multiCursorMergeOverlapping,
  "multiCursorMergeOverlapping",
  !0,
  { description: h(584, "Merge multiple cursors when they are overlapping.") }
)), U(new Fu(
  R.multiCursorModifier,
  "multiCursorModifier",
  "altKey",
  "alt",
  ["ctrlCmd", "alt"],
  _7,
  {
    markdownEnumDescriptions: [
      h(585, "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
      h(586, "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
    ],
    markdownDescription: h(
      587,
      "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier)."
    )
  }
)), U(new _t(
  R.multiCursorPaste,
  "multiCursorPaste",
  "spread",
  ["spread", "full"],
  {
    markdownEnumDescriptions: [
      h(588, "Each cursor pastes a single line of the text."),
      h(589, "Each cursor pastes the full text.")
    ],
    markdownDescription: h(
      590,
      "Controls pasting when the line count of the pasted text matches the cursor count."
    )
  }
)), U(new Ke(R.multiCursorLimit, "multiCursorLimit", 1e4, 1, 1e5, {
  markdownDescription: h(
    591,
    "Controls the max number of cursors that can be in an active editor at once."
  )
})), U(new _t(
  R.occurrencesHighlight,
  "occurrencesHighlight",
  "singleFile",
  ["off", "singleFile", "multiFile"],
  {
    markdownEnumDescriptions: [
      h(592, "Does not highlight occurrences."),
      h(593, "Highlights occurrences only in the current file."),
      h(594, "Experimental: Highlights occurrences across all valid open files.")
    ],
    markdownDescription: h(
      595,
      "Controls whether occurrences should be highlighted across open files."
    )
  }
)), U(new Ke(
  R.occurrencesHighlightDelay,
  "occurrencesHighlightDelay",
  0,
  0,
  2e3,
  {
    description: h(
      596,
      "Controls the delay in milliseconds after which occurrences are highlighted."
    ),
    tags: ["preview"]
  }
)), U(new xe(
  R.overtypeOnPaste,
  "overtypeOnPaste",
  !0,
  { description: h(597, "Controls whether pasting should overtype.") }
)), U(new xe(
  R.overviewRulerBorder,
  "overviewRulerBorder",
  !0,
  { description: h(
    598,
    "Controls whether a border should be drawn around the overview ruler."
  ) }
)), U(new Ke(R.overviewRulerLanes, "overviewRulerLanes", 3, 0, 3)), U(new v7()), U(new F7()), U(new w7()), U(new _t(
  R.peekWidgetDefaultFocus,
  "peekWidgetDefaultFocus",
  "tree",
  ["tree", "editor"],
  {
    enumDescriptions: [
      h(599, "Focus the tree when opening peek"),
      h(600, "Focus the editor when opening peek")
    ],
    description: h(
      601,
      "Controls whether to focus the inline editor or the tree in the peek widget."
    )
  }
)), U(new y7()), U(new xe(
  R.definitionLinkOpensInPeek,
  "definitionLinkOpensInPeek",
  !1,
  { description: h(
    602,
    "Controls whether the Go to Definition mouse gesture always opens the peek widget."
  ) }
)), U(new x7()), U(new Ke(
  R.quickSuggestionsDelay,
  "quickSuggestionsDelay",
  10,
  0,
  Ii.MAX_SAFE_SMALL_INTEGER,
  {
    description: h(
      603,
      "Controls the delay in milliseconds after which quick suggestions will show up."
    ),
    experiment: {
      mode: "startup"
    }
  }
)), U(new xe(R.readOnly, "readOnly", !1)), U(new D7()), U(new xe(
  R.renameOnType,
  "renameOnType",
  !1,
  { description: h(604, "Controls whether the editor auto renames on type."), markdownDeprecationMessage: h(605, "Deprecated, use `editor.linkedEditing` instead.") }
)), U(new xe(
  R.renderControlCharacters,
  "renderControlCharacters",
  !0,
  { description: h(606, "Controls whether the editor should render control characters."), restricted: !0 }
)), U(new _t(
  R.renderFinalNewline,
  "renderFinalNewline",
  So ? "dimmed" : "on",
  ["off", "on", "dimmed"],
  { description: h(607, "Render last line number when the file ends with a newline.") }
)), U(new _t(
  R.renderLineHighlight,
  "renderLineHighlight",
  "line",
  ["none", "gutter", "line", "all"],
  {
    enumDescriptions: [
      "",
      "",
      "",
      h(608, "Highlights both the gutter and the current line.")
    ],
    description: h(609, "Controls how the editor should render the current line highlight.")
  }
)), U(new xe(
  R.renderLineHighlightOnlyWhenFocus,
  "renderLineHighlightOnlyWhenFocus",
  !1,
  { description: h(
    610,
    "Controls if the editor should render the current line highlight only when the editor is focused."
  ) }
)), U(new _t(
  R.renderValidationDecorations,
  "renderValidationDecorations",
  "editable",
  ["editable", "on", "off"]
)), U(new _t(
  R.renderWhitespace,
  "renderWhitespace",
  "selection",
  ["none", "boundary", "selection", "trailing", "all"],
  {
    enumDescriptions: [
      "",
      h(
        611,
        "Render whitespace characters except for single spaces between words."
      ),
      h(612, "Render whitespace characters only on selected text."),
      h(613, "Render only trailing whitespace characters."),
      ""
    ],
    description: h(614, "Controls how the editor should render whitespace characters.")
  }
)), U(new Ke(
  R.revealHorizontalRightPadding,
  "revealHorizontalRightPadding",
  15,
  0,
  1e3
)), U(new xe(
  R.roundedSelection,
  "roundedSelection",
  !0,
  { description: h(615, "Controls whether selections should have rounded corners.") }
)), U(new S7()), U(new k7()), U(new Ke(
  R.scrollBeyondLastColumn,
  "scrollBeyondLastColumn",
  4,
  0,
  Ii.MAX_SAFE_SMALL_INTEGER,
  { description: h(
    616,
    "Controls the number of extra characters beyond which the editor will scroll horizontally."
  ) }
)), U(new xe(
  R.scrollBeyondLastLine,
  "scrollBeyondLastLine",
  !0,
  { description: h(617, "Controls whether the editor will scroll beyond the last line.") }
)), U(new xe(
  R.scrollOnMiddleClick,
  "scrollOnMiddleClick",
  !1,
  { description: h(
    618,
    "Controls whether the editor will scroll when the middle button is pressed."
  ) }
)), U(new xe(
  R.scrollPredominantAxis,
  "scrollPredominantAxis",
  !0,
  { description: h(
    619,
    "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad."
  ) }
)), U(new xe(R.selectionClipboard, "selectionClipboard", !0, {
  description: h(620, "Controls whether the Linux primary clipboard should be supported."),
  included: So
})), U(new xe(
  R.selectionHighlight,
  "selectionHighlight",
  !0,
  { description: h(
    621,
    "Controls whether the editor should highlight matches similar to the selection."
  ) }
)), U(new Ke(
  R.selectionHighlightMaxLength,
  "selectionHighlightMaxLength",
  200,
  0,
  Ii.MAX_SAFE_SMALL_INTEGER,
  { description: h(
    622,
    "Controls how many characters can be in the selection before similiar matches are not highlighted. Set to zero for unlimited."
  ) }
)), U(new xe(
  R.selectionHighlightMultiline,
  "selectionHighlightMultiline",
  !1,
  { description: h(
    623,
    "Controls whether the editor should highlight selection matches that span multiple lines."
  ) }
)), U(new xe(R.selectOnLineNumbers, "selectOnLineNumbers", !0)), U(new _t(
  R.showFoldingControls,
  "showFoldingControls",
  "mouseover",
  ["always", "never", "mouseover"],
  {
    enumDescriptions: [
      h(624, "Always show the folding controls."),
      h(625, "Never show the folding controls and reduce the gutter size."),
      h(626, "Only show the folding controls when the mouse is over the gutter.")
    ],
    description: h(627, "Controls when the folding controls on the gutter are shown.")
  }
)), U(new xe(R.showUnused, "showUnused", !0, { description: h(628, "Controls fading out of unused code.") })), U(new xe(
  R.showDeprecated,
  "showDeprecated",
  !0,
  { description: h(629, "Controls strikethrough deprecated variables.") }
)), U(new f7()), U(new _t(
  R.snippetSuggestions,
  "snippetSuggestions",
  "inline",
  ["top", "bottom", "inline", "none"],
  {
    enumDescriptions: [
      h(630, "Show snippet suggestions on top of other suggestions."),
      h(631, "Show snippet suggestions below other suggestions."),
      h(632, "Show snippets suggestions with other suggestions."),
      h(633, "Do not show snippet suggestions.")
    ],
    description: h(
      634,
      "Controls whether snippets are shown with other suggestions and how they are sorted."
    )
  }
)), U(new R7()), U(new xe(
  R.smoothScrolling,
  "smoothScrolling",
  !1,
  { description: h(635, "Controls whether the editor will scroll using an animation.") }
)), U(new Ke(
  R.stopRenderingLineAfter,
  "stopRenderingLineAfter",
  1e4,
  -1,
  Ii.MAX_SAFE_SMALL_INTEGER
)), U(new A7()), U(new C7()), U(new xe(
  R.inlineCompletionsAccessibilityVerbose,
  "inlineCompletionsAccessibilityVerbose",
  !1,
  { description: h(
    636,
    "Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown."
  ) }
)), U(new Ke(
  R.suggestFontSize,
  "suggestFontSize",
  0,
  0,
  1e3,
  { markdownDescription: h(
    637,
    "Font size for the suggest widget. When set to {0}, the value of {1} is used.",
    "`0`",
    "`#editor.fontSize#`"
  ) }
)), U(new Ke(
  R.suggestLineHeight,
  "suggestLineHeight",
  0,
  0,
  1e3,
  { markdownDescription: h(
    638,
    "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.",
    "`0`",
    "`#editor.lineHeight#`"
  ) }
)), U(new xe(
  R.suggestOnTriggerCharacters,
  "suggestOnTriggerCharacters",
  !0,
  { description: h(
    639,
    "Controls whether suggestions should automatically show up when typing trigger characters."
  ) }
)), U(new _t(
  R.suggestSelection,
  "suggestSelection",
  "first",
  ["first", "recentlyUsed", "recentlyUsedByPrefix"],
  {
    markdownEnumDescriptions: [
      h(640, "Always select the first suggestion."),
      h(
        641,
        "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."
      ),
      h(
        642,
        "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`."
      )
    ],
    description: h(
      643,
      "Controls how suggestions are pre-selected when showing the suggest list."
    )
  }
)), U(new _t(
  R.tabCompletion,
  "tabCompletion",
  "off",
  ["on", "off", "onlySnippets"],
  {
    enumDescriptions: [
      h(
        644,
        "Tab complete will insert the best matching suggestion when pressing tab."
      ),
      h(645, "Disable tab completions."),
      h(
        646,
        "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled."
      )
    ],
    description: h(647, "Enables tab completions.")
  }
)), U(new Ke(R.tabIndex, "tabIndex", 0, -1, Ii.MAX_SAFE_SMALL_INTEGER)), U(new xe(
  R.trimWhitespaceOnDelete,
  "trimWhitespaceOnDelete",
  !1,
  { description: h(
    648,
    "Controls whether the editor will also delete the next line's indentation whitespace when deleting a newline."
  ) }
)), U(new I7()), U(new _t(
  R.unusualLineTerminators,
  "unusualLineTerminators",
  "prompt",
  ["auto", "off", "prompt"],
  {
    enumDescriptions: [
      h(649, "Unusual line terminators are automatically removed."),
      h(650, "Unusual line terminators are ignored."),
      h(651, "Unusual line terminators prompt to be removed.")
    ],
    description: h(652, "Remove unusual line terminators that might cause problems.")
  }
)), U(new xe(R.useShadowDOM, "useShadowDOM", !0)), U(new xe(
  R.useTabStops,
  "useTabStops",
  !0,
  { description: h(
    653,
    "Spaces and tabs are inserted and deleted in alignment with tab stops."
  ) }
)), U(new _t(R.wordBreak, "wordBreak", "normal", ["normal", "keepAll"], {
  markdownEnumDescriptions: [
    h(654, "Use the default line break rule."),
    h(
      655,
      "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal."
    )
  ],
  description: h(
    656,
    "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text."
  )
})), U(new L7()), U(new Ti(
  R.wordSeparators,
  "wordSeparators",
  gT,
  { description: h(
    657,
    "Characters that will be used as word separators when doing word related navigations or operations."
  ) }
)), U(new _t(
  R.wordWrap,
  "wordWrap",
  "off",
  ["off", "on", "wordWrapColumn", "bounded"],
  {
    markdownEnumDescriptions: [
      h(658, "Lines will never wrap."),
      h(659, "Lines will wrap at the viewport width."),
      h(660, "Lines will wrap at `#editor.wordWrapColumn#`."),
      h(
        661,
        "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`."
      )
    ],
    description: h(662, "Controls how lines should wrap.")
  }
)), U(new Ti(
  R.wordWrapBreakAfterCharacters,
  "wordWrapBreakAfterCharacters",
  " 	})]?|/&.,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣"
)), U(new Ti(
  R.wordWrapBreakBeforeCharacters,
  "wordWrapBreakBeforeCharacters",
  "([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋"
)), U(new Ke(
  R.wordWrapColumn,
  "wordWrapColumn",
  80,
  1,
  Ii.MAX_SAFE_SMALL_INTEGER,
  {
    markdownDescription: h(
      663,
      "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`."
    )
  }
)), U(new _t(
  R.wordWrapOverride1,
  "wordWrapOverride1",
  "inherit",
  ["off", "on", "inherit"]
)), U(new _t(
  R.wordWrapOverride2,
  "wordWrapOverride2",
  "inherit",
  ["off", "on", "inherit"]
)), U(new xe(
  R.wrapOnEscapedLineFeeds,
  "wrapOnEscapedLineFeeds",
  !1,
  { markdownDescription: h(
    664,
    'Controls whether literal `\\n` shall trigger a wordWrap when `#editor.wordWrap#` is enabled.\n\nFor example:\n```c\nchar* str="hello\\nworld"\n```\nwill be displayed as\n```c\nchar* str="hello\\n\n           world"\n```'
  ) }
)), U(new r7()), U(new e7()), U(new _t(
  R.defaultColorDecorators,
  "defaultColorDecorators",
  "auto",
  ["auto", "always", "never"],
  {
    enumDescriptions: [
      h(
        665,
        "Show default color decorators only when no extension provides colors decorators."
      ),
      h(666, "Always show default color decorators."),
      h(667, "Never show default color decorators.")
    ],
    description: h(
      668,
      "Controls whether inline color decorations should be shown using the default document color provider."
    )
  }
)), U(new b7()), U(new xe(
  R.tabFocusMode,
  "tabFocusMode",
  !1,
  { markdownDescription: h(
    669,
    "Controls whether the editor receives tabs or defers them to the workbench for navigation."
  ) }
)), U(new cd()), U(new M7()), U(new N7()), U(new u7()), U(new s7()), U(new o7());
let Pn = class Vo {
  constructor(e, i) {
    this.lineNumber = e, this.column = i;
  }
  with(e = this.lineNumber, i = this.column) {
    return e === this.lineNumber && i === this.column ? this : new Vo(e, i);
  }
  delta(e = 0, i = 0) {
    return this.with(Math.max(1, this.lineNumber + e), Math.max(1, this.column + i));
  }
  equals(e) {
    return Vo.equals(this, e);
  }
  static equals(e, i) {
    return !e && !i ? !0 : !!e && !!i && e.lineNumber === i.lineNumber && e.column === i.column;
  }
  isBefore(e) {
    return Vo.isBefore(this, e);
  }
  static isBefore(e, i) {
    return e.lineNumber < i.lineNumber ? !0 : i.lineNumber < e.lineNumber ? !1 : e.column < i.column;
  }
  isBeforeOrEqual(e) {
    return Vo.isBeforeOrEqual(this, e);
  }
  static isBeforeOrEqual(e, i) {
    return e.lineNumber < i.lineNumber ? !0 : i.lineNumber < e.lineNumber ? !1 : e.column <= i.column;
  }
  static compare(e, i) {
    const n = e.lineNumber | 0, r = i.lineNumber | 0;
    if (n === r) {
      const s = e.column | 0, o = i.column | 0;
      return s - o;
    }
    return n - r;
  }
  clone() {
    return new Vo(this.lineNumber, this.column);
  }
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  static lift(e) {
    return new Vo(e.lineNumber, e.column);
  }
  static isIPosition(e) {
    return e && typeof e.lineNumber == "number" && typeof e.column == "number";
  }
  toJSON() {
    return {
      lineNumber: this.lineNumber,
      column: this.column
    };
  }
}, ut = class ci {
  constructor(e, i, n, r) {
    e > n || e === n && i > r ? (this.startLineNumber = n, this.startColumn = r, this.endLineNumber = e, this.endColumn = i) : (this.startLineNumber = e, this.startColumn = i, this.endLineNumber = n, this.endColumn = r);
  }
  isEmpty() {
    return ci.isEmpty(this);
  }
  static isEmpty(e) {
    return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
  }
  containsPosition(e) {
    return ci.containsPosition(this, e);
  }
  static containsPosition(e, i) {
    return !(i.lineNumber < e.startLineNumber || i.lineNumber > e.endLineNumber || i.lineNumber === e.startLineNumber && i.column < e.startColumn || i.lineNumber === e.endLineNumber && i.column > e.endColumn);
  }
  static strictContainsPosition(e, i) {
    return !(i.lineNumber < e.startLineNumber || i.lineNumber > e.endLineNumber || i.lineNumber === e.startLineNumber && i.column <= e.startColumn || i.lineNumber === e.endLineNumber && i.column >= e.endColumn);
  }
  containsRange(e) {
    return ci.containsRange(this, e);
  }
  static containsRange(e, i) {
    return !(i.startLineNumber < e.startLineNumber || i.endLineNumber < e.startLineNumber || i.startLineNumber > e.endLineNumber || i.endLineNumber > e.endLineNumber || i.startLineNumber === e.startLineNumber && i.startColumn < e.startColumn || i.endLineNumber === e.endLineNumber && i.endColumn > e.endColumn);
  }
  strictContainsRange(e) {
    return ci.strictContainsRange(this, e);
  }
  static strictContainsRange(e, i) {
    return !(i.startLineNumber < e.startLineNumber || i.endLineNumber < e.startLineNumber || i.startLineNumber > e.endLineNumber || i.endLineNumber > e.endLineNumber || i.startLineNumber === e.startLineNumber && i.startColumn <= e.startColumn || i.endLineNumber === e.endLineNumber && i.endColumn >= e.endColumn);
  }
  plusRange(e) {
    return ci.plusRange(this, e);
  }
  static plusRange(e, i) {
    let n, r, s, o;
    return i.startLineNumber < e.startLineNumber ? (n = i.startLineNumber, r = i.startColumn) : i.startLineNumber === e.startLineNumber ? (n = i.startLineNumber, r = Math.min(i.startColumn, e.startColumn)) : (n = e.startLineNumber, r = e.startColumn), i.endLineNumber > e.endLineNumber ? (s = i.endLineNumber, o = i.endColumn) : i.endLineNumber === e.endLineNumber ? (s = i.endLineNumber, o = Math.max(i.endColumn, e.endColumn)) : (s = e.endLineNumber, o = e.endColumn), new ci(n, r, s, o);
  }
  intersectRanges(e) {
    return ci.intersectRanges(this, e);
  }
  static intersectRanges(e, i) {
    let n = e.startLineNumber, r = e.startColumn, s = e.endLineNumber, o = e.endColumn;
    const a = i.startLineNumber, l = i.startColumn, c = i.endLineNumber, u = i.endColumn;
    return n < a ? (n = a, r = l) : n === a && (r = Math.max(r, l)), s > c ? (s = c, o = u) : s === c && (o = Math.min(o, u)), n > s || n === s && r > o ? null : new ci(
      n,
      r,
      s,
      o
    );
  }
  equalsRange(e) {
    return ci.equalsRange(this, e);
  }
  static equalsRange(e, i) {
    return !e && !i ? !0 : !!e && !!i && e.startLineNumber === i.startLineNumber && e.startColumn === i.startColumn && e.endLineNumber === i.endLineNumber && e.endColumn === i.endColumn;
  }
  getEndPosition() {
    return ci.getEndPosition(this);
  }
  static getEndPosition(e) {
    return new Pn(e.endLineNumber, e.endColumn);
  }
  getStartPosition() {
    return ci.getStartPosition(this);
  }
  static getStartPosition(e) {
    return new Pn(e.startLineNumber, e.startColumn);
  }
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  setEndPosition(e, i) {
    return new ci(this.startLineNumber, this.startColumn, e, i);
  }
  setStartPosition(e, i) {
    return new ci(e, i, this.endLineNumber, this.endColumn);
  }
  collapseToStart() {
    return ci.collapseToStart(this);
  }
  static collapseToStart(e) {
    return new ci(
      e.startLineNumber,
      e.startColumn,
      e.startLineNumber,
      e.startColumn
    );
  }
  collapseToEnd() {
    return ci.collapseToEnd(this);
  }
  static collapseToEnd(e) {
    return new ci(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn);
  }
  delta(e) {
    return new ci(
      this.startLineNumber + e,
      this.startColumn,
      this.endLineNumber + e,
      this.endColumn
    );
  }
  isSingleLine() {
    return this.startLineNumber === this.endLineNumber;
  }
  static fromPositions(e, i = e) {
    return new ci(e.lineNumber, e.column, i.lineNumber, i.column);
  }
  static lift(e) {
    return e ? new ci(
      e.startLineNumber,
      e.startColumn,
      e.endLineNumber,
      e.endColumn
    ) : null;
  }
  static isIRange(e) {
    return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
  }
  static areIntersectingOrTouching(e, i) {
    return !(e.endLineNumber < i.startLineNumber || e.endLineNumber === i.startLineNumber && e.endColumn < i.startColumn || i.endLineNumber < e.startLineNumber || i.endLineNumber === e.startLineNumber && i.endColumn < e.startColumn);
  }
  static areIntersecting(e, i) {
    return !(e.endLineNumber < i.startLineNumber || e.endLineNumber === i.startLineNumber && e.endColumn <= i.startColumn || i.endLineNumber < e.startLineNumber || i.endLineNumber === e.startLineNumber && i.endColumn <= e.startColumn);
  }
  static areOnlyIntersecting(e, i) {
    return !(e.endLineNumber < i.startLineNumber - 1 || e.endLineNumber === i.startLineNumber && e.endColumn < i.startColumn - 1 || i.endLineNumber < e.startLineNumber - 1 || i.endLineNumber === e.startLineNumber && i.endColumn < e.startColumn - 1);
  }
  static compareRangesUsingStarts(e, i) {
    if (e && i) {
      const s = e.startLineNumber | 0, o = i.startLineNumber | 0;
      if (s === o) {
        const a = e.startColumn | 0, l = i.startColumn | 0;
        if (a === l) {
          const c = e.endLineNumber | 0, u = i.endLineNumber | 0;
          if (c === u) {
            const d = e.endColumn | 0, f = i.endColumn | 0;
            return d - f;
          }
          return c - u;
        }
        return a - l;
      }
      return s - o;
    }
    return (e ? 1 : 0) - (i ? 1 : 0);
  }
  static compareRangesUsingEnds(e, i) {
    return e.endLineNumber === i.endLineNumber ? e.endColumn === i.endColumn ? e.startLineNumber === i.startLineNumber ? e.startColumn - i.startColumn : e.startLineNumber - i.startLineNumber : e.endColumn - i.endColumn : e.endLineNumber - i.endLineNumber;
  }
  static spansMultipleLines(e) {
    return e.endLineNumber > e.startLineNumber;
  }
  toJSON() {
    return this;
  }
};
var KS;
(function(t) {
  t[t.Null = 0] = "Null", t[t.PlainText = 1] = "PlainText";
})(KS || (KS = {}));
var JS;
(function(t) {
  t[t.NotSet = -1] = "NotSet", t[t.None = 0] = "None", t[t.Italic = 1] = "Italic", t[t.Bold = 2] = "Bold", t[t.Underline = 4] = "Underline", t[t.Strikethrough = 8] = "Strikethrough";
})(JS || (JS = {}));
var Jp;
(function(t) {
  t[t.None = 0] = "None", t[t.DefaultForeground = 1] = "DefaultForeground", t[t.DefaultBackground = 2] = "DefaultBackground";
})(Jp || (Jp = {}));
var Bl;
(function(t) {
  t[t.Other = 0] = "Other", t[t.Comment = 1] = "Comment", t[t.String = 2] = "String", t[t.RegEx = 3] = "RegEx";
})(Bl || (Bl = {}));
var YS;
(function(t) {
  t[t.LANGUAGEID_MASK = 255] = "LANGUAGEID_MASK", t[t.TOKEN_TYPE_MASK = 768] = "TOKEN_TYPE_MASK", t[t.BALANCED_BRACKETS_MASK = 1024] = "BALANCED_BRACKETS_MASK", t[t.FONT_STYLE_MASK = 30720] = "FONT_STYLE_MASK", t[t.FOREGROUND_MASK = 16744448] = "FOREGROUND_MASK", t[t.BACKGROUND_MASK = 4278190080] = "BACKGROUND_MASK", t[t.ITALIC_MASK = 2048] = "ITALIC_MASK", t[t.BOLD_MASK = 4096] = "BOLD_MASK", t[t.UNDERLINE_MASK = 8192] = "UNDERLINE_MASK", t[t.STRIKETHROUGH_MASK = 16384] = "STRIKETHROUGH_MASK", t[t.SEMANTIC_USE_ITALIC = 1] = "SEMANTIC_USE_ITALIC", t[t.SEMANTIC_USE_BOLD = 2] = "SEMANTIC_USE_BOLD", t[t.SEMANTIC_USE_UNDERLINE = 4] = "SEMANTIC_USE_UNDERLINE", t[t.SEMANTIC_USE_STRIKETHROUGH = 8] = "SEMANTIC_USE_STRIKETHROUGH", t[t.SEMANTIC_USE_FOREGROUND = 16] = "SEMANTIC_USE_FOREGROUND", t[t.SEMANTIC_USE_BACKGROUND = 32] = "SEMANTIC_USE_BACKGROUND", t[t.LANGUAGEID_OFFSET = 0] = "LANGUAGEID_OFFSET", t[t.TOKEN_TYPE_OFFSET = 8] = "TOKEN_TYPE_OFFSET", t[t.BALANCED_BRACKETS_OFFSET = 10] = "BALANCED_BRACKETS_OFFSET", t[t.FONT_STYLE_OFFSET = 11] = "FONT_STYLE_OFFSET", t[t.FOREGROUND_OFFSET = 15] = "FOREGROUND_OFFSET", t[t.BACKGROUND_OFFSET = 24] = "BACKGROUND_OFFSET";
})(YS || (YS = {}));
class W7 {
  constructor() {
    this._tokenizationSupports = /* @__PURE__ */ new Map(), this._factories = /* @__PURE__ */ new Map(), this._onDidChange = new N(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
  }
  handleChange(e) {
    this._onDidChange.fire({
      changedLanguages: e,
      changedColorMap: !1
    });
  }
  register(e, i) {
    return this._tokenizationSupports.set(e, i), this.handleChange([e]), Ee(() => {
      this._tokenizationSupports.get(e) === i && (this._tokenizationSupports.delete(e), this.handleChange([e]));
    });
  }
  get(e) {
    return this._tokenizationSupports.get(e) || null;
  }
  registerFactory(e, i) {
    this._factories.get(e)?.dispose();
    const n = new V7(this, e, i);
    return this._factories.set(e, n), Ee(() => {
      const r = this._factories.get(e);
      !r || r !== n || (this._factories.delete(e), r.dispose());
    });
  }
  async getOrCreate(e) {
    const i = this.get(e);
    if (i)
      return i;
    const n = this._factories.get(e);
    return !n || n.isResolved ? null : (await n.resolve(), this.get(e));
  }
  isResolved(e) {
    if (this.get(e))
      return !0;
    const n = this._factories.get(e);
    return !!(!n || n.isResolved);
  }
  setColorMap(e) {
    this._colorMap = e, this._onDidChange.fire({
      changedLanguages: Array.from(this._tokenizationSupports.keys()),
      changedColorMap: !0
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    return this._colorMap && this._colorMap.length > Jp.DefaultBackground ? this._colorMap[Jp.DefaultBackground] : null;
  }
}
class V7 extends ve {
  get isResolved() {
    return this._isResolved;
  }
  constructor(e, i, n) {
    super(), this._registry = e, this._languageId = i, this._factory = n, this._isDisposed = !1, this._resolvePromise = null, this._isResolved = !1;
  }
  dispose() {
    this._isDisposed = !0, super.dispose();
  }
  async resolve() {
    return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise;
  }
  async _create() {
    const e = await this._factory.tokenizationSupport;
    this._isResolved = !0, e && !this._isDisposed && this._register(this._registry.register(this._languageId, e));
  }
}
var XS;
(function(t) {
  t[t.Increase = 0] = "Increase", t[t.Decrease = 1] = "Decrease";
})(XS || (XS = {}));
var O;
(function(t) {
  t[t.Method = 0] = "Method", t[t.Function = 1] = "Function", t[t.Constructor = 2] = "Constructor", t[t.Field = 3] = "Field", t[t.Variable = 4] = "Variable", t[t.Class = 5] = "Class", t[t.Struct = 6] = "Struct", t[t.Interface = 7] = "Interface", t[t.Module = 8] = "Module", t[t.Property = 9] = "Property", t[t.Event = 10] = "Event", t[t.Operator = 11] = "Operator", t[t.Unit = 12] = "Unit", t[t.Value = 13] = "Value", t[t.Constant = 14] = "Constant", t[t.Enum = 15] = "Enum", t[t.EnumMember = 16] = "EnumMember", t[t.Keyword = 17] = "Keyword", t[t.Text = 18] = "Text", t[t.Color = 19] = "Color", t[t.File = 20] = "File", t[t.Reference = 21] = "Reference", t[t.Customcolor = 22] = "Customcolor", t[t.Folder = 23] = "Folder", t[t.TypeParameter = 24] = "TypeParameter", t[t.User = 25] = "User", t[t.Issue = 26] = "Issue", t[t.Tool = 27] = "Tool", t[t.Snippet = 28] = "Snippet";
})(O || (O = {}));
var ZS;
(function(t) {
  const e = /* @__PURE__ */ new Map();
  e.set(O.Method, ge.symbolMethod), e.set(O.Function, ge.symbolFunction), e.set(O.Constructor, ge.symbolConstructor), e.set(O.Field, ge.symbolField), e.set(O.Variable, ge.symbolVariable), e.set(O.Class, ge.symbolClass), e.set(O.Struct, ge.symbolStruct), e.set(O.Interface, ge.symbolInterface), e.set(O.Module, ge.symbolModule), e.set(O.Property, ge.symbolProperty), e.set(O.Event, ge.symbolEvent), e.set(O.Operator, ge.symbolOperator), e.set(O.Unit, ge.symbolUnit), e.set(O.Value, ge.symbolValue), e.set(O.Enum, ge.symbolEnum), e.set(O.Constant, ge.symbolConstant), e.set(O.Enum, ge.symbolEnum), e.set(O.EnumMember, ge.symbolEnumMember), e.set(O.Keyword, ge.symbolKeyword), e.set(O.Snippet, ge.symbolSnippet), e.set(O.Text, ge.symbolText), e.set(O.Color, ge.symbolColor), e.set(O.File, ge.symbolFile), e.set(O.Reference, ge.symbolReference), e.set(O.Customcolor, ge.symbolCustomColor), e.set(O.Folder, ge.symbolFolder), e.set(O.TypeParameter, ge.symbolTypeParameter), e.set(O.User, ge.account), e.set(O.Issue, ge.issues), e.set(O.Tool, ge.tools);
  function i(o) {
    let a = e.get(o);
    return a || (console.info("No codicon found for CompletionItemKind " + o), a = ge.symbolProperty), a;
  }
  t.toIcon = i;
  function n(o) {
    switch (o) {
      case O.Method:
        return h(786, "Method");
      case O.Function:
        return h(787, "Function");
      case O.Constructor:
        return h(788, "Constructor");
      case O.Field:
        return h(789, "Field");
      case O.Variable:
        return h(790, "Variable");
      case O.Class:
        return h(791, "Class");
      case O.Struct:
        return h(792, "Struct");
      case O.Interface:
        return h(793, "Interface");
      case O.Module:
        return h(794, "Module");
      case O.Property:
        return h(795, "Property");
      case O.Event:
        return h(796, "Event");
      case O.Operator:
        return h(797, "Operator");
      case O.Unit:
        return h(798, "Unit");
      case O.Value:
        return h(799, "Value");
      case O.Constant:
        return h(800, "Constant");
      case O.Enum:
        return h(801, "Enum");
      case O.EnumMember:
        return h(802, "Enum Member");
      case O.Keyword:
        return h(803, "Keyword");
      case O.Text:
        return h(804, "Text");
      case O.Color:
        return h(805, "Color");
      case O.File:
        return h(806, "File");
      case O.Reference:
        return h(807, "Reference");
      case O.Customcolor:
        return h(808, "Custom Color");
      case O.Folder:
        return h(809, "Folder");
      case O.TypeParameter:
        return h(810, "Type Parameter");
      case O.User:
        return h(811, "User");
      case O.Issue:
        return h(812, "Issue");
      case O.Tool:
        return h(813, "Tool");
      case O.Snippet:
        return h(814, "Snippet");
      default:
        return "";
    }
  }
  t.toLabel = n;
  const r = /* @__PURE__ */ new Map();
  r.set("method", O.Method), r.set("function", O.Function), r.set("constructor", O.Constructor), r.set("field", O.Field), r.set("variable", O.Variable), r.set("class", O.Class), r.set("struct", O.Struct), r.set("interface", O.Interface), r.set("module", O.Module), r.set("property", O.Property), r.set("event", O.Event), r.set("operator", O.Operator), r.set("unit", O.Unit), r.set("value", O.Value), r.set("constant", O.Constant), r.set("enum", O.Enum), r.set("enum-member", O.EnumMember), r.set("enumMember", O.EnumMember), r.set("keyword", O.Keyword), r.set("snippet", O.Snippet), r.set("text", O.Text), r.set("color", O.Color), r.set("file", O.File), r.set("reference", O.Reference), r.set("customcolor", O.Customcolor), r.set("folder", O.Folder), r.set("type-parameter", O.TypeParameter), r.set("typeParameter", O.TypeParameter), r.set("account", O.User), r.set("issue", O.Issue), r.set("tool", O.Tool);
  function s(o, a) {
    let l = r.get(o);
    return typeof l > "u" && !a && (l = O.Property), l;
  }
  t.fromString = s;
})(ZS || (ZS = {}));
var Yp;
(function(t) {
  t[t.Deprecated = 1] = "Deprecated";
})(Yp || (Yp = {}));
var Ia;
(function(t) {
  t[t.None = 0] = "None", t[t.KeepWhitespace = 1] = "KeepWhitespace", t[t.InsertAsSnippet = 4] = "InsertAsSnippet";
})(Ia || (Ia = {}));
var ud;
(function(t) {
  t[t.Word = 0] = "Word", t[t.Line = 1] = "Line", t[t.Suggest = 2] = "Suggest";
})(ud || (ud = {}));
var dd;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.TriggerCharacter = 1] = "TriggerCharacter", t[t.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
})(dd || (dd = {}));
var Xp;
(function(t) {
  t[t.Automatic = 0] = "Automatic", t[t.Explicit = 1] = "Explicit";
})(Xp || (Xp = {}));
var Zp;
(function(t) {
  t[t.Accepted = 0] = "Accepted", t[t.Rejected = 1] = "Rejected", t[t.Ignored = 2] = "Ignored";
})(Zp || (Zp = {}));
var eg;
(function(t) {
  t[t.Invoke = 1] = "Invoke", t[t.Auto = 2] = "Auto";
})(eg || (eg = {}));
var e2;
(function(t) {
  t[t.Automatic = 0] = "Automatic", t[t.PasteAs = 1] = "PasteAs";
})(e2 || (e2 = {}));
var t2;
(function(t) {
  t[t.Invoke = 1] = "Invoke", t[t.TriggerCharacter = 2] = "TriggerCharacter", t[t.ContentChange = 3] = "ContentChange";
})(t2 || (t2 = {}));
var i2;
(function(t) {
  t[t.Text = 0] = "Text", t[t.Read = 1] = "Read", t[t.Write = 2] = "Write";
})(i2 || (i2 = {}));
function z7(t) {
  return t && x.isUri(t.uri) && ut.isIRange(t.range) && (ut.isIRange(t.originSelectionRange) || ut.isIRange(t.targetSelectionRange));
}
function q7(t) {
  return t && x.isUri(t.uri) && ut.isIRange(t.range);
}
var G;
(function(t) {
  t[t.File = 0] = "File", t[t.Module = 1] = "Module", t[t.Namespace = 2] = "Namespace", t[t.Package = 3] = "Package", t[t.Class = 4] = "Class", t[t.Method = 5] = "Method", t[t.Property = 6] = "Property", t[t.Field = 7] = "Field", t[t.Constructor = 8] = "Constructor", t[t.Enum = 9] = "Enum", t[t.Interface = 10] = "Interface", t[t.Function = 11] = "Function", t[t.Variable = 12] = "Variable", t[t.Constant = 13] = "Constant", t[t.String = 14] = "String", t[t.Number = 15] = "Number", t[t.Boolean = 16] = "Boolean", t[t.Array = 17] = "Array", t[t.Object = 18] = "Object", t[t.Key = 19] = "Key", t[t.Null = 20] = "Null", t[t.EnumMember = 21] = "EnumMember", t[t.Struct = 22] = "Struct", t[t.Event = 23] = "Event", t[t.Operator = 24] = "Operator", t[t.TypeParameter = 25] = "TypeParameter";
})(G || (G = {}));
G.Array + "", h(815, "array"), G.Boolean + "", h(816, "boolean"), G.Class + "", h(817, "class"), G.Constant + "", h(818, "constant"), G.Constructor + "", h(819, "constructor"), G.Enum + "", h(820, "enumeration"), G.EnumMember + "", h(821, "enumeration member"), G.Event + "", h(822, "event"), G.Field + "", h(823, "field"), G.File + "", h(824, "file"), G.Function + "", h(825, "function"), G.Interface + "", h(826, "interface"), G.Key + "", h(827, "key"), G.Method + "", h(828, "method"), G.Module + "", h(829, "module"), G.Namespace + "", h(830, "namespace"), G.Null + "", h(831, "null"), G.Number + "", h(832, "number"), G.Object + "", h(833, "object"), G.Operator + "", h(834, "operator"), G.Package + "", h(835, "package"), G.Property + "", h(836, "property"), G.String + "", h(837, "string"), G.Struct + "", h(838, "struct"), G.TypeParameter + "", h(839, "type parameter"), G.Variable + "", h(840, "variable");
var tg;
(function(t) {
  t[t.Deprecated = 1] = "Deprecated";
})(tg || (tg = {}));
var n2;
(function(t) {
  const e = /* @__PURE__ */ new Map();
  e.set(G.File, ge.symbolFile), e.set(G.Module, ge.symbolModule), e.set(G.Namespace, ge.symbolNamespace), e.set(G.Package, ge.symbolPackage), e.set(G.Class, ge.symbolClass), e.set(G.Method, ge.symbolMethod), e.set(G.Property, ge.symbolProperty), e.set(G.Field, ge.symbolField), e.set(G.Constructor, ge.symbolConstructor), e.set(G.Enum, ge.symbolEnum), e.set(G.Interface, ge.symbolInterface), e.set(G.Function, ge.symbolFunction), e.set(G.Variable, ge.symbolVariable), e.set(G.Constant, ge.symbolConstant), e.set(G.String, ge.symbolString), e.set(G.Number, ge.symbolNumber), e.set(G.Boolean, ge.symbolBoolean), e.set(G.Array, ge.symbolArray), e.set(G.Object, ge.symbolObject), e.set(G.Key, ge.symbolKey), e.set(G.Null, ge.symbolNull), e.set(G.EnumMember, ge.symbolEnumMember), e.set(G.Struct, ge.symbolStruct), e.set(G.Event, ge.symbolEvent), e.set(G.Operator, ge.symbolOperator), e.set(G.TypeParameter, ge.symbolTypeParameter);
  function i(s) {
    let o = e.get(s);
    return o || (console.info("No codicon found for SymbolKind " + s), o = ge.symbolProperty), o;
  }
  t.toIcon = i;
  const n = /* @__PURE__ */ new Map();
  n.set(G.File, O.File), n.set(G.Module, O.Module), n.set(G.Namespace, O.Module), n.set(G.Package, O.Module), n.set(G.Class, O.Class), n.set(G.Method, O.Method), n.set(G.Property, O.Property), n.set(G.Field, O.Field), n.set(G.Constructor, O.Constructor), n.set(G.Enum, O.Enum), n.set(G.Interface, O.Interface), n.set(G.Function, O.Function), n.set(G.Variable, O.Variable), n.set(G.Constant, O.Constant), n.set(G.String, O.Text), n.set(G.Number, O.Value), n.set(G.Boolean, O.Value), n.set(G.Array, O.Value), n.set(G.Object, O.Value), n.set(G.Key, O.Keyword), n.set(G.Null, O.Value), n.set(G.EnumMember, O.EnumMember), n.set(G.Struct, O.Struct), n.set(G.Event, O.Event), n.set(G.Operator, O.Operator), n.set(G.TypeParameter, O.TypeParameter);
  function r(s) {
    let o = n.get(s);
    return o === void 0 && (console.info("No completion kind found for SymbolKind " + s), o = O.File), o;
  }
  t.toCompletionKind = r;
})(n2 || (n2 = {}));
var Xi;
let kl = (Xi = class {
  static fromValue(e) {
    switch (e) {
      case "comment":
        return Xi.Comment;
      case "imports":
        return Xi.Imports;
      case "region":
        return Xi.Region;
    }
    return new Xi(e);
  }
  constructor(e) {
    this.value = e;
  }
}, Xi.Comment = new Xi("comment"), Xi.Imports = new Xi("imports"), Xi.Region = new Xi("region"), Xi);
var r2;
(function(t) {
  t[t.AIGenerated = 1] = "AIGenerated";
})(r2 || (r2 = {}));
var ig;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})(ig || (ig = {}));
var Gv;
(function(t) {
  function e(i) {
    return !i || typeof i != "object" ? !1 : typeof i.id == "string" && typeof i.title == "string";
  }
  t.is = e;
})(Gv || (Gv = {}));
var Wl;
(function(t) {
  t[t.Collapsed = 0] = "Collapsed", t[t.Expanded = 1] = "Expanded";
})(Wl || (Wl = {}));
var hd;
(function(t) {
  t[t.Unresolved = 0] = "Unresolved", t[t.Resolved = 1] = "Resolved";
})(hd || (hd = {}));
var fd;
(function(t) {
  t[t.Current = 0] = "Current", t[t.Outdated = 1] = "Outdated";
})(fd || (fd = {}));
var s2;
(function(t) {
  t[t.Editing = 0] = "Editing", t[t.Preview = 1] = "Preview";
})(s2 || (s2 = {}));
var o2;
(function(t) {
  t[t.Published = 0] = "Published", t[t.Draft = 1] = "Draft";
})(o2 || (o2 = {}));
var a2;
(function(t) {
  t[t.Type = 1] = "Type", t[t.Parameter = 2] = "Parameter";
})(a2 || (a2 = {}));
new W7();
var l2;
(function(t) {
  t[t.None = 0] = "None", t[t.Option = 1] = "Option", t[t.Default = 2] = "Default", t[t.Preferred = 3] = "Preferred";
})(l2 || (l2 = {}));
var Qv;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Center = 2] = "Center", t[t.Right = 4] = "Right", t[t.Full = 7] = "Full";
})(Qv || (Qv = {}));
var c2;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Center = 2] = "Center", t[t.Right = 3] = "Right";
})(c2 || (c2 = {}));
var u2;
(function(t) {
  t[t.Inline = 1] = "Inline", t[t.Gutter = 2] = "Gutter";
})(u2 || (u2 = {}));
var d2;
(function(t) {
  t[t.Normal = 1] = "Normal", t[t.Underlined = 2] = "Underlined";
})(d2 || (d2 = {}));
var h2;
(function(t) {
  t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL";
})(h2 || (h2 = {}));
var f2;
(function(t) {
  t[t.Both = 0] = "Both", t[t.Right = 1] = "Right", t[t.Left = 2] = "Left", t[t.None = 3] = "None";
})(f2 || (f2 = {}));
var fs;
(function(t) {
  t[t.TextDefined = 0] = "TextDefined", t[t.LF = 1] = "LF", t[t.CRLF = 2] = "CRLF";
})(fs || (fs = {}));
var Kd;
(function(t) {
  t[t.LF = 1] = "LF", t[t.CRLF = 2] = "CRLF";
})(Kd || (Kd = {}));
var Vl;
(function(t) {
  t[t.LF = 0] = "LF", t[t.CRLF = 1] = "CRLF";
})(Vl || (Vl = {}));
class Kv {
  constructor(e, i) {
    this._findMatchBrand = void 0, this.range = e, this.matches = i;
  }
}
var zl;
(function(t) {
  t[t.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", t[t.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", t[t.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", t[t.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
})(zl || (zl = {}));
var p2;
(function(t) {
  t[t.Left = 0] = "Left", t[t.Right = 1] = "Right", t[t.None = 2] = "None", t[t.LeftOfInjectedText = 3] = "LeftOfInjectedText", t[t.RightOfInjectedText = 4] = "RightOfInjectedText";
})(p2 || (p2 = {}));
var ng;
(function(t) {
  t[t.FIRST_LINE_DETECTION_LENGTH_LIMIT = 1e3] = "FIRST_LINE_DETECTION_LENGTH_LIMIT";
})(ng || (ng = {}));
class j7 {
  constructor(e, i, n) {
    this.regex = e, this.wordSeparators = i, this.simpleSearch = n;
  }
}
class G7 {
  constructor(e, i, n) {
    this.reverseEdits = e, this.changes = i, this.trimAutoWhitespaceLineNumbers = n;
  }
}
var ql;
(function(t) {
  t[t.Unnecessary = 1] = "Unnecessary", t[t.Deprecated = 2] = "Deprecated";
})(ql || (ql = {}));
var en;
(function(t) {
  t[t.Hint = 1] = "Hint", t[t.Info = 2] = "Info", t[t.Warning = 4] = "Warning", t[t.Error = 8] = "Error";
})(en || (en = {}));
(function(t) {
  function e(l, c) {
    return c - l;
  }
  t.compare = e;
  const i = /* @__PURE__ */ Object.create(null);
  i[t.Error] = h(1960, "Error"), i[t.Warning] = h(1961, "Warning"), i[t.Info] = h(1962, "Info");
  function n(l) {
    return i[l] || "";
  }
  t.toString = n;
  const r = /* @__PURE__ */ Object.create(null);
  r[t.Error] = h(1963, "Errors"), r[t.Warning] = h(1964, "Warnings"), r[t.Info] = h(1965, "Infos");
  function s(l) {
    return r[l] || "";
  }
  t.toStringPlural = s;
  function o(l) {
    switch (l) {
      case Qt.Error:
        return t.Error;
      case Qt.Warning:
        return t.Warning;
      case Qt.Info:
        return t.Info;
      case Qt.Ignore:
        return t.Hint;
    }
  }
  t.fromSeverity = o;
  function a(l) {
    switch (l) {
      case t.Error:
        return Qt.Error;
      case t.Warning:
        return Qt.Warning;
      case t.Info:
        return Qt.Info;
      case t.Hint:
        return Qt.Ignore;
    }
  }
  t.toSeverity = a;
})(en || (en = {}));
var g2;
(function(t) {
  const e = "";
  function i(r) {
    return n(r, !0);
  }
  t.makeKey = i;
  function n(r, s) {
    const o = [e];
    return r.source ? o.push(r.source.replace("¦", "\\¦")) : o.push(e), r.code ? typeof r.code == "string" ? o.push(r.code.replace("¦", "\\¦")) : o.push(r.code.value.replace("¦", "\\¦")) : o.push(e), r.severity !== void 0 && r.severity !== null ? o.push(en.toString(r.severity)) : o.push(e), r.message && s ? o.push(r.message.replace("¦", "\\¦")) : o.push(e), r.startLineNumber !== void 0 && r.startLineNumber !== null ? o.push(r.startLineNumber.toString()) : o.push(e), r.startColumn !== void 0 && r.startColumn !== null ? o.push(r.startColumn.toString()) : o.push(e), r.endLineNumber !== void 0 && r.endLineNumber !== null ? o.push(r.endLineNumber.toString()) : o.push(e), r.endColumn !== void 0 && r.endColumn !== null ? o.push(r.endColumn.toString()) : o.push(e), o.push(e), o.join("¦");
  }
  t.makeKeyOptionalMessage = n;
})(g2 || (g2 = {}));
const Q7 = pe("progressService");
pe("editorProgressService");
var pd;
(function(t) {
  t[t.Explorer = 1] = "Explorer", t[t.Scm = 3] = "Scm", t[t.Extensions = 5] = "Extensions", t[t.Window = 10] = "Window", t[t.Notification = 15] = "Notification", t[t.Dialog = 20] = "Dialog";
})(pd || (pd = {}));
const FE = class FE {
  get value() {
    return this._value;
  }
  constructor(e) {
    this.callback = e;
  }
  report(e) {
    this._value = e, this.callback(this._value);
  }
};
FE.None = Object.freeze({ report() {
} });
let Jd = FE, m2 = class extends ve {
  constructor(e, i) {
    super(), this.deferred = new ko(), i.withProgress(e, (n) => (this.reporter = n, this.lastStep && n.report(this.lastStep), this.deferred.p)), this._register(Ee(() => this.deferred.complete()));
  }
  report(e) {
    this.reporter ? this.reporter.report(e) : this.lastStep = e;
  }
};
m2 = W([
  M(1, Q7)
], m2);
class K7 {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  add(e, i) {
    Wi(it(e)), Wi(ri(i)), Wi(!this.data.has(e), "There is already an extension with this id"), this.data.set(e, i);
  }
  knows(e) {
    return this.data.has(e);
  }
  as(e) {
    return this.data.get(e) || null;
  }
  dispose() {
    this.data.forEach((e) => {
      r4(e.dispose) && e.dispose();
    }), this.data.clear();
  }
}
const ai = new K7();
function W1(t, e) {
  return e && (t.stack || t.stacktrace) ? h(
    105,
    "{0}: {1}",
    v2(t),
    _2(t.stack) || _2(t.stacktrace)
  ) : v2(t);
}
function _2(t) {
  return Array.isArray(t) ? t.join(`
`) : t;
}
function v2(t) {
  return t.code === "ERR_UNC_HOST_NOT_ALLOWED" ? `${t.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.` : typeof t.code == "string" && typeof t.errno == "number" && typeof t.syscall == "string" ? h(106, "A system error occurred ({0})", t.message) : t.message || h(107, "An unknown error occurred. Please consult the log for more details.");
}
function xu(t = null, e = !1) {
  if (!t)
    return h(107, "An unknown error occurred. Please consult the log for more details.");
  if (Array.isArray(t)) {
    const i = Kt(t), n = xu(i[0], e);
    return i.length > 1 ? h(108, "{0} ({1} errors in total)", n, i.length) : n;
  }
  if (it(t))
    return t;
  if (t.detail) {
    const i = t.detail;
    if (i.error)
      return W1(i.error, e);
    if (i.exception)
      return W1(i.exception, e);
  }
  return t.stack ? W1(t, e) : t.message ? t.message : h(107, "An unknown error occurred. Please consult the log for more details.");
}
class J7 extends ve {
  constructor(e, i = "", n = "", r = !0, s) {
    super(), this._onDidChange = this._register(new N()), this.onDidChange = this._onDidChange.event, this._enabled = !0, this._id = e, this._label = i, this._cssClass = n, this._enabled = r, this._actionCallback = s;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._setLabel(e);
  }
  _setLabel(e) {
    this._label !== e && (this._label = e, this._onDidChange.fire({ label: e }));
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(e) {
    this._setTooltip(e);
  }
  _setTooltip(e) {
    this._tooltip !== e && (this._tooltip = e, this._onDidChange.fire({ tooltip: e }));
  }
  get class() {
    return this._cssClass;
  }
  set class(e) {
    this._setClass(e);
  }
  _setClass(e) {
    this._cssClass !== e && (this._cssClass = e, this._onDidChange.fire({ class: e }));
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._setEnabled(e);
  }
  _setEnabled(e) {
    this._enabled !== e && (this._enabled = e, this._onDidChange.fire({ enabled: e }));
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._setChecked(e);
  }
  _setChecked(e) {
    this._checked !== e && (this._checked = e, this._onDidChange.fire({ checked: e }));
  }
  async run(e, i) {
    this._actionCallback && await this._actionCallback(e);
  }
}
const m_ = class m_ extends J7 {
  constructor() {
    super(m_.ID, h(43, "(empty)"), void 0, !1);
  }
};
m_.ID = "vs.actions.empty";
let w2 = m_;
const Y7 = {
  EditorFactory: "workbench.contributions.editor.inputFactories"
}, X7 = {
  id: "default",
  displayName: h(3938, "Text Editor"),
  providerDisplayName: h(3939, "Built-in")
}, Z7 = "workbench.editors.textDiffEditor", e3 = "workbench.editors.binaryResourceDiffEditor";
var b2;
(function(t) {
  t[t.PROGRAMMATIC = 1] = "PROGRAMMATIC", t[t.USER = 2] = "USER", t[t.EDIT = 3] = "EDIT", t[t.NAVIGATION = 4] = "NAVIGATION", t[t.JUMP = 5] = "JUMP";
})(b2 || (b2 = {}));
var y2;
(function(t) {
  t[t.IDENTICAL = 1] = "IDENTICAL", t[t.SIMILAR = 2] = "SIMILAR", t[t.DIFFERENT = 3] = "DIFFERENT";
})(y2 || (y2 = {}));
function V1(t, e, i) {
  for (const n of i.visibleEditorPanes)
    if (n.group.id === e && t.matches(n.input))
      return n.getViewState();
}
function t3(t) {
  if (_r(t))
    return !1;
  const e = t;
  return x.isUri(e?.resource);
}
function ks(t) {
  if (_r(t))
    return !1;
  const e = t;
  return e?.original !== void 0 && e.modified !== void 0;
}
function gd(t) {
  if (_r(t))
    return !1;
  const e = t;
  return !e || e.resources && !Array.isArray(e.resources) ? !1 : !!e.resources || !!e.multiDiffSource;
}
function ua(t) {
  if (_r(t) || ks(t))
    return !1;
  const e = t;
  return e?.primary !== void 0 && e.secondary !== void 0;
}
function da(t) {
  if (_r(t))
    return !1;
  const e = t;
  return x.isUri(e?.base?.resource) && x.isUri(e?.input1?.resource) && x.isUri(e?.input2?.resource) && x.isUri(e?.result?.resource);
}
var Xt;
(function(t) {
  t[t.SHORT = 0] = "SHORT", t[t.MEDIUM = 1] = "MEDIUM", t[t.LONG = 2] = "LONG";
})(Xt || (Xt = {}));
var jl;
(function(t) {
  t[t.EXPLICIT = 1] = "EXPLICIT", t[t.AUTO = 2] = "AUTO", t[t.FOCUS_CHANGE = 3] = "FOCUS_CHANGE", t[t.WINDOW_CHANGE = 4] = "WINDOW_CHANGE";
})(jl || (jl = {}));
var In;
(function(t) {
  t[t.None = 0] = "None", t[t.Readonly = 2] = "Readonly", t[t.Untitled = 4] = "Untitled", t[t.Singleton = 8] = "Singleton", t[t.RequiresTrust = 16] = "RequiresTrust", t[t.CanSplitInGroup = 32] = "CanSplitInGroup", t[t.ForceDescription = 64] = "ForceDescription", t[t.CanDropIntoEditor = 128] = "CanDropIntoEditor", t[t.MultipleEditors = 256] = "MultipleEditors", t[t.Scratchpad = 512] = "Scratchpad";
})(In || (In = {}));
class yT extends ve {
}
function _r(t) {
  return t instanceof yT;
}
function i3(t) {
  const e = t;
  return x.isUri(e?.preferredResource);
}
function n3(t) {
  const e = t;
  return _r(e?.primary) && _r(e?.secondary);
}
function xT(t) {
  const e = t;
  return _r(e?.modified) && _r(e?.original);
}
var x2;
(function(t) {
  t[t.UNKNOWN = 0] = "UNKNOWN", t[t.REPLACE = 1] = "REPLACE", t[t.MOVE = 2] = "MOVE", t[t.UNPIN = 3] = "UNPIN";
})(x2 || (x2 = {}));
var E2;
(function(t) {
  t[t.GROUP_ACTIVE = 0] = "GROUP_ACTIVE", t[t.GROUP_INDEX = 1] = "GROUP_INDEX", t[t.GROUP_LABEL = 2] = "GROUP_LABEL", t[t.GROUP_LOCKED = 3] = "GROUP_LOCKED", t[t.EDITORS_SELECTION = 4] = "EDITORS_SELECTION", t[t.EDITOR_OPEN = 5] = "EDITOR_OPEN", t[t.EDITOR_CLOSE = 6] = "EDITOR_CLOSE", t[t.EDITOR_MOVE = 7] = "EDITOR_MOVE", t[t.EDITOR_ACTIVE = 8] = "EDITOR_ACTIVE", t[t.EDITOR_LABEL = 9] = "EDITOR_LABEL", t[t.EDITOR_CAPABILITIES = 10] = "EDITOR_CAPABILITIES", t[t.EDITOR_PIN = 11] = "EDITOR_PIN", t[t.EDITOR_TRANSIENT = 12] = "EDITOR_TRANSIENT", t[t.EDITOR_STICKY = 13] = "EDITOR_STICKY", t[t.EDITOR_DIRTY = 14] = "EDITOR_DIRTY", t[t.EDITOR_WILL_DISPOSE = 15] = "EDITOR_WILL_DISPOSE";
})(E2 || (E2 = {}));
var Ys;
(function(t) {
  t[t.PRIMARY = 1] = "PRIMARY", t[t.SECONDARY = 2] = "SECONDARY", t[t.BOTH = 3] = "BOTH", t[t.ANY = 4] = "ANY";
})(Ys || (Ys = {}));
class r3 {
  getOriginalUri(e, i) {
    if (!e)
      return;
    if (da(e))
      return Jv.getOriginalUri(e.result, i);
    if (i?.supportSideBySide) {
      const { primary: r, secondary: s } = this.getSideEditors(e);
      if (r && s) {
        if (i?.supportSideBySide === Ys.BOTH)
          return {
            primary: this.getOriginalUri(r, { filterByScheme: i.filterByScheme }),
            secondary: this.getOriginalUri(s, { filterByScheme: i.filterByScheme })
          };
        if (i?.supportSideBySide === Ys.ANY)
          return this.getOriginalUri(r, { filterByScheme: i.filterByScheme }) ?? this.getOriginalUri(s, { filterByScheme: i.filterByScheme });
        e = i.supportSideBySide === Ys.PRIMARY ? r : s;
      }
    }
    if (ks(e) || gd(e) || ua(e) || da(e))
      return;
    const n = i3(e) ? e.preferredResource : e.resource;
    return !n || !i || !i.filterByScheme ? n : this.filterUri(n, i.filterByScheme);
  }
  getSideEditors(e) {
    return n3(e) || ua(e) ? { primary: e.primary, secondary: e.secondary } : xT(e) || ks(e) ? { primary: e.modified, secondary: e.original } : { primary: void 0, secondary: void 0 };
  }
  getCanonicalUri(e, i) {
    if (!e)
      return;
    if (da(e))
      return Jv.getCanonicalUri(e.result, i);
    if (i?.supportSideBySide) {
      const { primary: r, secondary: s } = this.getSideEditors(e);
      if (r && s) {
        if (i?.supportSideBySide === Ys.BOTH)
          return {
            primary: this.getCanonicalUri(r, { filterByScheme: i.filterByScheme }),
            secondary: this.getCanonicalUri(s, { filterByScheme: i.filterByScheme })
          };
        if (i?.supportSideBySide === Ys.ANY)
          return this.getCanonicalUri(r, { filterByScheme: i.filterByScheme }) ?? this.getCanonicalUri(s, { filterByScheme: i.filterByScheme });
        e = i.supportSideBySide === Ys.PRIMARY ? r : s;
      }
    }
    if (ks(e) || gd(e) || ua(e) || da(e))
      return;
    const n = e.resource;
    return !n || !i || !i.filterByScheme ? n : this.filterUri(n, i.filterByScheme);
  }
  filterUri(e, i) {
    if (Array.isArray(i)) {
      if (i.some((n) => e.scheme === n))
        return e;
    } else if (i === e.scheme)
      return e;
  }
}
var S2;
(function(t) {
  t[t.UNKNOWN = 0] = "UNKNOWN", t[t.KEYBOARD = 1] = "KEYBOARD", t[t.MOUSE = 2] = "MOUSE";
})(S2 || (S2 = {}));
const Jv = new r3();
var D2;
(function(t) {
  t[t.LEFT = 0] = "LEFT", t[t.RIGHT = 1] = "RIGHT";
})(D2 || (D2 = {}));
class s3 {
  constructor() {
    this.editorSerializerConstructors = /* @__PURE__ */ new Map(), this.editorSerializerInstances = /* @__PURE__ */ new Map();
  }
  start(e) {
    const i = this.instantiationService = e.get(uf);
    for (const [n, r] of this.editorSerializerConstructors)
      this.createEditorSerializer(n, r, i);
    this.editorSerializerConstructors.clear();
  }
  createEditorSerializer(e, i, n) {
    const r = n.createInstance(i);
    this.editorSerializerInstances.set(e, r);
  }
  registerFileEditorFactory(e) {
    if (this.fileEditorFactory)
      throw new Error("Can only register one file editor factory.");
    this.fileEditorFactory = e;
  }
  getFileEditorFactory() {
    return Fc(this.fileEditorFactory);
  }
  registerEditorSerializer(e, i) {
    if (this.editorSerializerConstructors.has(e) || this.editorSerializerInstances.has(e))
      throw new Error(
        `A editor serializer with type ID '${e}' was already registered.`
      );
    return this.instantiationService ? this.createEditorSerializer(e, i, this.instantiationService) : this.editorSerializerConstructors.set(e, i), Ee(() => {
      this.editorSerializerConstructors.delete(e), this.editorSerializerInstances.delete(e);
    });
  }
  getEditorSerializer(e) {
    return this.editorSerializerInstances.get(typeof e == "string" ? e : e.typeId);
  }
}
ai.add(Y7.EditorFactory, new s3());
var k2;
(function(t) {
  t[t.MOST_RECENTLY_ACTIVE = 0] = "MOST_RECENTLY_ACTIVE", t[t.SEQUENTIAL = 1] = "SEQUENTIAL";
})(k2 || (k2 = {}));
var I2;
(function(t) {
  t[t.NotOmitted = 0] = "NotOmitted", t[t.Partial = 1] = "Partial", t[t.Full = 2] = "Full";
})(I2 || (I2 = {}));
var C2;
(function(t) {
  t.icon = ge.error;
  function e(s) {
    return {
      filterUri: s.resource,
      owner: s.owner,
      problemMessage: s.message,
      filterRange: { startLineNumber: s.startLineNumber, endLineNumber: s.endLineNumber, startColumn: s.startColumn, endColumn: s.endColumn }
    };
  }
  t.fromMarker = e;
  function i(s) {
    return {
      id: n(s),
      name: r(s),
      icon: t.icon,
      value: s,
      kind: "diagnostic",
      ...s
    };
  }
  t.toEntry = i;
  function n(s) {
    return [s.filterUri, s.owner, s.filterSeverity, s.filterRange?.startLineNumber].join(":");
  }
  t.id = n;
  function r(s) {
    let o;
    if (function(l) {
      l[l.MaxChars = 30] = "MaxChars", l[l.MaxSpaceLookback = 10] = "MaxSpaceLookback";
    }(o || (o = {})), s.problemMessage) {
      if (s.problemMessage.length < o.MaxChars)
        return s.problemMessage;
      const l = s.problemMessage.lastIndexOf(" ", o.MaxChars);
      return l === -1 || l + o.MaxSpaceLookback < o.MaxChars ? s.problemMessage.substring(0, o.MaxChars) + "…" : s.problemMessage.substring(0, l) + "…";
    }
    let a = h(5420, "All Problems");
    return s.filterUri && (a = h(5421, "Problems in {0}", Fs(s.filterUri))), a;
  }
  t.label = r;
})(C2 || (C2 = {}));
var T2;
(function(t) {
  function e(i) {
    return x.isUri(i.value) ? i.value : q7(i.value) ? i.value.uri : void 0;
  }
  t.toUri = e;
})(T2 || (T2 = {}));
function o3(t) {
  return t.kind === "image";
}
var P2;
(function(t) {
  t.Instruction = "vscode.prompt.instructions.root", t.InstructionReference = "vscode.prompt.instructions", t.PromptFile = "vscode.prompt.file";
})(P2 || (P2 = {}));
const Wx = pe("contextKeyService");
var md;
(function(t) {
  t[t.STORAGE_DOES_NOT_EXIST = 0] = "STORAGE_DOES_NOT_EXIST", t[t.STORAGE_IN_MEMORY = 1] = "STORAGE_IN_MEMORY";
})(md || (md = {}));
var er;
(function(t) {
  t[t.None = 0] = "None", t[t.Initialized = 1] = "Initialized", t[t.Closed = 2] = "Closed";
})(er || (er = {}));
const __ = class __ extends ve {
  constructor(e, i = /* @__PURE__ */ Object.create(null)) {
    super(), this.database = e, this.options = i, this._onDidChangeStorage = this._register(new Rp()), this.onDidChangeStorage = this._onDidChangeStorage.event, this.state = er.None, this.cache = /* @__PURE__ */ new Map(), this.flushDelayer = this._register(new F4(__.DEFAULT_FLUSH_DELAY)), this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.pendingClose = void 0, this.whenFlushedCallbacks = [], this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    this._onDidChangeStorage.pause();
    try {
      e.changed?.forEach((i, n) => this.acceptExternal(n, i)), e.deleted?.forEach((i) => this.acceptExternal(i, void 0));
    } finally {
      this._onDidChangeStorage.resume();
    }
  }
  acceptExternal(e, i) {
    if (this.state === er.Closed)
      return;
    let n = !1;
    ni(i) ? n = this.cache.delete(e) : this.cache.get(e) !== i && (this.cache.set(e, i), n = !0), n && this._onDidChangeStorage.fire({ key: e, external: !0 });
  }
  get items() {
    return this.cache;
  }
  get size() {
    return this.cache.size;
  }
  async init() {
    this.state === er.None && (this.state = er.Initialized, this.options.hint !== md.STORAGE_DOES_NOT_EXIST && (this.cache = await this.database.getItems()));
  }
  get(e, i) {
    const n = this.cache.get(e);
    return ni(n) ? i : n;
  }
  getBoolean(e, i) {
    const n = this.get(e);
    return ni(n) ? i : n === "true";
  }
  getNumber(e, i) {
    const n = this.get(e);
    return ni(n) ? i : parseInt(n, 10);
  }
  getObject(e, i) {
    const n = this.get(e);
    return ni(n) ? i : fT(n);
  }
  async set(e, i, n = !1) {
    if (this.state === er.Closed)
      return;
    if (ni(i))
      return this.delete(e, n);
    const r = ri(i) || Array.isArray(i) ? CL(i) : String(i);
    if (this.cache.get(e) !== r)
      return this.cache.set(e, r), this.pendingInserts.set(e, r), this.pendingDeletes.delete(e), this._onDidChangeStorage.fire({ key: e, external: n }), this.doFlush();
  }
  async delete(e, i = !1) {
    if (!(this.state === er.Closed || !this.cache.delete(e)))
      return this.pendingDeletes.has(e) || this.pendingDeletes.add(e), this.pendingInserts.delete(e), this._onDidChangeStorage.fire({ key: e, external: i }), this.doFlush();
  }
  async optimize() {
    if (this.state !== er.Closed)
      return await this.flush(0), this.database.optimize();
  }
  async close() {
    return this.pendingClose || (this.pendingClose = this.doClose()), this.pendingClose;
  }
  async doClose() {
    this.state = er.Closed;
    try {
      await this.doFlush(0);
    } catch {
    }
    await this.database.close(() => this.cache);
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  async flushPending() {
    if (!this.hasPending)
      return;
    const e = { insert: this.pendingInserts, delete: this.pendingDeletes };
    return this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.database.updateItems(e).finally(() => {
      if (!this.hasPending)
        for (; this.whenFlushedCallbacks.length; )
          this.whenFlushedCallbacks.pop()?.();
    });
  }
  async flush(e) {
    if (!(this.state === er.Closed || this.pendingClose))
      return this.doFlush(e);
  }
  async doFlush(e) {
    return this.options.hint === md.STORAGE_IN_MEMORY ? this.flushPending() : this.flushDelayer.trigger(() => this.flushPending(), e);
  }
  async whenFlushed() {
    if (this.hasPending)
      return new Promise((e) => this.whenFlushedCallbacks.push(e));
  }
  isInMemory() {
    return this.options.hint === md.STORAGE_IN_MEMORY;
  }
};
__.DEFAULT_FLUSH_DELAY = 100;
let A2 = __;
function Yd(t) {
  return Vx(t, 0);
}
function Vx(t, e) {
  switch (typeof t) {
    case "object":
      return t === null ? Is(349, e) : Array.isArray(t) ? l3(t, e) : c3(t, e);
    case "string":
      return zx(t, e);
    case "boolean":
      return a3(t, e);
    case "number":
      return Is(t, e);
    case "undefined":
      return Is(937, e);
    default:
      return Is(617, e);
  }
}
function Is(t, e) {
  return (e << 5) - e + t | 0;
}
function a3(t, e) {
  return Is(t ? 433 : 863, e);
}
function zx(t, e) {
  e = Is(149417, e);
  for (let i = 0, n = t.length; i < n; i++)
    e = Is(t.charCodeAt(i), e);
  return e;
}
function l3(t, e) {
  return e = Is(104579, e), t.reduce((i, n) => Vx(n, i), e);
}
function c3(t, e) {
  return e = Is(181387, e), Object.keys(t).sort().reduce((i, n) => (i = zx(n, i), Vx(t[n], i)), e);
}
var R2;
(function(t) {
  t[t.BLOCK_SIZE = 64] = "BLOCK_SIZE", t[t.UNICODE_REPLACEMENT = 65533] = "UNICODE_REPLACEMENT";
})(R2 || (R2 = {}));
const u3 = pe("environmentService"), ET = pe("fileService"), ST = pe("IUriIdentityService");
var L2;
(function(t) {
  t.Settings = "settings", t.Keybindings = "keybindings", t.Snippets = "snippets", t.Prompts = "prompts", t.Tasks = "tasks", t.Extensions = "extensions", t.GlobalState = "globalState", t.Mcp = "mcp";
})(L2 || (L2 = {}));
function d3(t) {
  const e = t;
  return !!(e && typeof e == "object" && typeof e.id == "string" && typeof e.isDefault == "boolean" && typeof e.name == "string" && x.isUri(e.location) && x.isUri(e.globalStorageHome) && x.isUri(e.settingsResource) && x.isUri(e.keybindingsResource) && x.isUri(e.tasksResource) && x.isUri(e.snippetsHome) && x.isUri(e.promptsHome) && x.isUri(e.extensionsResource) && x.isUri(e.mcpResource));
}
function Mf(t, e, i, n, r, s) {
  return {
    id: t,
    name: e,
    location: i,
    isDefault: !1,
    icon: r?.icon,
    globalStorageHome: s && r?.useDefaultFlags?.globalState ? s.globalStorageHome : wi(i, "globalStorage"),
    settingsResource: s && r?.useDefaultFlags?.settings ? s.settingsResource : wi(i, "settings.json"),
    keybindingsResource: s && r?.useDefaultFlags?.keybindings ? s.keybindingsResource : wi(i, "keybindings.json"),
    tasksResource: s && r?.useDefaultFlags?.tasks ? s.tasksResource : wi(i, "tasks.json"),
    snippetsHome: s && r?.useDefaultFlags?.snippets ? s.snippetsHome : wi(i, "snippets"),
    promptsHome: s && r?.useDefaultFlags?.prompts ? s.promptsHome : wi(i, "prompts"),
    extensionsResource: s && r?.useDefaultFlags?.extensions ? s.extensionsResource : wi(i, "extensions.json"),
    mcpResource: s && r?.useDefaultFlags?.mcp ? s.mcpResource : wi(i, "mcp.json"),
    cacheHome: wi(n, t),
    useDefaultFlags: r?.useDefaultFlags,
    isTransient: r?.transient,
    workspaces: r?.workspaces
  };
}
var Ha;
let N2 = (Ha = class extends ve {
  get defaultProfile() {
    return this.profiles[0];
  }
  get profiles() {
    return [...this.profilesObject.profiles, ...this.transientProfilesObject.profiles];
  }
  constructor(e, i, n, r) {
    super(), this.environmentService = e, this.fileService = i, this.uriIdentityService = n, this.logService = r, this._onDidChangeProfiles = this._register(new N()), this.onDidChangeProfiles = this._onDidChangeProfiles.event, this._onWillCreateProfile = this._register(new N()), this.onWillCreateProfile = this._onWillCreateProfile.event, this._onWillRemoveProfile = this._register(new N()), this.onWillRemoveProfile = this._onWillRemoveProfile.event, this._onDidResetWorkspaces = this._register(new N()), this.onDidResetWorkspaces = this._onDidResetWorkspaces.event, this.profileCreationPromises = /* @__PURE__ */ new Map(), this.transientProfilesObject = {
      profiles: [],
      emptyWindows: /* @__PURE__ */ new Map()
    }, this.profilesHome = wi(this.environmentService.userRoamingDataHome, "profiles"), this.profilesCacheHome = wi(this.environmentService.cacheHome, "CachedProfilesData");
  }
  init() {
    this._profilesObject = void 0;
  }
  get profilesObject() {
    if (!this._profilesObject) {
      const e = this.createDefaultProfile(), i = [e];
      try {
        for (const r of this.getStoredProfiles()) {
          if (!r.name || !it(r.name) || !r.location) {
            this.logService.warn("Skipping the invalid stored profile", r.location || r.name);
            continue;
          }
          i.push(Mf(Fs(r.location), r.name, r.location, this.profilesCacheHome, { icon: r.icon, useDefaultFlags: r.useDefaultFlags }, e));
        }
      } catch (r) {
        this.logService.error(r);
      }
      const n = /* @__PURE__ */ new Map();
      if (i.length)
        try {
          const r = this.getStoredProfileAssociations();
          if (r.workspaces)
            for (const [s, o] of Object.entries(r.workspaces)) {
              const a = x.parse(s), l = i.find((c) => c.id === o);
              if (l) {
                const c = l.workspaces ? l.workspaces.slice(0) : [];
                c.push(a), l.workspaces = c;
              }
            }
          if (r.emptyWindows)
            for (const [s, o] of Object.entries(r.emptyWindows)) {
              const a = i.find((l) => l.id === o);
              a && n.set(s, a);
            }
        } catch (r) {
          this.logService.error(r);
        }
      this._profilesObject = { profiles: i, emptyWindows: n };
    }
    return this._profilesObject;
  }
  createDefaultProfile() {
    const e = Mf("__default__profile__", h(2401, "Default"), this.environmentService.userRoamingDataHome, this.profilesCacheHome);
    return { ...e, extensionsResource: this.getDefaultProfileExtensionsLocation() ?? e.extensionsResource, isDefault: !0 };
  }
  async createTransientProfile(e) {
    const i = "Temp", n = new RegExp(`${Ja(i)}\\s(\\d+)`);
    let r = 0;
    for (const o of this.profiles) {
      const a = n.exec(o.name), l = a ? parseInt(a[1]) : 0;
      r = l > r ? l : r;
    }
    const s = `${i} ${r + 1}`;
    return this.createProfile(Yd(on()).toString(16), s, { transient: !0 }, e);
  }
  async createNamedProfile(e, i, n) {
    return this.createProfile(Yd(on()).toString(16), e, i, n);
  }
  async createProfile(e, i, n, r) {
    return await this.doCreateProfile(e, i, n, r);
  }
  async doCreateProfile(e, i, n, r) {
    if (!it(i) || !i)
      throw new Error("Name of the profile is mandatory and must be of type `string`");
    let s = this.profileCreationPromises.get(i);
    return s || (s = (async () => {
      try {
        if (this.profiles.find((u) => u.id === e || !u.isTransient && !n?.transient && u.name === i))
          throw new Error(`Profile with ${i} name already exists`);
        const a = r ? this.getWorkspace(r) : void 0;
        x.isUri(a) && (n = { ...n, workspaces: [a] });
        const l = Mf(e, i, wi(this.profilesHome, e), this.profilesCacheHome, n, this.defaultProfile);
        await this.fileService.createFolder(l.location);
        const c = [];
        return this._onWillCreateProfile.fire({
          profile: l,
          join(u) {
            c.push(u);
          }
        }), await Bc.settled(c), a && !x.isUri(a) && this.updateEmptyWindowAssociation(a, l, !!l.isTransient), this.updateProfiles([l], [], []), l;
      } finally {
        this.profileCreationPromises.delete(i);
      }
    })(), this.profileCreationPromises.set(i, s)), s;
  }
  async updateProfile(e, i) {
    const n = [];
    for (const s of this.profiles) {
      let o;
      if (e.id === s.id)
        s.isDefault ? i.workspaces && (o = s, o.workspaces = i.workspaces) : o = Mf(s.id, i.name ?? s.name, s.location, this.profilesCacheHome, {
          icon: i.icon === null ? void 0 : i.icon ?? s.icon,
          transient: i.transient ?? s.isTransient,
          useDefaultFlags: i.useDefaultFlags ?? s.useDefaultFlags,
          workspaces: i.workspaces ?? s.workspaces
        }, this.defaultProfile);
      else if (i.workspaces) {
        const a = s.workspaces?.filter((l) => !i.workspaces?.some((c) => this.uriIdentityService.extUri.isEqual(l, c)));
        s.workspaces?.length !== a?.length && (o = s, o.workspaces = a);
      }
      o && n.push(o);
    }
    if (!n.length)
      throw e.isDefault ? new Error("Cannot update default profile") : new Error(`Profile '${e.name}' does not exist`);
    this.updateProfiles([], [], n);
    const r = this.profiles.find((s) => s.id === e.id);
    if (!r)
      throw new Error(`Profile '${e.name}' was not updated`);
    return r;
  }
  async removeProfile(e) {
    if (e.isDefault)
      throw new Error("Cannot remove default profile");
    const i = this.profiles.find((r) => r.id === e.id);
    if (!i)
      throw new Error(`Profile '${e.name}' does not exist`);
    const n = [];
    this._onWillRemoveProfile.fire({
      profile: i,
      join(r) {
        n.push(r);
      }
    });
    try {
      await Promise.allSettled(n);
    } catch (r) {
      this.logService.error(r);
    }
    this.updateProfiles([], [i], []);
    try {
      await this.fileService.del(i.cacheHome, { recursive: !0 });
    } catch (r) {
      k8(r) !== Dn.FILE_NOT_FOUND && this.logService.error(r);
    }
  }
  async setProfileForWorkspace(e, i) {
    const n = this.profiles.find((s) => s.id === i.id);
    if (!n)
      throw new Error(`Profile '${i.name}' does not exist`);
    const r = this.getWorkspace(e);
    if (x.isUri(r)) {
      const s = n.workspaces ? [...n.workspaces] : [];
      s.some((o) => this.uriIdentityService.extUri.isEqual(o, r)) || (s.push(r), await this.updateProfile(n, { workspaces: s }));
    } else
      this.updateEmptyWindowAssociation(r, n, !1), this.updateStoredProfiles(this.profiles);
  }
  unsetWorkspace(e, i = !1) {
    const n = this.getWorkspace(e);
    if (x.isUri(n)) {
      const r = this.getProfileForWorkspace(e);
      r && this.updateProfile(r, { workspaces: r.workspaces?.filter((s) => !this.uriIdentityService.extUri.isEqual(s, n)) });
    } else
      this.updateEmptyWindowAssociation(n, void 0, i), this.updateStoredProfiles(this.profiles);
  }
  async resetWorkspaces() {
    this.transientProfilesObject.emptyWindows.clear(), this.profilesObject.emptyWindows.clear();
    for (const e of this.profiles)
      e.workspaces = void 0;
    this.updateProfiles([], [], this.profiles), this._onDidResetWorkspaces.fire();
  }
  async cleanUp() {
    if (await this.fileService.exists(this.profilesHome)) {
      const e = await this.fileService.resolve(this.profilesHome);
      await Promise.all((e.children || []).filter((i) => i.isDirectory && this.profiles.every((n) => !this.uriIdentityService.extUri.isEqual(n.location, i.resource))).map((i) => this.fileService.del(i.resource, { recursive: !0 })));
    }
  }
  async cleanUpTransientProfiles() {
    const e = this.transientProfilesObject.profiles.filter((i) => !this.isProfileAssociatedToWorkspace(i));
    await Promise.allSettled(e.map((i) => this.removeProfile(i)));
  }
  getProfileForWorkspace(e) {
    const i = this.getWorkspace(e);
    return x.isUri(i) ? this.profiles.find((n) => n.workspaces?.some((r) => this.uriIdentityService.extUri.isEqual(r, i))) : this.profilesObject.emptyWindows.get(i) ?? this.transientProfilesObject.emptyWindows.get(i);
  }
  getWorkspace(e) {
    return C8(e) ? e.uri : T8(e) ? e.configPath : e.id;
  }
  isProfileAssociatedToWorkspace(e) {
    return !!(e.workspaces?.length || [...this.profilesObject.emptyWindows.values()].some(
      (i) => this.uriIdentityService.extUri.isEqual(i.location, e.location)
    ) || [...this.transientProfilesObject.emptyWindows.values()].some(
      (i) => this.uriIdentityService.extUri.isEqual(i.location, e.location)
    ));
  }
  updateProfiles(e, i, n) {
    const r = [...this.profiles, ...e], s = this.transientProfilesObject.profiles;
    this.transientProfilesObject.profiles = [];
    const o = [];
    for (let a of r) {
      if (i.some((l) => a.id === l.id)) {
        for (const l of [...this.profilesObject.emptyWindows.keys()])
          a.id === this.profilesObject.emptyWindows.get(l)?.id && this.profilesObject.emptyWindows.delete(l);
        continue;
      }
      if (!a.isDefault) {
        a = n.find((c) => a.id === c.id) ?? a;
        const l = s.find((c) => a.id === c.id);
        if (a.isTransient)
          this.transientProfilesObject.profiles.push(a);
        else if (l) {
          for (const [c, u] of this.transientProfilesObject.emptyWindows.entries())
            if (a.id === u.id) {
              this.transientProfilesObject.emptyWindows.delete(c), this.profilesObject.emptyWindows.set(c, a);
              break;
            }
        }
      }
      a.workspaces?.length === 0 && (a.workspaces = void 0), o.push(a);
    }
    this.updateStoredProfiles(o), this.triggerProfilesChanges(e, i, n);
  }
  triggerProfilesChanges(e, i, n) {
    this._onDidChangeProfiles.fire({ added: e, removed: i, updated: n, all: this.profiles });
  }
  updateEmptyWindowAssociation(e, i, n) {
    n = i?.isTransient ? !0 : n, n ? i ? this.transientProfilesObject.emptyWindows.set(e, i) : this.transientProfilesObject.emptyWindows.delete(e) : (this.transientProfilesObject.emptyWindows.delete(e), i ? this.profilesObject.emptyWindows.set(e, i) : this.profilesObject.emptyWindows.delete(e));
  }
  updateStoredProfiles(e) {
    const i = [], n = {}, r = {};
    for (const s of e)
      if (!s.isTransient && (s.isDefault || i.push({ location: s.location, name: s.name, icon: s.icon, useDefaultFlags: s.useDefaultFlags }), s.workspaces))
        for (const o of s.workspaces)
          n[o.toString()] = s.id;
    for (const [s, o] of this.profilesObject.emptyWindows.entries())
      r[s.toString()] = o.id;
    this.saveStoredProfileAssociations({ workspaces: n, emptyWindows: r }), this.saveStoredProfiles(i), this._profilesObject = void 0;
  }
  getStoredProfiles() {
    return [];
  }
  saveStoredProfiles(e) {
    throw new Error("not implemented");
  }
  getStoredProfileAssociations() {
    return {};
  }
  saveStoredProfileAssociations(e) {
    throw new Error("not implemented");
  }
  getDefaultProfileExtensionsLocation() {
  }
}, Ha.PROFILES_KEY = "userDataProfiles", Ha.PROFILE_ASSOCIATIONS_KEY = "profileAssociations", Ha);
N2 = W([
  M(0, u3),
  M(1, ET),
  M(2, ST),
  M(3, nt)
], N2);
const h3 = "__$__isNewStorageMarker", rp = "__$__targetStorageMarker";
var Gl;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.SHUTDOWN = 1] = "SHUTDOWN";
})(Gl || (Gl = {}));
var jt;
(function(t) {
  t[t.APPLICATION = -1] = "APPLICATION", t[t.PROFILE = 0] = "PROFILE", t[t.WORKSPACE = 1] = "WORKSPACE";
})(jt || (jt = {}));
var rg;
(function(t) {
  t[t.USER = 0] = "USER", t[t.MACHINE = 1] = "MACHINE";
})(rg || (rg = {}));
function f3(t) {
  const e = t.get(rp);
  if (e)
    try {
      return JSON.parse(e);
    } catch {
    }
  return /* @__PURE__ */ Object.create(null);
}
const v_ = class v_ extends ve {
  constructor(e = { flushInterval: v_.DEFAULT_FLUSH_INTERVAL }) {
    super(), this._onDidChangeValue = this._register(new Rp()), this._onDidChangeTarget = this._register(new Rp()), this.onDidChangeTarget = this._onDidChangeTarget.event, this._onWillSaveState = this._register(new N()), this.onWillSaveState = this._onWillSaveState.event, this.runFlushWhenIdle = this._register(new Ss()), this._workspaceKeyTargets = void 0, this._profileKeyTargets = void 0, this._applicationKeyTargets = void 0, this.flushWhenIdleScheduler = this._register(new cl(() => this.doFlushWhenIdle(), e.flushInterval));
  }
  onDidChangeValue(e, i, n) {
    return It.filter(this._onDidChangeValue.event, (r) => r.scope === e && (i === void 0 || r.key === i), n);
  }
  doFlushWhenIdle() {
    this.runFlushWhenIdle.value = U4(() => {
      this.shouldFlushWhenIdle() && this.flush(), this.flushWhenIdleScheduler.schedule();
    });
  }
  shouldFlushWhenIdle() {
    return !0;
  }
  stopFlushWhenIdle() {
    Wn([this.runFlushWhenIdle, this.flushWhenIdleScheduler]);
  }
  initialize() {
    return this.initializationPromise || (this.initializationPromise = (async () => {
      tn("code/willInitStorage");
      try {
        await this.doInitialize();
      } finally {
        tn("code/didInitStorage");
      }
      this.flushWhenIdleScheduler.schedule();
    })()), this.initializationPromise;
  }
  emitDidChangeValue(e, i) {
    const { key: n, external: r } = i;
    if (n === rp) {
      switch (e) {
        case jt.APPLICATION:
          this._applicationKeyTargets = void 0;
          break;
        case jt.PROFILE:
          this._profileKeyTargets = void 0;
          break;
        case jt.WORKSPACE:
          this._workspaceKeyTargets = void 0;
          break;
      }
      this._onDidChangeTarget.fire({ scope: e });
    } else
      this._onDidChangeValue.fire({ scope: e, key: n, target: this.getKeyTargets(e)[n], external: r });
  }
  emitWillSaveState(e) {
    this._onWillSaveState.fire({ reason: e });
  }
  get(e, i, n) {
    return this.getStorage(i)?.get(e, n);
  }
  getBoolean(e, i, n) {
    return this.getStorage(i)?.getBoolean(e, n);
  }
  getNumber(e, i, n) {
    return this.getStorage(i)?.getNumber(e, n);
  }
  getObject(e, i, n) {
    return this.getStorage(i)?.getObject(e, n);
  }
  storeAll(e, i) {
    this.withPausedEmitters(() => {
      for (const n of e)
        this.store(n.key, n.value, n.scope, n.target, i);
    });
  }
  store(e, i, n, r, s = !1) {
    if (ni(i)) {
      this.remove(e, n, s);
      return;
    }
    this.withPausedEmitters(() => {
      this.updateKeyTarget(e, n, r), this.getStorage(n)?.set(e, i, s);
    });
  }
  remove(e, i, n = !1) {
    this.withPausedEmitters(() => {
      this.updateKeyTarget(e, i, void 0), this.getStorage(i)?.delete(e, n);
    });
  }
  withPausedEmitters(e) {
    this._onDidChangeValue.pause(), this._onDidChangeTarget.pause();
    try {
      e();
    } finally {
      this._onDidChangeValue.resume(), this._onDidChangeTarget.resume();
    }
  }
  keys(e, i) {
    const n = [], r = this.getKeyTargets(e);
    for (const s of Object.keys(r))
      r[s] === i && n.push(s);
    return n;
  }
  updateKeyTarget(e, i, n, r = !1) {
    const s = this.getKeyTargets(i);
    typeof n == "number" ? s[e] !== n && (s[e] = n, this.getStorage(i)?.set(rp, JSON.stringify(s), r)) : typeof s[e] == "number" && (delete s[e], this.getStorage(i)?.set(rp, JSON.stringify(s), r));
  }
  get workspaceKeyTargets() {
    return this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(jt.WORKSPACE)), this._workspaceKeyTargets;
  }
  get profileKeyTargets() {
    return this._profileKeyTargets || (this._profileKeyTargets = this.loadKeyTargets(jt.PROFILE)), this._profileKeyTargets;
  }
  get applicationKeyTargets() {
    return this._applicationKeyTargets || (this._applicationKeyTargets = this.loadKeyTargets(jt.APPLICATION)), this._applicationKeyTargets;
  }
  getKeyTargets(e) {
    switch (e) {
      case jt.APPLICATION:
        return this.applicationKeyTargets;
      case jt.PROFILE:
        return this.profileKeyTargets;
      default:
        return this.workspaceKeyTargets;
    }
  }
  loadKeyTargets(e) {
    const i = this.getStorage(e);
    return i ? f3(i) : /* @__PURE__ */ Object.create(null);
  }
  isNew(e) {
    return this.getBoolean(h3, e) === !0;
  }
  async flush(e = Gl.NONE) {
    this._onWillSaveState.fire({ reason: e });
    const i = this.getStorage(jt.APPLICATION), n = this.getStorage(jt.PROFILE), r = this.getStorage(jt.WORKSPACE);
    switch (e) {
      case Gl.NONE:
        await Bc.settled([
          i?.whenFlushed() ?? Promise.resolve(),
          n?.whenFlushed() ?? Promise.resolve(),
          r?.whenFlushed() ?? Promise.resolve()
        ]);
        break;
      case Gl.SHUTDOWN:
        await Bc.settled([
          i?.flush(0) ?? Promise.resolve(),
          n?.flush(0) ?? Promise.resolve(),
          r?.flush(0) ?? Promise.resolve()
        ]);
        break;
    }
  }
  async log() {
    const e = this.getStorage(jt.APPLICATION)?.items ?? /* @__PURE__ */ new Map(), i = this.getStorage(jt.PROFILE)?.items ?? /* @__PURE__ */ new Map(), n = this.getStorage(jt.WORKSPACE)?.items ?? /* @__PURE__ */ new Map();
    return p3(e, i, n, this.getLogDetails(jt.APPLICATION) ?? "", this.getLogDetails(jt.PROFILE) ?? "", this.getLogDetails(jt.WORKSPACE) ?? "");
  }
  async optimize(e) {
    return await this.flush(), this.getStorage(e)?.optimize();
  }
  async switch(e, i) {
    return this.emitWillSaveState(Gl.NONE), d3(e) ? this.switchToProfile(e, i) : this.switchToWorkspace(e, i);
  }
  canSwitchProfile(e, i) {
    return !(e.id === i.id || O2(i) && O2(e));
  }
  switchData(e, i, n) {
    this.withPausedEmitters(() => {
      const r = /* @__PURE__ */ new Set();
      for (const [s, o] of e)
        r.add(s), i.get(s) !== o && this.emitDidChangeValue(n, { key: s, external: !0 });
      for (const [s] of i.items)
        r.has(s) || this.emitDidChangeValue(n, { key: s, external: !0 });
    });
  }
};
v_.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
let M2 = v_;
function O2(t) {
  return t.isDefault || !!t.useDefaultFlags?.globalState;
}
async function p3(t, e, i, n, r, s) {
  const o = (w) => {
    try {
      return JSON.parse(w);
    } catch {
      return w;
    }
  }, a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
  t.forEach((w, v) => {
    a.set(v, w), l.set(v, o(w));
  });
  const c = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map();
  e.forEach((w, v) => {
    c.set(v, w), u.set(v, o(w));
  });
  const d = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map();
  i.forEach((w, v) => {
    d.set(v, w), f.set(v, o(w));
  }), console.group(n !== r ? `Storage: Application (path: ${n})` : `Storage: Application & Profile (path: ${n}, default profile)`);
  const g = [];
  if (a.forEach((w, v) => {
    g.push({ key: v, value: w });
  }), console.table(g), console.groupEnd(), console.log(l), n !== r) {
    console.group(`Storage: Profile (path: ${r}, profile specific)`);
    const w = [];
    c.forEach((v, S) => {
      w.push({ key: S, value: v });
    }), console.table(w), console.groupEnd(), console.log(u);
  }
  console.group(`Storage: Workspace (path: ${s})`);
  const _ = [];
  d.forEach((w, v) => {
    _.push({ key: v, value: w });
  }), console.table(_), console.groupEnd(), console.log(f);
}
const g3 = pe("storageService");
var ti;
(function(t) {
  t[t.APPLICATION = 1] = "APPLICATION", t[t.USER = 2] = "USER", t[t.USER_LOCAL = 3] = "USER_LOCAL", t[t.USER_REMOTE = 4] = "USER_REMOTE", t[t.WORKSPACE = 5] = "WORKSPACE", t[t.WORKSPACE_FOLDER = 6] = "WORKSPACE_FOLDER", t[t.DEFAULT = 7] = "DEFAULT", t[t.MEMORY = 8] = "MEMORY";
})(ti || (ti = {}));
function Yv(t, e) {
  const i = /* @__PURE__ */ Object.create(null);
  for (const n in t)
    DT(i, n, t[n], e);
  return i;
}
function DT(t, e, i, n) {
  const r = e.split("."), s = r.pop();
  let o = t;
  for (let a = 0; a < r.length; a++) {
    const l = r[a];
    let c = o[l];
    switch (typeof c) {
      case "undefined":
        c = o[l] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        if (c === null) {
          n(`Ignoring ${e} as ${r.slice(0, a + 1).join(".")} is null`);
          return;
        }
        break;
      default:
        n(`Ignoring ${e} as ${r.slice(0, a + 1).join(".")} is ${JSON.stringify(c)}`);
        return;
    }
    o = c;
  }
  if (typeof o == "object" && o !== null)
    try {
      o[s] = i;
    } catch {
      n(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(o)}`);
    }
  else
    n(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(o)}`);
}
function m3(t, e) {
  const i = e.split(".");
  kT(t, i);
}
function kT(t, e) {
  if (!t)
    return;
  const i = e.shift();
  if (e.length === 0) {
    delete t[i];
    return;
  }
  if (Object.keys(t).indexOf(i) !== -1) {
    const n = t[i];
    typeof n == "object" && !Array.isArray(n) && (kT(n, e), Object.keys(n).length === 0 && delete t[i]);
  }
}
function sg(t, e, i) {
  function n(o, a) {
    let l = o;
    for (const c of a) {
      if (typeof l != "object" || l === null)
        return;
      l = l[c];
    }
    return l;
  }
  const r = e.split("."), s = n(t, r);
  return typeof s > "u" ? i : s;
}
function _3(t) {
  return t.replace(/^\[/, "").replace(/]$/g, "").replace(/\]\[/g, ", ");
}
function v3(t) {
  let e = !1;
  const i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  if (w3(t, (u) => {
    if (t === u)
      return !0;
    const d = JSON.stringify(u);
    if (d.length < 30)
      return !0;
    const f = i.get(d);
    if (!f) {
      const g = { schemas: [u] };
      return i.set(d, g), n.set(u, g), !0;
    }
    return f.schemas.push(u), n.set(u, f), e = !0, !1;
  }), i.clear(), !e)
    return JSON.stringify(t);
  let s = "$defs";
  for (; t.hasOwnProperty(s); )
    s += "_";
  const o = [];
  function a(u) {
    return JSON.stringify(u, (d, f) => {
      if (f !== u) {
        const g = n.get(f);
        if (g && g.schemas.length > 1)
          return g.id || (g.id = `_${o.length}`, o.push(g.schemas[0])), { $ref: `#/${s}/${g.id}` };
      }
      return f;
    });
  }
  const l = a(t), c = [];
  for (let u = 0; u < o.length; u++)
    c.push(`"_${u}":${a(o[u])}`);
  return c.length ? `${l.substring(0, l.length - 1)},"${s}":{${c.join(",")}}}` : l;
}
function Il(t) {
  return typeof t == "object" && t !== null;
}
function w3(t, e) {
  if (!t || typeof t != "object")
    return;
  const i = (...l) => {
    for (const c of l)
      Il(c) && o.push(c);
  }, n = (...l) => {
    for (const c of l)
      if (Il(c))
        for (const u in c) {
          const d = c[u];
          Il(d) && o.push(d);
        }
  }, r = (...l) => {
    for (const c of l)
      if (Array.isArray(c))
        for (const u of c)
          Il(u) && o.push(u);
  }, s = (l) => {
    if (Array.isArray(l))
      for (const c of l)
        Il(c) && o.push(c);
    else Il(l) && o.push(l);
  }, o = [t];
  let a = o.pop();
  for (; a; )
    e(a) && (i(a.additionalItems, a.additionalProperties, a.not, a.contains, a.propertyNames, a.if, a.then, a.else, a.unevaluatedItems, a.unevaluatedProperties), n(a.definitions, a.$defs, a.properties, a.patternProperties, a.dependencies, a.dependentSchemas), r(a.anyOf, a.allOf, a.oneOf, a.prefixItems), s(a.items)), a = o.pop();
}
const K_ = {
  JSONContribution: "base.contributions.json"
};
function F2(t) {
  return t.length > 0 && t.charAt(t.length - 1) === "#" ? t.substring(0, t.length - 1) : t;
}
class b3 extends ve {
  constructor() {
    super(...arguments), this.schemasById = {}, this.schemaAssociations = {}, this._onDidChangeSchema = this._register(new N()), this.onDidChangeSchema = this._onDidChangeSchema.event, this._onDidChangeSchemaAssociations = this._register(new N()), this.onDidChangeSchemaAssociations = this._onDidChangeSchemaAssociations.event;
  }
  registerSchema(e, i, n) {
    const r = F2(e);
    this.schemasById[r] = i, this._onDidChangeSchema.fire(e), n && n.add(Ee(() => {
      delete this.schemasById[r], this._onDidChangeSchema.fire(e);
    }));
  }
  registerSchemaAssociation(e, i) {
    const n = F2(e);
    return this.schemaAssociations[n] || (this.schemaAssociations[n] = []), this.schemaAssociations[n].includes(i) || (this.schemaAssociations[n].push(i), this._onDidChangeSchemaAssociations.fire()), Ee(() => {
      const r = this.schemaAssociations[n];
      if (r) {
        const s = r.indexOf(i);
        s !== -1 && (r.splice(s, 1), r.length === 0 && delete this.schemaAssociations[n], this._onDidChangeSchemaAssociations.fire());
      }
    });
  }
  notifySchemaChanged(e) {
    this._onDidChangeSchema.fire(e);
  }
  getSchemaContributions() {
    return {
      schemas: this.schemasById
    };
  }
  getSchemaContent(e) {
    const i = this.schemasById[e];
    return i ? v3(i) : void 0;
  }
  hasSchemaContent(e) {
    return !!this.schemasById[e];
  }
  getSchemaAssociations() {
    return this.schemaAssociations;
  }
}
const y3 = new b3();
ai.add(K_.JSONContribution, y3);
var U2;
(function(t) {
  t.Multiline = "multilineText", t.Singleline = "singlelineText";
})(U2 || (U2 = {}));
const ml = {
  Configuration: "base.contributions.configuration"
};
var Lt;
(function(t) {
  t[t.APPLICATION = 1] = "APPLICATION", t[t.MACHINE = 2] = "MACHINE", t[t.APPLICATION_MACHINE = 3] = "APPLICATION_MACHINE", t[t.WINDOW = 4] = "WINDOW", t[t.RESOURCE = 5] = "RESOURCE", t[t.LANGUAGE_OVERRIDABLE = 6] = "LANGUAGE_OVERRIDABLE", t[t.MACHINE_OVERRIDABLE = 7] = "MACHINE_OVERRIDABLE";
})(Lt || (Lt = {}));
const Cl = "vscode://schemas/settings/resourceLanguage", Of = ai.as(K_.JSONContribution);
class x3 extends ve {
  constructor() {
    super(), this.registeredConfigurationDefaults = [], this.overrideIdentifiers = /* @__PURE__ */ new Set(), this._onDidSchemaChange = this._register(new N()), this.onDidSchemaChange = this._onDidSchemaChange.event, this._onDidUpdateConfiguration = this._register(new N()), this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event, this.configurationDefaultsOverrides = /* @__PURE__ */ new Map(), this.defaultLanguageConfigurationOverridesNode = {
      id: "defaultOverrides",
      title: h(1737, "Default Language Configuration Overrides"),
      properties: {}
    }, this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode], this.resourceLanguageSettingsSchema = {
      properties: {},
      patternProperties: {},
      additionalProperties: !0,
      allowTrailingCommas: !0,
      allowComments: !0
    }, this.configurationProperties = {}, this.policyConfigurations = /* @__PURE__ */ new Map(), this.excludedConfigurationProperties = {}, Of.registerSchema(Cl, this.resourceLanguageSettingsSchema), this.registerOverridePropertyPatternKey();
  }
  registerConfiguration(e, i = !0) {
    return this.registerConfigurations([e], i), e;
  }
  registerConfigurations(e, i = !0) {
    const n = /* @__PURE__ */ new Set();
    this.doRegisterConfigurations(e, i, n), Of.registerSchema(Cl, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: n });
  }
  deregisterConfigurations(e) {
    const i = /* @__PURE__ */ new Set();
    this.doDeregisterConfigurations(e, i), Of.registerSchema(Cl, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i });
  }
  updateConfigurations({ add: e, remove: i }) {
    const n = /* @__PURE__ */ new Set();
    this.doDeregisterConfigurations(i, n), this.doRegisterConfigurations(e, !1, n), Of.registerSchema(Cl, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: n });
  }
  registerDefaultConfigurations(e) {
    const i = /* @__PURE__ */ new Set();
    this.doRegisterDefaultConfigurations(e, i), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i, defaultsOverrides: !0 });
  }
  doRegisterDefaultConfigurations(e, i) {
    this.registeredConfigurationDefaults.push(...e);
    const n = [];
    for (const { overrides: r, source: s } of e)
      for (const o in r) {
        i.add(o);
        const a = this.configurationDefaultsOverrides.get(o) ?? this.configurationDefaultsOverrides.set(o, { configurationDefaultOverrides: [] }).get(o), l = r[o];
        if (a.configurationDefaultOverrides.push({ value: l, source: s }), jr.test(o)) {
          const c = this.mergeDefaultConfigurationsForOverrideIdentifier(o, l, s, a.configurationDefaultOverrideValue);
          if (!c)
            continue;
          a.configurationDefaultOverrideValue = c, this.updateDefaultOverrideProperty(o, c, s), n.push(...Xd(o));
        } else {
          const c = this.mergeDefaultConfigurationsForConfigurationProperty(o, l, s, a.configurationDefaultOverrideValue);
          if (!c)
            continue;
          a.configurationDefaultOverrideValue = c;
          const u = this.configurationProperties[o];
          u && (this.updatePropertyDefaultValue(o, u), this.updateSchema(o, u));
        }
      }
    this.doRegisterOverrideIdentifiers(n);
  }
  deregisterDefaultConfigurations(e) {
    const i = /* @__PURE__ */ new Set();
    this.doDeregisterDefaultConfigurations(e, i), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i, defaultsOverrides: !0 });
  }
  doDeregisterDefaultConfigurations(e, i) {
    for (const n of e) {
      const r = this.registeredConfigurationDefaults.indexOf(n);
      r !== -1 && this.registeredConfigurationDefaults.splice(r, 1);
    }
    for (const { overrides: n, source: r } of e)
      for (const s in n) {
        const o = this.configurationDefaultsOverrides.get(s);
        if (!o)
          continue;
        const a = o.configurationDefaultOverrides.findIndex((l) => r ? l.source?.id === r.id : l.value === n[s]);
        if (a !== -1) {
          if (o.configurationDefaultOverrides.splice(a, 1), o.configurationDefaultOverrides.length === 0 && this.configurationDefaultsOverrides.delete(s), jr.test(s)) {
            let l;
            for (const c of o.configurationDefaultOverrides)
              l = this.mergeDefaultConfigurationsForOverrideIdentifier(s, c.value, c.source, l);
            l && !n4(l.value) ? (o.configurationDefaultOverrideValue = l, this.updateDefaultOverrideProperty(s, l, r)) : (this.configurationDefaultsOverrides.delete(s), delete this.configurationProperties[s], delete this.defaultLanguageConfigurationOverridesNode.properties[s]);
          } else {
            let l;
            for (const u of o.configurationDefaultOverrides)
              l = this.mergeDefaultConfigurationsForConfigurationProperty(s, u.value, u.source, l);
            o.configurationDefaultOverrideValue = l;
            const c = this.configurationProperties[s];
            c && (this.updatePropertyDefaultValue(s, c), this.updateSchema(s, c));
          }
          i.add(s);
        }
      }
    this.updateOverridePropertyPatternKey();
  }
  updateDefaultOverrideProperty(e, i, n) {
    const r = {
      type: "object",
      default: i.value,
      description: h(
        1738,
        "Configure settings to be overridden for {0}.",
        _3(e)
      ),
      $ref: Cl,
      defaultDefaultValue: i.value,
      source: n,
      defaultValueSource: n
    };
    this.configurationProperties[e] = r, this.defaultLanguageConfigurationOverridesNode.properties[e] = r;
  }
  mergeDefaultConfigurationsForOverrideIdentifier(e, i, n, r) {
    const s = r?.value || {}, o = r?.source ?? /* @__PURE__ */ new Map();
    if (!(o instanceof Map)) {
      console.error("objectConfigurationSources is not a Map");
      return;
    }
    for (const a of Object.keys(i)) {
      const l = i[a];
      if (ri(l) && (Ku(s[a]) || ri(s[a]))) {
        if (s[a] = { ...s[a] ?? {}, ...l }, n)
          for (const u in l)
            o.set(`${a}.${u}`, n);
      } else
        s[a] = l, n ? o.set(a, n) : o.delete(a);
    }
    return { value: s, source: o };
  }
  mergeDefaultConfigurationsForConfigurationProperty(e, i, n, r) {
    const s = this.configurationProperties[e], o = r?.value ?? s?.defaultDefaultValue;
    let a = n;
    if (ri(i) && (s !== void 0 && s.type === "object" || s === void 0 && (Ku(o) || ri(o)))) {
      if (a = r?.source ?? /* @__PURE__ */ new Map(), !(a instanceof Map)) {
        console.error("defaultValueSource is not a Map");
        return;
      }
      for (const c in i)
        n && a.set(`${e}.${c}`, n);
      i = { ...ri(o) ? o : {}, ...i };
    }
    return { value: i, source: a };
  }
  deltaConfiguration(e) {
    let i = !1;
    const n = /* @__PURE__ */ new Set();
    e.removedDefaults && (this.doDeregisterDefaultConfigurations(e.removedDefaults, n), i = !0), e.addedDefaults && (this.doRegisterDefaultConfigurations(e.addedDefaults, n), i = !0), e.removedConfigurations && this.doDeregisterConfigurations(e.removedConfigurations, n), e.addedConfigurations && this.doRegisterConfigurations(e.addedConfigurations, !1, n), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: n, defaultsOverrides: i });
  }
  notifyConfigurationSchemaUpdated(...e) {
    this._onDidSchemaChange.fire();
  }
  registerOverrideIdentifiers(e) {
    this.doRegisterOverrideIdentifiers(e), this._onDidSchemaChange.fire();
  }
  doRegisterOverrideIdentifiers(e) {
    for (const i of e)
      this.overrideIdentifiers.add(i);
    this.updateOverridePropertyPatternKey();
  }
  doRegisterConfigurations(e, i, n) {
    e.forEach((r) => {
      this.validateAndRegisterProperties(r, i, r.extensionInfo, r.restrictedProperties, void 0, n), this.configurationContributors.push(r), this.registerJSONConfiguration(r);
    });
  }
  doDeregisterConfigurations(e, i) {
    const n = (r) => {
      if (r.properties)
        for (const s in r.properties) {
          i.add(s);
          const o = this.configurationProperties[s];
          o?.policy?.name && this.policyConfigurations.delete(o.policy.name), delete this.configurationProperties[s], this.removeFromSchema(s, r.properties[s]);
        }
      r.allOf?.forEach((s) => n(s));
    };
    for (const r of e) {
      n(r);
      const s = this.configurationContributors.indexOf(r);
      s !== -1 && this.configurationContributors.splice(s, 1);
    }
  }
  validateAndRegisterProperties(e, i = !0, n, r, s = Lt.WINDOW, o) {
    s = ni(e.scope) ? s : e.scope;
    const a = e.properties;
    if (a)
      for (const c in a) {
        const u = a[c];
        if (i && D3(c, u)) {
          delete a[c];
          continue;
        }
        u.source = n, u.defaultDefaultValue = a[c].default, this.updatePropertyDefaultValue(c, u), jr.test(c) ? u.scope = void 0 : (u.scope = ni(u.scope) ? s : u.scope, u.restricted = ni(u.restricted) ? !!r?.includes(c) : u.restricted), u.experiment ? u.tags?.some((g) => g.toLowerCase() === "onexp") || (u.tags = u.tags ?? [], u.tags.push("onExP")) : u.tags?.some((g) => g.toLowerCase() === "onexp") && (console.error(`Invalid tag 'onExP' found for property '${c}'. Please use 'experiment' property instead.`), u.experiment = { mode: "startup" });
        const d = a[c].hasOwnProperty("included") && !a[c].included, f = a[c].policy?.name;
        d ? (this.excludedConfigurationProperties[c] = a[c], f && (this.policyConfigurations.set(f, c), o.add(c)), delete a[c]) : (o.add(c), f && this.policyConfigurations.set(f, c), this.configurationProperties[c] = a[c], !a[c].deprecationMessage && a[c].markdownDeprecationMessage && (a[c].deprecationMessage = a[c].markdownDeprecationMessage));
      }
    const l = e.allOf;
    if (l)
      for (const c of l)
        this.validateAndRegisterProperties(c, i, n, r, s, o);
  }
  getConfigurations() {
    return this.configurationContributors;
  }
  getConfigurationProperties() {
    return this.configurationProperties;
  }
  getPolicyConfigurations() {
    return this.policyConfigurations;
  }
  getExcludedConfigurationProperties() {
    return this.excludedConfigurationProperties;
  }
  getRegisteredDefaultConfigurations() {
    return [...this.registeredConfigurationDefaults];
  }
  getConfigurationDefaultsOverrides() {
    const e = /* @__PURE__ */ new Map();
    for (const [i, n] of this.configurationDefaultsOverrides)
      n.configurationDefaultOverrideValue && e.set(i, n.configurationDefaultOverrideValue);
    return e;
  }
  registerJSONConfiguration(e) {
    const i = (n) => {
      const r = n.properties;
      if (r)
        for (const o in r)
          this.updateSchema(o, r[o]);
      n.allOf?.forEach(i);
    };
    i(e);
  }
  updateSchema(e, i) {
    switch (i.scope) {
      case Lt.APPLICATION:
        break;
      case Lt.MACHINE:
        break;
      case Lt.APPLICATION_MACHINE:
        break;
      case Lt.MACHINE_OVERRIDABLE:
        break;
      case Lt.WINDOW:
        break;
      case Lt.RESOURCE:
        break;
      case Lt.LANGUAGE_OVERRIDABLE:
        this.resourceLanguageSettingsSchema.properties[e] = i;
        break;
    }
  }
  removeFromSchema(e, i) {
    switch (i.scope) {
      case Lt.APPLICATION:
        break;
      case Lt.MACHINE:
        break;
      case Lt.APPLICATION_MACHINE:
        break;
      case Lt.MACHINE_OVERRIDABLE:
        break;
      case Lt.WINDOW:
        break;
      case Lt.RESOURCE:
      case Lt.LANGUAGE_OVERRIDABLE:
        delete this.resourceLanguageSettingsSchema.properties[e];
        break;
    }
  }
  updateOverridePropertyPatternKey() {
    for (const e of this.overrideIdentifiers.values()) {
      const i = `[${e}]`, n = {
        type: "object",
        description: h(1739, "Configure editor settings to be overridden for a language."),
        errorMessage: h(1740, "This setting does not support per-language configuration."),
        $ref: Cl
      };
      this.updatePropertyDefaultValue(i, n);
    }
  }
  registerOverridePropertyPatternKey() {
    h(1739, "Configure editor settings to be overridden for a language."), h(1740, "This setting does not support per-language configuration."), this._onDidSchemaChange.fire();
  }
  updatePropertyDefaultValue(e, i) {
    const n = this.configurationDefaultsOverrides.get(e)?.configurationDefaultOverrideValue;
    let r, s;
    n && (!i.disallowConfigurationDefault || !n.source) && (r = n.value, s = n.source), Ku(r) && (r = i.defaultDefaultValue, s = void 0), Ku(r) && (r = S3(i.type)), i.default = r, i.defaultValueSource = s;
  }
}
const IT = "\\[([^\\]]+)\\]", $2 = new RegExp(IT, "g"), E3 = `^(${IT})+$`, jr = new RegExp(E3);
function Xd(t) {
  const e = [];
  if (jr.test(t)) {
    let i = $2.exec(t);
    for (; i?.length; ) {
      const n = i[1].trim();
      n && e.push(n), i = $2.exec(t);
    }
  }
  return Fl(e);
}
function S3(t) {
  switch (Array.isArray(t) ? t[0] : t) {
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
const sp = new x3();
ai.add(ml.Configuration, sp);
function D3(t, e) {
  return t.trim() ? jr.test(t) ? h(
    1742,
    "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.",
    t
  ) : sp.getConfigurationProperties()[t] !== void 0 ? h(
    1743,
    "Cannot register '{0}'. This property is already registered.",
    t
  ) : e.policy?.name && sp.getPolicyConfigurations().get(e.policy?.name) !== void 0 ? h(
    1744,
    "Cannot register '{0}'. The associated policy {1} is already registered with {2}.",
    t,
    e.policy?.name,
    sp.getPolicyConfigurations().get(e.policy?.name)
  ) : null : h(1741, "Cannot register an empty property");
}
const H2 = "^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$";
var B2;
(function(t) {
  t.COMMAND = "command", t.SETTINGS_SYNC = "settingsSync";
})(B2 || (B2 = {}));
var Xv;
(function(t) {
  t.NoneOrRelevance = "NoneOrRelevance", t.LastUpdatedDate = "LastUpdatedDate", t.Title = "Title", t.PublisherName = "PublisherName", t.InstallCount = "InstallCount", t.PublishedDate = "PublishedDate", t.AverageRating = "AverageRating", t.WeightedRating = "WeightedRating";
})(Xv || (Xv = {}));
var W2;
(function(t) {
  t[t.Default = 0] = "Default", t[t.Ascending = 1] = "Ascending", t[t.Descending = 2] = "Descending";
})(W2 || (W2 = {}));
var V2;
(function(t) {
  t.Category = "Category", t.ExtensionId = "ExtensionId", t.ExtensionName = "ExtensionName", t.ExcludeWithFlags = "ExcludeWithFlags", t.Featured = "Featured", t.SearchText = "SearchText", t.Tag = "Tag", t.Target = "Target";
})(V2 || (V2 = {}));
var z2;
(function(t) {
  t.Install = "install", t.Uninstall = "uninstall";
})(z2 || (z2 = {}));
var q2;
(function(t) {
  t[t.None = 1] = "None", t[t.Install = 2] = "Install", t[t.Update = 3] = "Update", t[t.Migrate = 4] = "Migrate";
})(q2 || (q2 = {}));
var j2;
(function(t) {
  t.Timeout = "Timeout", t.Cancelled = "Cancelled", t.Failed = "Failed", t.DownloadFailedWriting = "DownloadFailedWriting", t.Offline = "Offline";
})(j2 || (j2 = {}));
var G2;
(function(t) {
  t.NotFound = "NotFound", t.Unsupported = "Unsupported", t.Deprecated = "Deprecated", t.Malicious = "Malicious", t.Incompatible = "Incompatible", t.IncompatibleApi = "IncompatibleApi", t.IncompatibleTargetPlatform = "IncompatibleTargetPlatform", t.ReleaseVersionNotFound = "ReleaseVersionNotFound", t.Invalid = "Invalid", t.Download = "Download", t.DownloadSignature = "DownloadSignature", t.DownloadFailedWriting = "DownloadFailedWriting", t.UpdateMetadata = "UpdateMetadata", t.Extract = "Extract", t.Scanning = "Scanning", t.ScanningExtension = "ScanningExtension", t.ReadRemoved = "ReadRemoved", t.UnsetRemoved = "UnsetRemoved", t.Delete = "Delete", t.Rename = "Rename", t.IntializeDefaultProfile = "IntializeDefaultProfile", t.AddToProfile = "AddToProfile", t.InstalledExtensionNotFound = "InstalledExtensionNotFound", t.PostInstall = "PostInstall", t.CorruptZip = "CorruptZip", t.IncompleteZip = "IncompleteZip", t.PackageNotSigned = "PackageNotSigned", t.SignatureVerificationInternal = "SignatureVerificationInternal", t.SignatureVerificationFailed = "SignatureVerificationFailed", t.NotAllowed = "NotAllowed", t.Gallery = "Gallery", t.Cancelled = "Cancelled", t.Unknown = "Unknown", t.Internal = "Internal";
})(G2 || (G2 = {}));
var Q2;
(function(t) {
  t.NotSigned = "NotSigned", t.Success = "Success", t.RequiredArgumentMissing = "RequiredArgumentMissing", t.InvalidArgument = "InvalidArgument", t.PackageIsUnreadable = "PackageIsUnreadable", t.UnhandledException = "UnhandledException", t.SignatureManifestIsMissing = "SignatureManifestIsMissing", t.SignatureManifestIsUnreadable = "SignatureManifestIsUnreadable", t.SignatureIsMissing = "SignatureIsMissing", t.SignatureIsUnreadable = "SignatureIsUnreadable", t.CertificateIsUnreadable = "CertificateIsUnreadable", t.SignatureArchiveIsUnreadable = "SignatureArchiveIsUnreadable", t.FileAlreadyExists = "FileAlreadyExists", t.SignatureArchiveIsInvalidZip = "SignatureArchiveIsInvalidZip", t.SignatureArchiveHasSameSignatureFile = "SignatureArchiveHasSameSignatureFile", t.PackageIntegrityCheckFailed = "PackageIntegrityCheckFailed", t.SignatureIsInvalid = "SignatureIsInvalid", t.SignatureManifestIsInvalid = "SignatureManifestIsInvalid", t.SignatureIntegrityCheckFailed = "SignatureIntegrityCheckFailed", t.EntryIsMissing = "EntryIsMissing", t.EntryIsTampered = "EntryIsTampered", t.Untrusted = "Untrusted", t.CertificateRevoked = "CertificateRevoked", t.SignatureIsNotValid = "SignatureIsNotValid", t.UnknownError = "UnknownError", t.PackageIsInvalidZip = "PackageIsInvalidZip", t.SignatureArchiveHasTooManyEntries = "SignatureArchiveHasTooManyEntries";
})(Q2 || (Q2 = {}));
$_(1797, "Extensions");
$_(1798, "Preferences");
const k3 = "extensions.allowed";
ai.as(ml.Configuration).registerConfiguration({
  id: "extensions",
  order: 30,
  title: h(1799, "Extensions"),
  type: "object",
  properties: {
    [k3]: {
      type: "object",
      markdownDescription: h(
        1800,
        "Specify a list of extensions that are allowed to use. This helps maintain a secure and consistent development environment by restricting the use of unauthorized extensions. For more information on how to configure this setting, please visit the [Configure Allowed Extensions](https://code.visualstudio.com/docs/setup/enterprise#_configure-allowed-extensions) section."
      ),
      default: "*",
      defaultSnippets: [{
        body: {},
        description: h(1801, "No extensions are allowed.")
      }, {
        body: {
          "*": !0
        },
        description: h(1802, "All extensions are allowed.")
      }],
      scope: Lt.APPLICATION,
      policy: {
        name: "AllowedExtensions",
        minimumVersion: "1.96",
        description: h(
          1803,
          "Specify a list of extensions that are allowed to use. This helps maintain a secure and consistent development environment by restricting the use of unauthorized extensions. More information: https://code.visualstudio.com/docs/setup/enterprise#_configure-allowed-extensions"
        )
      },
      additionalProperties: !1,
      patternProperties: {
        "([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$": {
          anyOf: [
            {
              type: ["boolean", "string"],
              enum: [!0, !1, "stable"],
              description: h(1804, "Allow or disallow the extension."),
              enumDescriptions: [
                h(1805, "Extension is allowed."),
                h(1806, "Extension is not allowed."),
                h(1807, "Allow only stable versions of the extension.")
              ]
            },
            {
              type: "array",
              items: {
                type: "string"
              },
              description: h(
                1808,
                "Allow or disallow specific versions of the extension. To specifcy a platform specific version, use the format `platform@1.2.3`, e.g. `win32-x64@1.2.3`. Supported platforms are `win32-x64`, `win32-arm64`, `linux-x64`, `linux-arm64`, `linux-armhf`, `alpine-x64`, `alpine-arm64`, `darwin-x64`, `darwin-arm64`"
              )
            }
          ]
        },
        "([a-z0-9A-Z][a-z0-9-A-Z]*)$": {
          type: ["boolean", "string"],
          enum: [!0, !1, "stable"],
          description: h(1809, "Allow or disallow all extensions from the publisher."),
          enumDescriptions: [
            h(1810, "All extensions from the publisher are allowed."),
            h(1811, "All extensions from the publisher are not allowed."),
            h(1812, "Allow only stable versions of the extensions from the publisher.")
          ]
        },
        "\\*": {
          type: "boolean",
          enum: [!0, !1],
          description: h(1813, "Allow or disallow all extensions."),
          enumDescriptions: [
            h(1814, "Allow all extensions."),
            h(1815, "Disallow all extensions.")
          ]
        }
      }
    }
  }
});
var lo;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.CRASH = 1] = "CRASH", t[t.ERROR = 2] = "ERROR", t[t.USAGE = 3] = "USAGE";
})(lo || (lo = {}));
var K2;
(function(t) {
  t.OFF = "off", t.CRASH = "crash", t.ERROR = "error", t.ON = "all";
})(K2 || (K2 = {}));
class qx {
  constructor(e) {
    this.value = e, this.isTrustedTelemetryValue = !0;
  }
}
class I3 {
  constructor() {
    this.telemetryLevel = lo.NONE, this.sessionId = "someValue.sessionId", this.machineId = "someValue.machineId", this.sqmId = "someValue.sqmId", this.devDeviceId = "someValue.devDeviceId", this.firstSessionDate = "someValue.firstSessionDate", this.sendErrorTelemetry = !1;
  }
  publicLog() {
  }
  publicLog2() {
  }
  publicLogError() {
  }
  publicLogError2() {
  }
  setExperimentProperty() {
  }
}
new I3();
const C3 = "telemetry", T3 = { id: C3, name: h(2043, "Telemetry") }, P3 = /* @__PURE__ */ new Set(
  ["ssh-remote", "dev-container", "attached-container", "wsl", "tunnel", "codespaces", "amlext"]
);
function A3(t) {
  if (!t)
    return "none";
  const e = Tx(t);
  return P3.has(e) ? e : "other";
}
function R3(t, e) {
  if (!t || !t.includes("/") && !t.includes("\\"))
    return t;
  let i = t;
  const n = [];
  for (const a of e)
    for (; ; ) {
      const l = a.exec(t);
      if (!l)
        break;
      n.push([l.index, a.lastIndex]);
    }
  const r = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/, s = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g;
  let o = 0;
  for (i = ""; ; ) {
    const a = s.exec(t);
    if (!a)
      break;
    const l = n.some(([c, u]) => a.index < u && c < s.lastIndex);
    !r.test(a[0]) && !l && (i += t.substring(o, a.index) + "<REDACTED: user-file-path>", o = s.lastIndex);
  }
  return o < t.length && (i += t.substr(o)), i;
}
function L3(t) {
  if (!t)
    return t;
  const e = [
    { label: "Google API Key", regex: /AIza[A-Za-z0-9_\\\-]{35}/ },
    { label: "JWT", regex: /eyJ[0eXAiOiJKV1Qi|hbGci|a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+/ },
    { label: "Slack Token", regex: /xox[pbar]\-[A-Za-z0-9]/ },
    { label: "GitHub Token", regex: /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/ },
    { label: "Generic Secret", regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i },
    { label: "CLI Credentials", regex: /((login|psexec|(certutil|psexec)\.exe).{1,50}(\s-u(ser(name)?)?\s+.{3,100})?\s-(admin|user|vm|root)?p(ass(word)?)?\s+["']?[^$\-\/\s]|(^|[\s\r\n\\])net(\.exe)?.{1,5}(user\s+|share\s+\/user:| user -? secrets ? set) \s + [^ $\s \/])/ },
    { label: "Microsoft Entra ID", regex: /eyJ(?:0eXAiOiJKV1Qi|hbGci|[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.)/ },
    { label: "Email", regex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/ }
  ];
  for (const i of e)
    if (i.regex.test(t))
      return `<REDACTED: ${i.label}>`;
  return t;
}
function J2(t, e) {
  return Wc(t, (i) => {
    if (i instanceof qx || Object.hasOwnProperty.call(i, "isTrustedTelemetryValue"))
      return i.value;
    if (typeof i == "string") {
      let n = i.replaceAll("%20", " ");
      n = R3(n, e);
      for (const r of e)
        n = n.replace(r, "");
      return n = L3(n), n;
    }
  });
}
function N3(t, e) {
  return t.uuid && e.uuid ? t.uuid === e.uuid : t.id === e.id ? !0 : Cv(t.id, e.id) === 0;
}
new ht("pprice.better-merge");
class M3 {
  constructor() {
    this._generators = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new WeakMap();
  }
  register(e, i) {
    this._generators.set(e, i);
  }
  readActivationEvents(e) {
    return this._cache.has(e) || this._cache.set(e, this._readActivationEvents(e)), this._cache.get(e);
  }
  createActivationEventsMap(e) {
    const i = /* @__PURE__ */ Object.create(null);
    for (const n of e) {
      const r = this.readActivationEvents(n);
      r.length > 0 && (i[ht.toKey(n.identifier)] = r);
    }
    return i;
  }
  _readActivationEvents(e) {
    if (typeof e.main > "u" && typeof e.browser > "u")
      return [];
    const i = Array.isArray(e.activationEvents) ? e.activationEvents.slice(0) : [];
    for (let n = 0; n < i.length; n++)
      i[n] === "onUri" && (i[n] = `onUri:${ht.toKey(e.identifier)}`);
    if (!e.contributes)
      return i;
    for (const n in e.contributes) {
      const r = this._generators.get(n);
      if (!r)
        continue;
      const s = e.contributes[n], o = Array.isArray(s) ? s : [s];
      try {
        r(o, i);
      } catch (a) {
        Li(a);
      }
    }
    return i;
  }
}
const O3 = new M3(), F3 = Object.freeze({
  identifier: new ht("nullExtensionDescription"),
  name: "Null Extension Description",
  version: "0.0.0",
  publisher: "vscode",
  engines: { vscode: "" },
  extensionLocation: x.parse("void:location"),
  isBuiltin: !1,
  targetPlatform: Mv.UNDEFINED,
  isUserBuiltin: !1,
  isUnderDevelopment: !1,
  preRelease: !1
});
class Y2 {
  constructor(e) {
    this.dependency = e;
  }
}
var X2;
(function(t) {
  t[t.EagerAutoStart = 1] = "EagerAutoStart", t[t.EagerManualStart = 2] = "EagerManualStart", t[t.LazyAutoStart = 3] = "LazyAutoStart";
})(X2 || (X2 = {}));
function lt(t, e) {
  return t.enabledApiProposals ? t.enabledApiProposals.includes(e) : !1;
}
function $(t, e) {
  if (!lt(t, e))
    throw new Error(
      `Extension '${t.identifier.value}' CANNOT use API proposal: ${e}.
Its package.json#enabledApiProposals-property declares: ${t.enabledApiProposals?.join(", ") ?? "[]"} but NOT ${e}.
 The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${t.identifier.value}`
    );
}
var Zv;
(function(t) {
  t[t.Normal = 0] = "Normal", t[t.Immediate = 1] = "Immediate";
})(Zv || (Zv = {}));
const U3 = pe("extensionService"), $3 = "vscode://schemas/vscode-product", H3 = {
  activeComment: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.activeComment.d.ts"
  },
  aiRelatedInformation: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts"
  },
  aiSettingsSearch: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiSettingsSearch.d.ts"
  },
  aiTextSearchProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProvider.d.ts",
    version: 2
  },
  authIssuers: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authIssuers.d.ts"
  },
  authLearnMore: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authLearnMore.d.ts"
  },
  authProviderSpecific: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authProviderSpecific.d.ts"
  },
  authSession: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts"
  },
  canonicalUriProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts"
  },
  chatEditing: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatEditing.d.ts"
  },
  chatOutputRenderer: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatOutputRenderer.d.ts"
  },
  chatParticipantAdditions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantAdditions.d.ts"
  },
  chatParticipantPrivate: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantPrivate.d.ts",
    version: 9
  },
  chatProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts"
  },
  chatReferenceBinaryData: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceBinaryData.d.ts"
  },
  chatReferenceDiagnostic: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceDiagnostic.d.ts"
  },
  chatSessionsProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatSessionsProvider.d.ts"
  },
  chatStatusItem: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatStatusItem.d.ts"
  },
  chatTab: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatTab.d.ts"
  },
  codeActionAI: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionAI.d.ts"
  },
  codeActionRanges: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionRanges.d.ts"
  },
  codiconDecoration: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts"
  },
  commentReactor: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReactor.d.ts"
  },
  commentReveal: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReveal.d.ts"
  },
  commentThreadApplicability: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentThreadApplicability.d.ts"
  },
  commentingRangeHint: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentingRangeHint.d.ts"
  },
  commentsDraftState: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts"
  },
  contribAccessibilityHelpContent: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribAccessibilityHelpContent.d.ts"
  },
  contribCommentEditorActionsMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts"
  },
  contribCommentPeekContext: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts"
  },
  contribCommentThreadAdditionalMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts"
  },
  contribCommentsViewThreadMenus: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentsViewThreadMenus.d.ts"
  },
  contribDebugCreateConfiguration: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDebugCreateConfiguration.d.ts"
  },
  contribDiffEditorGutterToolBarMenus: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDiffEditorGutterToolBarMenus.d.ts"
  },
  contribEditSessions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts"
  },
  contribEditorContentMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts"
  },
  contribLabelFormatterWorkspaceTooltip: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts"
  },
  contribLanguageModelToolSets: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLanguageModelToolSets.d.ts"
  },
  contribMenuBarHome: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts"
  },
  contribMergeEditorMenus: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts"
  },
  contribMultiDiffEditorMenus: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMultiDiffEditorMenus.d.ts"
  },
  contribNotebookStaticPreloads: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts"
  },
  contribRemoteHelp: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts"
  },
  contribShareMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts"
  },
  contribSourceControlHistoryItemMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemMenu.d.ts"
  },
  contribSourceControlHistoryTitleMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryTitleMenu.d.ts"
  },
  contribSourceControlInputBoxMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlInputBoxMenu.d.ts"
  },
  contribSourceControlTitleMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlTitleMenu.d.ts"
  },
  contribStatusBarItems: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts"
  },
  contribViewContainerTitle: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewContainerTitle.d.ts"
  },
  contribViewsRemote: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts"
  },
  contribViewsWelcome: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts"
  },
  customEditorMove: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts"
  },
  dataChannels: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.dataChannels.d.ts"
  },
  debugVisualization: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugVisualization.d.ts"
  },
  defaultChatParticipant: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.defaultChatParticipant.d.ts",
    version: 4
  },
  diffCommand: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts"
  },
  diffContentOptions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts"
  },
  documentFiltersExclusive: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts"
  },
  editSessionIdentityProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts"
  },
  editorHoverVerbosityLevel: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorHoverVerbosityLevel.d.ts"
  },
  editorInsets: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts"
  },
  embeddings: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.embeddings.d.ts"
  },
  extensionRuntime: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts"
  },
  extensionsAny: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts"
  },
  externalUriOpener: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts"
  },
  fileSearchProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts"
  },
  fileSearchProvider2: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider2.d.ts"
  },
  findFiles2: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2.d.ts",
    version: 2
  },
  findTextInFiles: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts"
  },
  findTextInFiles2: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles2.d.ts"
  },
  fsChunks: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts"
  },
  idToken: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.idToken.d.ts"
  },
  inlineCompletionsAdditions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts"
  },
  interactive: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts"
  },
  interactiveWindow: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts"
  },
  ipc: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts"
  },
  languageModelCapabilities: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelCapabilities.d.ts"
  },
  languageModelDataPart: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelDataPart.d.ts",
    version: 3
  },
  languageModelSystem: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelSystem.d.ts"
  },
  languageModelToolResultAudience: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelToolResultAudience.d.ts"
  },
  languageStatusText: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageStatusText.d.ts"
  },
  mappedEditsProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts"
  },
  multiDocumentHighlightProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts"
  },
  nativeWindowHandle: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.nativeWindowHandle.d.ts"
  },
  newSymbolNamesProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.newSymbolNamesProvider.d.ts"
  },
  notebookCellExecution: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecution.d.ts"
  },
  notebookControllerAffinityHidden: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts"
  },
  notebookDeprecated: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts"
  },
  notebookExecution: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts"
  },
  notebookKernelSource: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts"
  },
  notebookLiveShare: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts"
  },
  notebookMessaging: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts"
  },
  notebookMime: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts"
  },
  notebookReplDocument: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookReplDocument.d.ts"
  },
  notebookVariableProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookVariableProvider.d.ts"
  },
  portsAttributes: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts"
  },
  profileContentHandlers: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts"
  },
  quickDiffProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts"
  },
  quickInputButtonLocation: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickInputButtonLocation.d.ts"
  },
  quickPickItemTooltip: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts"
  },
  quickPickSortByLabel: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts"
  },
  remoteCodingAgents: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.remoteCodingAgents.d.ts"
  },
  resolvers: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts"
  },
  scmActionButton: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts"
  },
  scmHistoryProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmHistoryProvider.d.ts"
  },
  scmMultiDiffEditor: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmMultiDiffEditor.d.ts"
  },
  scmProviderOptions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmProviderOptions.d.ts"
  },
  scmSelectedProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts"
  },
  scmTextDocument: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts"
  },
  scmValidation: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts"
  },
  secretStorageKeys: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.secretStorageKeys.d.ts"
  },
  shareProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts"
  },
  speech: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.speech.d.ts"
  },
  statusBarItemTooltip: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.statusBarItemTooltip.d.ts"
  },
  tabInputMultiDiff: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputMultiDiff.d.ts"
  },
  tabInputTextMerge: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts"
  },
  taskExecutionTerminal: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskExecutionTerminal.d.ts"
  },
  taskPresentationGroup: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts"
  },
  taskProblemMatcherStatus: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskProblemMatcherStatus.d.ts"
  },
  telemetry: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts"
  },
  terminalCompletionProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalCompletionProvider.d.ts"
  },
  terminalDataWriteEvent: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts"
  },
  terminalDimensions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts"
  },
  terminalExecuteCommandEvent: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts"
  },
  terminalQuickFixProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts"
  },
  terminalSelection: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts"
  },
  terminalShellEnv: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalShellEnv.d.ts"
  },
  testObserver: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts"
  },
  testRelatedCode: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testRelatedCode.d.ts"
  },
  textDocumentChangeReason: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textDocumentChangeReason.d.ts"
  },
  textEditorDiffInformation: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textEditorDiffInformation.d.ts"
  },
  textSearchComplete2: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchComplete2.d.ts"
  },
  textSearchProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts"
  },
  textSearchProvider2: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider2.d.ts"
  },
  timeline: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts"
  },
  tokenInformation: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts"
  },
  toolProgress: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.toolProgress.d.ts"
  },
  treeViewActiveItem: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts"
  },
  treeViewMarkdownMessage: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts"
  },
  treeViewReveal: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts"
  },
  tunnelFactory: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts"
  },
  tunnels: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts"
  },
  valueSelectionInQuickPick: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.valueSelectionInQuickPick.d.ts"
  },
  workspaceTrust: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts"
  }
}, og = Object.freeze(H3), jx = ai.as(K_.JSONContribution);
class _d {
  static _toSet(e) {
    const i = new ul();
    for (let n = 0, r = e.length; n < r; n++)
      i.add(e[n].description.identifier);
    return i;
  }
  static compute(e, i) {
    if (!e || !e.length)
      return new _d(i, []);
    if (!i || !i.length)
      return new _d([], e);
    const n = this._toSet(e), r = this._toSet(i), s = i.filter((a) => !n.has(a.description.identifier)), o = e.filter((a) => !r.has(a.description.identifier));
    return new _d(s, o);
  }
  constructor(e, i) {
    this.added = e, this.removed = i;
  }
}
class B3 {
  constructor(e, i, n) {
    this.name = e, this.defaultExtensionKind = i, this.canHandleResolver = n, this._handler = null, this._users = null, this._delta = null;
  }
  setHandler(e) {
    if (this._handler !== null)
      throw new Error("Handler already set!");
    return this._handler = e, this._handle(), {
      dispose: () => {
        this._handler = null;
      }
    };
  }
  acceptUsers(e) {
    this._delta = _d.compute(this._users, e), this._users = e, this._handle();
  }
  _handle() {
    if (!(this._handler === null || this._users === null || this._delta === null))
      try {
        this._handler(this._users, this._delta);
      } catch (e) {
        Li(e);
      }
  }
}
const W3 = {
  type: "string",
  enum: [
    "ui",
    "workspace"
  ],
  enumDescriptions: [
    h(
      13131,
      "UI extension kind. In a remote window, such extensions are enabled only when available on the local machine."
    ),
    h(
      13132,
      "Workspace extension kind. In a remote window, such extensions are enabled only when available on the remote."
    )
  ]
}, CT = "vscode://schemas/vscode-extensions", ew = {
  properties: {
    engines: {
      type: "object",
      description: h(13133, "Engine compatibility."),
      properties: {
        vscode: {
          type: "string",
          description: h(
            13134,
            "For VS Code extensions, specifies the VS Code version that the extension is compatible with. Cannot be *. For example: ^0.10.5 indicates compatibility with a minimum VS Code version of 0.10.5."
          ),
          default: "^1.22.0"
        }
      }
    },
    publisher: {
      description: h(13135, "The publisher of the VS Code extension."),
      type: "string"
    },
    displayName: {
      description: h(13136, "The display name for the extension used in the VS Code gallery."),
      type: "string"
    },
    categories: {
      description: h(
        13137,
        "The categories used by the VS Code gallery to categorize the extension."
      ),
      type: "array",
      uniqueItems: !0,
      items: {
        oneOf: [
          {
            type: "string",
            enum: g8
          },
          {
            type: "string",
            const: "Languages",
            deprecationMessage: h(13138, "Use 'Programming  Languages' instead")
          }
        ]
      }
    },
    galleryBanner: {
      type: "object",
      description: h(13139, "Banner used in the VS Code marketplace."),
      properties: {
        color: {
          description: h(13140, "The banner color on the VS Code marketplace page header."),
          type: "string"
        },
        theme: {
          description: h(13141, "The color theme for the font used in the banner."),
          type: "string",
          enum: ["dark", "light"]
        }
      }
    },
    contributes: {
      description: h(
        13142,
        "All contributions of the VS Code extension represented by this package."
      ),
      type: "object",
      properties: {},
      default: {}
    },
    preview: {
      type: "boolean",
      description: h(13143, "Sets the extension to be flagged as a Preview in the Marketplace.")
    },
    enableProposedApi: {
      type: "boolean",
      deprecationMessage: h(13144, "Use `enabledApiProposals` instead.")
    },
    enabledApiProposals: {
      markdownDescription: h(
        13145,
        "Enable API proposals to try them out. Only valid **during development**. Extensions **cannot be published** with this property. For more details visit: https://code.visualstudio.com/api/advanced-topics/using-proposed-api"
      ),
      type: "array",
      uniqueItems: !0,
      items: {
        type: "string",
        enum: Object.keys(og).map((t) => t),
        markdownEnumDescriptions: Object.values(og).map((t) => t.proposal)
      }
    },
    api: {
      markdownDescription: h(
        13146,
        "Describe the API provided by this extension. For more details visit: https://code.visualstudio.com/api/advanced-topics/remote-extensions#handling-dependencies-with-remote-extensions"
      ),
      type: "string",
      enum: ["none"],
      enumDescriptions: [
        h(
          13147,
          "Give up entirely the ability to export any APIs. This allows other extensions that depend on this extension to run in a separate extension host process or in a remote machine."
        )
      ]
    },
    activationEvents: {
      description: h(13148, "Activation events for the VS Code extension."),
      type: "array",
      items: {
        type: "string",
        defaultSnippets: [
          {
            label: "onWebviewPanel",
            description: h(
              13149,
              "An activation event emmited when a webview is loaded of a certain viewType"
            ),
            body: "onWebviewPanel:viewType"
          },
          {
            label: "onLanguage",
            description: h(
              13150,
              "An activation event emitted whenever a file that resolves to the specified language gets opened."
            ),
            body: "onLanguage:${1:languageId}"
          },
          {
            label: "onCommand",
            description: h(
              13151,
              "An activation event emitted whenever the specified command gets invoked."
            ),
            body: "onCommand:${2:commandId}"
          },
          {
            label: "onDebug",
            description: h(
              13152,
              "An activation event emitted whenever a user is about to start debugging or about to setup debug configurations."
            ),
            body: "onDebug"
          },
          {
            label: "onDebugInitialConfigurations",
            description: h(
              13153,
              'An activation event emitted whenever a "launch.json" needs to be created (and all provideDebugConfigurations methods need to be called).'
            ),
            body: "onDebugInitialConfigurations"
          },
          {
            label: "onDebugDynamicConfigurations",
            description: h(
              13154,
              'An activation event emitted whenever a list of all debug configurations needs to be created (and all provideDebugConfigurations methods for the "dynamic" scope need to be called).'
            ),
            body: "onDebugDynamicConfigurations"
          },
          {
            label: "onDebugResolve",
            description: h(
              13155,
              "An activation event emitted whenever a debug session with the specific type is about to be launched (and a corresponding resolveDebugConfiguration method needs to be called)."
            ),
            body: "onDebugResolve:${6:type}"
          },
          {
            label: "onDebugAdapterProtocolTracker",
            description: h(
              13156,
              "An activation event emitted whenever a debug session with the specific type is about to be launched and a debug protocol tracker might be needed."
            ),
            body: "onDebugAdapterProtocolTracker:${6:type}"
          },
          {
            label: "workspaceContains",
            description: h(
              13157,
              "An activation event emitted whenever a folder is opened that contains at least a file matching the specified glob pattern."
            ),
            body: "workspaceContains:${4:filePattern}"
          },
          {
            label: "onStartupFinished",
            description: h(
              13158,
              "An activation event emitted after the start-up finished (after all `*` activated extensions have finished activating)."
            ),
            body: "onStartupFinished"
          },
          {
            label: "onTaskType",
            description: h(
              13159,
              "An activation event emitted whenever tasks of a certain type need to be listed or resolved."
            ),
            body: "onTaskType:${1:taskType}"
          },
          {
            label: "onFileSystem",
            description: h(
              13160,
              "An activation event emitted whenever a file or folder is accessed with the given scheme."
            ),
            body: "onFileSystem:${1:scheme}"
          },
          {
            label: "onEditSession",
            description: h(
              13161,
              "An activation event emitted whenever an edit session is accessed with the given scheme."
            ),
            body: "onEditSession:${1:scheme}"
          },
          {
            label: "onSearch",
            description: h(
              13162,
              "An activation event emitted whenever a search is started in the folder with the given scheme."
            ),
            body: "onSearch:${7:scheme}"
          },
          {
            label: "onView",
            body: "onView:${5:viewId}",
            description: h(
              13163,
              "An activation event emitted whenever the specified view is expanded."
            )
          },
          {
            label: "onUri",
            body: "onUri",
            description: h(
              13164,
              "An activation event emitted whenever a system-wide Uri directed towards this extension is open."
            )
          },
          {
            label: "onOpenExternalUri",
            body: "onOpenExternalUri",
            description: h(
              13165,
              "An activation event emitted whenever a external uri (such as an http or https link) is being opened."
            )
          },
          {
            label: "onCustomEditor",
            body: "onCustomEditor:${9:viewType}",
            description: h(
              13166,
              "An activation event emitted whenever the specified custom editor becomes visible."
            )
          },
          {
            label: "onNotebook",
            body: "onNotebook:${1:type}",
            description: h(
              13167,
              "An activation event emitted whenever the specified notebook document is opened."
            )
          },
          {
            label: "onAuthenticationRequest",
            body: "onAuthenticationRequest:${11:authenticationProviderId}",
            description: h(
              13168,
              "An activation event emitted whenever sessions are requested from the specified authentication provider."
            )
          },
          {
            label: "onRenderer",
            description: h(
              13169,
              "An activation event emitted whenever a notebook output renderer is used."
            ),
            body: "onRenderer:${11:rendererId}"
          },
          {
            label: "onTerminalProfile",
            body: "onTerminalProfile:${1:terminalId}",
            description: h(
              13170,
              "An activation event emitted when a specific terminal profile is launched."
            )
          },
          {
            label: "onTerminalQuickFixRequest",
            body: "onTerminalQuickFixRequest:${1:quickFixId}",
            description: h(
              13171,
              "An activation event emitted when a command matches the selector associated with this ID"
            )
          },
          {
            label: "onWalkthrough",
            body: "onWalkthrough:${1:walkthroughID}",
            description: h(
              13172,
              "An activation event emitted when a specified walkthrough is opened."
            )
          },
          {
            label: "onIssueReporterOpened",
            body: "onIssueReporterOpened",
            description: h(13173, "An activation event emitted when the issue reporter is opened.")
          },
          {
            label: "onChatParticipant",
            body: "onChatParticipant:${1:participantId}",
            description: h(
              13174,
              "An activation event emitted when the specified chat participant is invoked."
            )
          },
          {
            label: "onLanguageModelTool",
            body: "onLanguageModelTool:${1:toolId}",
            description: h(
              13175,
              "An activation event emitted when the specified language model tool is invoked."
            )
          },
          {
            label: "onTerminal",
            body: "onTerminal:{1:shellType}",
            description: h(
              13176,
              "An activation event emitted when a terminal of the given shell type is opened."
            )
          },
          {
            label: "onTerminalCompletionsRequested",
            body: "onTerminalCompletionsRequested",
            description: h(
              13177,
              "An activation event emitted when terminal completions are requested."
            )
          },
          {
            label: "onTerminalShellIntegration",
            body: "onTerminalShellIntegration:${1:shellType}",
            description: h(
              13178,
              "An activation event emitted when terminal shell integration is activated for the given shell type."
            )
          },
          {
            label: "onMcpCollection",
            description: h(
              13179,
              "An activation event emitted whenver a tool from the MCP server is requested."
            ),
            body: "onMcpCollection:${2:collectionId}"
          },
          {
            label: "*",
            description: h(
              13180,
              "An activation event emitted on VS Code startup. To ensure a great end user experience, please use this activation event in your extension only when no other activation events combination works in your use-case."
            ),
            body: "*"
          }
        ]
      }
    },
    badges: {
      type: "array",
      description: h(
        13181,
        "Array of badges to display in the sidebar of the Marketplace's extension page."
      ),
      items: {
        type: "object",
        required: ["url", "href", "description"],
        properties: {
          url: {
            type: "string",
            description: h(13182, "Badge image URL.")
          },
          href: {
            type: "string",
            description: h(13183, "Badge link.")
          },
          description: {
            type: "string",
            description: h(13184, "Badge description.")
          }
        }
      }
    },
    markdown: {
      type: "string",
      description: h(
        13185,
        "Controls the Markdown rendering engine used in the Marketplace. Either github (default) or standard."
      ),
      enum: ["github", "standard"],
      default: "github"
    },
    qna: {
      default: "marketplace",
      description: h(
        13186,
        "Controls the Q&A link in the Marketplace. Set to marketplace to enable the default Marketplace Q & A site. Set to a string to provide the URL of a custom Q & A site. Set to false to disable Q & A altogether."
      ),
      anyOf: [
        {
          type: ["string", "boolean"],
          enum: ["marketplace", !1]
        },
        {
          type: "string"
        }
      ]
    },
    extensionDependencies: {
      description: h(
        13187,
        "Dependencies to other extensions. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp."
      ),
      type: "array",
      uniqueItems: !0,
      items: {
        type: "string",
        pattern: H2
      }
    },
    extensionPack: {
      description: h(
        13188,
        "A set of extensions that can be installed together. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp."
      ),
      type: "array",
      uniqueItems: !0,
      items: {
        type: "string",
        pattern: H2
      }
    },
    extensionKind: {
      description: h(
        13189,
        "Define the kind of an extension. `ui` extensions are installed and run on the local machine while `workspace` extensions run on the remote."
      ),
      type: "array",
      items: W3,
      default: ["workspace"],
      defaultSnippets: [
        {
          body: ["ui"],
          description: h(
            13190,
            "Define an extension which can run only on the local machine when connected to remote window."
          )
        },
        {
          body: ["workspace"],
          description: h(
            13191,
            "Define an extension which can run only on the remote machine when connected remote window."
          )
        },
        {
          body: ["ui", "workspace"],
          description: h(
            13192,
            "Define an extension which can run on either side, with a preference towards running on the local machine."
          )
        },
        {
          body: ["workspace", "ui"],
          description: h(
            13193,
            "Define an extension which can run on either side, with a preference towards running on the remote machine."
          )
        },
        {
          body: [],
          description: h(
            13194,
            "Define an extension which cannot run in a remote context, neither on the local, nor on the remote machine."
          )
        }
      ]
    },
    capabilities: {
      description: h(13195, "Declare the set of supported capabilities by the extension."),
      type: "object",
      properties: {
        virtualWorkspaces: {
          description: h(
            13196,
            "Declares whether the extension should be enabled in virtual workspaces. A virtual workspace is a workspace which is not backed by any on-disk resources. When false, this extension will be automatically disabled in virtual workspaces. Default is true."
          ),
          type: ["boolean", "object"],
          defaultSnippets: [
            { label: "limited", body: { supported: "${1:limited}", description: "${2}" } },
            { label: "false", body: { supported: !1, description: "${2}" } }
          ],
          default: (!0).valueOf,
          properties: {
            supported: {
              markdownDescription: h(
                13197,
                "Declares the level of support for virtual workspaces by the extension."
              ),
              type: ["string", "boolean"],
              enum: ["limited", !0, !1],
              enumDescriptions: [
                h(
                  13198,
                  "The extension will be enabled in virtual workspaces with some functionality disabled."
                ),
                h(
                  13199,
                  "The extension will be enabled in virtual workspaces with all functionality enabled."
                ),
                h(13200, "The extension will not be enabled in virtual workspaces.")
              ]
            },
            description: {
              type: "string",
              markdownDescription: h(
                13201,
                "A description of how virtual workspaces affects the extensions behavior and why it is needed. This only applies when `supported` is not `true`."
              )
            }
          }
        },
        untrustedWorkspaces: {
          description: h(
            13202,
            "Declares how the extension should be handled in untrusted workspaces."
          ),
          type: "object",
          required: ["supported"],
          defaultSnippets: [
            { body: { supported: "${1:limited}", description: "${2}" } }
          ],
          properties: {
            supported: {
              markdownDescription: h(
                13203,
                "Declares the level of support for untrusted workspaces by the extension."
              ),
              type: ["string", "boolean"],
              enum: ["limited", !0, !1],
              enumDescriptions: [
                h(
                  13204,
                  "The extension will be enabled in untrusted workspaces with some functionality disabled."
                ),
                h(
                  13205,
                  "The extension will be enabled in untrusted workspaces with all functionality enabled."
                ),
                h(13206, "The extension will not be enabled in untrusted workspaces.")
              ]
            },
            restrictedConfigurations: {
              description: h(
                13207,
                "A list of configuration keys contributed by the extension that should not use workspace values in untrusted workspaces."
              ),
              type: "array",
              items: {
                type: "string"
              }
            },
            description: {
              type: "string",
              markdownDescription: h(
                13208,
                "A description of how workspace trust affects the extensions behavior and why it is needed. This only applies when `supported` is not `true`."
              )
            }
          }
        }
      }
    },
    sponsor: {
      description: h(13209, "Specify the location from where users can sponsor your extension."),
      type: "object",
      defaultSnippets: [
        { body: { url: "${1:https:}" } }
      ],
      properties: {
        url: {
          description: h(
            13210,
            "URL from where users can sponsor your extension. It must be a valid URL with a HTTP or HTTPS protocol. Example value: https://github.com/sponsors/nvaccess"
          ),
          type: "string"
        }
      }
    },
    scripts: {
      type: "object",
      properties: {
        "vscode:prepublish": {
          description: h(
            13211,
            "Script executed before the package is published as a VS Code extension."
          ),
          type: "string"
        },
        "vscode:uninstall": {
          description: h(
            13212,
            "Uninstall hook for VS Code extension. Script that gets executed when the extension is completely uninstalled from VS Code which is when VS Code is restarted (shutdown and start) after the extension is uninstalled. Only Node scripts are supported."
          ),
          type: "string"
        }
      }
    },
    icon: {
      type: "string",
      description: h(13213, "The path to a 128x128 pixel icon.")
    },
    l10n: {
      type: "string",
      description: h(
        13214,
        "The relative path to a folder containing localization (bundle.l10n.*.json) files. Must be specified if you are using the vscode.l10n API."
      )
    },
    pricing: {
      type: "string",
      markdownDescription: h(
        13215,
        "The pricing information for the extension. Can be Free (default) or Trial. For more details visit: https://code.visualstudio.com/api/working-with-extensions/publishing-extension#extension-pricing-label"
      ),
      enum: ["Free", "Trial"],
      default: "Free"
    }
  }
};
class V3 {
  constructor() {
    this._extensionPoints = /* @__PURE__ */ new Map();
  }
  registerExtensionPoint(e) {
    if (this._extensionPoints.has(e.extensionPoint))
      throw new Error("Duplicate extension point: " + e.extensionPoint);
    const i = new B3(e.extensionPoint, e.defaultExtensionKind, e.canHandleResolver);
    return this._extensionPoints.set(e.extensionPoint, i), e.activationEventsGenerator && O3.register(e.extensionPoint, e.activationEventsGenerator), ew.properties.contributes.properties[e.extensionPoint] = e.jsonSchema, jx.registerSchema(CT, ew), i;
  }
  getExtensionPoints() {
    return Array.from(this._extensionPoints.values());
  }
}
const TT = {
  ExtensionsRegistry: "ExtensionsRegistry"
};
ai.add(TT.ExtensionsRegistry, new V3());
const PT = ai.as(TT.ExtensionsRegistry);
jx.registerSchema(CT, ew);
jx.registerSchema($3, {
  properties: {
    extensionEnabledApiProposals: {
      description: h(13216, "API proposals that the respective extensions can freely use."),
      type: "object",
      properties: {},
      additionalProperties: {
        anyOf: [{
          type: "array",
          uniqueItems: !0,
          items: {
            type: "string",
            enum: Object.keys(og),
            markdownEnumDescriptions: Object.values(og).map((t) => t.proposal)
          }
        }]
      }
    }
  }
});
new T("isMac", Rn, h(1757, "Whether the operating system is macOS"));
new T("isLinux", So, h(1758, "Whether the operating system is Linux"));
new T("isWindows", ji, h(1759, "Whether the operating system is Windows"));
const z3 = new T("isWeb", af, h(1760, "Whether the platform is a web browser"));
new T("isMacNative", Rn && !af, h(1761, "Whether the operating system is macOS on a non-browser platform"));
new T("isIOS", qA, h(1762, "Whether the operating system is iOS"));
new T("isMobile", jA, h(1763, "Whether the platform is a mobile web browser"));
new T("isDevelopment", !1, !0);
new T("productQualityType", "", h(1764, "Quality type of VS Code"));
const q3 = "inputFocus";
new T(q3, !1, h(1765, "Whether keyboard focus is inside an input box"));
const AT = pe("languageService"), RT = pe("modelService");
class Z2 extends yT {
  constructor() {
    super(...arguments), this._onDidChangeDirty = this._register(new N()), this._onDidChangeLabel = this._register(new N()), this._onDidChangeCapabilities = this._register(new N()), this._onWillDispose = this._register(new N()), this.onDidChangeDirty = this._onDidChangeDirty.event, this.onDidChangeLabel = this._onDidChangeLabel.event, this.onDidChangeCapabilities = this._onDidChangeCapabilities.event, this.onWillDispose = this._onWillDispose.event;
  }
  get editorId() {
  }
  get capabilities() {
    return In.Readonly;
  }
  hasCapability(e) {
    return e === In.None ? this.capabilities === In.None : (this.capabilities & e) !== 0;
  }
  isReadonly() {
    return this.hasCapability(In.Readonly);
  }
  getName() {
    return `Editor ${this.typeId}`;
  }
  getDescription(e) {
  }
  getTitle(e) {
    return this.getName();
  }
  getLabelExtraClasses() {
    return [];
  }
  getAriaLabel() {
    return this.getTitle(Xt.SHORT);
  }
  getIcon() {
  }
  getTelemetryDescriptor() {
    return { typeId: this.typeId };
  }
  isDirty() {
    return !1;
  }
  isModified() {
    return this.isDirty();
  }
  isSaving() {
    return !1;
  }
  async resolve() {
    return null;
  }
  async save(e, i) {
    return this;
  }
  async saveAs(e, i) {
    return this;
  }
  async revert(e, i) {
  }
  async rename(e, i) {
  }
  copy() {
    return this;
  }
  canMove(e, i) {
    return !0;
  }
  matches(e) {
    if (_r(e))
      return this === e;
    const i = e.options?.override;
    return this.editorId !== i && i !== void 0 && this.editorId !== void 0 ? !1 : uc(this.resource, Jv.getCanonicalUri(e));
  }
  prefersEditorPane(e) {
    return e.at(0);
  }
  toUntyped(e) {
  }
  isDisposed() {
    return this._store.isDisposed;
  }
  dispose() {
    this.isDisposed() || this._onWillDispose.fire(), super.dispose();
  }
}
const LT = pe("editorService");
var Ol, Ba;
let tw = (Ba = class extends Z2 {
  get typeId() {
    return Ol.ID;
  }
  get capabilities() {
    let e = this.primary.capabilities;
    return e &= ~In.CanSplitInGroup, this.secondary.hasCapability(In.RequiresTrust) && (e |= In.RequiresTrust), this.secondary.hasCapability(In.Singleton) && (e |= In.Singleton), e |= In.MultipleEditors, e;
  }
  get resource() {
    if (this.hasIdenticalSides)
      return this.primary.resource;
  }
  constructor(e, i, n, r, s) {
    super(), this.preferredName = e, this.preferredDescription = i, this.secondary = n, this.primary = r, this.editorService = s, this.hasIdenticalSides = this.primary.matches(this.secondary), this.registerListeners();
  }
  registerListeners() {
    this._register(It.once(It.any(this.primary.onWillDispose, this.secondary.onWillDispose))(() => {
      this.isDisposed() || this.dispose();
    })), this._register(this.primary.onDidChangeDirty(() => this._onDidChangeDirty.fire())), this._register(this.primary.onDidChangeCapabilities(() => this._onDidChangeCapabilities.fire())), this._register(this.secondary.onDidChangeCapabilities(() => this._onDidChangeCapabilities.fire())), this._register(this.primary.onDidChangeLabel(() => this._onDidChangeLabel.fire())), this._register(this.secondary.onDidChangeLabel(() => this._onDidChangeLabel.fire()));
  }
  getName() {
    const e = this.getPreferredName();
    return e || (this.hasIdenticalSides ? this.primary.getName() : h(3943, "{0} - {1}", this.secondary.getName(), this.primary.getName()));
  }
  getPreferredName() {
    return this.preferredName;
  }
  getDescription(e) {
    const i = this.getPreferredDescription();
    return i || (this.hasIdenticalSides ? this.primary.getDescription(e) : super.getDescription(e));
  }
  getPreferredDescription() {
    return this.preferredDescription;
  }
  getTitle(e) {
    let i;
    this.hasIdenticalSides ? i = this.primary.getTitle(e) ?? this.getName() : i = super.getTitle(e);
    const n = this.getPreferredTitle();
    return n && (i = `${n} (${i})`), i;
  }
  getPreferredTitle() {
    if (this.preferredName && this.preferredDescription)
      return `${this.preferredName} ${this.preferredDescription}`;
    if (this.preferredName || this.preferredDescription)
      return this.preferredName ?? this.preferredDescription;
  }
  getLabelExtraClasses() {
    return this.hasIdenticalSides ? this.primary.getLabelExtraClasses() : super.getLabelExtraClasses();
  }
  getAriaLabel() {
    return this.hasIdenticalSides ? this.primary.getAriaLabel() : super.getAriaLabel();
  }
  getTelemetryDescriptor() {
    return { ...this.primary.getTelemetryDescriptor(), ...super.getTelemetryDescriptor() };
  }
  isDirty() {
    return this.primary.isDirty();
  }
  isSaving() {
    return this.primary.isSaving();
  }
  async save(e, i) {
    const n = await this.primary.save(e, i);
    return this.saveResultToEditor(n);
  }
  async saveAs(e, i) {
    const n = await this.primary.saveAs(e, i);
    return this.saveResultToEditor(n);
  }
  saveResultToEditor(e) {
    if (!e || !this.hasIdenticalSides)
      return e;
    if (this.primary.matches(e))
      return this;
    if (e instanceof Z2)
      return new Ol(
        this.preferredName,
        this.preferredDescription,
        e,
        e,
        this.editorService
      );
    if (!ks(e) && !gd(e) && !ua(e) && !da(e))
      return {
        primary: e,
        secondary: e,
        label: this.preferredName,
        description: this.preferredDescription
      };
  }
  revert(e, i) {
    return this.primary.revert(e, i);
  }
  async rename(e, i) {
    if (!this.hasIdenticalSides)
      return;
    const n = await this.primary.rename(e, i);
    if (n) {
      if (_r(n.editor))
        return {
          editor: new Ol(
            this.preferredName,
            this.preferredDescription,
            n.editor,
            n.editor,
            this.editorService
          ),
          options: {
            ...n.options,
            viewState: V1(this, e, this.editorService)
          }
        };
      if (t3(n.editor))
        return {
          editor: {
            label: this.preferredName,
            description: this.preferredDescription,
            primary: n.editor,
            secondary: n.editor,
            options: {
              ...n.options,
              viewState: V1(this, e, this.editorService)
            }
          }
        };
    }
  }
  isReadonly() {
    return this.primary.isReadonly();
  }
  toUntyped(e) {
    const i = this.primary.toUntyped(e), n = this.secondary.toUntyped(e);
    if (i && n && !ks(i) && !ks(n) && !gd(i) && !gd(n) && !ua(i) && !ua(n) && !da(i) && !da(n)) {
      const r = {
        label: this.preferredName,
        description: this.preferredDescription,
        primary: i,
        secondary: n
      };
      return typeof e?.preserveViewState == "number" && (r.options = {
        viewState: V1(this, e.preserveViewState, this.editorService)
      }), r;
    }
  }
  matches(e) {
    return this === e ? !0 : xT(e) || ks(e) ? !1 : e instanceof Ol ? this.primary.matches(e.primary) && this.secondary.matches(e.secondary) : ua(e) ? this.primary.matches(e.primary) && this.secondary.matches(e.secondary) : !1;
  }
}, Ol = Ba, Ba.ID = "workbench.editorinputs.sidebysideEditorInput", Ba);
tw = Ol = W([
  M(4, LT)
], tw);
class NT extends ve {
  constructor() {
    super(...arguments), this._onWillDispose = this._register(new N()), this.onWillDispose = this._onWillDispose.event, this.resolved = !1;
  }
  async resolve() {
    this.resolved = !0;
  }
  isResolved() {
    return this.resolved;
  }
  isDisposed() {
    return this._store.isDisposed;
  }
  dispose() {
    this._onWillDispose.fire(), super.dispose();
  }
}
const j3 = {
  ModesRegistry: "editor.modesRegistry"
};
class G3 extends ve {
  constructor() {
    super(), this._onDidChangeLanguages = this._register(new N()), this.onDidChangeLanguages = this._onDidChangeLanguages.event, this._languages = [];
  }
  registerLanguage(e) {
    return this._languages.push(e), this._onDidChangeLanguages.fire(void 0), {
      dispose: () => {
        for (let i = 0, n = this._languages.length; i < n; i++)
          if (this._languages[i] === e) {
            this._languages.splice(i, 1);
            return;
          }
      }
    };
  }
  getLanguages() {
    return this._languages;
  }
}
const MT = new G3();
ai.add(j3.ModesRegistry, MT);
const op = "plaintext", Q3 = ".txt";
MT.registerLanguage({
  id: op,
  extensions: [Q3],
  aliases: [h(842, "Plain Text"), "text"],
  mimetypes: [gr.text]
});
ai.as(ml.Configuration).registerDefaultConfigurations([{
  overrides: {
    "[plaintext]": {
      "editor.unicodeHighlight.ambiguousCharacters": !1,
      "editor.unicodeHighlight.invisibleCharacters": !1
    },
    "[go]": {
      "editor.insertSpaces": !1
    },
    "[makefile]": {
      "editor.insertSpaces": !1
    },
    "[shellscript]": {
      "files.eol": `
`
    },
    "[yaml]": {
      "editor.insertSpaces": !0,
      "editor.tabSize": 2
    }
  }
}]);
const eD = "languageDetection", K3 = pe("ILanguageDetectionService"), J3 = pe("accessibilityService");
var iw, Wa;
let ag = (Wa = class extends NT {
  constructor(e, i, n, r, s) {
    super(), this.modelService = e, this.languageService = i, this.languageDetectionService = n, this.accessibilityService = r, this.textEditorModelHandle = void 0, this.modelDisposeListener = this._register(new Ss()), this.autoDetectLanguageThrottler = this._register(new F4(iw.AUTO_DETECT_LANGUAGE_THROTTLE_DELAY)), this._blockLanguageChangeListener = !1, this._languageChangeSource = void 0, s && this.handleExistingModel(s);
  }
  handleExistingModel(e) {
    const i = this.modelService.getModel(e);
    if (!i)
      throw new Error(`Document with resource ${e.toString(!0)} does not exist`);
    this.textEditorModelHandle = e, this.registerModelDisposeListener(i);
  }
  registerModelDisposeListener(e) {
    this.modelDisposeListener.value = e.onWillDispose(() => {
      this.textEditorModelHandle = void 0, this.dispose();
    });
  }
  get textEditorModel() {
    return this.textEditorModelHandle ? this.modelService.getModel(this.textEditorModelHandle) : null;
  }
  isReadonly() {
    return !0;
  }
  get languageChangeSource() {
    return this._languageChangeSource;
  }
  get hasLanguageSetExplicitly() {
    return typeof this._languageChangeSource == "string";
  }
  setLanguageId(e, i) {
    this._languageChangeSource = "user", this.setLanguageIdInternal(e, i);
  }
  setLanguageIdInternal(e, i) {
    if (this.isResolved() && !(!e || e === this.textEditorModel.getLanguageId())) {
      this._blockLanguageChangeListener = !0;
      try {
        this.textEditorModel.setLanguage(this.languageService.createById(e), i);
      } finally {
        this._blockLanguageChangeListener = !1;
      }
    }
  }
  installModelListeners(e) {
    const i = this._register(e.onDidChangeLanguage((n) => {
      n.source === eD || this._blockLanguageChangeListener || (this._languageChangeSource = "api", i.dispose());
    }));
  }
  getLanguageId() {
    return this.textEditorModel?.getLanguageId();
  }
  autoDetectLanguage() {
    return this.autoDetectLanguageThrottler.trigger(() => this.doAutoDetectLanguage());
  }
  async doAutoDetectLanguage() {
    if (this.hasLanguageSetExplicitly || !this.textEditorModelHandle || !this.languageDetectionService.isEnabledForLanguage(this.getLanguageId() ?? op))
      return;
    const e = await this.languageDetectionService.detectLanguage(this.textEditorModelHandle), i = this.getLanguageId();
    if (e && e !== i && !this.isDisposed()) {
      this.setLanguageIdInternal(e, eD);
      const n = this.languageService.getLanguageName(e);
      this.accessibilityService.alert(h(
        3944,
        "Language {0} was automatically detected and set as the language mode.",
        n ?? e
      ));
    }
  }
  createTextEditorModel(e, i, n) {
    const r = this.getFirstLineText(e), s = this.getOrCreateLanguage(i, this.languageService, n, r);
    return this.doCreateTextEditorModel(e, s, i);
  }
  doCreateTextEditorModel(e, i, n) {
    let r = n && this.modelService.getModel(n);
    return r ? this.updateTextEditorModel(e, i.languageId) : (r = this.modelService.createModel(e, i, n), this.createdEditorModel = !0, this.registerModelDisposeListener(r)), this.textEditorModelHandle = r.uri, r;
  }
  getFirstLineText(e) {
    const i = e;
    return typeof i.getFirstLineText == "function" ? i.getFirstLineText(ng.FIRST_LINE_DETECTION_LENGTH_LIMIT) : e.getLineContent(1).substr(0, ng.FIRST_LINE_DETECTION_LENGTH_LIMIT);
  }
  getOrCreateLanguage(e, i, n, r) {
    return !n || n === op ? i.createByFilepathOrFirstLine(e ?? null, r) : i.createById(n);
  }
  updateTextEditorModel(e, i, n) {
    this.isResolved() && (e && this.modelService.updateModel(this.textEditorModel, e, n), i && i !== op && this.textEditorModel.getLanguageId() !== i && this.textEditorModel.setLanguage(this.languageService.createById(i)));
  }
  createSnapshot() {
    return this.textEditorModel ? this.textEditorModel.createSnapshot(!0) : null;
  }
  isResolved() {
    return !!this.textEditorModelHandle;
  }
  dispose() {
    this.modelDisposeListener.dispose(), this.textEditorModelHandle && this.createdEditorModel && this.modelService.destroyModel(this.textEditorModelHandle), this.textEditorModelHandle = void 0, this.createdEditorModel = !1, super.dispose();
  }
}, iw = Wa, Wa.AUTO_DETECT_LANGUAGE_THROTTLE_DELAY = 600, Wa);
ag = iw = W([
  M(0, RT),
  M(1, AT),
  M(2, K3),
  M(3, J3)
], ag);
class OT extends NT {
  get originalModel() {
    return this._originalModel;
  }
  get modifiedModel() {
    return this._modifiedModel;
  }
  constructor(e, i) {
    super(), this._originalModel = e, this._modifiedModel = i;
  }
  async resolve() {
    await Promise.all([
      this._originalModel?.resolve(),
      this._modifiedModel?.resolve()
    ]);
  }
  isResolved() {
    return !!(this._originalModel?.isResolved() && this._modifiedModel?.isResolved());
  }
  dispose() {
    super.dispose();
  }
}
class Y3 extends OT {
  get originalModel() {
    return this._originalModel;
  }
  get modifiedModel() {
    return this._modifiedModel;
  }
  get textDiffEditorModel() {
    return this._textDiffEditorModel;
  }
  constructor(e, i) {
    super(e, i), this._textDiffEditorModel = void 0, this._originalModel = e, this._modifiedModel = i, this.updateTextDiffEditorModel();
  }
  async resolve() {
    await super.resolve(), this.updateTextDiffEditorModel();
  }
  updateTextDiffEditorModel() {
    this.originalModel?.isResolved() && this.modifiedModel?.isResolved() && (this._textDiffEditorModel ? (this._textDiffEditorModel.original = this.originalModel.textEditorModel, this._textDiffEditorModel.modified = this.modifiedModel.textEditorModel) : this._textDiffEditorModel = {
      original: this.originalModel.textEditorModel,
      modified: this.modifiedModel.textEditorModel
    });
  }
  isResolved() {
    return !!this._textDiffEditorModel;
  }
  isReadonly() {
    return !!this.modifiedModel && this.modifiedModel.isReadonly();
  }
  dispose() {
    this._textDiffEditorModel = void 0, super.dispose();
  }
}
function Uu(t, e = ji) {
  return NR(t, e) ? t.charAt(0).toUpperCase() + t.slice(1) : t;
}
function X3(t, e) {
  return t.replace(/^~($|\/|\\)/, `${e}$1`);
}
const tD = "…", $u = "\\\\", Hu = "~";
function Z3(t, e = Vn) {
  const i = new Array(t.length);
  let n = !1;
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    if (s === "") {
      i[r] = `.${e}`;
      continue;
    }
    if (!s) {
      i[r] = s;
      continue;
    }
    n = !0;
    let o = "", a = s;
    a.indexOf($u) === 0 ? (o = a.substr(0, a.indexOf($u) + $u.length), a = a.substr(a.indexOf($u) + $u.length)) : a.indexOf(e) === 0 ? (o = a.substr(0, a.indexOf(e) + e.length), a = a.substr(a.indexOf(e) + e.length)) : a.indexOf(Hu) === 0 && (o = a.substr(0, a.indexOf(Hu) + Hu.length), a = a.substr(a.indexOf(Hu) + Hu.length));
    const l = a.split(e);
    for (let c = 1; n && c <= l.length; c++)
      for (let u = l.length - c; n && u >= 0; u--) {
        n = !1;
        let d = l.slice(u, u + c).join(e);
        for (let f = 0; !n && f < t.length; f++)
          if (f !== r && t[f] && t[f].indexOf(d) > -1) {
            const g = u + c === l.length, _ = u > 0 && t[f].indexOf(e) > -1 ? e + d : d, w = t[f].endsWith(_);
            n = !g || w;
          }
        if (!n) {
          let f = "";
          (l[0].endsWith(":") || o !== "") && (u === 1 && (u = 0, c++, d = l[0] + e + d), u > 0 && (f = l[0] + e), f = o + f), u > 0 && (f = f + tD + e), f = f + d, u + c < l.length && (f = f + e + tD), i[r] = f;
        }
      }
    n && (i[r] = s);
  }
  return i;
}
var iD;
(function(t) {
  t[t.TEXT = 0] = "TEXT", t[t.VARIABLE = 1] = "VARIABLE", t[t.SEPARATOR = 2] = "SEPARATOR";
})(iD || (iD = {}));
function nD(t) {
  const e = t;
  return typeof e?.resolve == "function" && typeof e?.isResolved == "function";
}
var rD;
(function(t) {
  t[t.ACTIVATE = 1] = "ACTIVATE", t[t.RESTORE = 2] = "RESTORE", t[t.PRESERVE = 3] = "PRESERVE";
})(rD || (rD = {}));
var sD;
(function(t) {
  t[t.PICK = 0] = "PICK", t[t.EXCLUSIVE_ONLY = 1] = "EXCLUSIVE_ONLY";
})(sD || (sD = {}));
var oD;
(function(t) {
  t[t.API = 0] = "API", t[t.USER = 1] = "USER";
})(oD || (oD = {}));
var aD;
(function(t) {
  t[t.Center = 0] = "Center", t[t.CenterIfOutsideViewport = 1] = "CenterIfOutsideViewport", t[t.NearTop = 2] = "NearTop", t[t.NearTopIfOutsideViewport = 3] = "NearTopIfOutsideViewport";
})(aD || (aD = {}));
var vd;
(function(t) {
  t.PROGRAMMATIC = "api", t.NAVIGATION = "code.navigation", t.JUMP = "code.jump";
})(vd || (vd = {}));
var ap, Va;
let lD = (Va = class extends tw {
  get typeId() {
    return ap.ID;
  }
  get editorId() {
    return this.modified.editorId === this.original.editorId ? this.modified.editorId : void 0;
  }
  get capabilities() {
    let e = super.capabilities;
    return this.labels.forceDescription && (e |= In.ForceDescription), e;
  }
  constructor(e, i, n, r, s, o) {
    super(e, i, n, r, o), this.original = n, this.modified = r, this.forceOpenAsBinary = s, this.cachedModel = void 0, this.labels = this.computeLabels();
  }
  computeLabels() {
    let e, i = !1;
    if (this.preferredName)
      e = this.preferredName;
    else {
      const u = this.original.getName(), d = this.modified.getName();
      e = h(3942, "{0} ↔ {1}", u, d), i = u === d;
    }
    let n, r, s;
    if (this.preferredDescription)
      n = this.preferredDescription, r = this.preferredDescription, s = this.preferredDescription;
    else {
      n = this.computeLabel(this.original.getDescription(Xt.SHORT), this.modified.getDescription(Xt.SHORT)), s = this.computeLabel(this.original.getDescription(Xt.LONG), this.modified.getDescription(Xt.LONG));
      const u = this.original.getDescription(Xt.MEDIUM), d = this.modified.getDescription(Xt.MEDIUM);
      if (typeof u == "string" && typeof d == "string" && (u || d)) {
        const [f, g] = Z3([u, d]);
        r = this.computeLabel(f, g);
      }
    }
    let o = this.computeLabel(this.original.getTitle(Xt.SHORT) ?? this.original.getName(), this.modified.getTitle(Xt.SHORT) ?? this.modified.getName(), " ↔ "), a = this.computeLabel(this.original.getTitle(Xt.MEDIUM) ?? this.original.getName(), this.modified.getTitle(Xt.MEDIUM) ?? this.modified.getName(), " ↔ "), l = this.computeLabel(this.original.getTitle(Xt.LONG) ?? this.original.getName(), this.modified.getTitle(Xt.LONG) ?? this.modified.getName(), " ↔ ");
    const c = this.getPreferredTitle();
    return c && (o = `${c} (${o})`, a = `${c} (${a})`, l = `${c} (${l})`), { name: e, shortDescription: n, mediumDescription: r, longDescription: s, forceDescription: i, shortTitle: o, mediumTitle: a, longTitle: l };
  }
  computeLabel(e, i, n = " - ") {
    if (!(!e || !i))
      return e === i ? i : `${e}${n}${i}`;
  }
  getName() {
    return this.labels.name;
  }
  getDescription(e = Xt.MEDIUM) {
    switch (e) {
      case Xt.SHORT:
        return this.labels.shortDescription;
      case Xt.LONG:
        return this.labels.longDescription;
      case Xt.MEDIUM:
      default:
        return this.labels.mediumDescription;
    }
  }
  getTitle(e) {
    switch (e) {
      case Xt.SHORT:
        return this.labels.shortTitle;
      case Xt.LONG:
        return this.labels.longTitle;
      default:
      case Xt.MEDIUM:
        return this.labels.mediumTitle;
    }
  }
  async resolve() {
    const e = await this.createModel();
    return this.cachedModel?.dispose(), this.cachedModel = e, this.cachedModel;
  }
  prefersEditorPane(e) {
    return this.forceOpenAsBinary ? e.find((i) => i.typeId === e3) : e.find((i) => i.typeId === Z7);
  }
  async createModel() {
    const [e, i] = await Promise.all([
      this.original.resolve(),
      this.modified.resolve()
    ]);
    return i instanceof ag && e instanceof ag ? new Y3(e, i) : new OT(
      nD(e) ? e : void 0,
      nD(i) ? i : void 0
    );
  }
  toUntyped(e) {
    const i = super.toUntyped(e);
    if (i)
      return {
        ...i,
        modified: i.primary,
        original: i.secondary
      };
  }
  matches(e) {
    return this === e ? !0 : e instanceof ap ? this.modified.matches(e.modified) && this.original.matches(e.original) && e.forceOpenAsBinary === this.forceOpenAsBinary : ks(e) ? this.modified.matches(e.modified) && this.original.matches(e.original) : !1;
  }
  dispose() {
    this.cachedModel && (this.cachedModel.dispose(), this.cachedModel = void 0), super.dispose();
  }
}, ap = Va, Va.ID = "workbench.editors.diffEditorInput", Va);
lD = ap = W([
  M(5, LT)
], lD);
var Yn;
new T("workbenchState", void 0, { type: "string", description: h(
  3866,
  "The kind of workspace opened in the window, either 'empty' (no workspace), 'folder' (single folder) or 'workspace' (multi-root workspace)"
) });
new T("workspaceFolderCount", 0, h(3867, "The number of root folders in the workspace"));
new T("openFolderWorkspaceSupport", !0, !0);
new T("enterMultiRootWorkspaceSupport", !0, !0);
new T("emptyWorkspaceSupport", !0, !0);
new T("dirtyWorkingCopies", !1, h(3868, "Whether there are any working copies with unsaved changes"));
const e9 = new T("remoteName", "", h(
  3869,
  "The name of the remote the window is connected to or an empty string if not connected to any remote"
));
new T("virtualWorkspace", "", h(
  3870,
  "The scheme of the current workspace is from a virtual file system or an empty string."
));
new T("temporaryWorkspace", !1, h(
  3871,
  "The scheme of the current workspace is from a temporary file system."
));
new T("hasWebFileSystemAccess", !1, !0);
new T("embedderIdentifier", void 0, h(
  3872,
  "The identifier of the embedder according to the product service, if one is defined"
));
new T("isSandboxWorkspace", !1, !0);
new T("isFullscreen", !1, h(3873, "Whether the main window is in fullscreen mode"));
new T("isAuxiliaryWindowFocusedContext", !1, h(3874, "Whether an auxiliary window is focused"));
new T("isAuxiliaryWindow", !1, h(3875, "Window is an auxiliary window"));
new T("activeEditorIsDirty", !1, h(3876, "Whether the active editor has unsaved changes"));
new T("activeEditorIsNotPreview", !1, h(3877, "Whether the active editor is not in preview mode"));
new T("activeEditorIsFirstInGroup", !1, h(3878, "Whether the active editor is the first one in its group"));
new T("activeEditorIsLastInGroup", !1, h(3879, "Whether the active editor is the last one in its group"));
new T("activeEditorIsPinned", !1, h(3880, "Whether the active editor is pinned"));
new T("activeEditorIsReadonly", !1, h(3881, "Whether the active editor is read-only"));
new T("activeCompareEditorCanSwap", !1, h(3882, "Whether the active compare editor can swap sides"));
new T("activeEditorCanToggleReadonly", !0, h(
  3883,
  "Whether the active editor can toggle between being read-only or writeable"
));
new T("activeEditorCanRevert", !1, h(3884, "Whether the active editor can revert"));
new T("activeEditorCanSplitInGroup", !0);
new T("activeEditor", null, { type: "string", description: h(3885, "The identifier of the active editor") });
new T("activeEditorAvailableEditorIds", "", h(
  3886,
  "The available editor identifiers that are usable for the active editor"
));
new T("textCompareEditorVisible", !1, h(3887, "Whether a text compare editor is visible"));
new T("textCompareEditorActive", !1, h(3888, "Whether a text compare editor is active"));
new T("sideBySideEditorActive", !1, h(3889, "Whether a side by side editor is active"));
new T("groupEditorsCount", 0, h(3890, "The number of opened editor groups"));
new T("activeEditorGroupEmpty", !1, h(3891, "Whether the active editor group is empty"));
new T("activeEditorGroupIndex", 0, h(3892, "The index of the active editor group"));
new T("activeEditorGroupLast", !1, h(3893, "Whether the active editor group is the last group"));
new T("activeEditorGroupLocked", !1, h(3894, "Whether the active editor group is locked"));
new T("multipleEditorGroups", !1, h(3895, "Whether there are multiple editor groups opened"));
new T("multipleEditorsSelectedInGroup", !1, h(3896, "Whether multiple editors have been selected in an editor group"));
new T("twoEditorsSelectedInGroup", !1, h(3897, "Whether exactly two editors have been selected in an editor group"));
new T(
  "SelectedEditorsInGroupFileOrUntitledResourceContextKey",
  !0,
  h(
    3898,
    "Whether all selected editors in a group have a file or untitled resource associated"
  )
);
new T("editorPartMultipleEditorGroups", !1, h(3899, "Whether there are multiple editor groups opened in an editor part"));
new T("editorPartMaximizedEditorGroup", !1, h(3900, "Editor Part has a maximized group"));
new T("editorIsOpen", !1, h(3901, "Whether an editor is open"));
new T("inZenMode", !1, h(3902, "Whether Zen mode is enabled"));
new T("isCenteredLayout", !1, h(3903, "Whether centered layout is enabled for the main editor"));
new T("splitEditorsVertically", !1, h(3904, "Whether editors split vertically"));
new T("mainEditorAreaVisible", !0, h(3905, "Whether the editor area in the main window is visible"));
new T("editorTabsVisible", !0, h(3906, "Whether editor tabs are visible"));
new T("sideBarVisible", !1, h(3907, "Whether the sidebar is visible"));
new T("sideBarFocus", !1, h(3908, "Whether the sidebar has keyboard focus"));
new T("activeViewlet", "", h(3909, "The identifier of the active viewlet"));
new T("statusBarFocused", !1, h(3910, "Whether the status bar has keyboard focus"));
new T("titleBarStyle", "custom", h(3911, "Style of the window title bar"));
new T("titleBarVisible", !1, h(3912, "Whether the title bar is visible"));
new T("isCompactTitleBar", !1, h(3913, "Title bar is in compact mode"));
new T("bannerFocused", !1, h(3914, "Whether the banner has keyboard focus"));
new T("notificationFocus", !0, h(3915, "Whether a notification has keyboard focus"));
new T("notificationCenterVisible", !1, h(3916, "Whether the notifications center is visible"));
new T("notificationToastsVisible", !1, h(3917, "Whether a notification toast is visible"));
new T("activeAuxiliary", "", h(3918, "The identifier of the active auxiliary panel"));
new T("auxiliaryBarFocus", !1, h(3919, "Whether the auxiliary bar has keyboard focus"));
new T("auxiliaryBarVisible", !1, h(3920, "Whether the auxiliary bar is visible"));
new T("auxiliaryBarMaximized", !1, h(3921, "Whether the auxiliary bar is maximized"));
new T("activePanel", "", h(3922, "The identifier of the active panel"));
new T("panelFocus", !1, h(3923, "Whether the panel has keyboard focus"));
new T("panelPosition", "bottom", h(3924, "The position of the panel, always 'bottom'"));
new T("panelAlignment", "center", h(
  3925,
  "The alignment of the panel, either 'center', 'left', 'right' or 'justify'"
));
new T("panelVisible", !1, h(3926, "Whether the panel is visible"));
new T("panelMaximized", !1, h(3927, "Whether the panel is maximized"));
new T("focusedView", "", h(3928, "The identifier of the view that has keyboard focus"));
var Zi;
let cD = (Zi = class {
  constructor(e, i, n, r) {
    this._contextKeyService = e, this._fileService = i, this._languageService = n, this._modelService = r, this._disposables = new De(), this._schemeKey = Yn.Scheme.bindTo(this._contextKeyService), this._filenameKey = Yn.Filename.bindTo(this._contextKeyService), this._dirnameKey = Yn.Dirname.bindTo(this._contextKeyService), this._pathKey = Yn.Path.bindTo(this._contextKeyService), this._langIdKey = Yn.LangId.bindTo(this._contextKeyService), this._resourceKey = Yn.Resource.bindTo(this._contextKeyService), this._extensionKey = Yn.Extension.bindTo(this._contextKeyService), this._hasResource = Yn.HasResource.bindTo(this._contextKeyService), this._isFileSystemResource = Yn.IsFileSystemResource.bindTo(this._contextKeyService), this._disposables.add(i.onDidChangeFileSystemProviderRegistrations(() => {
      const s = this.get();
      this._isFileSystemResource.set(!!(s && i.hasProvider(s)));
    })), this._disposables.add(r.onModelAdded((s) => {
      uc(s.uri, this.get()) && this._setLangId();
    })), this._disposables.add(r.onModelLanguageChanged((s) => {
      uc(s.model.uri, this.get()) && this._setLangId();
    }));
  }
  dispose() {
    this._disposables.dispose();
  }
  _setLangId() {
    const e = this.get();
    if (!e) {
      this._langIdKey.set(null);
      return;
    }
    const i = this._modelService.getModel(e)?.getLanguageId() ?? this._languageService.guessLanguageIdByFilepathOrFirstLine(e);
    this._langIdKey.set(i);
  }
  set(e) {
    e = e ?? void 0, !uc(this._value, e) && (this._value = e, this._contextKeyService.bufferChangeEvents(() => {
      this._resourceKey.set(e ? e.toString() : null), this._schemeKey.set(e ? e.scheme : null), this._filenameKey.set(e ? Fs(e) : null), this._dirnameKey.set(e ? this.uriToPath(H_(e)) : null), this._pathKey.set(e ? this.uriToPath(e) : null), this._setLangId(), this._extensionKey.set(e ? VR(e) : null), this._hasResource.set(!!e), this._isFileSystemResource.set(e ? this._fileService.hasProvider(e) : !1);
    }));
  }
  uriToPath(e) {
    return e.scheme === de.file ? e.fsPath : e.path;
  }
  reset() {
    this._value = void 0, this._contextKeyService.bufferChangeEvents(() => {
      this._resourceKey.reset(), this._schemeKey.reset(), this._filenameKey.reset(), this._dirnameKey.reset(), this._pathKey.reset(), this._langIdKey.reset(), this._extensionKey.reset(), this._hasResource.reset(), this._isFileSystemResource.reset();
    });
  }
  get() {
    return this._value;
  }
}, Yn = Zi, Zi.Scheme = new T("resourceScheme", void 0, { type: "string", description: h(3929, "The scheme of the resource") }), Zi.Filename = new T(
  "resourceFilename",
  void 0,
  { type: "string", description: h(3930, "The file name of the resource") }
), Zi.Dirname = new T(
  "resourceDirname",
  void 0,
  { type: "string", description: h(3931, "The folder name the resource is contained in") }
), Zi.Path = new T("resourcePath", void 0, { type: "string", description: h(3932, "The full path of the resource") }), Zi.LangId = new T("resourceLangId", void 0, { type: "string", description: h(3933, "The language identifier of the resource") }), Zi.Resource = new T("resource", void 0, { type: "URI", description: h(3934, "The full value of the resource including scheme and path") }), Zi.Extension = new T(
  "resourceExtname",
  void 0,
  { type: "string", description: h(3935, "The extension name of the resource") }
), Zi.HasResource = new T("resourceSet", void 0, { type: "boolean", description: h(3936, "Whether a resource is present or not") }), Zi.IsFileSystemResource = new T(
  "isFileSystemResource",
  void 0,
  { type: "boolean", description: h(3937, "Whether the resource is backed by a file system provider") }
), Zi);
cD = Yn = W([
  M(0, Wx),
  M(1, ET),
  M(2, AT),
  M(3, RT)
], cD);
var uD;
(function(t) {
  t.UseFileStorage = "chat.useFileStorage", t.AgentEnabled = "chat.agent.enabled", t.Edits2Enabled = "chat.edits2.enabled", t.ExtensionToolsEnabled = "chat.extensionTools.enabled", t.EditRequests = "chat.editRequests", t.EnableMath = "chat.math.enabled", t.CheckpointsEnabled = "chat.checkpoints.enabled", t.AgentSessionsViewLocation = "chat.agentSessionsViewLocation";
})(uD || (uD = {}));
var Zd;
(function(t) {
  t.Ask = "ask", t.Edit = "edit", t.Agent = "agent";
})(Zd || (Zd = {}));
var nn;
(function(t) {
  t.Panel = "panel", t.Terminal = "terminal", t.Notebook = "notebook", t.Editor = "editor";
})(nn || (nn = {}));
(function(t) {
  function e(i) {
    switch (i) {
      case "panel":
        return t.Panel;
      case "terminal":
        return t.Terminal;
      case "notebook":
        return t.Notebook;
      case "editor":
        return t.Editor;
    }
    return t.Panel;
  }
  t.fromRaw = e;
})(nn || (nn = {}));
var eh;
(function(t) {
  t.responseVote = new T(
    "chatSessionResponseVote",
    "",
    { type: "string", description: h(
      5354,
      "When the response has been voted up, is set to 'up'. When voted down, is set to 'down'. Otherwise an empty string."
    ) }
  ), t.responseDetectedAgentCommand = new T(
    "chatSessionResponseDetectedAgentOrCommand",
    !1,
    { type: "boolean", description: h(5355, "When the agent or command was automatically detected") }
  ), t.responseSupportsIssueReporting = new T(
    "chatResponseSupportsIssueReporting",
    !1,
    { type: "boolean", description: h(5356, "True when the current chat response supports issue reporting.") }
  ), t.responseIsFiltered = new T(
    "chatSessionResponseFiltered",
    !1,
    { type: "boolean", description: h(5357, "True when the chat response was filtered out by the server.") }
  ), t.responseHasError = new T(
    "chatSessionResponseError",
    !1,
    { type: "boolean", description: h(5358, "True when the chat response resulted in an error.") }
  ), t.requestInProgress = new T(
    "chatSessionRequestInProgress",
    !1,
    { type: "boolean", description: h(5359, "True when the current request is still in progress.") }
  ), t.currentlyEditing = new T(
    "chatSessionCurrentlyEditing",
    !1,
    { type: "boolean", description: h(5360, "True when the current request is being edited.") }
  ), t.currentlyEditingInput = new T(
    "chatSessionCurrentlyEditingInput",
    !1,
    { type: "boolean", description: h(5361, "True when the current request input at the bottom is being edited.") }
  ), t.isRequestPaused = new T(
    "chatRequestIsPaused",
    !1,
    { type: "boolean", description: h(5362, "True when the current request is paused.") }
  ), t.canRequestBePaused = new T(
    "chatCanRequestBePaused",
    !1,
    { type: "boolean", description: h(5363, "True when the current request can be paused.") }
  ), t.isResponse = new T("chatResponse", !1, { type: "boolean", description: h(5364, "The chat item is a response.") }), t.isRequest = new T("chatRequest", !1, { type: "boolean", description: h(5365, "The chat item is a request") }), t.itemId = new T("chatItemId", "", { type: "string", description: h(5366, "The id of the chat item.") }), t.lastItemId = new T("chatLastItemId", [], { type: "string", description: h(5367, "The id of the last chat item.") }), t.editApplied = new T("chatEditApplied", !1, { type: "boolean", description: h(5368, "True when the chat text edits have been applied.") }), t.inputHasText = new T("chatInputHasText", !1, { type: "boolean", description: h(5369, "True when the chat input has text.") }), t.inputHasFocus = new T("chatInputHasFocus", !1, { type: "boolean", description: h(5370, "True when the chat input has focus.") }), t.inChatInput = new T("inChatInput", !1, { type: "boolean", description: h(5371, "True when focus is in the chat input, false otherwise.") }), t.inChatSession = new T("inChat", !1, { type: "boolean", description: h(5372, "True when focus is in the chat widget, false otherwise.") }), t.inChatEditor = new T("inChatEditor", !1, { type: "boolean", description: h(5373, "Whether focus is in a chat editor.") }), t.hasPromptFile = new T(
    "chatPromptFileAttached",
    !1,
    { type: "boolean", description: h(5374, "True when the chat has a prompt file attached.") }
  ), t.chatModeKind = new T(
    "chatMode",
    Zd.Ask,
    { type: "string", description: h(5375, "The 'kind' of the current chat mode- Agent for custom modes.") }
  ), t.chatToolCount = new T("chatToolCount", 0, { type: "number", description: h(5376, "The number of tools available in the current chat mode.") }), t.chatToolGroupingThreshold = new T(
    "chat.toolGroupingThreshold",
    0,
    { type: "number", description: h(5377, "The number of tools at which we start doing virtual grouping.") }
  ), t.supported = Gt.or(z3.negate(), e9.notEqualsTo(""), Gt.has("config.chat.experimental.serverlessWebEnabled")), t.enabled = new T("chatIsEnabled", !1, { type: "boolean", description: h(
    5378,
    "True when chat is enabled because a default chat participant is activated with an implementation."
  ) }), t.lockedToCodingAgent = new T(
    "lockedToCodingAgent",
    !1,
    { type: "boolean", description: h(5379, "True when the chat widget is locked to the coding agent session.") }
  ), t.extensionParticipantRegistered = new T(
    "chatPanelExtensionParticipantRegistered",
    !1,
    { type: "boolean", description: h(
      5380,
      "True when a default chat participant is registered for the panel from an extension."
    ) }
  ), t.panelParticipantRegistered = new T(
    "chatPanelParticipantRegistered",
    !1,
    { type: "boolean", description: h(5381, "True when a default chat participant is registered for the panel.") }
  ), t.chatEditingCanUndo = new T(
    "chatEditingCanUndo",
    !1,
    { type: "boolean", description: h(
      5382,
      "True when it is possible to undo an interaction in the editing panel."
    ) }
  ), t.chatEditingCanRedo = new T(
    "chatEditingCanRedo",
    !1,
    { type: "boolean", description: h(
      5383,
      "True when it is possible to redo an interaction in the editing panel."
    ) }
  ), t.languageModelsAreUserSelectable = new T(
    "chatModelsAreUserSelectable",
    !1,
    { type: "boolean", description: h(5384, "True when the chat model can be selected manually by the user.") }
  ), t.extensionInvalid = new T(
    "chatExtensionInvalid",
    !1,
    { type: "boolean", description: h(
      5385,
      "True when the installed chat extension is invalid and needs to be updated."
    ) }
  ), t.inputCursorAtTop = new T("chatCursorAtTop", !1), t.inputHasAgent = new T("chatInputHasAgent", !1), t.location = new T("chatLocation", void 0), t.inQuickChat = new T("quickChatHasFocus", !1, { type: "boolean", description: h(5386, "True when the quick chat UI has focus, false otherwise.") }), t.hasFileAttachments = new T(
    "chatHasFileAttachments",
    !1,
    { type: "boolean", description: h(5387, "True when the chat has file attachments.") }
  ), t.remoteJobCreating = new T(
    "chatRemoteJobCreating",
    !1,
    { type: "boolean", description: h(5388, "True when a remote coding agent job is being created.") }
  ), t.hasRemoteCodingAgent = new T("hasRemoteCodingAgent", !1, h(5389, "Whether any remote coding agent is available")), t.enableRemoteCodingAgentPromptFileOverlay = new T("enableRemoteCodingAgentPromptFileOverlay", !1, h(
    5390,
    "Whether the remote coding agent prompt file overlay feature is enabled"
  )), t.skipChatRequestInProgressMessage = new T(
    "chatSkipRequestInProgressMessage",
    !1,
    { type: "boolean", description: h(5391, "True when the chat request in progress message should be skipped.") }
  ), t.Setup = {
    hidden: new T("chatSetupHidden", !1, !0),
    installed: new T("chatSetupInstalled", !1, !0),
    disabled: new T("chatSetupDisabled", !1, !0),
    untrusted: new T("chatSetupUntrusted", !1, !0),
    later: new T("chatSetupLater", !1, !0)
  }, t.Entitlement = {
    signedOut: new T("chatEntitlementSignedOut", !1, !0),
    canSignUp: new T("chatPlanCanSignUp", !1, !0),
    free: new T("chatPlanFree", !1, !0),
    pro: new T("chatPlanPro", !1, !0),
    proPlus: new T("chatPlanProPlus", !1, !0),
    business: new T("chatPlanBusiness", !1, !0),
    enterprise: new T("chatPlanEnterprise", !1, !0)
  }, t.chatQuotaExceeded = new T("chatQuotaExceeded", !1, !0), t.completionsQuotaExceeded = new T("completionsQuotaExceeded", !1, !0), t.Editing = {
    hasToolConfirmation: new T(
      "chatHasToolConfirmation",
      !1,
      { type: "boolean", description: h(5392, "True when a tool confirmation is present.") }
    )
  }, t.Tools = {
    toolsCount: new T("toolsCount", 0, { type: "number", description: h(5393, "The count of tools available in the chat.") })
  }, t.Modes = {
    hasCustomChatModes: new T(
      "chatHasCustomChatModes",
      !1,
      { type: "boolean", description: h(5394, "True when the chat has custom chat modes available.") }
    )
  }, t.panelLocation = new T(
    "chatPanelLocation",
    void 0,
    { type: "number", description: h(5395, "The location of the chat panel.") }
  );
})(eh || (eh = {}));
var dD;
(function(t) {
  t.inEditingMode = Gt.or(eh.chatModeKind.isEqualTo(Zd.Edit), eh.chatModeKind.isEqualTo(Zd.Agent));
})(dD || (dD = {}));
var ps;
(function(t) {
  t[t.System = 0] = "System", t[t.User = 1] = "User", t[t.Assistant = 2] = "Assistant";
})(ps || (ps = {}));
var hD;
(function(t) {
  t[t.Assistant = 0] = "Assistant", t[t.User = 1] = "User";
})(hD || (hD = {}));
var fD;
(function(t) {
  t.PNG = "image/png", t.JPEG = "image/jpeg", t.GIF = "image/gif", t.WEBP = "image/webp", t.BMP = "image/bmp";
})(fD || (fD = {}));
var pD;
(function(t) {
  t.Low = "low", t.High = "high";
})(pD || (pD = {}));
var gD;
(function(t) {
  function e(n) {
    return (typeof n.capabilities?.agentMode > "u" || n.capabilities.agentMode) && !!n.capabilities?.toolCalling;
  }
  t.suitableForAgentMode = e;
  function i(n) {
    return n.modelPickerCategory === void 0 ? `${n.name} (${n.family})` : n.name;
  }
  t.asQualifiedName = i;
})(gD || (gD = {}));
const mD = {
  type: "object",
  properties: {
    vendor: {
      type: "string",
      description: h(5429, "A globally unique vendor of language models.")
    },
    displayName: {
      type: "string",
      description: h(5430, "The display name of the language model vendor.")
    },
    managementCommand: {
      type: "string",
      description: h(
        5431,
        "A command to manage the language model vendor, e.g. 'Manage Copilot models'. This is used in the chat model picker. If not provided, a gear icon is not rendered during vendor selection."
      )
    }
  }
}, t9 = PT.registerExtensionPoint({
  extensionPoint: "languageModels",
  jsonSchema: {
    description: h(5432, "Contribute language models of a specific vendor."),
    oneOf: [
      mD,
      {
        type: "array",
        items: mD
      }
    ]
  },
  activationEventsGenerator: (t, e) => {
    for (const i of t)
      e.push(`onLanguageModelChat:${i.vendor}`);
  }
});
let _D = class {
  constructor(e, i, n, r) {
    this._extensionService = e, this._logService = i, this._storageService = n, this._store = new De(), this._providers = /* @__PURE__ */ new Map(), this._modelCache = /* @__PURE__ */ new Map(), this._vendors = /* @__PURE__ */ new Map(), this._modelPickerUserPreferences = {}, this._onLanguageModelChange = this._store.add(new N()), this.onDidChangeLanguageModels = this._onLanguageModelChange.event, this._hasUserSelectableModels = eh.languageModelsAreUserSelectable.bindTo(r), this._modelPickerUserPreferences = this._storageService.getObject("chatModelPickerPreferences", jt.PROFILE, this._modelPickerUserPreferences), this._store.add(this.onDidChangeLanguageModels(() => {
      this._hasUserSelectableModels.set(this._modelCache.size > 0 && Array.from(this._modelCache.values()).some((s) => s.isUserSelectable));
    })), this._store.add(t9.setHandler((s) => {
      this._vendors.clear();
      for (const o of s) {
        if (!lt(o.description, "chatProvider")) {
          o.collector.error(h(5433, "This contribution point requires the 'chatProvider' proposal."));
          continue;
        }
        for (const a of Oi.wrap(o.value)) {
          if (this._vendors.has(a.vendor)) {
            o.collector.error(h(
              5434,
              "The vendor '{0}' is already registered and cannot be registered twice",
              a.vendor
            ));
            continue;
          }
          if (qd(a.vendor)) {
            o.collector.error(h(5435, "The vendor field cannot be empty."));
            continue;
          }
          if (a.vendor.trim() !== a.vendor) {
            o.collector.error(h(5436, "The vendor field cannot start or end with whitespace."));
            continue;
          }
          this._vendors.set(a.vendor, a);
        }
      }
      for (const [o, a] of this._providers)
        this._vendors.has(o) || this._providers.delete(o);
    }));
  }
  dispose() {
    this._store.dispose(), this._providers.clear();
  }
  updateModelPickerPreference(e, i) {
    const n = this._modelCache.get(e);
    if (!n) {
      this._logService.warn(`[LM] Cannot update model picker preference for unknown model ${e}`);
      return;
    }
    this._modelPickerUserPreferences[e] = i, i === n.isUserSelectable ? (delete this._modelPickerUserPreferences[e], this._storageService.store("chatModelPickerPreferences", this._modelPickerUserPreferences, jt.PROFILE, rg.USER)) : n.isUserSelectable !== i && this._storageService.store("chatModelPickerPreferences", this._modelPickerUserPreferences, jt.PROFILE, rg.USER), this._onLanguageModelChange.fire(), this._logService.trace(`[LM] Updated model picker preference for ${e} to ${i}`);
  }
  getVendors() {
    return Array.from(this._vendors.values());
  }
  getLanguageModelIds() {
    return Array.from(this._modelCache.keys());
  }
  lookupLanguageModel(e) {
    const i = this._modelCache.get(e);
    return i && this._modelPickerUserPreferences[e] !== void 0 ? { ...i, isUserSelectable: this._modelPickerUserPreferences[e] } : i;
  }
  _clearModelCache(e) {
    typeof e == "string" && (e = [e]);
    for (const i of e)
      for (const [n, r] of this._modelCache.entries())
        r.vendor === i && this._modelCache.delete(n);
  }
  async resolveLanguageModels(e, i) {
    typeof e == "string" && (e = [e]), this._clearModelCache(e);
    for (const n of e) {
      const r = this._providers.get(n);
      if (!r) {
        this._logService.warn(`[LM] No provider registered for vendor ${n}`);
        continue;
      }
      try {
        const s = await r.prepareLanguageModelChat({ silent: i }, xt.None);
        for (const o of s) {
          if (this._modelCache.has(o.identifier)) {
            this._logService.warn(`[LM] Model ${o.identifier} is already registered. Skipping.`);
            continue;
          }
          this._modelCache.set(o.identifier, o.metadata);
        }
        this._logService.trace(`[LM] Resolved language models for vendor ${n}`, s);
      } catch (s) {
        this._logService.error(`[LM] Error resolving language models for vendor ${n}:`, s);
      }
    }
    this._onLanguageModelChange.fire();
  }
  async selectLanguageModels(e, i) {
    if (e.vendor)
      await this._extensionService.activateByEvent(`onLanguageModelChat:${e.vendor}}`), await this.resolveLanguageModels([e.vendor], !i);
    else {
      const r = Array.from(this._vendors.keys()), s = r.map(
        (o) => this._extensionService.activateByEvent(`onLanguageModelChat:${o}`)
      );
      await Promise.all(s), await this.resolveLanguageModels(r, !i);
    }
    const n = [];
    for (const [r, s] of this._modelCache)
      (e.vendor === void 0 || s.vendor === e.vendor) && (e.family === void 0 || s.family === e.family) && (e.version === void 0 || s.version === e.version) && (e.id === void 0 || s.id === e.id) && n.push(r);
    return this._logService.trace("[LM] selected language models", e, n), n;
  }
  registerLanguageModelProvider(e, i) {
    if (this._logService.trace("[LM] registering language model provider", e, i), !this._vendors.has(e))
      throw new Error(`Chat model provider uses UNKNOWN vendor ${e}.`);
    if (this._providers.has(e))
      throw new Error(`Chat model provider for vendor ${e} is already registered.`);
    return this._providers.set(e, i), this.resolveLanguageModels(e, !0).then(() => {
      this._onLanguageModelChange.fire();
    }), Ee(() => {
      this._logService.trace("[LM] UNregistered language model provider", e), this._clearModelCache(e), this._providers.delete(e);
    });
  }
  async sendChatRequest(e, i, n, r, s) {
    const o = this._providers.get(this._modelCache.get(e)?.vendor || "");
    if (!o)
      throw new Error(`Chat provider for model ${e} is not registered.`);
    return o.sendChatRequest(e, n, i, r, s);
  }
  computeTokenLength(e, i, n) {
    const r = this._modelCache.get(e);
    if (!r)
      throw new Error(`Chat model ${e} could not be found.`);
    const s = this._providers.get(r.vendor);
    if (!s)
      throw new Error(`Chat provider for model ${e} is not registered.`);
    return s.provideTokenCount(e, i, n);
  }
};
_D = W([
  M(0, U3),
  M(1, nt),
  M(2, g3),
  M(3, Wx)
], _D);
new T("debugType", void 0, { type: "string", description: h(6392, "Debug type of the active debug session. For example 'python'.") });
new T(
  "debugConfigurationType",
  void 0,
  { type: "string", description: h(
    6393,
    "Debug type of the selected launch configuration. For example 'python'."
  ) }
);
new T("debugState", "inactive", { type: "string", description: h(
  6394,
  "State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'."
) });
const i9 = "debugUx";
new T(
  i9,
  "default",
  { type: "string", description: h(
    6395,
    "Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet."
  ) }
);
new T("hasDebugged", !1, { type: "boolean", description: h(
  6396,
  "True when a debug session has been started at least once, false otherwise."
) });
new T("inDebugMode", !1, { type: "boolean", description: h(6397, "True when debugging, false otherwise.") });
new T("inDebugRepl", !1, { type: "boolean", description: h(6398, "True when focus is in the debug console, false otherwise.") });
new T(
  "breakpointWidgetVisible",
  !1,
  { type: "boolean", description: h(
    6399,
    "True when breakpoint editor zone widget is visible, false otherwise."
  ) }
);
new T(
  "inBreakpointWidget",
  !1,
  { type: "boolean", description: h(
    6400,
    "True when focus is in the breakpoint editor zone widget, false otherwise."
  ) }
);
new T("breakpointsFocused", !0, { type: "boolean", description: h(6401, "True when the BREAKPOINTS view is focused, false otherwise.") });
new T(
  "watchExpressionsFocused",
  !0,
  { type: "boolean", description: h(6402, "True when the WATCH view is focused, false otherwise.") }
);
new T(
  "watchExpressionsExist",
  !1,
  { type: "boolean", description: h(6403, "True when at least one watch expression exists, false otherwise.") }
);
new T("variablesFocused", !0, { type: "boolean", description: h(6404, "True when the VARIABLES views is focused, false otherwise") });
new T(
  "expressionSelected",
  !1,
  { type: "boolean", description: h(
    6405,
    "True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise."
  ) }
);
new T(
  "breakpointInputFocused",
  !1,
  { type: "boolean", description: h(6406, "True when the input box has focus in the BREAKPOINTS view.") }
);
new T(
  "callStackItemType",
  void 0,
  { type: "string", description: h(
    6407,
    "Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'"
  ) }
);
new T(
  "callStackSessionIsAttach",
  !1,
  { type: "boolean", description: h(
    6408,
    "True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view."
  ) }
);
new T(
  "callStackItemStopped",
  !1,
  { type: "boolean", description: h(
    6409,
    "True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view."
  ) }
);
new T(
  "callStackSessionHasOneThread",
  !1,
  { type: "boolean", description: h(
    6410,
    "True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view."
  ) }
);
new T("callStackFocused", !0, { type: "boolean", description: h(6411, "True when the CALLSTACK view is focused, false otherwise.") });
new T("watchItemType", void 0, { type: "string", description: h(
  6412,
  "Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'"
) });
new T("canViewMemory", void 0, { type: "boolean", description: h(
  6413,
  "Indicates whether the item in the view has an associated memory refrence."
) });
new T(
  "breakpointItemType",
  void 0,
  { type: "string", description: h(
    6414,
    "Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'"
  ) }
);
new T(
  "breakpointItemBytes",
  void 0,
  { type: "boolean", description: h(6415, "Whether the breakpoint item is a data breakpoint on a byte range.") }
);
new T(
  "breakpointHasModes",
  !1,
  { type: "boolean", description: h(6416, "Whether the breakpoint has multiple modes it can switch to.") }
);
new T(
  "breakpointSupportsCondition",
  !1,
  { type: "boolean", description: h(6417, "True when the focused breakpoint supports conditions.") }
);
new T(
  "loadedScriptsSupported",
  !1,
  { type: "boolean", description: h(6418, "True when the focused sessions supports the LOADED SCRIPTS view") }
);
new T(
  "loadedScriptsItemType",
  void 0,
  { type: "string", description: h(
    6419,
    "Represents the item type of the focused element in the LOADED SCRIPTS view."
  ) }
);
new T(
  "focusedSessionIsAttach",
  !1,
  { type: "boolean", description: h(6420, "True when the focused session is 'attach'.") }
);
new T(
  "focusedSessionIsNoDebug",
  !1,
  { type: "boolean", description: h(6421, "True when the focused session is run without debugging.") }
);
new T("stepBackSupported", !1, { type: "boolean", description: h(6422, "True when the focused session supports 'stepBack' requests.") });
new T(
  "restartFrameSupported",
  !1,
  { type: "boolean", description: h(6423, "True when the focused session supports 'restartFrame' requests.") }
);
new T(
  "stackFrameSupportsRestart",
  !1,
  { type: "boolean", description: h(6424, "True when the focused stack frame supports 'restartFrame'.") }
);
new T(
  "jumpToCursorSupported",
  !1,
  { type: "boolean", description: h(6425, "True when the focused session supports 'jumpToCursor' request.") }
);
new T(
  "stepIntoTargetsSupported",
  !1,
  { type: "boolean", description: h(6426, "True when the focused session supports 'stepIntoTargets' request.") }
);
new T("breakpointsExist", !1, { type: "boolean", description: h(6427, "True when at least one breakpoint exists.") });
new T(
  "debuggersAvailable",
  !1,
  { type: "boolean", description: h(6428, "True when there is at least one debug extensions active.") }
);
new T(
  "debugExtensionAvailable",
  !0,
  { type: "boolean", description: h(
    6429,
    "True when there is at least one debug extension installed and enabled."
  ) }
);
new T(
  "debugProtocolVariableMenuContext",
  void 0,
  { type: "string", description: h(
    6430,
    "Represents the context the debug adapter sets on the focused variable in the VARIABLES view."
  ) }
);
new T(
  "debugSetVariableSupported",
  !1,
  { type: "boolean", description: h(6431, "True when the focused session supports 'setVariable' request.") }
);
new T(
  "debugSetDataBreakpointAddressSupported",
  !1,
  { type: "boolean", description: h(
    6432,
    "True when the focused session supports 'getBreakpointInfo' request on an address."
  ) }
);
new T(
  "debugSetExpressionSupported",
  !1,
  { type: "boolean", description: h(6433, "True when the focused session supports 'setExpression' request.") }
);
new T(
  "breakWhenValueChangesSupported",
  !1,
  { type: "boolean", description: h(
    6434,
    "True when the focused session supports to break when value changes."
  ) }
);
new T(
  "breakWhenValueIsAccessedSupported",
  !1,
  { type: "boolean", description: h(
    6435,
    "True when the focused breakpoint supports to break when value is accessed."
  ) }
);
new T(
  "breakWhenValueIsReadSupported",
  !1,
  { type: "boolean", description: h(
    6436,
    "True when the focused breakpoint supports to break when value is read."
  ) }
);
new T(
  "terminateDebuggeeSupported",
  !1,
  { type: "boolean", description: h(
    6437,
    "True when the focused session supports the terminate debuggee capability."
  ) }
);
new T(
  "suspendDebuggeeSupported",
  !1,
  { type: "boolean", description: h(
    6438,
    "True when the focused session supports the suspend debuggee capability."
  ) }
);
new T(
  "terminateThreadsSupported",
  !1,
  { type: "boolean", description: h(
    6439,
    "True when the focused session supports the terminate threads capability."
  ) }
);
new T(
  "variableEvaluateNamePresent",
  !1,
  { type: "boolean", description: h(6440, "True when the focused variable has an 'evalauteName' field set.") }
);
new T(
  "variableIsReadonly",
  !1,
  { type: "boolean", description: h(6441, "True when the focused variable is read-only.") }
);
new T("variableValue", !1, { type: "string", description: h(6442, "Value of the variable, present for debug visualization clauses.") });
new T("variableType", !1, { type: "string", description: h(6443, "Type of the variable, present for debug visualization clauses.") });
new T("variableInterfaces", !1, { type: "array", description: h(
  6444,
  "Any interfaces or contracts that the variable satisfies, present for debug visualization clauses."
) });
new T("variableName", !1, { type: "string", description: h(6445, "Name of the variable, present for debug visualization clauses.") });
new T("variableLanguage", !1, { type: "string", description: h(
  6446,
  "Language of the variable source, present for debug visualization clauses."
) });
new T(
  "variableExtensionId",
  !1,
  { type: "string", description: h(
    6447,
    "Extension ID of the variable source, present for debug visualization clauses."
  ) }
);
new T(
  "exceptionWidgetVisible",
  !1,
  { type: "boolean", description: h(6448, "True when the exception widget is visible.") }
);
new T("multiSessionRepl", !1, { type: "boolean", description: h(6449, "True when there is more than 1 debug console.") });
new T("multiSessionDebug", !1, { type: "boolean", description: h(6450, "True when there is more than 1 active debug session.") });
new T(
  "disassembleRequestSupported",
  !1,
  { type: "boolean", description: h(6451, "True when the focused sessions supports disassemble request.") }
);
new T(
  "disassemblyViewFocus",
  !1,
  { type: "boolean", description: h(6452, "True when the Disassembly View is focused.") }
);
new T(
  "languageSupportsDisassembleRequest",
  !1,
  { type: "boolean", description: h(
    6453,
    "True when the language in the current editor supports disassemble request."
  ) }
);
new T(
  "focusedStackFrameHasInstructionReference",
  !1,
  { type: "boolean", description: h(
    6454,
    "True when the focused stack frame has instruction pointer reference."
  ) }
);
h(6456, "Controls when the internal Debug Console should open.");
var vD;
(function(t) {
  t[t.Inactive = 0] = "Inactive", t[t.Initializing = 1] = "Initializing", t[t.Stopped = 2] = "Stopped", t[t.Running = 3] = "Running";
})(vD || (vD = {}));
var wD;
(function(t) {
  t[t.Valid = 0] = "Valid", t[t.Unreadable = 1] = "Unreadable", t[t.Error = 2] = "Error";
})(wD || (wD = {}));
var bD;
(function(t) {
  t[t.Variable = 0] = "Variable", t[t.Address = 1] = "Address";
})(bD || (bD = {}));
var lg;
(function(t) {
  t[t.Initial = 1] = "Initial", t[t.Dynamic = 2] = "Dynamic";
})(lg || (lg = {}));
var yD;
(function(t) {
  t.UnverifiedBreakpoints = "unverifiedBreakpoints";
})(yD || (yD = {}));
var xD;
(function(t) {
  t[t.CONDITION = 0] = "CONDITION", t[t.HIT_COUNT = 1] = "HIT_COUNT", t[t.LOG_MESSAGE = 2] = "LOG_MESSAGE", t[t.TRIGGER_POINT = 3] = "TRIGGER_POINT";
})(xD || (xD = {}));
var cg;
(function(t) {
  t[t.Command = 0] = "Command", t[t.Tree = 1] = "Tree";
})(cg || (cg = {}));
var nw;
(function(t) {
  t[t.None = 0] = "None", t[t.Collapsed = 1] = "Collapsed", t[t.Expanded = 2] = "Expanded";
})(nw || (nw = {}));
var ED;
(function(t) {
  t.deserialize = (e) => e, t.serialize = (e) => e;
})(ED || (ED = {}));
var SD;
(function(t) {
  t.deserialize = (e) => ({
    id: e.id,
    name: e.name,
    iconPath: e.iconPath && { light: x.revive(e.iconPath.light), dark: x.revive(e.iconPath.dark) },
    iconClass: e.iconClass,
    visualization: e.visualization
  }), t.serialize = (e) => e;
})(SD || (SD = {}));
const ha = "**", rw = "/", lp = "[/\\\\]", cp = "[^/\\\\]", n9 = /\//g;
function DD(t, e) {
  switch (t) {
    case 0:
      return "";
    case 1:
      return `${cp}*?`;
    default:
      return `(?:${lp}|${cp}+${lp}${e ? `|${lp}${cp}+` : ""})*?`;
  }
}
function sw(t, e) {
  if (!t)
    return [];
  const i = [];
  let n = !1, r = !1, s = "";
  for (const o of t) {
    switch (o) {
      case e:
        if (!n && !r) {
          i.push(s), s = "";
          continue;
        }
        break;
      case "{":
        n = !0;
        break;
      case "}":
        n = !1;
        break;
      case "[":
        r = !0;
        break;
      case "]":
        r = !1;
        break;
    }
    s += o;
  }
  return s && i.push(s), i;
}
function FT(t) {
  if (!t)
    return "";
  let e = "";
  const i = sw(t, rw);
  if (i.every((n) => n === ha))
    e = ".*";
  else {
    let n = !1;
    i.forEach((r, s) => {
      if (r === ha) {
        if (n)
          return;
        e += DD(2, s === i.length - 1);
      } else {
        let o = !1, a = "", l = !1, c = "";
        for (const u of r) {
          if (u !== "}" && o) {
            a += u;
            continue;
          }
          if (l && (u !== "]" || !c)) {
            let d;
            u === "-" ? d = u : (u === "^" || u === "!") && !c ? d = "^" : u === rw ? d = "" : d = Ja(u), c += d;
            continue;
          }
          switch (u) {
            case "{":
              o = !0;
              continue;
            case "[":
              l = !0;
              continue;
            case "}": {
              const f = `(?:${sw(a, ",").map((g) => FT(g)).join("|")})`;
              e += f, o = !1, a = "";
              break;
            }
            case "]": {
              e += "[" + c + "]", l = !1, c = "";
              break;
            }
            case "?":
              e += cp;
              continue;
            case "*":
              e += DD(1);
              continue;
            default:
              e += Ja(u);
          }
        }
        s < i.length - 1 && (i[s + 1] !== ha || s + 2 < i.length) && (e += lp);
      }
      n = r === ha;
    });
  }
  return e;
}
const r9 = /^\*\*\/\*\.[\w\.-]+$/, s9 = /^\*\*\/([\w\.-]+)\/?$/, o9 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/, a9 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/, l9 = /^\*\*((\/[\w\.-]+)+)\/?$/, c9 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, kD = new _x(1e4), ID = function() {
  return !1;
}, Gr = function() {
  return null;
};
function Gx(t, e) {
  if (!t)
    return Gr;
  let i;
  typeof t != "string" ? i = t.pattern : i = t, i = i.trim();
  const n = `${i}_${!!e.trimForExclusions}`;
  let r = kD.get(n);
  if (r)
    return CD(r, t);
  let s;
  return r9.test(i) ? r = u9(i.substr(4), i) : (s = s9.exec(z1(i, e))) ? r = d9(s[1], i) : (e.trimForExclusions ? a9 : o9).test(i) ? r = h9(i, e) : (s = l9.exec(z1(i, e))) ? r = TD(s[1].substr(1), i, !0) : (s = c9.exec(z1(i, e))) ? r = TD(s[1], i, !1) : r = f9(i), kD.set(n, r), CD(r, t);
}
function CD(t, e) {
  if (typeof e == "string")
    return t;
  const i = function(n, r) {
    return Hp(n, e.base, !So) ? t(vR(n.substr(e.base.length), Vn), r) : null;
  };
  return i.allBasenames = t.allBasenames, i.allPaths = t.allPaths, i.basenames = t.basenames, i.patterns = t.patterns, i;
}
function z1(t, e) {
  return e.trimForExclusions && t.endsWith("/**") ? t.substr(0, t.length - 2) : t;
}
function u9(t, e) {
  return function(i, n) {
    return typeof i == "string" && i.endsWith(t) ? e : null;
  };
}
function d9(t, e) {
  const i = `/${t}`, n = `\\${t}`, r = function(o, a) {
    return typeof o != "string" ? null : a ? a === t ? e : null : o === t || o.endsWith(i) || o.endsWith(n) ? e : null;
  }, s = [t];
  return r.basenames = s, r.patterns = [e], r.allBasenames = s, r;
}
function h9(t, e) {
  const i = UT(t.slice(1, -1).split(",").map((a) => Gx(a, e)).filter((a) => a !== Gr), t), n = i.length;
  if (!n)
    return Gr;
  if (n === 1)
    return i[0];
  const r = function(a, l) {
    for (let c = 0, u = i.length; c < u; c++)
      if (i[c](a, l))
        return t;
    return null;
  }, s = i.find((a) => !!a.allBasenames);
  s && (r.allBasenames = s.allBasenames);
  const o = i.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return o.length && (r.allPaths = o), r;
}
function TD(t, e, i) {
  const n = Vn === dt.sep, r = n ? t : t.replace(n9, Vn), s = Vn + r, o = dt.sep + t;
  let a;
  return i ? a = function(l, c) {
    return typeof l == "string" && (l === r || l.endsWith(s) || !n && (l === t || l.endsWith(o))) ? e : null;
  } : a = function(l, c) {
    return typeof l == "string" && (l === r || !n && l === t) ? e : null;
  }, a.allPaths = [(i ? "*/" : "./") + t], a;
}
function f9(t) {
  try {
    const e = new RegExp(`^${FT(t)}$`);
    return function(i) {
      return e.lastIndex = 0, typeof i == "string" && e.test(i) ? t : null;
    };
  } catch {
    return Gr;
  }
}
function wd(t, e, i) {
  return !t || typeof e != "string" ? !1 : qc(t)(e, void 0, i);
}
function qc(t, e = {}) {
  if (!t)
    return ID;
  if (typeof t == "string" || p9(t)) {
    const i = Gx(t, e);
    if (i === Gr)
      return ID;
    const n = function(r, s) {
      return !!i(r, s);
    };
    return i.allBasenames && (n.allBasenames = i.allBasenames), i.allPaths && (n.allPaths = i.allPaths), n;
  }
  return g9(t, e);
}
function p9(t) {
  const e = t;
  return e ? typeof e.base == "string" && typeof e.pattern == "string" : !1;
}
function g9(t, e) {
  const i = UT(Object.getOwnPropertyNames(t).map((a) => m9(a, t[a], e)).filter((a) => a !== Gr)), n = i.length;
  if (!n)
    return Gr;
  if (!i.some((a) => !!a.requiresSiblings)) {
    if (n === 1)
      return i[0];
    const a = function(u, d) {
      let f;
      for (let g = 0, _ = i.length; g < _; g++) {
        const w = i[g](u, d);
        if (typeof w == "string")
          return w;
        Do(w) && (f || (f = []), f.push(w));
      }
      return f ? (async () => {
        for (const g of f) {
          const _ = await g;
          if (typeof _ == "string")
            return _;
        }
        return null;
      })() : null;
    }, l = i.find((u) => !!u.allBasenames);
    l && (a.allBasenames = l.allBasenames);
    const c = i.reduce((u, d) => d.allPaths ? u.concat(d.allPaths) : u, []);
    return c.length && (a.allPaths = c), a;
  }
  const r = function(a, l, c) {
    let u, d;
    for (let f = 0, g = i.length; f < g; f++) {
      const _ = i[f];
      _.requiresSiblings && c && (l || (l = mn(a)), u || (u = l.substr(0, l.length - Op(a).length)));
      const w = _(a, l, u, c);
      if (typeof w == "string")
        return w;
      Do(w) && (d || (d = []), d.push(w));
    }
    return d ? (async () => {
      for (const f of d) {
        const g = await f;
        if (typeof g == "string")
          return g;
      }
      return null;
    })() : null;
  }, s = i.find((a) => !!a.allBasenames);
  s && (r.allBasenames = s.allBasenames);
  const o = i.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return o.length && (r.allPaths = o), r;
}
function m9(t, e, i) {
  if (e === !1)
    return Gr;
  const n = Gx(t, i);
  if (n === Gr)
    return Gr;
  if (typeof e == "boolean")
    return n;
  if (e) {
    const r = e.when;
    if (typeof r == "string") {
      const s = (o, a, l, c) => {
        if (!c || !n(o, a))
          return null;
        const u = r.replace("$(basename)", () => l), d = c(u);
        return Do(d) ? d.then((f) => f ? t : null) : d ? t : null;
      };
      return s.requiresSiblings = !0, s;
    }
  }
  return n;
}
function UT(t, e) {
  const i = t.filter((a) => !!a.basenames);
  if (i.length < 2)
    return t;
  const n = i.reduce((a, l) => {
    const c = l.basenames;
    return c ? a.concat(c) : a;
  }, []);
  let r;
  if (e) {
    r = [];
    for (let a = 0, l = n.length; a < l; a++)
      r.push(e);
  } else
    r = i.reduce((a, l) => {
      const c = l.patterns;
      return c ? a.concat(c) : a;
    }, []);
  const s = function(a, l) {
    if (typeof a != "string")
      return null;
    if (!l) {
      let u;
      for (u = a.length; u > 0; u--) {
        const d = a.charCodeAt(u - 1);
        if (d === L.Slash || d === L.Backslash)
          break;
      }
      l = a.substr(u);
    }
    const c = n.indexOf(l);
    return c !== -1 ? r[c] : null;
  };
  s.basenames = n, s.patterns = r, s.allBasenames = n;
  const o = t.filter((a) => !a.basenames);
  return o.push(s), o;
}
const ow = ["W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f"], _9 = new RegExp(`^[${ow.join("")}]+`), $T = 7;
function HT(t) {
  if (t.scheme !== de.vscodeNotebookCell)
    return;
  const e = t.fragment.indexOf("s");
  if (e < 0)
    return;
  const i = parseInt(t.fragment.substring(0, e).replace(_9, ""), $T), n = Uc(t.fragment.substring(e + 1)).toString();
  if (!isNaN(i))
    return {
      handle: i,
      notebook: t.with({ scheme: n, fragment: null })
    };
}
function v9(t, e) {
  const i = e.toString($T), r = `${i.length < ow.length ? ow[i.length - 1] : "z"}${i}s${U_(ue.fromString(t.scheme), !0, !0)}`;
  return t.with({ scheme: de.vscodeNotebookCell, fragment: r });
}
function w9(t) {
  if (t.scheme !== de.vscodeNotebookMetadata)
    return;
  const e = Uc(t.fragment).toString();
  return t.with({ scheme: e, fragment: null });
}
function b9(t) {
  const e = `${U_(ue.fromString(t.scheme), !0, !0)}`;
  return t.with({ scheme: de.vscodeNotebookMetadata, fragment: e });
}
function y9(t) {
  if (t.scheme !== de.vscodeNotebookCellOutput)
    return;
  const e = new URLSearchParams(t.query), i = e.get("openIn");
  if (!i)
    return;
  const n = e.get("outputId") ?? void 0, r = HT(t.with({ scheme: de.vscodeNotebookCell, query: null })), s = e.get("outputIndex") ? parseInt(e.get("outputIndex") || "", 10) : void 0, o = r ? r.notebook : t.with({
    scheme: e.get("notebookScheme") || de.file,
    fragment: null,
    query: null
  }), a = e.get("cellIndex") ? parseInt(e.get("cellIndex") || "", 10) : void 0;
  return {
    notebook: o,
    openIn: i,
    outputId: n,
    outputIndex: s,
    cellHandle: r?.handle,
    cellFragment: t.fragment,
    cellIndex: a
  };
}
var Ql;
(function(t) {
  t[t.Markup = 1] = "Markup", t[t.Code = 2] = "Code";
})(Ql || (Ql = {}));
gr.latex, gr.markdown, gr.text;
gr.latex, gr.markdown, gr.text;
var PD;
(function(t) {
  t[t.Running = 1] = "Running", t[t.Idle = 2] = "Idle";
})(PD || (PD = {}));
var AD;
(function(t) {
  t[t.Unconfirmed = 1] = "Unconfirmed", t[t.Pending = 2] = "Pending", t[t.Executing = 3] = "Executing";
})(AD || (AD = {}));
var RD;
(function(t) {
  t[t.Unconfirmed = 1] = "Unconfirmed", t[t.Pending = 2] = "Pending", t[t.Executing = 3] = "Executing";
})(RD || (RD = {}));
var LD;
(function(t) {
  t[t.WithHardKernelDependency = 0] = "WithHardKernelDependency", t[t.WithOptionalKernelDependency = 1] = "WithOptionalKernelDependency", t[t.Pure = 2] = "Pure", t[t.Never = 3] = "Never";
})(LD || (LD = {}));
var ND;
(function(t) {
  t.Always = "always", t.Never = "never", t.Optional = "optional";
})(ND || (ND = {}));
var tr;
(function(t) {
  t[t.ModelChange = 1] = "ModelChange", t[t.Move = 2] = "Move", t[t.ChangeCellLanguage = 5] = "ChangeCellLanguage", t[t.Initialize = 6] = "Initialize", t[t.ChangeCellMetadata = 7] = "ChangeCellMetadata", t[t.Output = 8] = "Output", t[t.OutputItem = 9] = "OutputItem", t[t.ChangeCellContent = 10] = "ChangeCellContent", t[t.ChangeDocumentMetadata = 11] = "ChangeDocumentMetadata", t[t.ChangeCellInternalMetadata = 12] = "ChangeCellInternalMetadata", t[t.ChangeCellMime = 13] = "ChangeCellMime", t[t.Unknown = 100] = "Unknown";
})(tr || (tr = {}));
var MD;
(function(t) {
  t[t.Handle = 0] = "Handle", t[t.Index = 1] = "Index";
})(MD || (MD = {}));
var bo;
(function(t) {
  t[t.Replace = 1] = "Replace", t[t.Output = 2] = "Output", t[t.Metadata = 3] = "Metadata", t[t.CellLanguage = 4] = "CellLanguage", t[t.DocumentMetadata = 5] = "DocumentMetadata", t[t.Move = 6] = "Move", t[t.OutputItems = 7] = "OutputItems", t[t.PartialMetadata = 8] = "PartialMetadata", t[t.PartialInternalMetadata = 9] = "PartialInternalMetadata";
})(bo || (bo = {}));
var OD;
(function(t) {
  t.scheme = de.vscodeNotebookMetadata;
  function e(n) {
    return b9(n);
  }
  t.generate = e;
  function i(n) {
    return w9(n);
  }
  t.parse = i;
})(OD || (OD = {}));
var aw;
(function(t) {
  t.scheme = de.vscodeNotebookCell;
  function e(c, u) {
    return v9(c, u);
  }
  t.generate = e;
  function i(c) {
    return HT(c);
  }
  t.parse = i;
  function n(c, u) {
    return c.with({
      scheme: de.vscodeNotebookCellOutput,
      query: new URLSearchParams({
        openIn: "editor",
        outputId: u ?? "",
        notebookScheme: c.scheme !== de.file ? c.scheme : ""
      }).toString()
    });
  }
  t.generateCellOutputUriWithId = n;
  function r(c, u, d) {
    return c.with({
      scheme: de.vscodeNotebookCellOutput,
      fragment: u.fragment,
      query: new URLSearchParams({
        openIn: "notebook",
        outputIndex: String(d)
      }).toString()
    });
  }
  t.generateCellOutputUriWithIndex = r;
  function s(c, u, d, f, g) {
    return c.with({
      scheme: de.vscodeNotebookCellOutput,
      query: new URLSearchParams({
        openIn: "notebookOutputEditor",
        notebook: c.toString(),
        cellIndex: String(d),
        outputId: f,
        outputIndex: String(g)
      }).toString()
    });
  }
  t.generateOutputEditorUri = s;
  function o(c) {
    return y9(c);
  }
  t.parseCellOutputUri = o;
  function a(c, u, d) {
    return t.generate(c, u).with({ scheme: d });
  }
  t.generateCellPropertyUri = a;
  function l(c, u) {
    if (c.scheme === u)
      return t.parse(c.with({ scheme: t.scheme }));
  }
  t.parseCellPropertyUri = l;
})(aw || (aw = {}));
new T("notebookEditorCursorAtBoundary", "none");
new T("notebookEditorCursorAtLineBoundary", "none");
var FD;
(function(t) {
  t.default = "default", t.option = "option";
})(FD || (FD = {}));
var UD;
(function(t) {
  t.Cells = "cells", t.Text = "text", t.None = "none";
})(UD || (UD = {}));
var ug;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Right = 2] = "Right";
})(ug || (ug = {}));
function BT(t) {
  return ["application/vnd.code.notebook.stdout", "application/vnd.code.notebook.stderr"].includes(t);
}
const x9 = new TextDecoder();
function E9(t) {
  const e = [];
  let i = !1;
  for (const o of t)
    (e.length === 0 || i) && (e.push(o), i = !0);
  let n = D9(e);
  const r = ue.concat(e.map((o) => ue.wrap(o))), s = P9(r);
  return n = n || s.byteLength !== r.byteLength, { data: s, didCompression: n };
}
const up = "\x1B[A", q1 = up.split("").map((t) => t.charCodeAt(0)), S9 = 10;
function D9(t) {
  let e = !1;
  return t.forEach((i, n) => {
    if (n === 0 || i.length < up.length)
      return;
    const r = t[n - 1], s = i.subarray(0, up.length);
    if (s[0] === q1[0] && s[1] === q1[1] && s[2] === q1[2]) {
      const o = r.lastIndexOf(S9);
      if (o === -1)
        return;
      e = !0, t[n - 1] = r.subarray(0, o), t[n] = i.subarray(up.length);
    }
  }), e;
}
function k9(t) {
  let e = t;
  do
    t = e, e = t.replace(/[^\n]\x08/gm, "");
  while (e.length < t.length);
  return t;
}
function I9(t) {
  for (t = t.replace(/\r+\n/gm, `
`); t.search(/\r[^$]/g) > -1; ) {
    const e = t.match(/^(.*)\r+/m)[1];
    let i = t.match(/\r+(.*)$/m)[1];
    i = i + e.slice(i.length, e.length), t = t.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, i);
  }
  return t;
}
const C9 = 8, T9 = 13;
function P9(t) {
  return !t.buffer.includes(C9) && !t.buffer.includes(T9) ? t : ue.fromString(I9(k9(x9.decode(t.buffer))));
}
var Sn;
(function(t) {
  t.Delimiter = "\0";
})(Sn || (Sn = {}));
var nr;
(function(t) {
  t[t.IsSame = 0] = "IsSame", t[t.Disconnected = 1] = "Disconnected", t[t.IsChild = 2] = "IsChild", t[t.IsParent = 3] = "IsParent";
})(nr || (nr = {}));
class Ne {
  static fromExtHostTestItem(e, i, n = e.parent) {
    if (e._isRoot)
      return new Ne([i]);
    const r = [e.id];
    for (let s = n; s && s.id !== i; s = s.parent)
      r.push(s.id);
    return r.push(i), new Ne(r.reverse());
  }
  static isRoot(e) {
    return !e.includes(Sn.Delimiter);
  }
  static root(e) {
    const i = e.indexOf(Sn.Delimiter);
    return i === -1 ? e : e.slice(0, i);
  }
  static fromString(e) {
    return new Ne(e.split(Sn.Delimiter));
  }
  static join(e, i) {
    return new Ne([...e.path, i]);
  }
  static split(e) {
    return e.split(Sn.Delimiter);
  }
  static joinToString(e, i) {
    return e.toString() + Sn.Delimiter + i;
  }
  static parentId(e) {
    const i = e.lastIndexOf(Sn.Delimiter);
    return i === -1 ? void 0 : e.slice(0, i);
  }
  static localId(e) {
    const i = e.lastIndexOf(Sn.Delimiter);
    return i === -1 ? e : e.slice(i + Sn.Delimiter.length);
  }
  static isChild(e, i) {
    return i[e.length] === Sn.Delimiter && i.startsWith(e);
  }
  static compare(e, i) {
    return e === i ? nr.IsSame : Ne.isChild(e, i) ? nr.IsChild : Ne.isChild(i, e) ? nr.IsParent : nr.Disconnected;
  }
  static getLengthOfCommonPrefix(e, i) {
    if (e === 0)
      return 0;
    let n = 0;
    for (; n < e - 1; ) {
      for (let r = 1; r < e; r++) {
        const s = i(r - 1), o = i(r);
        if (s.path[n] !== o.path[n])
          return n;
      }
      n++;
    }
    return n;
  }
  constructor(e, i = e.length) {
    if (this.path = e, this.viewEnd = i, e.length === 0 || i < 1)
      throw new Error("cannot create test with empty path");
  }
  get rootId() {
    return new Ne(this.path, 1);
  }
  get parentId() {
    return this.viewEnd > 1 ? new Ne(this.path, this.viewEnd - 1) : void 0;
  }
  get localId() {
    return this.path[this.viewEnd - 1];
  }
  get controllerId() {
    return this.path[0];
  }
  get isRoot() {
    return this.viewEnd === 1;
  }
  *idsFromRoot() {
    for (let e = 1; e <= this.viewEnd; e++)
      yield new Ne(this.path, e);
  }
  *idsToRoot() {
    for (let e = this.viewEnd; e > 0; e--)
      yield new Ne(this.path, e);
  }
  compare(e) {
    if (typeof e == "string")
      return Ne.compare(this.toString(), e);
    for (let i = 0; i < e.viewEnd && i < this.viewEnd; i++)
      if (e.path[i] !== this.path[i])
        return nr.Disconnected;
    return e.viewEnd > this.viewEnd ? nr.IsChild : e.viewEnd < this.viewEnd ? nr.IsParent : nr.IsSame;
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    if (!this.stringifed) {
      this.stringifed = this.path[0];
      for (let e = 1; e < this.viewEnd; e++)
        this.stringifed += Sn.Delimiter, this.stringifed += this.path[e];
    }
    return this.stringifed;
  }
}
var ii;
(function(t) {
  t[t.Unset = 0] = "Unset", t[t.Queued = 1] = "Queued", t[t.Running = 2] = "Running", t[t.Passed = 3] = "Passed", t[t.Failed = 4] = "Failed", t[t.Skipped = 5] = "Skipped", t[t.Errored = 6] = "Errored";
})(ii || (ii = {}));
ii.Unset + "", ii.Queued + "", ii.Running + "", ii.Passed + "", ii.Failed + "", ii.Skipped + "", ii.Errored + "";
var $D;
(function(t) {
  t[t.Run = 1] = "Run", t[t.Debug = 2] = "Debug", t[t.Coverage = 3] = "Coverage";
})($D || ($D = {}));
var bd;
(function(t) {
  t[t.Refresh = 2] = "Refresh", t[t.CodeRelatedToTest = 4] = "CodeRelatedToTest", t[t.TestRelatedToCode = 8] = "TestRelatedToCode";
})(bd || (bd = {}));
var Pi;
(function(t) {
  t[t.Run = 2] = "Run", t[t.Debug = 4] = "Debug", t[t.Coverage = 8] = "Coverage", t[t.HasNonDefaultProfile = 16] = "HasNonDefaultProfile", t[t.HasConfigurable = 32] = "HasConfigurable", t[t.SupportsContinuousRun = 64] = "SupportsContinuousRun";
})(Pi || (Pi = {}));
Pi.Run + "", h(11849, "Run"), Pi.Debug + "", h(11850, "Debug"), Pi.Coverage + "", h(11851, "Coverage");
Pi.Run, Pi.Debug, Pi.Coverage, Pi.HasNonDefaultProfile, Pi.HasConfigurable, Pi.SupportsContinuousRun;
const A9 = (t) => "runId" in t;
var jc;
(function(t) {
  t.serialize = (e) => ({
    range: e.range.toJSON(),
    uri: e.uri.toJSON()
  }), t.deserialize = (e, i) => ({
    range: ut.lift(i.range),
    uri: e.asCanonicalUri(x.revive(i.uri))
  });
})(jc || (jc = {}));
var mr;
(function(t) {
  t[t.Error = 0] = "Error", t[t.Output = 1] = "Output";
})(mr || (mr = {}));
var dg;
(function(t) {
  t.serialize = (e) => ({
    label: e.label,
    uri: e.uri?.toJSON(),
    position: e.position?.toJSON()
  }), t.deserialize = (e, i) => ({
    label: i.label,
    uri: i.uri ? e.asCanonicalUri(x.revive(i.uri)) : void 0,
    position: i.position ? Pn.lift(i.position) : void 0
  });
})(dg || (dg = {}));
var hg;
(function(t) {
  t.serialize = (e) => ({
    message: e.message,
    type: mr.Error,
    expected: e.expected,
    actual: e.actual,
    contextValue: e.contextValue,
    location: e.location && jc.serialize(e.location),
    stackTrace: e.stackTrace?.map(dg.serialize)
  }), t.deserialize = (e, i) => ({
    message: i.message,
    type: mr.Error,
    expected: i.expected,
    actual: i.actual,
    contextValue: i.contextValue,
    location: i.location && jc.deserialize(e, i.location),
    stackTrace: i.stackTrace && i.stackTrace.map((n) => dg.deserialize(e, n))
  });
})(hg || (hg = {}));
var fg;
(function(t) {
  t.serialize = (e) => ({
    message: e.message,
    type: mr.Output,
    offset: e.offset,
    length: e.length,
    location: e.location && jc.serialize(e.location)
  }), t.deserialize = (e, i) => ({
    message: i.message,
    type: mr.Output,
    offset: i.offset,
    length: i.length,
    location: i.location && jc.deserialize(e, i.location)
  });
})(fg || (fg = {}));
var pg;
(function(t) {
  t.serialize = (e) => e.type === mr.Error ? hg.serialize(e) : fg.serialize(e), t.deserialize = (e, i) => i.type === mr.Error ? hg.deserialize(e, i) : fg.deserialize(e, i), t.isDiffable = (e) => e.type === mr.Error && e.actual !== void 0 && e.expected !== void 0;
})(pg || (pg = {}));
var yd;
(function(t) {
  t.serializeWithoutMessages = (e) => ({
    state: e.state,
    duration: e.duration,
    messages: []
  }), t.serialize = (e) => ({
    state: e.state,
    duration: e.duration,
    messages: e.messages.map(pg.serialize)
  }), t.deserialize = (e, i) => ({
    state: i.state,
    duration: i.duration,
    messages: i.messages.map((n) => pg.deserialize(e, n))
  });
})(yd || (yd = {}));
const WT = "\0", dp = (t, e) => t + WT + e, VT = (t) => {
  const e = t.indexOf(WT);
  return { ctrlId: t.slice(0, e), tagId: t.slice(e + 1) };
};
var gg;
(function(t) {
  t.serialize = (e) => ({
    extId: e.extId,
    label: e.label,
    tags: e.tags,
    busy: e.busy,
    children: void 0,
    uri: e.uri?.toJSON(),
    range: e.range?.toJSON() || null,
    description: e.description,
    error: e.error,
    sortText: e.sortText
  }), t.deserialize = (e, i) => ({
    extId: i.extId,
    label: i.label,
    tags: i.tags,
    busy: i.busy,
    children: void 0,
    uri: i.uri ? e.asCanonicalUri(x.revive(i.uri)) : void 0,
    range: i.range ? ut.lift(i.range) : null,
    description: i.description,
    error: i.error,
    sortText: i.sortText
  });
})(gg || (gg = {}));
var ki;
(function(t) {
  t[t.NotExpandable = 0] = "NotExpandable", t[t.Expandable = 1] = "Expandable", t[t.BusyExpanding = 2] = "BusyExpanding", t[t.Expanded = 3] = "Expanded";
})(ki || (ki = {}));
var yo;
(function(t) {
  t.serialize = (e) => ({
    expand: e.expand,
    item: gg.serialize(e.item)
  }), t.deserialize = (e, i) => ({
    controllerId: Ne.root(i.item.extId),
    expand: i.expand,
    item: gg.deserialize(e, i.item)
  });
})(yo || (yo = {}));
var th;
(function(t) {
  t.serialize = (e) => {
    let i;
    return e.item && (i = {}, e.item.label !== void 0 && (i.label = e.item.label), e.item.tags !== void 0 && (i.tags = e.item.tags), e.item.busy !== void 0 && (i.busy = e.item.busy), e.item.uri !== void 0 && (i.uri = e.item.uri?.toJSON()), e.item.range !== void 0 && (i.range = e.item.range?.toJSON()), e.item.description !== void 0 && (i.description = e.item.description), e.item.error !== void 0 && (i.error = e.item.error), e.item.sortText !== void 0 && (i.sortText = e.item.sortText)), { extId: e.extId, expand: e.expand, item: i };
  }, t.deserialize = (e) => {
    let i;
    return e.item && (i = {}, e.item.label !== void 0 && (i.label = e.item.label), e.item.tags !== void 0 && (i.tags = e.item.tags), e.item.busy !== void 0 && (i.busy = e.item.busy), e.item.range !== void 0 && (i.range = e.item.range ? ut.lift(e.item.range) : null), e.item.description !== void 0 && (i.description = e.item.description), e.item.error !== void 0 && (i.error = e.item.error), e.item.sortText !== void 0 && (i.sortText = e.item.sortText)), { extId: e.extId, expand: e.expand, item: i };
  };
})(th || (th = {}));
const lw = (t, e) => {
  e.expand !== void 0 && (t.expand = e.expand), e.item !== void 0 && (t.item = t.item ? Object.assign(t.item, e.item) : e.item);
};
var HD;
(function(t) {
  t.serializeWithoutMessages = (e) => ({
    ...yo.serialize(e),
    ownComputedState: e.ownComputedState,
    computedState: e.computedState,
    tasks: e.tasks.map(yd.serializeWithoutMessages)
  }), t.serialize = (e) => ({
    ...yo.serialize(e),
    ownComputedState: e.ownComputedState,
    computedState: e.computedState,
    tasks: e.tasks.map(yd.serialize)
  }), t.deserialize = (e, i) => ({
    ...yo.deserialize(e, i),
    ownComputedState: i.ownComputedState,
    computedState: i.computedState,
    tasks: i.tasks.map((n) => yd.deserialize(e, n)),
    retired: !0
  });
})(HD || (HD = {}));
var cw;
(function(t) {
  t.empty = () => ({ covered: 0, total: 0 }), t.sum = (e, i) => {
    e.covered += i.covered, e.total += i.total;
  };
})(cw || (cw = {}));
var BD;
(function(t) {
  t.serialize = (e) => ({
    id: e.id,
    statement: e.statement,
    branch: e.branch,
    declaration: e.declaration,
    testIds: e.testIds,
    uri: e.uri.toJSON()
  }), t.deserialize = (e, i) => ({
    id: i.id,
    statement: i.statement,
    branch: i.branch,
    declaration: i.declaration,
    testIds: i.testIds,
    uri: e.asCanonicalUri(x.revive(i.uri))
  }), t.empty = (e, i) => ({
    id: e,
    uri: i,
    statement: cw.empty()
  });
})(BD || (BD = {}));
function Qx(t) {
  return {
    ...t,
    location: t.location?.toJSON()
  };
}
function Kx(t) {
  return t.location = t.location ? Pn.isIPosition(t.location) ? Pn.lift(t.location) : ut.lift(t.location) : void 0, t;
}
var Ca;
(function(t) {
  t[t.Declaration = 0] = "Declaration", t[t.Statement = 1] = "Statement", t[t.Branch = 2] = "Branch";
})(Ca || (Ca = {}));
var WD;
(function(t) {
  t.serialize = (e) => e.type === Ca.Declaration ? _g.serialize(e) : vg.serialize(e), t.deserialize = (e) => e.type === Ca.Declaration ? _g.deserialize(e) : vg.deserialize(e);
})(WD || (WD = {}));
var mg;
(function(t) {
  t.serialize = Qx, t.deserialize = Kx;
})(mg || (mg = {}));
var _g;
(function(t) {
  t.serialize = Qx, t.deserialize = Kx;
})(_g || (_g = {}));
var vg;
(function(t) {
  t.serialize = (e) => ({
    ...Qx(e),
    branches: e.branches?.map(mg.serialize)
  }), t.deserialize = (e) => ({
    ...Kx(e),
    branches: e.branches?.map(mg.deserialize)
  });
})(vg || (vg = {}));
var kt;
(function(t) {
  t[t.Add = 0] = "Add", t[t.Update = 1] = "Update", t[t.DocumentSynced = 2] = "DocumentSynced", t[t.Remove = 3] = "Remove", t[t.IncrementPendingExtHosts = 4] = "IncrementPendingExtHosts", t[t.Retire = 5] = "Retire", t[t.AddTag = 6] = "AddTag", t[t.RemoveTag = 7] = "RemoveTag";
})(kt || (kt = {}));
var wg;
(function(t) {
  t.deserialize = (e, i) => i.op === kt.Add ? { op: i.op, item: yo.deserialize(e, i.item) } : i.op === kt.Update ? { op: i.op, item: th.deserialize(i.item) } : i.op === kt.DocumentSynced ? { op: i.op, uri: e.asCanonicalUri(x.revive(i.uri)), docv: i.docv } : i, t.serialize = (e) => e.op === kt.Add ? { op: e.op, item: yo.serialize(e.item) } : e.op === kt.Update ? { op: e.op, item: th.serialize(e.item) } : e;
})(wg || (wg = {}));
class R9 {
  constructor(e) {
    this.uriIdentity = e, this._tags = /* @__PURE__ */ new Map(), this.items = /* @__PURE__ */ new Map(), this.roots = /* @__PURE__ */ new Set(), this.busyControllerCount = 0, this.pendingRootCount = 0, this.tags = this._tags;
  }
  apply(e) {
    const i = this.createChangeCollector();
    for (const n of e)
      switch (n.op) {
        case kt.Add:
          this.add(yo.deserialize(this.uriIdentity, n.item), i);
          break;
        case kt.Update:
          this.update(th.deserialize(n.item), i);
          break;
        case kt.Remove:
          this.remove(n.itemId, i);
          break;
        case kt.Retire:
          this.retireTest(n.itemId);
          break;
        case kt.IncrementPendingExtHosts:
          this.updatePendingRoots(n.amount);
          break;
        case kt.AddTag:
          this._tags.set(n.tag.id, n.tag);
          break;
        case kt.RemoveTag:
          this._tags.delete(n.id);
          break;
      }
    i.complete?.();
  }
  add(e, i) {
    const n = Ne.parentId(e.item.extId)?.toString();
    let r;
    if (!n)
      r = this.createItem(e), this.roots.add(r), this.items.set(e.item.extId, r);
    else if (this.items.has(n)) {
      const s = this.items.get(n);
      s.children.add(e.item.extId), r = this.createItem(e, s), this.items.set(e.item.extId, r);
    } else {
      console.error(`Test with unknown parent ID: ${JSON.stringify(e)}`);
      return;
    }
    return i.add?.(r), e.expand === ki.BusyExpanding && this.busyControllerCount++, r;
  }
  update(e, i) {
    const n = this.items.get(e.extId);
    if (n)
      return e.expand !== void 0 && (n.expand === ki.BusyExpanding && this.busyControllerCount--, e.expand === ki.BusyExpanding && this.busyControllerCount++), lw(n, e), i.update?.(n), n;
  }
  remove(e, i) {
    const n = this.items.get(e);
    if (!n)
      return;
    const r = Ne.parentId(n.item.extId)?.toString();
    r ? this.items.get(r).children.delete(n.item.extId) : this.roots.delete(n);
    const s = [[e]];
    for (; s.length; )
      for (const o of s.pop()) {
        const a = this.items.get(o);
        a && (s.push(a.children), this.items.delete(o), i.remove?.(a, a !== n), a.expand === ki.BusyExpanding && this.busyControllerCount--);
      }
  }
  retireTest(e) {
  }
  updatePendingRoots(e) {
    this.pendingRootCount += e;
  }
  createChangeCollector() {
    return {};
  }
}
var VD;
(function(t) {
  t[t.UP = 0] = "UP", t[t.DOWN = 1] = "DOWN", t[t.LEFT = 2] = "LEFT", t[t.RIGHT = 3] = "RIGHT";
})(VD || (VD = {}));
var zD;
(function(t) {
  t[t.HORIZONTAL = 0] = "HORIZONTAL", t[t.VERTICAL = 1] = "VERTICAL";
})(zD || (zD = {}));
var qD;
(function(t) {
  t[t.FIRST = 0] = "FIRST", t[t.LAST = 1] = "LAST", t[t.NEXT = 2] = "NEXT", t[t.PREVIOUS = 3] = "PREVIOUS";
})(qD || (qD = {}));
var jD;
(function(t) {
  t[t.MAXIMIZE = 0] = "MAXIMIZE", t[t.EXPAND = 1] = "EXPAND", t[t.EVEN = 2] = "EVEN";
})(jD || (jD = {}));
var GD;
(function(t) {
  t[t.COPY_EDITORS = 0] = "COPY_EDITORS", t[t.MOVE_EDITORS = 1] = "MOVE_EDITORS";
})(GD || (GD = {}));
var QD;
(function(t) {
  t[t.CREATION_TIME = 0] = "CREATION_TIME", t[t.MOST_RECENTLY_ACTIVE = 1] = "MOST_RECENTLY_ACTIVE", t[t.GRID_APPEARANCE = 2] = "GRID_APPEARANCE";
})(QD || (QD = {}));
var KD;
(function(t) {
  t[t.NEW_EDITOR = 1] = "NEW_EDITOR", t[t.MOVE_EDITOR = 2] = "MOVE_EDITOR", t[t.COPY_EDITOR = 3] = "COPY_EDITOR";
})(KD || (KD = {}));
const L9 = -1, N9 = -2;
var yi;
(function(t) {
  t[t.Upsert = 0] = "Upsert", t[t.SetTags = 1] = "SetTags", t[t.UpdateCanResolveChildren = 2] = "UpdateCanResolveChildren", t[t.RemoveChild = 3] = "RemoveChild", t[t.SetProp = 4] = "SetProp", t[t.Bulk = 5] = "Bulk", t[t.DocumentSynced = 6] = "DocumentSynced";
})(yi || (yi = {}));
const Bu = (t, e) => t === e, M9 = {
  range: (t, e) => t === e ? !0 : !t || !e ? !1 : t.equalsRange(e),
  busy: Bu,
  label: Bu,
  description: Bu,
  error: Bu,
  sortText: Bu,
  tags: (t, e) => !(t.length !== e.length || t.some((i) => !e.includes(i)))
}, O9 = Object.entries(M9), F9 = (t, e) => {
  let i;
  for (const [n, r] of O9)
    r(t[n], e[n]) || (i ? i[n] = e[n] : i = { [n]: e[n] });
  return i;
};
class U9 extends ve {
  get root() {
    return this.options.root;
  }
  constructor(e) {
    super(), this.options = e, this.debounceSendDiff = this._register(new cl(() => this.flushDiff(), 200)), this.diffOpEmitter = this._register(new N()), this.tree = /* @__PURE__ */ new Map(), this.tags = /* @__PURE__ */ new Map(), this.diff = [], this.onDidGenerateDiff = this.diffOpEmitter.event, this.root.canResolveChildren = !0, this.upsertItem(this.root, void 0);
  }
  set resolveHandler(e) {
    this._resolveHandler = e;
    for (const i of this.tree.values())
      this.updateExpandability(i);
  }
  get resolveHandler() {
    return this._resolveHandler;
  }
  collectDiff() {
    const e = this.diff;
    return this.diff = [], e;
  }
  pushDiff(e) {
    switch (e.op) {
      case kt.DocumentSynced: {
        for (const i of this.diff)
          if (i.op === kt.DocumentSynced && i.uri === e.uri) {
            i.docv = e.docv;
            return;
          }
        break;
      }
      case kt.Update: {
        const i = this.diff[this.diff.length - 1];
        if (i) {
          if (i.op === kt.Update && i.item.extId === e.item.extId) {
            lw(i.item, e.item);
            return;
          }
          if (i.op === kt.Add && i.item.item.extId === e.item.extId) {
            lw(i.item, e.item);
            return;
          }
        }
        break;
      }
    }
    this.diff.push(e), this.debounceSendDiff.isScheduled() || this.debounceSendDiff.schedule();
  }
  expand(e, i) {
    const n = this.tree.get(e);
    if (n) {
      if ((n.expandLevels === void 0 || i > n.expandLevels) && (n.expandLevels = i), n.expand === ki.Expandable) {
        const r = this.resolveChildren(n);
        return r.isOpen() ? this.expandChildren(n, i - 1) : r.wait().then(() => this.expandChildren(n, i - 1));
      } else if (n.expand === ki.Expanded)
        return n.resolveBarrier?.isOpen() === !1 ? n.resolveBarrier.wait().then(() => this.expandChildren(n, i - 1)) : this.expandChildren(n, i - 1);
    }
  }
  dispose() {
    for (const e of this.tree.values())
      this.options.getApiFor(e.actual).listener = void 0;
    this.tree.clear(), this.diff = [], super.dispose();
  }
  onTestItemEvent(e, i) {
    switch (i.op) {
      case yi.RemoveChild:
        this.removeItem(Ne.joinToString(e.fullId, i.id));
        break;
      case yi.Upsert:
        this.upsertItem(i.item, e);
        break;
      case yi.Bulk:
        for (const n of i.ops)
          this.onTestItemEvent(e, n);
        break;
      case yi.SetTags:
        this.diffTagRefs(i.new, i.old, e.fullId.toString());
        break;
      case yi.UpdateCanResolveChildren:
        this.updateExpandability(e);
        break;
      case yi.SetProp:
        this.pushDiff({
          op: kt.Update,
          item: {
            extId: e.fullId.toString(),
            item: i.update
          }
        });
        break;
      case yi.DocumentSynced:
        this.documentSynced(e.actual.uri);
        break;
      default:
        vv();
    }
  }
  documentSynced(e) {
    e && this.pushDiff({
      op: kt.DocumentSynced,
      uri: e,
      docv: this.options.getDocumentVersion(e)
    });
  }
  upsertItem(e, i) {
    const n = Ne.fromExtHostTestItem(e, this.root.id, i?.actual), r = this.options.getApiFor(e);
    r.parent && r.parent !== i?.actual && this.options.getChildren(r.parent).delete(e.id);
    let s = this.tree.get(n.toString());
    if (!s) {
      s = {
        fullId: n,
        actual: e,
        expandLevels: i?.expandLevels ? i.expandLevels - 1 : void 0,
        expand: ki.NotExpandable
      }, e.tags.forEach(this.incrementTagRefs, this), this.tree.set(s.fullId.toString(), s), this.setItemParent(e, i), this.pushDiff({
        op: kt.Add,
        item: {
          controllerId: this.options.controllerId,
          expand: s.expand,
          item: this.options.toITestItem(e)
        }
      }), this.connectItemAndChildren(e, s, i);
      return;
    }
    if (s.actual === e) {
      this.connectItem(e, s, i);
      return;
    }
    if (s.actual.uri?.toString() !== e.uri?.toString())
      return this.removeItem(n.toString()), this.upsertItem(e, i);
    const o = this.options.getChildren(s.actual), a = s.actual, l = F9(this.options.toITestItem(a), this.options.toITestItem(e));
    this.options.getApiFor(a).listener = void 0, s.actual = e, s.resolveBarrier = void 0, s.expand = ki.NotExpandable, l && (l.hasOwnProperty("tags") && (this.diffTagRefs(e.tags, a.tags, n.toString()), delete l.tags), this.onTestItemEvent(s, { op: yi.SetProp, update: l })), this.connectItemAndChildren(e, s, i);
    for (const [u, d] of o)
      this.options.getChildren(e).get(d.id) || this.removeItem(Ne.joinToString(n, d.id));
    const c = s.expandLevels;
    c !== void 0 && queueMicrotask(() => {
      s.expand === ki.Expandable && (s.expandLevels = void 0, this.expand(n.toString(), c));
    }), this.documentSynced(s.actual.uri);
  }
  diffTagRefs(e, i, n) {
    const r = new Set(i.map((s) => s.id));
    for (const s of e)
      r.delete(s.id) || this.incrementTagRefs(s);
    this.pushDiff({
      op: kt.Update,
      item: { extId: n, item: { tags: e.map((s) => dp(this.options.controllerId, s.id)) } }
    }), r.forEach(this.decrementTagRefs, this);
  }
  incrementTagRefs(e) {
    const i = this.tags.get(e.id);
    i ? i.refCount++ : (this.tags.set(e.id, { refCount: 1 }), this.pushDiff({
      op: kt.AddTag,
      tag: {
        id: dp(this.options.controllerId, e.id)
      }
    }));
  }
  decrementTagRefs(e) {
    const i = this.tags.get(e);
    i && !--i.refCount && (this.tags.delete(e), this.pushDiff({ op: kt.RemoveTag, id: dp(this.options.controllerId, e) }));
  }
  setItemParent(e, i) {
    this.options.getApiFor(e).parent = i && i.actual !== this.root ? i.actual : void 0;
  }
  connectItem(e, i, n) {
    this.setItemParent(e, n);
    const r = this.options.getApiFor(e);
    r.parent = n?.actual, r.listener = (s) => this.onTestItemEvent(i, s), this.updateExpandability(i);
  }
  connectItemAndChildren(e, i, n) {
    this.connectItem(e, i, n);
    for (const [r, s] of this.options.getChildren(e))
      this.upsertItem(s, i);
  }
  updateExpandability(e) {
    let i;
    this._resolveHandler ? e.resolveBarrier ? i = e.resolveBarrier.isOpen() ? ki.Expanded : ki.BusyExpanding : i = e.actual.canResolveChildren ? ki.Expandable : ki.NotExpandable : i = ki.NotExpandable, i !== e.expand && (e.expand = i, this.pushDiff({ op: kt.Update, item: { extId: e.fullId.toString(), expand: i } }), i === ki.Expandable && e.expandLevels !== void 0 && this.resolveChildren(e));
  }
  expandChildren(e, i) {
    if (i < 0)
      return;
    const n = [];
    for (const [r, s] of this.options.getChildren(e.actual)) {
      const o = this.expand(Ne.joinToString(e.fullId, s.id), i);
      Do(o) && n.push(o);
    }
    if (n.length)
      return Promise.all(n).then(() => {
      });
  }
  resolveChildren(e) {
    if (e.resolveBarrier)
      return e.resolveBarrier;
    if (!this._resolveHandler) {
      const s = new Ur();
      return s.open(), s;
    }
    e.expand = ki.BusyExpanding, this.pushExpandStateUpdate(e);
    const i = e.resolveBarrier = new Ur(), n = (s) => {
      console.error(`Unhandled error in resolveHandler of test controller "${this.options.controllerId}"`, s);
    };
    let r;
    try {
      r = this._resolveHandler(e.actual === this.root ? void 0 : e.actual);
    } catch (s) {
      n(s);
    }
    return Do(r) ? r.catch(n).then(() => {
      i.open(), this.updateExpandability(e);
    }) : (i.open(), this.updateExpandability(e)), e.resolveBarrier;
  }
  pushExpandStateUpdate(e) {
    this.pushDiff({ op: kt.Update, item: { extId: e.fullId.toString(), expand: e.expand } });
  }
  removeItem(e) {
    const i = this.tree.get(e);
    if (!i)
      throw new Error("attempting to remove non-existent child");
    this.pushDiff({ op: kt.Remove, itemId: e });
    const n = [i];
    for (; n.length; ) {
      const r = n.pop();
      if (r) {
        this.options.getApiFor(r.actual).listener = void 0;
        for (const s of r.actual.tags)
          this.decrementTagRefs(s.id);
        this.tree.delete(r.fullId.toString());
        for (const [s, o] of this.options.getChildren(r.actual))
          n.push(this.tree.get(Ne.joinToString(r.fullId, o.id)));
      }
    }
  }
  flushDiff() {
    const e = this.collectDiff();
    e.length && this.diffOpEmitter.fire(e);
  }
}
class $9 extends Error {
  constructor(e) {
    super(`Attempted to insert a duplicate test item ID ${e}`);
  }
}
class bg extends Error {
  constructor(e) {
    super(`TestItem with ID "${e}" is invalid. Make sure to create it from the createTestItem method.`);
  }
}
class H9 extends Error {
  constructor(e, i, n) {
    super(`TestItem with ID "${e}" is from controller "${i}" and cannot be added as a child of an item from controller "${n}".`);
  }
}
const B9 = (t, e, i) => {
  let n = /* @__PURE__ */ new Map();
  return {
    get size() {
      return n.size;
    },
    forEach(r, s) {
      for (const o of n.values())
        r.call(s, o, this);
    },
    [Symbol.iterator]() {
      return n.entries();
    },
    replace(r) {
      const s = /* @__PURE__ */ new Map(), o = new Set(n.keys()), a = { op: yi.Bulk, ops: [] };
      for (const l of r) {
        if (!(l instanceof i))
          throw new bg(l.id);
        const c = e(l).controllerId;
        if (c !== t.controllerId)
          throw new H9(l.id, c, t.controllerId);
        if (s.has(l.id))
          throw new $9(l.id);
        s.set(l.id, l), o.delete(l.id), a.ops.push({ op: yi.Upsert, item: l });
      }
      for (const l of o.keys())
        a.ops.push({ op: yi.RemoveChild, id: l });
      t.listener?.(a), n = s;
    },
    add(r) {
      if (!(r instanceof i))
        throw new bg(r.id);
      n.set(r.id, r), t.listener?.({ op: yi.Upsert, item: r });
    },
    delete(r) {
      n.delete(r) && t.listener?.({ op: yi.RemoveChild, id: r });
    },
    get(r) {
      return n.get(r);
    },
    toJSON() {
      return Array.from(n.values());
    }
  };
}, zT = /* @__PURE__ */ new WeakMap(), W9 = (t, e) => {
  const i = { controllerId: e };
  return zT.set(t, i), i;
}, J_ = (t) => {
  const e = zT.get(t);
  if (!e)
    throw new bg(t?.id || "<unknown>");
  return e;
};
var yg;
(function(t) {
  t[t.WebSocket = 0] = "WebSocket", t[t.Managed = 1] = "Managed";
})(yg || (yg = {}));
class V9 {
  constructor(e) {
    this.id = e, this.type = yg.Managed;
  }
  toString() {
    return `Managed(${this.id})`;
  }
}
class z9 {
  constructor(e, i) {
    this.host = e, this.port = i, this.type = yg.WebSocket;
  }
  toString() {
    return `WebSocket(${this.host}:${this.port})`;
  }
}
var Cs;
(function(t) {
  t.Unknown = "Unknown", t.NotAvailable = "NotAvailable", t.TemporarilyNotAvailable = "TemporarilyNotAvailable", t.NoResolverFound = "NoResolverFound", t.InvalidAuthority = "InvalidAuthority";
})(Cs || (Cs = {}));
function JD(t) {
  const e = t.indexOf("+");
  return e === -1 ? t : t.substring(0, e);
}
var uw, zo, as, dw, qo, Ks, jo, hw, fw, hp, Ju, pw, Er, Sr, gw, Ji, mw;
function _e(t) {
  return Object.assign(t, {
    apply: function(...i) {
      if (i.length === 0)
        return Reflect.construct(t, []);
      {
        const n = i.length === 1 ? [] : i[1];
        return Reflect.construct(t, n, i[0].constructor);
      }
    },
    call: function(...i) {
      if (i.length === 0)
        return Reflect.construct(t, []);
      {
        const [n, ...r] = i;
        return Reflect.construct(t, r, n.constructor);
      }
    }
  });
}
var _w;
(function(t) {
  t[t.Top = 0] = "Top", t[t.Bottom = 1] = "Bottom";
})(_w || (_w = {}));
var YD;
(function(t) {
  t[t.TerminalCommand = 0] = "TerminalCommand", t[t.Opener = 1] = "Opener", t[t.Command = 3] = "Command";
})(YD || (YD = {}));
let Ve = uw = class {
  static from(...e) {
    let i = e;
    return new uw(function() {
      if (i) {
        for (const n of i)
          n && typeof n.dispose == "function" && n.dispose();
        i = void 0;
      }
    });
  }
  #e;
  constructor(e) {
    this.#e = e;
  }
  dispose() {
    typeof this.#e == "function" && (this.#e(), this.#e = void 0);
  }
};
Ve = uw = W([
  _e
], Ve);
let je = zo = class {
  static Min(...e) {
    if (e.length === 0)
      throw new TypeError();
    let i = e[0];
    for (let n = 1; n < e.length; n++) {
      const r = e[n];
      r.isBefore(i) && (i = r);
    }
    return i;
  }
  static Max(...e) {
    if (e.length === 0)
      throw new TypeError();
    let i = e[0];
    for (let n = 1; n < e.length; n++) {
      const r = e[n];
      r.isAfter(i) && (i = r);
    }
    return i;
  }
  static isPosition(e) {
    if (!e)
      return !1;
    if (e instanceof zo)
      return !0;
    const { line: i, character: n } = e;
    return typeof i == "number" && typeof n == "number";
  }
  static of(e) {
    if (e instanceof zo)
      return e;
    if (this.isPosition(e))
      return new zo(e.line, e.character);
    throw new Error("Invalid argument, is NOT a position-like object");
  }
  get line() {
    return this._line;
  }
  get character() {
    return this._character;
  }
  constructor(e, i) {
    if (e < 0)
      throw ze("line must be non-negative");
    if (i < 0)
      throw ze("character must be non-negative");
    this._line = e, this._character = i;
  }
  isBefore(e) {
    return this._line < e._line ? !0 : e._line < this._line ? !1 : this._character < e._character;
  }
  isBeforeOrEqual(e) {
    return this._line < e._line ? !0 : e._line < this._line ? !1 : this._character <= e._character;
  }
  isAfter(e) {
    return !this.isBeforeOrEqual(e);
  }
  isAfterOrEqual(e) {
    return !this.isBefore(e);
  }
  isEqual(e) {
    return this._line === e._line && this._character === e._character;
  }
  compareTo(e) {
    return this._line < e._line ? -1 : this._line > e.line ? 1 : this._character < e._character ? -1 : this._character > e._character ? 1 : 0;
  }
  translate(e, i = 0) {
    if (e === null || i === null)
      throw ze();
    let n;
    return typeof e > "u" ? n = 0 : typeof e == "number" ? n = e : (n = typeof e.lineDelta == "number" ? e.lineDelta : 0, i = typeof e.characterDelta == "number" ? e.characterDelta : 0), n === 0 && i === 0 ? this : new zo(this.line + n, this.character + i);
  }
  with(e, i = this.character) {
    if (e === null || i === null)
      throw ze();
    let n;
    return typeof e > "u" ? n = this.line : typeof e == "number" ? n = e : (n = typeof e.line == "number" ? e.line : this.line, i = typeof e.character == "number" ? e.character : this.character), n === this.line && i === this.character ? this : new zo(n, i);
  }
  toJSON() {
    return { line: this.line, character: this.character };
  }
  [Symbol.for("debug.description")]() {
    return `(${this.line}:${this.character})`;
  }
};
je = zo = W([
  _e
], je);
let Oe = as = class {
  static isRange(e) {
    return e instanceof as ? !0 : e ? je.isPosition(e.start) && je.isPosition(e.end) : !1;
  }
  static of(e) {
    if (e instanceof as)
      return e;
    if (this.isRange(e))
      return new as(e.start, e.end);
    throw new Error("Invalid argument, is NOT a range-like object");
  }
  get start() {
    return this._start;
  }
  get end() {
    return this._end;
  }
  constructor(e, i, n, r) {
    let s, o;
    if (typeof e == "number" && typeof i == "number" && typeof n == "number" && typeof r == "number" ? (s = new je(e, i), o = new je(n, r)) : je.isPosition(e) && je.isPosition(i) && (s = je.of(e), o = je.of(i)), !s || !o)
      throw new Error("Invalid arguments");
    s.isBefore(o) ? (this._start = s, this._end = o) : (this._start = o, this._end = s);
  }
  contains(e) {
    return as.isRange(e) ? this.contains(e.start) && this.contains(e.end) : je.isPosition(e) ? !(je.of(e).isBefore(this._start) || this._end.isBefore(e)) : !1;
  }
  isEqual(e) {
    return this._start.isEqual(e._start) && this._end.isEqual(e._end);
  }
  intersection(e) {
    const i = je.Max(e.start, this._start), n = je.Min(e.end, this._end);
    if (!i.isAfter(n))
      return new as(i, n);
  }
  union(e) {
    if (this.contains(e))
      return this;
    if (e.contains(this))
      return e;
    const i = je.Min(e.start, this._start), n = je.Max(e.end, this.end);
    return new as(i, n);
  }
  get isEmpty() {
    return this._start.isEqual(this._end);
  }
  get isSingleLine() {
    return this._start.line === this._end.line;
  }
  with(e, i = this.end) {
    if (e === null || i === null)
      throw ze();
    let n;
    return e ? je.isPosition(e) ? n = e : (n = e.start || this.start, i = e.end || this.end) : n = this.start, n.isEqual(this._start) && i.isEqual(this.end) ? this : new as(n, i);
  }
  toJSON() {
    return [this.start, this.end];
  }
  [Symbol.for("debug.description")]() {
    return qT(this);
  }
};
Oe = as = W([
  _e
], Oe);
let Qr = dw = class extends Oe {
  static isSelection(e) {
    return e instanceof dw ? !0 : e ? Oe.isRange(e) && je.isPosition(e.anchor) && je.isPosition(e.active) && typeof e.isReversed == "boolean" : !1;
  }
  get anchor() {
    return this._anchor;
  }
  get active() {
    return this._active;
  }
  constructor(e, i, n, r) {
    let s, o;
    if (typeof e == "number" && typeof i == "number" && typeof n == "number" && typeof r == "number" ? (s = new je(e, i), o = new je(n, r)) : je.isPosition(e) && je.isPosition(i) && (s = je.of(e), o = je.of(i)), !s || !o)
      throw new Error("Invalid arguments");
    super(s, o), this._anchor = s, this._active = o;
  }
  get isReversed() {
    return this._anchor === this._end;
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end,
      active: this.active,
      anchor: this.anchor
    };
  }
  [Symbol.for("debug.description")]() {
    return q9(this);
  }
};
Qr = dw = W([
  _e
], Qr);
function qT(t) {
  return t.isEmpty ? `[${t.start.line}:${t.start.character})` : `[${t.start.line}:${t.start.character} -> ${t.end.line}:${t.end.character})`;
}
function q9(t) {
  let e = qT(t);
  return t.isEmpty || (t.active.isEqual(t.start) ? e = `|${e}` : e = `${e}|`), e;
}
const jT = (t) => {
  if (typeof t != "string" || t.length === 0 || !/^[0-9A-Za-z_\-]+$/.test(t))
    throw ze("connectionToken");
};
class j9 {
  static isResolvedAuthority(e) {
    return e && typeof e == "object" && typeof e.host == "string" && typeof e.port == "number" && (e.connectionToken === void 0 || typeof e.connectionToken == "string");
  }
  constructor(e, i, n) {
    if (typeof e != "string" || e.length === 0)
      throw ze("host");
    if (typeof i != "number" || i === 0 || Math.round(i) !== i)
      throw ze("port");
    typeof n < "u" && jT(n), this.host = e, this.port = Math.round(i), this.connectionToken = n;
  }
}
class fp {
  static isManagedResolvedAuthority(e) {
    return e && typeof e == "object" && typeof e.makeConnection == "function" && (e.connectionToken === void 0 || typeof e.connectionToken == "string");
  }
  constructor(e, i) {
    this.makeConnection = e, this.connectionToken = i, typeof i < "u" && jT(i);
  }
}
class Lr extends Error {
  static NotAvailable(e, i) {
    return new Lr(e, Cs.NotAvailable, i);
  }
  static TemporarilyNotAvailable(e) {
    return new Lr(e, Cs.TemporarilyNotAvailable);
  }
  constructor(e, i = Cs.Unknown, n) {
    super(e), this._message = e, this._code = i, this._detail = n, Object.setPrototypeOf(this, Lr.prototype);
  }
}
var fr;
(function(t) {
  t[t.LF = 1] = "LF", t[t.CRLF = 2] = "CRLF";
})(fr || (fr = {}));
var hc;
(function(t) {
  t[t.Replace = 1] = "Replace", t[t.Append = 2] = "Append", t[t.Prepend = 3] = "Prepend";
})(hc || (hc = {}));
let Co = qo = class {
  static isTextEdit(e) {
    return e instanceof qo ? !0 : e ? Oe.isRange(e) && typeof e.newText == "string" : !1;
  }
  static replace(e, i) {
    return new qo(e, i);
  }
  static insert(e, i) {
    return qo.replace(new Oe(e, e), i);
  }
  static delete(e) {
    return qo.replace(e, "");
  }
  static setEndOfLine(e) {
    const i = new qo(new Oe(new je(0, 0), new je(0, 0)), "");
    return i.newEol = e, i;
  }
  get range() {
    return this._range;
  }
  set range(e) {
    if (e && !Oe.isRange(e))
      throw ze("range");
    this._range = e;
  }
  get newText() {
    return this._newText || "";
  }
  set newText(e) {
    if (e && typeof e != "string")
      throw ze("newText");
    this._newText = e;
  }
  get newEol() {
    return this._newEol;
  }
  set newEol(e) {
    if (e && typeof e != "number")
      throw ze("newEol");
    this._newEol = e;
  }
  constructor(e, i) {
    this._range = e, this._newText = i;
  }
  toJSON() {
    return {
      range: this.range,
      newText: this.newText,
      newEol: this._newEol
    };
  }
};
Co = qo = W([
  _e
], Co);
let xg = Ks = class {
  static isNotebookCellEdit(e) {
    return e instanceof Ks ? !0 : e ? Wr.isNotebookRange(e) && Array.isArray(e.newCells) : !1;
  }
  static replaceCells(e, i) {
    return new Ks(e, i);
  }
  static insertCells(e, i) {
    return new Ks(new Wr(e, e), i);
  }
  static deleteCells(e) {
    return new Ks(e, []);
  }
  static updateCellMetadata(e, i) {
    const n = new Ks(new Wr(e, e), []);
    return n.newCellMetadata = i, n;
  }
  static updateNotebookMetadata(e) {
    const i = new Ks(new Wr(0, 0), []);
    return i.newNotebookMetadata = e, i;
  }
  constructor(e, i) {
    this.range = e, this.newCells = i;
  }
};
xg = Ks = W([
  _e
], xg);
class Ta {
  static isSnippetTextEdit(e) {
    return e instanceof Ta ? !0 : e ? Oe.isRange(e.range) && il.isSnippetString(e.snippet) : !1;
  }
  static replace(e, i) {
    return new Ta(e, i);
  }
  static insert(e, i) {
    return Ta.replace(new Oe(e, e), i);
  }
  constructor(e, i) {
    this.range = e, this.snippet = i;
  }
}
var Wt;
(function(t) {
  t[t.File = 1] = "File", t[t.Text = 2] = "Text", t[t.Cell = 3] = "Cell", t[t.CellReplace = 5] = "CellReplace", t[t.Snippet = 6] = "Snippet";
})(Wt || (Wt = {}));
let tl = class {
  constructor() {
    this._edits = [];
  }
  _allEntries() {
    return this._edits;
  }
  renameFile(e, i, n, r) {
    this._edits.push({ _type: Wt.File, from: e, to: i, options: n, metadata: r });
  }
  createFile(e, i, n) {
    this._edits.push({ _type: Wt.File, from: void 0, to: e, options: i, metadata: n });
  }
  deleteFile(e, i, n) {
    this._edits.push({ _type: Wt.File, from: e, to: void 0, options: i, metadata: n });
  }
  replaceNotebookMetadata(e, i, n) {
    this._edits.push({ _type: Wt.Cell, metadata: n, uri: e, edit: { editType: bo.DocumentMetadata, metadata: i } });
  }
  replaceNotebookCells(e, i, n, r) {
    const s = i.start, o = i.end;
    (s !== o || n.length > 0) && this._edits.push({ _type: Wt.CellReplace, uri: e, index: s, count: o - s, cells: n, metadata: r });
  }
  replaceNotebookCellMetadata(e, i, n, r) {
    this._edits.push({ _type: Wt.Cell, metadata: r, uri: e, edit: { editType: bo.Metadata, index: i, metadata: n } });
  }
  replace(e, i, n, r) {
    this._edits.push({ _type: Wt.Text, uri: e, edit: new Co(i, n), metadata: r });
  }
  insert(e, i, n, r) {
    this.replace(e, new Oe(i, i), n, r);
  }
  delete(e, i, n) {
    this.replace(e, i, "", n);
  }
  has(e) {
    return this._edits.some((i) => i._type === Wt.Text && i.uri.toString() === e.toString());
  }
  set(e, i) {
    if (i)
      for (const n of i) {
        if (!n)
          continue;
        let r, s;
        Array.isArray(n) ? (r = n[0], s = n[1]) : r = n, xg.isNotebookCellEdit(r) ? r.newCellMetadata ? this.replaceNotebookCellMetadata(e, r.range.start, r.newCellMetadata, s) : r.newNotebookMetadata ? this.replaceNotebookMetadata(e, r.newNotebookMetadata, s) : this.replaceNotebookCells(e, r.range, r.newCells, s) : Ta.isSnippetTextEdit(r) ? this._edits.push({ _type: Wt.Snippet, uri: e, range: r.range, edit: r.snippet, metadata: s, keepWhitespace: r.keepWhitespace }) : this._edits.push({ _type: Wt.Text, uri: e, edit: r, metadata: s });
      }
    else {
      for (let n = 0; n < this._edits.length; n++) {
        const r = this._edits[n];
        switch (r._type) {
          case Wt.Text:
          case Wt.Snippet:
          case Wt.Cell:
          case Wt.CellReplace:
            r.uri.toString() === e.toString() && (this._edits[n] = void 0);
            break;
        }
      }
      G5(this._edits);
    }
  }
  get(e) {
    const i = [];
    for (const n of this._edits)
      n._type === Wt.Text && n.uri.toString() === e.toString() && i.push(n.edit);
    return i;
  }
  entries() {
    const e = new fi();
    for (const i of this._edits)
      if (i._type === Wt.Text) {
        let n = e.get(i.uri);
        n || (n = [i.uri, []], e.set(i.uri, n)), n[1].push(i.edit);
      }
    return [...e.values()];
  }
  get size() {
    return this.entries().length;
  }
  toJSON() {
    return this.entries();
  }
};
tl = W([
  _e
], tl);
let il = jo = class {
  static isSnippetString(e) {
    return e instanceof jo ? !0 : e ? typeof e.value == "string" : !1;
  }
  static _escape(e) {
    return e.replace(/\$|}|\\/g, "\\$&");
  }
  constructor(e) {
    this._tabstop = 1, this.value = e || "";
  }
  appendText(e) {
    return this.value += jo._escape(e), this;
  }
  appendTabstop(e = this._tabstop++) {
    return this.value += "$", this.value += e, this;
  }
  appendPlaceholder(e, i = this._tabstop++) {
    if (typeof e == "function") {
      const n = new jo();
      n._tabstop = this._tabstop, e(n), this._tabstop = n._tabstop, e = n.value;
    } else
      e = jo._escape(e);
    return this.value += "${", this.value += i, this.value += ":", this.value += e, this.value += "}", this;
  }
  appendChoice(e, i = this._tabstop++) {
    const n = e.map((r) => r.replaceAll(/[|\\,]/g, "\\$&")).join(",");
    return this.value += "${", this.value += i, this.value += "|", this.value += n, this.value += "|}", this;
  }
  appendVariable(e, i) {
    if (typeof i == "function") {
      const n = new jo();
      n._tabstop = this._tabstop, i(n), this._tabstop = n._tabstop, i = n.value;
    } else typeof i == "string" && (i = i.replace(/\$|}/g, "\\$&"));
    return this.value += "${", this.value += e, i && (this.value += ":", this.value += i), this.value += "}", this;
  }
};
il = jo = W([
  _e
], il);
var fa;
(function(t) {
  t[t.Unnecessary = 1] = "Unnecessary", t[t.Deprecated = 2] = "Deprecated";
})(fa || (fa = {}));
var Ci;
(function(t) {
  t[t.Hint = 3] = "Hint", t[t.Information = 2] = "Information", t[t.Warning = 1] = "Warning", t[t.Error = 0] = "Error";
})(Ci || (Ci = {}));
let Ln = hw = class {
  static isLocation(e) {
    return e instanceof hw ? !0 : e ? Oe.isRange(e.range) && x.isUri(e.uri) : !1;
  }
  constructor(e, i) {
    if (this.uri = e, i) if (Oe.isRange(i))
      this.range = Oe.of(i);
    else if (je.isPosition(i))
      this.range = new Oe(i, i);
    else
      throw new Error("Illegal argument");
  }
  toJSON() {
    return {
      uri: this.uri,
      range: this.range
    };
  }
};
Ln = hw = W([
  _e
], Ln);
let ih = class {
  static is(e) {
    return e ? typeof e.message == "string" && e.location && Oe.isRange(e.location.range) && x.isUri(e.location.uri) : !1;
  }
  constructor(e, i) {
    this.location = e, this.message = i;
  }
  static isEqual(e, i) {
    return e === i ? !0 : !e || !i ? !1 : e.message === i.message && e.location.range.isEqual(i.location.range) && e.location.uri.toString() === i.location.uri.toString();
  }
};
ih = W([
  _e
], ih);
let Eg = class {
  constructor(e, i, n = Ci.Error) {
    if (!Oe.isRange(e))
      throw new TypeError("range must be set");
    if (!i)
      throw new TypeError("message must be set");
    this.range = e, this.message = i, this.severity = n;
  }
  toJSON() {
    return {
      severity: Ci[this.severity],
      message: this.message,
      range: this.range,
      source: this.source,
      code: this.code
    };
  }
  static isEqual(e, i) {
    return e === i ? !0 : !e || !i ? !1 : e.message === i.message && e.severity === i.severity && e.code === i.code && e.severity === i.severity && e.source === i.source && e.range.isEqual(i.range) && An(e.tags, i.tags) && An(e.relatedInformation, i.relatedInformation, ih.isEqual);
  }
};
Eg = W([
  _e
], Eg);
let Sg = class {
  constructor(e, i) {
    if (!e)
      throw new Error("Illegal argument, contents must be defined");
    Array.isArray(e) ? this.contents = e : this.contents = [e], this.range = i;
  }
};
Sg = W([
  _e
], Sg);
let Dg = class extends Sg {
  constructor(e, i, n, r) {
    super(e, i), this.canIncreaseVerbosity = n, this.canDecreaseVerbosity = r;
  }
};
Dg = W([
  _e
], Dg);
var vw;
(function(t) {
  t[t.Increase = 0] = "Increase", t[t.Decrease = 1] = "Decrease";
})(vw || (vw = {}));
var nh;
(function(t) {
  t[t.Text = 0] = "Text", t[t.Read = 1] = "Read", t[t.Write = 2] = "Write";
})(nh || (nh = {}));
let kg = class {
  constructor(e, i = nh.Text) {
    this.range = e, this.kind = i;
  }
  toJSON() {
    return {
      range: this.range,
      kind: nh[this.kind]
    };
  }
};
kg = W([
  _e
], kg);
let Ig = class {
  constructor(e, i) {
    this.uri = e, this.highlights = i;
  }
  toJSON() {
    return {
      uri: this.uri,
      highlights: this.highlights.map((e) => e.toJSON())
    };
  }
};
Ig = W([
  _e
], Ig);
var bt;
(function(t) {
  t[t.File = 0] = "File", t[t.Module = 1] = "Module", t[t.Namespace = 2] = "Namespace", t[t.Package = 3] = "Package", t[t.Class = 4] = "Class", t[t.Method = 5] = "Method", t[t.Property = 6] = "Property", t[t.Field = 7] = "Field", t[t.Constructor = 8] = "Constructor", t[t.Enum = 9] = "Enum", t[t.Interface = 10] = "Interface", t[t.Function = 11] = "Function", t[t.Variable = 12] = "Variable", t[t.Constant = 13] = "Constant", t[t.String = 14] = "String", t[t.Number = 15] = "Number", t[t.Boolean = 16] = "Boolean", t[t.Array = 17] = "Array", t[t.Object = 18] = "Object", t[t.Key = 19] = "Key", t[t.Null = 20] = "Null", t[t.EnumMember = 21] = "EnumMember", t[t.Struct = 22] = "Struct", t[t.Event = 23] = "Event", t[t.Operator = 24] = "Operator", t[t.TypeParameter = 25] = "TypeParameter";
})(bt || (bt = {}));
var rh;
(function(t) {
  t[t.Deprecated = 1] = "Deprecated";
})(rh || (rh = {}));
let sh = fw = class {
  static validate(e) {
    if (!e.name)
      throw new Error("name must not be falsy");
  }
  constructor(e, i, n, r, s) {
    this.name = e, this.kind = i, this.containerName = s, typeof n == "string" && (this.containerName = n), r instanceof Ln ? this.location = r : n instanceof Oe && (this.location = new Ln(r, n)), fw.validate(this);
  }
  toJSON() {
    return {
      name: this.name,
      kind: bt[this.kind],
      location: this.location,
      containerName: this.containerName
    };
  }
};
sh = fw = W([
  _e
], sh);
let oh = hp = class {
  static validate(e) {
    if (!e.name)
      throw new Error("name must not be falsy");
    if (!e.range.contains(e.selectionRange))
      throw new Error("selectionRange must be contained in fullRange");
    e.children?.forEach(hp.validate);
  }
  constructor(e, i, n, r, s) {
    this.name = e, this.detail = i, this.kind = n, this.range = r, this.selectionRange = s, this.children = [], hp.validate(this);
  }
};
oh = hp = W([
  _e
], oh);
var ah;
(function(t) {
  t[t.Invoke = 1] = "Invoke", t[t.Automatic = 2] = "Automatic";
})(ah || (ah = {}));
let lh = class {
  constructor(e, i) {
    this.title = e, this.kind = i;
  }
};
lh = W([
  _e
], lh);
var za;
let At = (za = class {
  constructor(e) {
    this.value = e;
  }
  append(e) {
    return new Ju(this.value ? this.value + Ju.sep + e : e);
  }
  intersects(e) {
    return this.contains(e) || e.contains(this);
  }
  contains(e) {
    return this.value === e.value || e.value.startsWith(this.value + Ju.sep);
  }
}, Ju = za, za.sep = ".", za);
At = Ju = W([
  _e
], At);
At.Empty = new At("");
At.QuickFix = At.Empty.append("quickfix");
At.Refactor = At.Empty.append("refactor");
At.RefactorExtract = At.Refactor.append("extract");
At.RefactorInline = At.Refactor.append("inline");
At.RefactorMove = At.Refactor.append("move");
At.RefactorRewrite = At.Refactor.append("rewrite");
At.Source = At.Empty.append("source");
At.SourceOrganizeImports = At.Source.append("organizeImports");
At.SourceFixAll = At.Source.append("fixAll");
At.Notebook = At.Empty.append("notebook");
let ch = class {
  constructor(e, i) {
    if (this.range = e, this.parent = i, i && !i.range.contains(this.range))
      throw new Error("Invalid argument: parent must contain this range");
  }
};
ch = W([
  _e
], ch);
let Jx = class {
  constructor(e, i, n, r, s, o) {
    this.kind = e, this.name = i, this.detail = n, this.uri = r, this.range = s, this.selectionRange = o;
  }
}, GT = class {
  constructor(e, i) {
    this.fromRanges = i, this.from = e;
  }
}, QT = class {
  constructor(e, i) {
    this.fromRanges = i, this.to = e;
  }
};
var fc;
(function(t) {
  t[t.Information = 0] = "Information", t[t.Warning = 1] = "Warning", t[t.Error = 2] = "Error";
})(fc || (fc = {}));
let Cg = class {
  constructor(e, i) {
    this.range = e, this.command = i;
  }
  get isResolved() {
    return !!this.command;
  }
};
Cg = W([
  _e
], Cg);
let bn = pw = class {
  #e;
  static isMarkdownString(e) {
    return e instanceof pw ? !0 : e && e.appendCodeblock && e.appendMarkdown && e.appendText && e.value !== void 0;
  }
  constructor(e, i = !1) {
    this.#e = new Gd(e, { supportThemeIcons: i });
  }
  get value() {
    return this.#e.value;
  }
  set value(e) {
    this.#e.value = e;
  }
  get isTrusted() {
    return this.#e.isTrusted;
  }
  set isTrusted(e) {
    this.#e.isTrusted = e;
  }
  get supportThemeIcons() {
    return this.#e.supportThemeIcons;
  }
  set supportThemeIcons(e) {
    this.#e.supportThemeIcons = e;
  }
  get supportHtml() {
    return this.#e.supportHtml;
  }
  set supportHtml(e) {
    this.#e.supportHtml = e;
  }
  get baseUri() {
    return this.#e.baseUri;
  }
  set baseUri(e) {
    this.#e.baseUri = e;
  }
  appendText(e) {
    return this.#e.appendText(e), this;
  }
  appendMarkdown(e) {
    return this.#e.appendMarkdown(e), this;
  }
  appendCodeblock(e, i) {
    return this.#e.appendCodeblock(i ?? "", e), this;
  }
};
bn = pw = W([
  _e
], bn);
let ww = class {
  constructor(e, i) {
    this.label = e, this.documentation = i;
  }
};
ww = W([
  _e
], ww);
let bw = class {
  constructor(e, i) {
    this.label = e, this.documentation = i, this.parameters = [];
  }
};
bw = W([
  _e
], bw);
let yw = class {
  constructor() {
    this.activeSignature = 0, this.activeParameter = 0, this.signatures = [];
  }
};
yw = W([
  _e
], yw);
var xw;
(function(t) {
  t[t.Invoke = 1] = "Invoke", t[t.TriggerCharacter = 2] = "TriggerCharacter", t[t.ContentChange = 3] = "ContentChange";
})(xw || (xw = {}));
var Ew;
(function(t) {
  t[t.Type = 1] = "Type", t[t.Parameter = 2] = "Parameter";
})(Ew || (Ew = {}));
let Tg = class {
  constructor(e) {
    this.value = e;
  }
};
Tg = W([
  _e
], Tg);
let Pg = class {
  constructor(e, i, n) {
    this.position = e, this.label = i, this.kind = n;
  }
};
Pg = W([
  _e
], Pg);
var pc;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.TriggerCharacter = 1] = "TriggerCharacter", t[t.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
})(pc || (pc = {}));
var Ce;
(function(t) {
  t[t.Text = 0] = "Text", t[t.Method = 1] = "Method", t[t.Function = 2] = "Function", t[t.Constructor = 3] = "Constructor", t[t.Field = 4] = "Field", t[t.Variable = 5] = "Variable", t[t.Class = 6] = "Class", t[t.Interface = 7] = "Interface", t[t.Module = 8] = "Module", t[t.Property = 9] = "Property", t[t.Unit = 10] = "Unit", t[t.Value = 11] = "Value", t[t.Enum = 12] = "Enum", t[t.Keyword = 13] = "Keyword", t[t.Snippet = 14] = "Snippet", t[t.Color = 15] = "Color", t[t.File = 16] = "File", t[t.Reference = 17] = "Reference", t[t.Folder = 18] = "Folder", t[t.EnumMember = 19] = "EnumMember", t[t.Constant = 20] = "Constant", t[t.Struct = 21] = "Struct", t[t.Event = 22] = "Event", t[t.Operator = 23] = "Operator", t[t.TypeParameter = 24] = "TypeParameter", t[t.User = 25] = "User", t[t.Issue = 26] = "Issue";
})(Ce || (Ce = {}));
var uh;
(function(t) {
  t[t.Deprecated = 1] = "Deprecated";
})(uh || (uh = {}));
let Ag = class {
  constructor(e, i) {
    this.label = e, this.kind = i;
  }
  toJSON() {
    return {
      label: this.label,
      kind: this.kind && Ce[this.kind],
      detail: this.detail,
      documentation: this.documentation,
      sortText: this.sortText,
      filterText: this.filterText,
      preselect: this.preselect,
      insertText: this.insertText,
      textEdit: this.textEdit
    };
  }
};
Ag = W([
  _e
], Ag);
let Gc = class {
  constructor(e = [], i = !1) {
    this.items = e, this.isIncomplete = i;
  }
};
Gc = W([
  _e
], Gc);
let Sw = class {
  constructor(e, i, n) {
    this.insertText = e, this.range = i, this.command = n;
  }
};
Sw = W([
  _e
], Sw);
let Dw = class {
  constructor(e) {
    this.commands = void 0, this.suppressSuggestions = void 0, this.items = e;
  }
};
Dw = W([
  _e
], Dw);
var pa;
(function(t) {
  t[t.Unknown = 0] = "Unknown", t[t.Word = 1] = "Word", t[t.Line = 2] = "Line", t[t.Suggest = 3] = "Suggest";
})(pa || (pa = {}));
var gc;
(function(t) {
  t[t.Accepted = 0] = "Accepted", t[t.Rejected = 1] = "Rejected", t[t.Ignored = 2] = "Ignored";
})(gc || (gc = {}));
var dh;
(function(t) {
  t[t.Active = -1] = "Active", t[t.Beside = -2] = "Beside", t[t.One = 1] = "One", t[t.Two = 2] = "Two", t[t.Three = 3] = "Three", t[t.Four = 4] = "Four", t[t.Five = 5] = "Five", t[t.Six = 6] = "Six", t[t.Seven = 7] = "Seven", t[t.Eight = 8] = "Eight", t[t.Nine = 9] = "Nine";
})(dh || (dh = {}));
var fo;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Right = 2] = "Right";
})(fo || (fo = {}));
function G9(t, e) {
  return `${ht.toKey(t)}.${e}`;
}
var rr;
(function(t) {
  t[t.Off = 0] = "Off", t[t.On = 1] = "On", t[t.Relative = 2] = "Relative", t[t.Interval = 3] = "Interval";
})(rr || (rr = {}));
var mc;
(function(t) {
  t[t.Manual = 1] = "Manual", t[t.AfterDelay = 2] = "AfterDelay", t[t.FocusOut = 3] = "FocusOut";
})(mc || (mc = {}));
var Rg;
(function(t) {
  t[t.Default = 0] = "Default", t[t.InCenter = 1] = "InCenter", t[t.InCenterIfOutsideViewport = 2] = "InCenterIfOutsideViewport", t[t.AtTop = 3] = "AtTop";
})(Rg || (Rg = {}));
var Qc;
(function(t) {
  t[t.Keyboard = 1] = "Keyboard", t[t.Mouse = 2] = "Mouse", t[t.Command = 3] = "Command";
})(Qc || (Qc = {}));
var _c;
(function(t) {
  t[t.Addition = 1] = "Addition", t[t.Deletion = 2] = "Deletion", t[t.Modification = 3] = "Modification";
})(_c || (_c = {}));
var hh;
(function(t) {
  t[t.Undo = 1] = "Undo", t[t.Redo = 2] = "Redo";
})(hh || (hh = {}));
var ga;
(function(t) {
  t[t.OpenOpen = 0] = "OpenOpen", t[t.ClosedClosed = 1] = "ClosedClosed", t[t.OpenClosed = 2] = "OpenClosed", t[t.ClosedOpen = 3] = "ClosedOpen";
})(ga || (ga = {}));
(function(t) {
  function e(i) {
    switch (i) {
      case "keyboard":
        return t.Keyboard;
      case "mouse":
        return t.Mouse;
      case vd.PROGRAMMATIC:
      case vd.JUMP:
      case vd.NAVIGATION:
        return t.Command;
    }
  }
  t.fromValue = e;
})(Qc || (Qc = {}));
var Kc;
(function(t) {
  t[t.Other = 0] = "Other", t[t.Comment = 1] = "Comment", t[t.String = 2] = "String", t[t.RegEx = 3] = "RegEx";
})(Kc || (Kc = {}));
(function(t) {
  function e(i) {
    switch (i) {
      case t.Other:
        return "other";
      case t.Comment:
        return "comment";
      case t.String:
        return "string";
      case t.RegEx:
        return "regex";
    }
    return "other";
  }
  t.toString = e;
})(Kc || (Kc = {}));
let Lg = class {
  constructor(e, i) {
    if (i && !x.isUri(i))
      throw ze("target");
    if (!Oe.isRange(e) || e.isEmpty)
      throw ze("range");
    this.range = e, this.target = i;
  }
};
Lg = W([
  _e
], Lg);
let Jc = class {
  constructor(e, i, n, r) {
    this.red = e, this.green = i, this.blue = n, this.alpha = r;
  }
};
Jc = W([
  _e
], Jc);
let Ng = class {
  constructor(e, i) {
    if (i && !(i instanceof Jc))
      throw ze("color");
    if (!Oe.isRange(e) || e.isEmpty)
      throw ze("range");
    this.range = e, this.color = i;
  }
};
Ng = W([
  _e
], Ng);
let Mg = class {
  constructor(e) {
    if (!e || typeof e != "string")
      throw ze("label");
    this.label = e;
  }
};
Mg = W([
  _e
], Mg);
var XD;
(function(t) {
  t[t.RGB = 0] = "RGB", t[t.HEX = 1] = "HEX", t[t.HSL = 2] = "HSL";
})(XD || (XD = {}));
var kw;
(function(t) {
  t[t.Error = 0] = "Error", t[t.Warning = 1] = "Warning", t[t.Information = 2] = "Information";
})(kw || (kw = {}));
var Iw;
(function(t) {
  t[t.Unknown = 0] = "Unknown", t[t.Shutdown = 1] = "Shutdown", t[t.Process = 2] = "Process", t[t.User = 3] = "User", t[t.Extension = 4] = "Extension";
})(Iw || (Iw = {}));
var fh;
(function(t) {
  t[t.Low = 0] = "Low", t[t.Medium = 1] = "Medium", t[t.High = 2] = "High";
})(fh || (fh = {}));
var Cw;
(function(t) {
  t[t.Sh = 1] = "Sh", t[t.Bash = 2] = "Bash", t[t.Fish = 3] = "Fish", t[t.Csh = 4] = "Csh", t[t.Ksh = 5] = "Ksh", t[t.Zsh = 6] = "Zsh", t[t.CommandPrompt = 7] = "CommandPrompt", t[t.GitBash = 8] = "GitBash", t[t.PowerShell = 9] = "PowerShell", t[t.Python = 10] = "Python", t[t.Julia = 11] = "Julia", t[t.NuShell = 12] = "NuShell", t[t.Node = 13] = "Node";
})(Cw || (Cw = {}));
class Q9 {
  constructor(e, i, n) {
    if (this.startIndex = e, this.length = i, this.tooltip = n, typeof e != "number" || e < 0)
      throw ze("startIndex");
    if (typeof i != "number" || i < 1)
      throw ze("length");
    if (n !== void 0 && typeof n != "string")
      throw ze("tooltip");
  }
}
class K9 {
  constructor(e) {
    this.uri = e;
  }
}
class J9 {
  constructor(e) {
    this.terminalCommand = e;
  }
}
var Tw;
(function(t) {
  t[t.Panel = 1] = "Panel", t[t.Editor = 2] = "Editor";
})(Tw || (Tw = {}));
class Y9 {
  constructor(e) {
    if (this.options = e, typeof e != "object")
      throw ze("options");
  }
}
var Pw;
(function(t) {
  t[t.File = 0] = "File", t[t.Folder = 1] = "Folder", t[t.Method = 2] = "Method", t[t.Alias = 3] = "Alias", t[t.Argument = 4] = "Argument", t[t.Option = 5] = "Option", t[t.OptionValue = 6] = "OptionValue", t[t.Flag = 7] = "Flag", t[t.SymbolicLinkFile = 8] = "SymbolicLinkFile", t[t.SymbolicLinkFolder = 9] = "SymbolicLinkFolder";
})(Pw || (Pw = {}));
class X9 {
  constructor(e, i, n, r, s, o, a, l, c) {
    this.label = e, this.icon = i, this.detail = n, this.documentation = r, this.isFile = s, this.isDirectory = o, this.isKeyword = a, this.replacementIndex = l ?? 0, this.replacementLength = c ?? 0;
  }
}
let Z9 = class {
  constructor(e, i) {
    this.items = e ?? [], this.resourceRequestConfig = i;
  }
};
var Aw;
(function(t) {
  t[t.Always = 1] = "Always", t[t.Silent = 2] = "Silent", t[t.Never = 3] = "Never";
})(Aw || (Aw = {}));
var Rw;
(function(t) {
  t.Changed = "changed", t.ProcessStarted = "processStarted", t.ProcessEnded = "processEnded", t.Terminated = "terminated", t.Start = "start", t.AcquiredInput = "acquiredInput", t.DependsOnStarted = "dependsOnStarted", t.Active = "active", t.Inactive = "inactive", t.End = "end", t.ProblemMatcherStarted = "problemMatcherStarted", t.ProblemMatcherEnded = "problemMatcherEnded", t.ProblemMatcherFoundErrors = "problemMatcherFoundErrors";
})(Rw || (Rw = {}));
var Lw;
(function(t) {
  t[t.Shared = 1] = "Shared", t[t.Dedicated = 2] = "Dedicated", t[t.New = 3] = "New";
})(Lw || (Lw = {}));
var Mr;
let ph = (Mr = class {
  static from(e) {
    switch (e) {
      case "clean":
        return Er.Clean;
      case "build":
        return Er.Build;
      case "rebuild":
        return Er.Rebuild;
      case "test":
        return Er.Test;
      default:
        return;
    }
  }
  constructor(e, i) {
    if (this.label = i, typeof e != "string" || typeof i != "string")
      throw ze("name");
    this._id = e;
  }
  get id() {
    return this._id;
  }
}, Er = Mr, Mr.Clean = new Er("clean", "Clean"), Mr.Build = new Er("build", "Build"), Mr.Rebuild = new Er("rebuild", "Rebuild"), Mr.Test = new Er("test", "Test"), Mr);
ph = Er = W([
  _e
], ph);
function KT(t) {
  let e = "";
  for (let i = 0; i < t.length; i++)
    e += t[i].replace(/,/g, ",,") + ",";
  return e;
}
let Yc = class {
  constructor(e, i, n) {
    if (typeof e != "string")
      throw ze("process");
    this._args = [], this._process = e, i !== void 0 && (Array.isArray(i) ? (this._args = i, this._options = n) : this._options = i);
  }
  get process() {
    return this._process;
  }
  set process(e) {
    if (typeof e != "string")
      throw ze("process");
    this._process = e;
  }
  get args() {
    return this._args;
  }
  set args(e) {
    Array.isArray(e) || (e = []), this._args = e;
  }
  get options() {
    return this._options;
  }
  set options(e) {
    this._options = e;
  }
  computeId() {
    const e = [];
    if (e.push("process"), this._process !== void 0 && e.push(this._process), this._args && this._args.length > 0)
      for (const i of this._args)
        e.push(i);
    return KT(e);
  }
};
Yc = W([
  _e
], Yc);
let nl = class {
  constructor(e, i, n) {
    if (this._args = [], Array.isArray(i)) {
      if (!e)
        throw ze("command can't be undefined or null");
      if (typeof e != "string" && typeof e.value != "string")
        throw ze("command");
      this._command = e, i && (this._args = i), this._options = n;
    } else {
      if (typeof e != "string")
        throw ze("commandLine");
      this._commandLine = e, this._options = i;
    }
  }
  get commandLine() {
    return this._commandLine;
  }
  set commandLine(e) {
    if (typeof e != "string")
      throw ze("commandLine");
    this._commandLine = e;
  }
  get command() {
    return this._command ? this._command : "";
  }
  set command(e) {
    if (typeof e != "string" && typeof e.value != "string")
      throw ze("command");
    this._command = e;
  }
  get args() {
    return this._args;
  }
  set args(e) {
    this._args = e || [];
  }
  get options() {
    return this._options;
  }
  set options(e) {
    this._options = e;
  }
  computeId() {
    const e = [];
    if (e.push("shell"), this._commandLine !== void 0 && e.push(this._commandLine), this._command !== void 0 && e.push(typeof this._command == "string" ? this._command : this._command.value), this._args && this._args.length > 0)
      for (const i of this._args)
        e.push(typeof i == "string" ? i : i.value);
    return KT(e);
  }
};
nl = W([
  _e
], nl);
var Nw;
(function(t) {
  t[t.Escape = 1] = "Escape", t[t.Strong = 2] = "Strong", t[t.Weak = 3] = "Weak";
})(Nw || (Nw = {}));
var To;
(function(t) {
  t[t.Global = 1] = "Global", t[t.Workspace = 2] = "Workspace";
})(To || (To = {}));
class Yx {
  constructor(e) {
    this._callback = e;
  }
  computeId() {
    return "customExecution" + on();
  }
  set callback(e) {
    this._callback = e;
  }
  get callback() {
    return this._callback;
  }
}
var Or;
let Og = (Or = class {
  constructor(e, i, n, r, s, o) {
    this.__deprecated = !1, this._definition = this.definition = e;
    let a;
    typeof i == "string" ? (this._name = this.name = i, this._source = this.source = n, this.execution = r, a = s, this.__deprecated = !0) : i === To.Global || i === To.Workspace ? (this.target = i, this._name = this.name = n, this._source = this.source = r, this.execution = s, a = o) : (this.target = i, this._name = this.name = n, this._source = this.source = r, this.execution = s, a = o), typeof a == "string" ? (this._problemMatchers = [a], this._hasDefinedMatchers = !0) : Array.isArray(a) ? (this._problemMatchers = a, this._hasDefinedMatchers = !0) : (this._problemMatchers = [], this._hasDefinedMatchers = !1), this._isBackground = !1, this._presentationOptions = /* @__PURE__ */ Object.create(null), this._runOptions = /* @__PURE__ */ Object.create(null);
  }
  get _id() {
    return this.__id;
  }
  set _id(e) {
    this.__id = e;
  }
  get _deprecated() {
    return this.__deprecated;
  }
  clear() {
    this.__id !== void 0 && (this.__id = void 0, this._scope = void 0, this.computeDefinitionBasedOnExecution());
  }
  computeDefinitionBasedOnExecution() {
    this._execution instanceof Yc ? this._definition = {
      type: Sr.ProcessType,
      id: this._execution.computeId()
    } : this._execution instanceof nl ? this._definition = {
      type: Sr.ShellType,
      id: this._execution.computeId()
    } : this._execution instanceof Yx ? this._definition = {
      type: Sr.ExtensionCallbackType,
      id: this._execution.computeId()
    } : this._definition = {
      type: Sr.EmptyType,
      id: on()
    };
  }
  get definition() {
    return this._definition;
  }
  set definition(e) {
    if (e == null)
      throw ze("Kind can't be undefined or null");
    this.clear(), this._definition = e;
  }
  get scope() {
    return this._scope;
  }
  set target(e) {
    this.clear(), this._scope = e;
  }
  get name() {
    return this._name;
  }
  set name(e) {
    if (typeof e != "string")
      throw ze("name");
    this.clear(), this._name = e;
  }
  get execution() {
    return this._execution;
  }
  set execution(e) {
    e === null && (e = void 0), this.clear(), this._execution = e;
    const i = this._definition.type;
    (Sr.EmptyType === i || Sr.ProcessType === i || Sr.ShellType === i || Sr.ExtensionCallbackType === i) && this.computeDefinitionBasedOnExecution();
  }
  get problemMatchers() {
    return this._problemMatchers;
  }
  set problemMatchers(e) {
    if (Array.isArray(e))
      this.clear(), this._problemMatchers = e, this._hasDefinedMatchers = !0;
    else {
      this.clear(), this._problemMatchers = [], this._hasDefinedMatchers = !1;
      return;
    }
  }
  get hasDefinedMatchers() {
    return this._hasDefinedMatchers;
  }
  get isBackground() {
    return this._isBackground;
  }
  set isBackground(e) {
    e !== !0 && e !== !1 && (e = !1), this.clear(), this._isBackground = e;
  }
  get source() {
    return this._source;
  }
  set source(e) {
    if (typeof e != "string" || e.length === 0)
      throw ze("source must be a string of length > 0");
    this.clear(), this._source = e;
  }
  get group() {
    return this._group;
  }
  set group(e) {
    e === null && (e = void 0), this.clear(), this._group = e;
  }
  get detail() {
    return this._detail;
  }
  set detail(e) {
    e === null && (e = void 0), this._detail = e;
  }
  get presentationOptions() {
    return this._presentationOptions;
  }
  set presentationOptions(e) {
    e == null && (e = /* @__PURE__ */ Object.create(null)), this.clear(), this._presentationOptions = e;
  }
  get runOptions() {
    return this._runOptions;
  }
  set runOptions(e) {
    e == null && (e = /* @__PURE__ */ Object.create(null)), this.clear(), this._runOptions = e;
  }
}, Sr = Or, Or.ExtensionCallbackType = "customExecution", Or.ProcessType = "process", Or.ShellType = "shell", Or.EmptyType = "$empty", Or);
Og = Sr = W([
  _e
], Og);
var xo;
(function(t) {
  t[t.SourceControl = 1] = "SourceControl", t[t.Window = 10] = "Window", t[t.Notification = 15] = "Notification";
})(xo || (xo = {}));
var Mw;
(function(t) {
  function e(i) {
    const n = i;
    return xa(n.value) ? n.tooltip && !it(n.tooltip) ? (console.log("INVALID view badge, invalid tooltip", n.tooltip), !1) : !0 : (console.log("INVALID view badge, invalid value", n.value), !1);
  }
  t.isViewBadge = e;
})(Mw || (Mw = {}));
let Fg = gw = class {
  static isTreeItem(e, i) {
    const n = e;
    if (n.checkboxState !== void 0) {
      const r = xa(n.checkboxState) ? n.checkboxState : ri(n.checkboxState) && xa(n.checkboxState.state) ? n.checkboxState.state : void 0, s = !xa(n.checkboxState) && ri(n.checkboxState) ? n.checkboxState.tooltip : void 0;
      if (r === void 0 || r !== Nr.Checked && r !== Nr.Unchecked || s !== void 0 && !it(s))
        return console.log("INVALID tree item, invalid checkboxState", n.checkboxState), !1;
    }
    if (e instanceof gw)
      return !0;
    if (n.label !== void 0 && !it(n.label) && !n.label?.label)
      return console.log("INVALID tree item, invalid label", n.label), !1;
    if (n.id !== void 0 && !it(n.id))
      return console.log("INVALID tree item, invalid id", n.id), !1;
    if (n.iconPath !== void 0 && !it(n.iconPath) && !x.isUri(n.iconPath) && (!n.iconPath || !it(n.iconPath.id))) {
      const r = n.iconPath;
      if (!r || !it(r.light) && !x.isUri(r.light) && !it(r.dark) && !x.isUri(r.dark))
        return console.log("INVALID tree item, invalid iconPath", n.iconPath), !1;
    }
    return n.description !== void 0 && !it(n.description) && typeof n.description != "boolean" ? (console.log("INVALID tree item, invalid description", n.description), !1) : n.resourceUri !== void 0 && !x.isUri(n.resourceUri) ? (console.log("INVALID tree item, invalid resourceUri", n.resourceUri), !1) : n.tooltip !== void 0 && !it(n.tooltip) && !(n.tooltip instanceof bn) ? (console.log("INVALID tree item, invalid tooltip", n.tooltip), !1) : n.command !== void 0 && !n.command.command ? (console.log("INVALID tree item, invalid command", n.command), !1) : n.collapsibleState !== void 0 && n.collapsibleState < Pa.None && n.collapsibleState > Pa.Expanded ? (console.log("INVALID tree item, invalid collapsibleState", n.collapsibleState), !1) : n.contextValue !== void 0 && !it(n.contextValue) ? (console.log("INVALID tree item, invalid contextValue", n.contextValue), !1) : n.accessibilityInformation !== void 0 && !n.accessibilityInformation?.label ? (console.log("INVALID tree item, invalid accessibilityInformation", n.accessibilityInformation), !1) : !0;
  }
  constructor(e, i = Pa.None) {
    this.collapsibleState = i, x.isUri(e) ? this.resourceUri = e : this.label = e;
  }
};
Fg = gw = W([
  _e
], Fg);
var Pa;
(function(t) {
  t[t.None = 0] = "None", t[t.Collapsed = 1] = "Collapsed", t[t.Expanded = 2] = "Expanded";
})(Pa || (Pa = {}));
var Nr;
(function(t) {
  t[t.Unchecked = 0] = "Unchecked", t[t.Checked = 1] = "Checked";
})(Nr || (Nr = {}));
let Ug = class {
  async asString() {
    return typeof this.value == "string" ? this.value : JSON.stringify(this.value);
  }
  asFile() {
  }
  constructor(e) {
    this.value = e;
  }
};
Ug = W([
  _e
], Ug);
class $g extends Ug {
}
class e6 extends $g {
  #e;
  constructor(e) {
    super(""), this.#e = e;
  }
  asFile() {
    return this.#e;
  }
}
class t6 {
  constructor(e, i, n, r) {
    this.name = e, this.uri = i, this._itemId = n, this._getData = r;
  }
  data() {
    return this._getData();
  }
}
let Xc = class {
  #e = /* @__PURE__ */ new Map();
  constructor(e) {
    for (const [i, n] of e ?? []) {
      const r = this.#e.get(this.#t(i));
      r ? r.push(n) : this.#e.set(this.#t(i), [n]);
    }
  }
  get(e) {
    return this.#e.get(this.#t(e))?.[0];
  }
  set(e, i) {
    this.#e.set(this.#t(e), [i]);
  }
  forEach(e, i) {
    for (const [n, r] of this.#e)
      for (const s of r)
        e.call(i, s, n, this);
  }
  *[Symbol.iterator]() {
    for (const [e, i] of this.#e)
      for (const n of i)
        yield [e, n];
  }
  #t(e) {
    return e.toLowerCase();
  }
};
Xc = W([
  _e
], Xc);
let Ow = class {
  constructor(e, i, n) {
    this.insertText = e, this.title = i, this.kind = n;
  }
};
Ow = W([
  _e
], Ow);
var Fw;
(function(t) {
  t[t.Automatic = 0] = "Automatic", t[t.PasteAs = 1] = "PasteAs";
})(Fw || (Fw = {}));
const sc = class sc {
  constructor(e) {
    this.value = e;
  }
  append(...e) {
    return new sc(
      (this.value ? [this.value, ...e] : e).join(sc.sep)
    );
  }
  intersects(e) {
    return this.contains(e) || e.contains(this);
  }
  contains(e) {
    return this.value === e.value || e.value.startsWith(this.value + sc.sep);
  }
};
sc.sep = ".";
let es = sc;
es.Empty = new es("");
es.Text = new es("text");
es.TextUpdateImports = es.Text.append("updateImports");
class i6 {
  constructor(e, i, n) {
    this.title = i, this.insertText = e, this.kind = n;
  }
}
let qi = class {
  constructor(e, i) {
    this.id = e, this.color = i;
  }
  static isThemeIcon(e) {
    return typeof e.id != "string" ? (console.log("INVALID ThemeIcon, invalid id", e.id), !1) : !0;
  }
};
qi = W([
  _e
], qi);
qi.File = new qi("file");
qi.Folder = new qi("folder");
let gh = class {
  constructor(e) {
    this.id = e;
  }
};
gh = W([
  _e
], gh);
var vc;
(function(t) {
  t[t.Global = 1] = "Global", t[t.Workspace = 2] = "Workspace", t[t.WorkspaceFolder = 3] = "WorkspaceFolder";
})(vc || (vc = {}));
let wc = class {
  get base() {
    return this._base;
  }
  set base(e) {
    this._base = e, this._baseUri = x.file(e);
  }
  get baseUri() {
    return this._baseUri;
  }
  set baseUri(e) {
    this._baseUri = e, this._base = e.fsPath;
  }
  constructor(e, i) {
    if (typeof e != "string" && (!e || !x.isUri(e) && !x.isUri(e.uri)))
      throw ze("base");
    if (typeof i != "string")
      throw ze("pattern");
    typeof e == "string" ? this.baseUri = x.file(e) : x.isUri(e) ? this.baseUri = e : this.baseUri = e.uri, this.pattern = i;
  }
  toJSON() {
    return {
      pattern: this.pattern,
      base: this.base,
      baseUri: this.baseUri.toJSON()
    };
  }
};
wc = W([
  _e
], wc);
const JT = /* @__PURE__ */ new WeakMap();
function n6(t, e) {
  JT.set(t, e);
}
let Zc = class {
  constructor(e, i, n, r, s) {
    this.enabled = typeof e == "boolean" ? e : !0, typeof i == "string" && (this.condition = i), typeof n == "string" && (this.hitCondition = n), typeof r == "string" && (this.logMessage = r), typeof s == "string" && (this.mode = s);
  }
  get id() {
    return this._id || (this._id = JT.get(this) ?? on()), this._id;
  }
};
Zc = W([
  _e
], Zc);
let ma = class extends Zc {
  constructor(e, i, n, r, s, o) {
    if (super(i, n, r, s, o), e === null)
      throw ze("location");
    this.location = e;
  }
};
ma = W([
  _e
], ma);
let _a = class extends Zc {
  constructor(e, i, n, r, s, o) {
    super(i, n, r, s, o), this.functionName = e;
  }
};
_a = W([
  _e
], _a);
let Hg = class extends Zc {
  constructor(e, i, n, r, s, o, a, l) {
    if (super(r, s, o, a, l), !i)
      throw ze("dataId");
    this.label = e, this.dataId = i, this.canPersist = n;
  }
};
Hg = W([
  _e
], Hg);
let Bg = class {
  constructor(e, i, n) {
    this.command = e, this.args = i || [], this.options = n;
  }
};
Bg = W([
  _e
], Bg);
let mh = class {
  constructor(e, i) {
    this.port = e, this.host = i;
  }
};
mh = W([
  _e
], mh);
let Wg = class {
  constructor(e) {
    this.path = e;
  }
};
Wg = W([
  _e
], Wg);
let _h = class {
  constructor(e) {
    this.implementation = e;
  }
};
_h = W([
  _e
], _h);
class YT {
  constructor(e, i, n) {
    this.session = e, this.threadId = i, this.frameId = n;
  }
}
class XT {
  constructor(e, i) {
    this.session = e, this.threadId = i;
  }
}
let Vg = class {
  constructor(e, i) {
    this.range = e, this.expression = i;
  }
};
Vg = W([
  _e
], Vg);
var vh;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})(vh || (vh = {}));
var ws;
(function(t) {
  t[t.Other = 0] = "Other", t[t.Empty = 1] = "Empty", t[t.TokenCancellation = 2] = "TokenCancellation", t[t.LostRace = 3] = "LostRace", t[t.NotTaken = 4] = "NotTaken";
})(ws || (ws = {}));
let zg = class {
  constructor(e, i) {
    this.range = e, this.text = i;
  }
};
zg = W([
  _e
], zg);
let qg = class {
  constructor(e, i, n = !0) {
    this.range = e, this.variableName = i, this.caseSensitiveLookup = n;
  }
};
qg = W([
  _e
], qg);
let jg = class {
  constructor(e, i) {
    this.range = e, this.expression = i;
  }
};
jg = W([
  _e
], jg);
let Uw = class {
  constructor(e, i) {
    this.frameId = e, this.stoppedLocation = i;
  }
};
Uw = W([
  _e
], Uw);
var $w;
(function(t) {
  t[t.AIGenerated = 1] = "AIGenerated";
})($w || ($w = {}));
var wh;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})(wh || (wh = {}));
class r6 {
  constructor(e, i) {
    this.newSymbolName = e, this.tags = i;
  }
}
var bc;
(function(t) {
  t[t.Changed = 1] = "Changed", t[t.Created = 2] = "Created", t[t.Deleted = 3] = "Deleted";
})(bc || (bc = {}));
let ui = Ji = class extends Error {
  static FileExists(e) {
    return new Ji(
      e,
      Me.FileExists,
      Ji.FileExists
    );
  }
  static FileNotFound(e) {
    return new Ji(
      e,
      Me.FileNotFound,
      Ji.FileNotFound
    );
  }
  static FileNotADirectory(e) {
    return new Ji(
      e,
      Me.FileNotADirectory,
      Ji.FileNotADirectory
    );
  }
  static FileIsADirectory(e) {
    return new Ji(
      e,
      Me.FileIsADirectory,
      Ji.FileIsADirectory
    );
  }
  static NoPermissions(e) {
    return new Ji(
      e,
      Me.NoPermissions,
      Ji.NoPermissions
    );
  }
  static Unavailable(e) {
    return new Ji(
      e,
      Me.Unavailable,
      Ji.Unavailable
    );
  }
  constructor(e, i = Me.Unknown, n) {
    super(x.isUri(e) ? e.toString(!0) : e), this.code = n?.name ?? "Unknown", G4(this, i), Object.setPrototypeOf(this, Ji.prototype), typeof Error.captureStackTrace == "function" && typeof n == "function" && Error.captureStackTrace(this, n);
  }
};
ui = Ji = W([
  _e
], ui);
let Hw = class {
  constructor(e, i, n) {
    this.start = e, this.end = i, this.kind = n;
  }
};
Hw = W([
  _e
], Hw);
var bs;
(function(t) {
  t[t.Comment = 1] = "Comment", t[t.Imports = 2] = "Imports", t[t.Region = 3] = "Region";
})(bs || (bs = {}));
var bh;
(function(t) {
  t[t.Collapsed = 0] = "Collapsed", t[t.Expanded = 1] = "Expanded";
})(bh || (bh = {}));
var Bw;
(function(t) {
  t[t.Editing = 0] = "Editing", t[t.Preview = 1] = "Preview";
})(Bw || (Bw = {}));
var Ww;
(function(t) {
  t[t.Published = 0] = "Published", t[t.Draft = 1] = "Draft";
})(Ww || (Ww = {}));
var yh;
(function(t) {
  t[t.Unresolved = 0] = "Unresolved", t[t.Resolved = 1] = "Resolved";
})(yh || (yh = {}));
var xh;
(function(t) {
  t[t.Current = 0] = "Current", t[t.Outdated = 1] = "Outdated";
})(xh || (xh = {}));
var Eh;
(function(t) {
  t[t.Reply = 1] = "Reply", t[t.Comment = 2] = "Comment";
})(Eh || (Eh = {}));
class Vw {
  constructor(e, i = []) {
    this.tokenTypes = e, this.tokenModifiers = i;
  }
}
function s6(t) {
  return typeof t > "u" || iA(t);
}
class Xx {
  constructor(e) {
    if (this._prevLine = 0, this._prevChar = 0, this._dataIsSortedAndDeltaEncoded = !0, this._data = [], this._dataLen = 0, this._tokenTypeStrToInt = /* @__PURE__ */ new Map(), this._tokenModifierStrToInt = /* @__PURE__ */ new Map(), this._hasLegend = !1, e) {
      this._hasLegend = !0;
      for (let i = 0, n = e.tokenTypes.length; i < n; i++)
        this._tokenTypeStrToInt.set(e.tokenTypes[i], i);
      for (let i = 0, n = e.tokenModifiers.length; i < n; i++)
        this._tokenModifierStrToInt.set(e.tokenModifiers[i], i);
    }
  }
  push(e, i, n, r, s) {
    if (typeof e == "number" && typeof i == "number" && typeof n == "number" && typeof r == "number" && (typeof s == "number" || typeof s > "u"))
      return typeof s > "u" && (s = 0), this._pushEncoded(e, i, n, r, s);
    if (Oe.isRange(e) && typeof i == "string" && s6(n))
      return this._push(e, i, n);
    throw ze();
  }
  _push(e, i, n) {
    if (!this._hasLegend)
      throw new Error("Legend must be provided in constructor");
    if (e.start.line !== e.end.line)
      throw new Error("`range` cannot span multiple lines");
    if (!this._tokenTypeStrToInt.has(i))
      throw new Error("`tokenType` is not in the provided legend");
    const r = e.start.line, s = e.start.character, o = e.end.character - e.start.character, a = this._tokenTypeStrToInt.get(i);
    let l = 0;
    if (n)
      for (const c of n) {
        if (!this._tokenModifierStrToInt.has(c))
          throw new Error("`tokenModifier` is not in the provided legend");
        const u = this._tokenModifierStrToInt.get(c);
        l |= 1 << u >>> 0;
      }
    this._pushEncoded(r, s, o, a, l);
  }
  _pushEncoded(e, i, n, r, s) {
    if (this._dataIsSortedAndDeltaEncoded && (e < this._prevLine || e === this._prevLine && i < this._prevChar)) {
      this._dataIsSortedAndDeltaEncoded = !1;
      const l = this._data.length / 5 | 0;
      let c = 0, u = 0;
      for (let d = 0; d < l; d++) {
        let f = this._data[5 * d], g = this._data[5 * d + 1];
        f === 0 ? (f = c, g += u) : f += c, this._data[5 * d] = f, this._data[5 * d + 1] = g, c = f, u = g;
      }
    }
    let o = e, a = i;
    this._dataIsSortedAndDeltaEncoded && this._dataLen > 0 && (o -= this._prevLine, o === 0 && (a -= this._prevChar)), this._data[this._dataLen++] = o, this._data[this._dataLen++] = a, this._data[this._dataLen++] = n, this._data[this._dataLen++] = r, this._data[this._dataLen++] = s, this._prevLine = e, this._prevChar = i;
  }
  static _sortAndDeltaEncode(e) {
    const i = [], n = e.length / 5 | 0;
    for (let a = 0; a < n; a++)
      i[a] = a;
    i.sort((a, l) => {
      const c = e[5 * a], u = e[5 * l];
      if (c === u) {
        const d = e[5 * a + 1], f = e[5 * l + 1];
        return d - f;
      }
      return c - u;
    });
    const r = new Uint32Array(e.length);
    let s = 0, o = 0;
    for (let a = 0; a < n; a++) {
      const l = 5 * i[a], c = e[l + 0], u = e[l + 1], d = e[l + 2], f = e[l + 3], g = e[l + 4], _ = c - s, w = _ === 0 ? u - o : u, v = 5 * a;
      r[v + 0] = _, r[v + 1] = w, r[v + 2] = d, r[v + 3] = f, r[v + 4] = g, s = c, o = u;
    }
    return r;
  }
  build(e) {
    return this._dataIsSortedAndDeltaEncoded ? new eu(new Uint32Array(this._data), e) : new eu(Xx._sortAndDeltaEncode(this._data), e);
  }
}
class eu {
  constructor(e, i) {
    this.resultId = i, this.data = e;
  }
}
class ZT {
  constructor(e, i, n) {
    this.start = e, this.deleteCount = i, this.data = n;
  }
}
class pp {
  constructor(e, i) {
    this.resultId = i, this.edits = e;
  }
}
var Gg;
(function(t) {
  t[t.Separate = 0] = "Separate", t[t.MergeWithParent = 1] = "MergeWithParent";
})(Gg || (Gg = {}));
class o6 {
  constructor(e) {
    this.name = e;
  }
}
var zw;
(function(t) {
  t[t.Title = 1] = "Title", t[t.Inline = 2] = "Inline";
})(zw || (zw = {}));
var Tc;
let Sh = (Tc = class {
  constructor() {
  }
}, Tc.Back = { iconPath: new qi("arrow-left") }, Tc);
Sh = W([
  _e
], Sh);
var Dh;
(function(t) {
  t[t.Separator = -1] = "Separator", t[t.Default = 0] = "Default";
})(Dh || (Dh = {}));
var yc;
(function(t) {
  t[t.Info = 1] = "Info", t[t.Warning = 2] = "Warning", t[t.Error = 3] = "Error";
})(yc || (yc = {}));
var Aa;
(function(t) {
  t[t.UI = 1] = "UI", t[t.Workspace = 2] = "Workspace";
})(Aa || (Aa = {}));
class qw {
  static validate(e) {
    if (typeof e.badge == "string") {
      let i = dS(e.badge, 0);
      if (i < e.badge.length && (i += dS(e.badge, i)), e.badge.length > i)
        throw new Error("The 'badge'-property must be undefined or a short character");
    } else if (e.badge && !qi.isThemeIcon(e.badge))
      throw new Error("The 'badge'-property is not a valid ThemeIcon");
    if (!e.color && !e.badge && !e.tooltip)
      throw new Error("The decoration is empty");
    return !0;
  }
  constructor(e, i, n) {
    this.badge = e, this.tooltip = i, this.color = n;
  }
}
let Qg = class {
  constructor(e) {
    this.kind = e;
  }
};
Qg = W([
  _e
], Qg);
var co;
(function(t) {
  t[t.Light = 1] = "Light", t[t.Dark = 2] = "Dark", t[t.HighContrast = 3] = "HighContrast", t[t.HighContrastLight = 4] = "HighContrastLight";
})(co || (co = {}));
let Wr = class jw {
  static isNotebookRange(e) {
    return e instanceof jw ? !0 : e ? typeof e.start == "number" && typeof e.end == "number" : !1;
  }
  get start() {
    return this._start;
  }
  get end() {
    return this._end;
  }
  get isEmpty() {
    return this._start === this._end;
  }
  constructor(e, i) {
    if (e < 0)
      throw ze("start must be positive");
    if (i < 0)
      throw ze("end must be positive");
    e <= i ? (this._start = e, this._end = i) : (this._start = i, this._end = e);
  }
  with(e) {
    let i = this._start, n = this._end;
    return e.start !== void 0 && (i = e.start), e.end !== void 0 && (n = e.end), i === this._start && n === this._end ? this : new jw(i, n);
  }
}, Y_ = class Gw {
  static validate(e) {
    if (typeof e.kind != "number")
      throw new Error("NotebookCellData MUST have 'kind' property");
    if (typeof e.value != "string")
      throw new Error("NotebookCellData MUST have 'value' property");
    if (typeof e.languageId != "string")
      throw new Error("NotebookCellData MUST have 'languageId' property");
  }
  static isNotebookCellDataArray(e) {
    return Array.isArray(e) && e.every((i) => Gw.isNotebookCellData(i));
  }
  static isNotebookCellData(e) {
    return !0;
  }
  constructor(e, i, n, r, s, o, a) {
    this.kind = e, this.value = i, this.languageId = n, this.mime = r, this.outputs = s ?? [], this.metadata = o, this.executionSummary = a, Gw.validate(this);
  }
}, eP = class {
  constructor(e) {
    this.cells = e;
  }
}, tP = class ls {
  static isNotebookCellOutputItem(e) {
    return e instanceof ls ? !0 : e ? typeof e.mime == "string" && e.data instanceof Uint8Array : !1;
  }
  static error(e) {
    const i = {
      name: e.name,
      message: e.message,
      stack: e.stack
    };
    return ls.json(i, "application/vnd.code.notebook.error");
  }
  static stdout(e) {
    return ls.text(e, "application/vnd.code.notebook.stdout");
  }
  static stderr(e) {
    return ls.text(e, "application/vnd.code.notebook.stderr");
  }
  static bytes(e, i = "application/octet-stream") {
    return new ls(e, i);
  }
  static #e = new TextEncoder();
  static text(e, i = gr.text) {
    const n = ls.#e.encode(String(e));
    return new ls(n, i);
  }
  static json(e, i = "text/x-json") {
    const n = JSON.stringify(e, void 0, "	");
    return ls.text(n, i);
  }
  constructor(e, i) {
    this.data = e, this.mime = i;
    const n = pT(i, !0);
    if (!n)
      throw new Error(
        `INVALID mime type: ${i}. Must be in the format "type/subtype[;optionalparameter]"`
      );
    this.mime = n;
  }
}, Kg = class Qw {
  static isNotebookCellOutput(e) {
    return e instanceof Qw ? !0 : !e || typeof e != "object" ? !1 : typeof e.id == "string" && Array.isArray(e.items);
  }
  static ensureUniqueMimeTypes(e, i = !1) {
    const n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
    for (let s = 0; s < e.length; s++) {
      const o = e[s], a = pT(o.mime);
      if (!n.has(a) || BT(a)) {
        n.add(a);
        continue;
      }
      r.add(s), i && console.warn(`DUPLICATED mime type '${o.mime}' will be dropped`);
    }
    return r.size === 0 ? e : e.filter((s, o) => !r.has(o));
  }
  constructor(e, i, n) {
    this.items = Qw.ensureUniqueMimeTypes(e, !0), typeof i == "string" ? (this.id = i, this.metadata = n) : (this.id = on(), this.metadata = i ?? n);
  }
};
class a6 {
  constructor(e, i, n) {
    this.label = e, this.uri = i, this.position = n;
  }
}
var va;
(function(t) {
  t[t.Markup = 1] = "Markup", t[t.Code = 2] = "Code";
})(va || (va = {}));
var Kw;
(function(t) {
  t[t.Idle = 1] = "Idle", t[t.Pending = 2] = "Pending", t[t.Executing = 3] = "Executing";
})(Kw || (Kw = {}));
var Jg;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Right = 2] = "Right";
})(Jg || (Jg = {}));
var Yg;
(function(t) {
  t[t.Default = 0] = "Default", t[t.InCenter = 1] = "InCenter", t[t.InCenterIfOutsideViewport = 2] = "InCenterIfOutsideViewport", t[t.AtTop = 3] = "AtTop";
})(Yg || (Yg = {}));
class l6 {
  constructor(e, i) {
    this.text = e, this.alignment = i;
  }
}
var Jw;
(function(t) {
  t[t.Default = 1] = "Default", t[t.Preferred = 2] = "Preferred";
})(Jw || (Jw = {}));
var Xg;
(function(t) {
  t[t.Default = 1] = "Default", t[t.Preferred = 2] = "Preferred", t[t.Hidden = -1] = "Hidden";
})(Xg || (Xg = {}));
let iP = class {
  constructor(e, i = []) {
    this.uri = e, this.provides = qn(i);
  }
}, c6 = class {
  constructor(e) {
    this.label = e;
  }
};
var kh;
(function(t) {
  t[t.Named = 1] = "Named", t[t.Indexed = 2] = "Indexed";
})(kh || (kh = {}));
let Yw = class {
  constructor(e, i) {
    this.label = e, this.timestamp = i;
  }
};
Yw = W([
  _e
], Yw);
var xc;
(function(t) {
  t[t.Production = 1] = "Production", t[t.Development = 2] = "Development", t[t.Test = 3] = "Test";
})(xc || (xc = {}));
var Zg;
(function(t) {
  t[t.Node = 1] = "Node", t[t.Webworker = 2] = "Webworker";
})(Zg || (Zg = {}));
var po;
(function(t) {
  t[t.Other = 0] = "Other", t[t.Comment = 1] = "Comment", t[t.String = 2] = "String", t[t.RegEx = 3] = "RegEx";
})(po || (po = {}));
class u6 {
  constructor(e, i) {
    this.ranges = e, this.wordPattern = i;
  }
}
class d6 {
  constructor(e) {
    this._autoForwardAction = e;
  }
  get autoForwardAction() {
    return this._autoForwardAction;
  }
}
var Xw;
(function(t) {
  t[t.Queued = 1] = "Queued", t[t.Running = 2] = "Running", t[t.Passed = 3] = "Passed", t[t.Failed = 4] = "Failed", t[t.Skipped = 5] = "Skipped", t[t.Errored = 6] = "Errored";
})(Xw || (Xw = {}));
var Ec;
(function(t) {
  t[t.Run = 1] = "Run", t[t.Debug = 2] = "Debug", t[t.Coverage = 3] = "Coverage";
})(Ec || (Ec = {}));
class nP {
  constructor(e, i, n) {
    this.controllerId = e, this.profileId = i, this.kind = n;
  }
}
let em = class {
  constructor(e = void 0, i = void 0, n = void 0, r = !1, s = !0) {
    this.include = e, this.exclude = i, this.profile = n, this.continuous = r, this.preserveFocus = s;
  }
};
em = W([
  _e
], em);
let tm = mw = class {
  static diff(e, i, n) {
    const r = new mw(e);
    return r.expectedOutput = i, r.actualOutput = n, r;
  }
  constructor(e) {
    this.message = e;
  }
};
tm = mw = W([
  _e
], tm);
let Ih = class {
  constructor(e) {
    this.id = e;
  }
};
Ih = W([
  _e
], Ih);
class h6 {
  constructor(e, i, n) {
    this.label = e, this.uri = i, this.position = n;
  }
}
class gp {
  constructor(e, i) {
    this.covered = e, this.total = i, mp(this);
  }
}
function mp(t) {
  if (t) {
    if (t.covered > t.total)
      throw new Error(
        `The total number of covered items (${t.covered}) cannot be greater than the total (${t.total})`
      );
    if (t.total < 0)
      throw new Error(`The number of covered items (${t.total}) cannot be negative`);
  }
}
class tu {
  static fromDetails(e, i) {
    const n = new gp(0, 0), r = new gp(0, 0), s = new gp(0, 0);
    for (const a of i)
      if ("branches" in a) {
        n.total += 1, n.covered += a.executed ? 1 : 0;
        for (const l of a.branches)
          r.total += 1, r.covered += l.executed ? 1 : 0;
      } else
        s.total += 1, s.covered += a.executed ? 1 : 0;
    const o = new tu(
      e,
      n,
      r.total > 0 ? r : void 0,
      s.total > 0 ? s : void 0
    );
    return o.detailedCoverage = i, o;
  }
  constructor(e, i, n, r, s = []) {
    this.uri = e, this.statementCoverage = i, this.branchCoverage = n, this.declarationCoverage = r, this.includesTests = s;
  }
}
class rP {
  get executionCount() {
    return +this.executed;
  }
  set executionCount(e) {
    this.executed = e;
  }
  constructor(e, i, n = []) {
    this.executed = e, this.location = i, this.branches = n;
  }
}
class sP {
  get executionCount() {
    return +this.executed;
  }
  set executionCount(e) {
    this.executed = e;
  }
  constructor(e, i, n) {
    this.executed = e, this.location = i, this.label = n;
  }
}
class oP {
  get executionCount() {
    return +this.executed;
  }
  set executionCount(e) {
    this.executed = e;
  }
  constructor(e, i, n) {
    this.name = e, this.executed = i, this.location = n;
  }
}
var Zw;
(function(t) {
  t[t.None = 0] = "None", t[t.Option = 1] = "Option", t[t.Default = 2] = "Default", t[t.Preferred = 3] = "Preferred";
})(Zw || (Zw = {}));
var eb;
(function(t) {
  t[t.Untrusted = 0] = "Untrusted", t[t.Trusted = 1] = "Trusted", t[t.Unspecified = 2] = "Unspecified";
})(eb || (eb = {}));
var tb;
(function(t) {
  t[t.Notify = 1] = "Notify", t[t.OpenBrowser = 2] = "OpenBrowser", t[t.OpenPreview = 3] = "OpenPreview", t[t.Silent = 4] = "Silent", t[t.Ignore = 5] = "Ignore", t[t.OpenBrowserOnce = 6] = "OpenBrowserOnce";
})(tb || (tb = {}));
let Zx = class {
  constructor(e, i, n, r, s, o) {
    this.kind = e, this.name = i, this.detail = n, this.uri = r, this.range = s, this.selectionRange = o;
  }
};
class eE {
  constructor(e) {
    this.uri = e;
  }
}
class im {
  constructor(e, i) {
    this.original = e, this.modified = i;
  }
}
class aP {
  constructor(e, i, n, r) {
    this.base = e, this.input1 = i, this.input2 = n, this.result = r;
  }
}
class tE {
  constructor(e, i) {
    this.uri = e, this.viewType = i;
  }
}
class lP {
  constructor(e) {
    this.viewType = e;
  }
}
class iE {
  constructor(e, i) {
    this.uri = e, this.notebookType = i;
  }
}
class nE {
  constructor(e, i, n) {
    this.original = e, this.modified = i, this.notebookType = n;
  }
}
class cP {
  constructor() {
  }
}
class uP {
  constructor(e, i) {
    this.uri = e, this.inputBoxUri = i;
  }
}
class dP {
  constructor() {
  }
}
class hP {
  constructor(e) {
    this.textDiffs = e;
  }
}
var ib;
(function(t) {
  t[t.Down = 0] = "Down", t[t.Up = 1] = "Up";
})(ib || (ib = {}));
var nb;
(function(t) {
  t[t.Action = 1] = "Action", t[t.Toolbar = 2] = "Toolbar";
})(nb || (nb = {}));
var rb;
(function(t) {
  t[t.Short = 1] = "Short", t[t.Medium = 2] = "Medium", t[t.Full = 3] = "Full";
})(rb || (rb = {}));
class f6 {
  constructor(e, i, n) {
    this.id = e, this.label = i, this.values = n;
  }
}
var Tr;
(function(t) {
  t[t.Accepted = 1] = "Accepted", t[t.Rejected = 2] = "Rejected", t[t.Saved = 3] = "Saved";
})(Tr || (Tr = {}));
var sb;
(function(t) {
  t[t.Keep = 1] = "Keep", t[t.Undo = 2] = "Undo", t[t.UserModification = 3] = "UserModification";
})(sb || (sb = {}));
var ob;
(function(t) {
  t[t.Unhelpful = 0] = "Unhelpful", t[t.Helpful = 1] = "Helpful", t[t.Undone = 2] = "Undone", t[t.Accepted = 3] = "Accepted", t[t.Bug = 4] = "Bug";
})(ob || (ob = {}));
var Ch;
(function(t) {
  t[t.Unhelpful = 0] = "Unhelpful", t[t.Helpful = 1] = "Helpful";
})(Ch || (Ch = {}));
let X_ = class {
  constructor(e) {
    if (typeof e != "string" && e.isTrusted === !0)
      throw new Error(
        "The boolean form of MarkdownString.isTrusted is NOT supported for chat participants."
      );
    this.value = typeof e == "string" ? new bn(e) : e;
  }
}, Th = class {
  constructor(e, i) {
    if (typeof e != "string" && e.isTrusted === !0)
      throw new Error(
        "The boolean form of MarkdownString.isTrusted is NOT supported for chat participants."
      );
    this.value = typeof e == "string" ? new bn(e) : e, this.vulnerabilities = i;
  }
}, nm = class {
  constructor(e, i, n, r) {
    this.title = e, this.message = i, this.data = n, this.buttons = r;
  }
};
class Z_ {
  constructor(e, i) {
    this.value = e, this.baseUri = i;
  }
}
let rE = class {
  constructor(e, i) {
    this.value = e, this.title = i;
  }
}, Ph = class {
  constructor(e, i) {
    this.value = e, this.value2 = e, this.title = i;
  }
}, sE = class {
  constructor(e) {
    this.value = e;
  }
};
class _p {
  constructor(e, i) {
    this.value = e, this.task = i;
  }
}
let Ah = class {
  constructor(e) {
    if (typeof e != "string" && e.isTrusted === !0)
      throw new Error(
        "The boolean form of MarkdownString.isTrusted is NOT supported for chat participants."
      );
    this.value = typeof e == "string" ? new bn(e) : e;
  }
}, e1 = class {
  constructor(e) {
    this.value = e;
  }
}, Ra = class {
  constructor(e, i, n) {
    this.value = e, this.iconPath = i, this.options = n;
  }
}, t1 = class {
  constructor(e, i) {
    this.value = e, this.isEdit = i;
  }
}, rm = class {
  constructor(e, i, n) {
    this.value = e, this.license = i, this.snippet = n;
  }
}, i1 = class {
  constructor(e, i) {
    this.uri = e, this.range = i;
  }
}, oE = class {
  constructor(e) {
    this.extensions = e;
  }
}, aE = class {
  constructor(e, i, n, r, s) {
    this.uri = e, this.title = i, this.description = n, this.author = r, this.linkTag = s;
  }
  toJSON() {
    return {
      $mid: tt.ChatResponsePullRequestPart,
      uri: this.uri,
      title: this.title,
      description: this.description,
      author: this.author
    };
  }
}, Rh = class {
  constructor(e, i) {
    this.uri = e, i === !0 ? (this.isDone = !0, this.edits = []) : this.edits = Array.isArray(i) ? i : [i];
  }
}, sm = class {
  constructor(e, i) {
    this.uri = e, i === !0 ? (this.isDone = !0, this.edits = []) : this.edits = Array.isArray(i) ? i : [i];
  }
}, Lh = class {
  constructor(e) {
    this.toolName = e;
  }
}, lE = class {
  constructor(e, i, n) {
    this.toolName = e, this.toolCallId = i, this.isError = n;
  }
};
class om {
  constructor(e, i, n, r, s, o) {
    this.prompt = e, this.command = i, this.references = n, this.participant = r, this.toolReferences = s, this.editedFileEvents = o;
  }
}
class fP {
  constructor(e, i, n, r) {
    this.response = e, this.result = i, this.participant = n, this.command = r;
  }
}
class p6 {
  constructor(e, i, n, r) {
    this.response = e, this.result = i, this.participant = n, this.command = r;
  }
}
var sr;
(function(t) {
  t[t.Panel = 1] = "Panel", t[t.Terminal = 2] = "Terminal", t[t.Notebook = 3] = "Notebook", t[t.Editor = 4] = "Editor";
})(sr || (sr = {}));
var ab;
(function(t) {
  t[t.Complete = 1] = "Complete", t[t.Partial = 2] = "Partial", t[t.Omitted = 3] = "Omitted";
})(ab || (ab = {}));
var lb;
(function(t) {
  t[t.NoReason = 0] = "NoReason", t[t.FilteredContentRetry = 1] = "FilteredContentRetry", t[t.CopyrightContentRetry = 2] = "CopyrightContentRetry";
})(lb || (lb = {}));
class pP {
  constructor(e, i, n) {
    this.document = e, this.selection = i, this.wholeRange = n;
  }
}
class gP {
  constructor(e) {
    this.cell = e;
  }
}
class mP {
  constructor(e, i, n) {
    this.mimeType = e, this.data = i, this.reference = n;
  }
}
class _P {
  constructor(e) {
    this.diagnostics = e;
  }
}
var _n;
(function(t) {
  t[t.User = 1] = "User", t[t.Assistant = 2] = "Assistant", t[t.System = 3] = "System";
})(_n || (_n = {}));
class am {
  constructor(e, i, n) {
    this.callId = e, this.content = i, this.isError = n ?? !1;
  }
}
class cb {
  constructor(e, i, n) {
    this.callId = e, this.content = i, this.isError = n ?? !1;
  }
}
var ub;
(function(t) {
  t[t.Info = 0] = "Info", t[t.Warning = 1] = "Warning", t[t.Error = 2] = "Error";
})(ub || (ub = {}));
let vP = class db {
  static User(e, i) {
    return new db(_n.User, e, i);
  }
  static Assistant(e, i) {
    return new db(_n.Assistant, e, i);
  }
  set content(e) {
    typeof e == "string" ? this._content = [new Ut(e)] : this._content = e;
  }
  get content() {
    return this._content;
  }
  constructor(e, i, n) {
    this._content = [], this.role = e, this.content = i, this.name = n;
  }
}, wP = class hb {
  static User(e, i) {
    return new hb(_n.User, e, i);
  }
  static Assistant(e, i) {
    return new hb(_n.Assistant, e, i);
  }
  set content(e) {
    typeof e == "string" ? this._content = [new Ut(e)] : this._content = e;
  }
  get content() {
    return this._content;
  }
  set content2(e) {
    e && (this.content = e.map((i) => typeof i == "string" ? new Ut(i) : i));
  }
  get content2() {
    return this.content.map((e) => e instanceof Ut ? e.value : e);
  }
  constructor(e, i, n) {
    this._content = [], this.role = e, this.content = i, this.name = n;
  }
};
class rl {
  constructor(e, i, n) {
    this.callId = e, this.name = i, this.input = n;
  }
}
var fb;
(function(t) {
  t[t.Assistant = 0] = "Assistant", t[t.User = 1] = "User";
})(fb || (fb = {}));
class Ut {
  constructor(e, i) {
    this.value = e;
  }
  toJSON() {
    return {
      $mid: tt.LanguageModelTextPart,
      value: this.value,
      audience: this.audience
    };
  }
}
class wn {
  constructor(e, i, n) {
    this.mimeType = i, this.data = e, this.audience = n;
  }
  static image(e, i) {
    return new wn(e, i);
  }
  static json(e, i = "text/x-json") {
    const n = JSON.stringify(e, void 0, "	");
    return new wn(ue.fromString(n).buffer, i);
  }
  static text(e, i = gr.text) {
    return new wn(ue.fromString(e).buffer, i);
  }
  toJSON() {
    return {
      $mid: tt.LanguageModelDataPart,
      mimeType: this.mimeType,
      data: this.data,
      audience: this.audience
    };
  }
}
var uo;
(function(t) {
  t.PNG = "image/png", t.JPEG = "image/jpeg", t.GIF = "image/gif", t.WEBP = "image/webp", t.BMP = "image/bmp";
})(uo || (uo = {}));
class ts {
  constructor(e) {
    this.value = e;
  }
  toJSON() {
    return {
      $mid: tt.LanguageModelPromptTsxPart,
      value: this.value
    };
  }
}
class bi extends Error {
  static #e = "LanguageModelError";
  static NotFound(e) {
    return new bi(e, bi.NotFound.name);
  }
  static NoPermissions(e) {
    return new bi(e, bi.NoPermissions.name);
  }
  static Blocked(e) {
    return new bi(e, bi.Blocked.name);
  }
  static tryDeserialize(e) {
    if (e.name === bi.#e)
      return new bi(e.message, e.code, e.cause);
  }
  constructor(e, i, n) {
    super(e, { cause: n }), this.name = bi.#e, this.code = i ?? "";
  }
}
let n1 = class {
  constructor(e) {
    this.content = e;
  }
  toJSON() {
    return {
      $mid: tt.LanguageModelToolResult,
      content: this.content
    };
  }
}, bP = class {
  constructor(e) {
    this.content = e;
  }
  toJSON() {
    return {
      $mid: tt.LanguageModelToolResult,
      content: this.content
    };
  }
};
class g6 extends n1 {
}
var pb;
(function(t) {
  t[t.Auto = 1] = "Auto", t[t.Required = 2] = "Required";
})(pb || (pb = {}));
class yP {
  constructor(e, i) {
    this.id = e, this.label = i;
  }
}
class xP {
  constructor(e, i, n) {
    this.label = e, this.name = i, this.instructions = n;
  }
}
var gb;
(function(t) {
  t[t.SymbolInformation = 1] = "SymbolInformation", t[t.CommandInformation = 2] = "CommandInformation", t[t.SearchInformation = 3] = "SearchInformation", t[t.SettingInformation = 4] = "SettingInformation";
})(gb || (gb = {}));
var mb;
(function(t) {
  t[t.EMBEDDED = 1] = "EMBEDDED", t[t.LLM_RANKED = 2] = "LLM_RANKED", t[t.CANCELED = 3] = "CANCELED";
})(mb || (mb = {}));
var _b;
(function(t) {
  t[t.Started = 1] = "Started", t[t.Recognizing = 2] = "Recognizing", t[t.Recognized = 3] = "Recognized", t[t.Stopped = 4] = "Stopped", t[t.Error = 5] = "Error";
})(_b || (_b = {}));
var vb;
(function(t) {
  t[t.Started = 1] = "Started", t[t.Stopped = 2] = "Stopped", t[t.Error = 3] = "Error";
})(vb || (vb = {}));
var wb;
(function(t) {
  t[t.Recognized = 1] = "Recognized", t[t.Stopped = 2] = "Stopped";
})(wb || (wb = {}));
class m6 {
  constructor(e, i, n, r = {}, s) {
    this.label = e, this.command = i, this.args = n, this.env = r, this.version = s;
  }
}
class _6 {
  constructor(e, i, n = {}, r) {
    this.label = e, this.uri = i, this.headers = n, this.version = r;
  }
}
var Xs;
(function(t) {
  t[t.EMBEDDED = 1] = "EMBEDDED", t[t.LLM_RANKED = 2] = "LLM_RANKED", t[t.CANCELED = 3] = "CANCELED";
})(Xs || (Xs = {}));
let Go;
function EP(t) {
  Go ? Go instanceof ZD ? Go.loggers.push(t) : Go = new ZD([Go, t]) : Go = t;
}
function xi() {
  return Go;
}
let bb;
function v6(t) {
  bb = t;
}
function w6(t) {
  bb && bb(t);
}
class ZD {
  constructor(e) {
    this.loggers = e;
  }
  handleObservableCreated(e) {
    for (const i of this.loggers)
      i.handleObservableCreated(e);
  }
  handleOnListenerCountChanged(e, i) {
    for (const n of this.loggers)
      n.handleOnListenerCountChanged(e, i);
  }
  handleObservableUpdated(e, i) {
    for (const n of this.loggers)
      n.handleObservableUpdated(e, i);
  }
  handleAutorunCreated(e) {
    for (const i of this.loggers)
      i.handleAutorunCreated(e);
  }
  handleAutorunDisposed(e) {
    for (const i of this.loggers)
      i.handleAutorunDisposed(e);
  }
  handleAutorunDependencyChanged(e, i, n) {
    for (const r of this.loggers)
      r.handleAutorunDependencyChanged(e, i, n);
  }
  handleAutorunStarted(e) {
    for (const i of this.loggers)
      i.handleAutorunStarted(e);
  }
  handleAutorunFinished(e) {
    for (const i of this.loggers)
      i.handleAutorunFinished(e);
  }
  handleDerivedDependencyChanged(e, i, n) {
    for (const r of this.loggers)
      r.handleDerivedDependencyChanged(e, i, n);
  }
  handleDerivedCleared(e) {
    for (const i of this.loggers)
      i.handleDerivedCleared(e);
  }
  handleBeginTransaction(e) {
    for (const i of this.loggers)
      i.handleBeginTransaction(e);
  }
  handleEndTransaction(e) {
    for (const i of this.loggers)
      i.handleEndTransaction(e);
  }
}
var Di;
(function(t) {
  t[t.dependenciesMightHaveChanged = 1] = "dependenciesMightHaveChanged", t[t.stale = 2] = "stale", t[t.upToDate = 3] = "upToDate";
})(Di || (Di = {}));
class yb {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  constructor(e, i, n) {
    this._debugNameData = e, this._runFn = i, this._changeTracker = n, this._state = Di.stale, this._updateCount = 0, this._disposed = !1, this._dependencies = /* @__PURE__ */ new Set(), this._dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this._isRunning = !1, this._store = void 0, this._delayedStore = void 0, this._changeSummary = this._changeTracker?.createChangeSummary(void 0), xi()?.handleAutorunCreated(this), this._run();
  }
  dispose() {
    if (!this._disposed) {
      this._disposed = !0;
      for (const e of this._dependencies)
        e.removeObserver(this);
      this._dependencies.clear(), this._store !== void 0 && this._store.dispose(), this._delayedStore !== void 0 && this._delayedStore.dispose(), xi()?.handleAutorunDisposed(this);
    }
  }
  _run() {
    const e = this._dependenciesToBeRemoved;
    this._dependenciesToBeRemoved = this._dependencies, this._dependencies = e, this._state = Di.upToDate;
    try {
      if (!this._disposed) {
        xi()?.handleAutorunStarted(this);
        const i = this._changeSummary, n = this._delayedStore;
        n !== void 0 && (this._delayedStore = void 0);
        try {
          this._isRunning = !0, this._changeTracker && (this._changeTracker.beforeUpdate?.(this, i), this._changeSummary = this._changeTracker.createChangeSummary(i)), this._store !== void 0 && (this._store.dispose(), this._store = void 0), this._runFn(this, i);
        } catch (r) {
          Cp(r);
        } finally {
          this._isRunning = !1, n !== void 0 && n.dispose();
        }
      }
    } finally {
      this._disposed || xi()?.handleAutorunFinished(this);
      for (const i of this._dependenciesToBeRemoved)
        i.removeObserver(this);
      this._dependenciesToBeRemoved.clear();
    }
  }
  toString() {
    return `Autorun<${this.debugName}>`;
  }
  beginUpdate(e) {
    this._state === Di.upToDate && (this._state = Di.dependenciesMightHaveChanged), this._updateCount++;
  }
  endUpdate(e) {
    try {
      if (this._updateCount === 1)
        do {
          if (this._state === Di.dependenciesMightHaveChanged) {
            this._state = Di.upToDate;
            for (const i of this._dependencies)
              if (i.reportChanges(), this._state === Di.stale)
                break;
          }
          this._state !== Di.upToDate && this._run();
        } while (this._state !== Di.upToDate);
    } finally {
      this._updateCount--;
    }
    t4(() => this._updateCount >= 0);
  }
  handlePossibleChange(e) {
    this._state === Di.upToDate && this._isDependency(e) && (this._state = Di.dependenciesMightHaveChanged);
  }
  handleChange(e, i) {
    if (this._isDependency(e)) {
      xi()?.handleAutorunDependencyChanged(this, e, i);
      try {
        (this._changeTracker ? this._changeTracker.handleChange({
          changedObservable: e,
          change: i,
          didChange: (r) => r === e
        }, this._changeSummary) : !0) && (this._state = Di.stale);
      } catch (n) {
        Cp(n);
      }
    }
  }
  _isDependency(e) {
    return this._dependencies.has(e) && !this._dependenciesToBeRemoved.has(e);
  }
  _ensureNoRunning() {
    if (!this._isRunning)
      throw new rn("The reader object cannot be used outside its compute function!");
  }
  readObservable(e) {
    if (this._ensureNoRunning(), this._disposed)
      return e.get();
    e.addObserver(this);
    const i = e.get();
    return this._dependencies.add(e), this._dependenciesToBeRemoved.delete(e), i;
  }
  get store() {
    if (this._ensureNoRunning(), this._disposed)
      throw new rn("Cannot access store after dispose");
    return this._store === void 0 && (this._store = new De()), this._store;
  }
  get delayedStore() {
    if (this._ensureNoRunning(), this._disposed)
      throw new rn("Cannot access store after dispose");
    return this._delayedStore === void 0 && (this._delayedStore = new De()), this._delayedStore;
  }
  debugGetState() {
    return {
      isRunning: this._isRunning,
      updateCount: this._updateCount,
      dependencies: this._dependencies,
      state: this._state
    };
  }
  debugRerun() {
    this._isRunning ? this._state = Di.stale : this._run();
  }
}
const cE = (t, e) => t === e;
function xb(t, e) {
  if (t === e)
    return !0;
  if (Array.isArray(t) && Array.isArray(e)) {
    if (t.length !== e.length)
      return !1;
    for (let i = 0; i < t.length; i++)
      if (!xb(t[i], e[i]))
        return !1;
    return !0;
  }
  if (t && typeof t == "object" && e && typeof e == "object" && Object.getPrototypeOf(t) === Object.prototype && Object.getPrototypeOf(e) === Object.prototype) {
    const i = t, n = e, r = Object.keys(i), s = Object.keys(n), o = new Set(s);
    if (r.length !== s.length)
      return !1;
    for (const a of r)
      if (!o.has(a) || !xb(i[a], n[a]))
        return !1;
    return !0;
  }
  return !1;
}
class r1 {
  constructor(e, i, n) {
    this.owner = e, this.debugNameSource = i, this.referenceFn = n;
  }
  getDebugName(e) {
    return b6(e, this);
  }
}
const ek = /* @__PURE__ */ new Map(), Eb = /* @__PURE__ */ new WeakMap();
function b6(t, e) {
  const i = Eb.get(t);
  if (i)
    return i;
  const n = y6(t, e);
  if (n) {
    let r = ek.get(n) ?? 0;
    r++, ek.set(n, r);
    const s = r === 1 ? n : `${n}#${r}`;
    return Eb.set(t, s), s;
  }
}
function y6(t, e) {
  const i = Eb.get(t);
  if (i)
    return i;
  const n = e.owner ? E6(e.owner) + "." : "";
  let r;
  const s = e.debugNameSource;
  if (s !== void 0)
    if (typeof s == "function") {
      if (r = s(), r !== void 0)
        return n + r;
    } else
      return n + s;
  const o = e.referenceFn;
  if (o !== void 0 && (r = uE(o), r !== void 0))
    return n + r;
  if (e.owner !== void 0) {
    const a = x6(e.owner, t);
    if (a !== void 0)
      return n + a;
  }
}
function x6(t, e) {
  for (const i in t)
    if (t[i] === e)
      return i;
}
const tk = /* @__PURE__ */ new Map(), ik = /* @__PURE__ */ new WeakMap();
function E6(t) {
  const e = ik.get(t);
  if (e)
    return e;
  const i = SP(t) ?? "Object";
  let n = tk.get(i) ?? 0;
  n++, tk.set(i, n);
  const r = n === 1 ? i : `${i}#${n}`;
  return ik.set(t, r), r;
}
function SP(t) {
  const e = t.constructor;
  if (e)
    return e.name === "Object" ? void 0 : e.name;
}
function uE(t) {
  const e = t.toString(), n = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(e);
  return (n ? n[1] : void 0)?.trim();
}
let Sb;
function S6(t) {
  Sb = t;
}
let DP;
function D6(t) {
  DP = t;
}
let kP;
function k6(t) {
  kP = t;
}
class I6 {
  get TChange() {
    return null;
  }
  reportChanges() {
    this.get();
  }
  read(e) {
    return e ? e.readObservable(this) : this.get();
  }
  map(e, i) {
    const n = i === void 0 ? void 0 : e, r = i === void 0 ? e : i;
    return Sb({
      owner: n,
      debugName: () => {
        const s = uE(r);
        if (s !== void 0)
          return s;
        const a = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(r.toString());
        if (a)
          return `${this.debugName}.${a[2]}`;
        if (!n)
          return `${this.debugName} (mapped)`;
      },
      debugReferenceFn: r
    }, (s) => r(this.read(s), s));
  }
  flatten() {
    return Sb({
      owner: void 0,
      debugName: () => `${this.debugName} (flattened)`
    }, (e) => this.read(e).read(e));
  }
  recomputeInitiallyAndOnChange(e, i) {
    return e.add(DP(this, i)), this;
  }
  keepObserved(e) {
    return e.add(kP(this)), this;
  }
  get debugValue() {
    return this.get();
  }
}
class dE extends I6 {
  constructor() {
    super(), this._observers = /* @__PURE__ */ new Set(), xi()?.handleObservableCreated(this);
  }
  addObserver(e) {
    const i = this._observers.size;
    this._observers.add(e), i === 0 && this.onFirstObserverAdded(), i !== this._observers.size && xi()?.handleOnListenerCountChanged(this, this._observers.size);
  }
  removeObserver(e) {
    const i = this._observers.delete(e);
    i && this._observers.size === 0 && this.onLastObserverRemoved(), i && xi()?.handleOnListenerCountChanged(this, this._observers.size);
  }
  onFirstObserverAdded() {
  }
  onLastObserverRemoved() {
  }
  log() {
    const e = !!xi();
    return w6(this), e || xi()?.handleObservableCreated(this), this;
  }
  debugGetObservers() {
    return this._observers;
  }
}
var Bt;
(function(t) {
  t[t.initial = 0] = "initial", t[t.dependenciesMightHaveChanged = 1] = "dependenciesMightHaveChanged", t[t.stale = 2] = "stale", t[t.upToDate = 3] = "upToDate";
})(Bt || (Bt = {}));
class Pr extends dE {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  constructor(e, i, n, r = void 0, s) {
    super(), this._debugNameData = e, this._computeFn = i, this._changeTracker = n, this._handleLastObserverRemoved = r, this._equalityComparator = s, this._state = Bt.initial, this._value = void 0, this._updateCount = 0, this._dependencies = /* @__PURE__ */ new Set(), this._dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this._changeSummary = void 0, this._isUpdating = !1, this._isComputing = !1, this._didReportChange = !1, this._isInBeforeUpdate = !1, this._isReaderValid = !1, this._store = void 0, this._delayedStore = void 0, this._removedObserverToCallEndUpdateOn = null, this._changeSummary = this._changeTracker?.createChangeSummary(void 0);
  }
  onLastObserverRemoved() {
    this._state = Bt.initial, this._value = void 0, xi()?.handleDerivedCleared(this);
    for (const e of this._dependencies)
      e.removeObserver(this);
    this._dependencies.clear(), this._store !== void 0 && (this._store.dispose(), this._store = void 0), this._delayedStore !== void 0 && (this._delayedStore.dispose(), this._delayedStore = void 0), this._handleLastObserverRemoved?.();
  }
  get() {
    if (this._observers.size === 0) {
      let e;
      try {
        this._isReaderValid = !0;
        let i;
        this._changeTracker && (i = this._changeTracker.createChangeSummary(void 0), this._changeTracker.beforeUpdate?.(this, i)), e = this._computeFn(this, i);
      } finally {
        this._isReaderValid = !1;
      }
      return this.onLastObserverRemoved(), e;
    } else {
      do {
        if (this._state === Bt.dependenciesMightHaveChanged) {
          for (const e of this._dependencies)
            if (e.reportChanges(), this._state === Bt.stale)
              break;
        }
        this._state === Bt.dependenciesMightHaveChanged && (this._state = Bt.upToDate), this._state !== Bt.upToDate && this._recompute();
      } while (this._state !== Bt.upToDate);
      return this._value;
    }
  }
  _recompute() {
    let e = !1;
    this._isComputing = !0, this._didReportChange = !1;
    const i = this._dependenciesToBeRemoved;
    this._dependenciesToBeRemoved = this._dependencies, this._dependencies = i;
    try {
      const n = this._changeSummary;
      this._isReaderValid = !0, this._changeTracker && (this._isInBeforeUpdate = !0, this._changeTracker.beforeUpdate?.(this, n), this._isInBeforeUpdate = !1, this._changeSummary = this._changeTracker?.createChangeSummary(n));
      const r = this._state !== Bt.initial, s = this._value;
      this._state = Bt.upToDate;
      const o = this._delayedStore;
      o !== void 0 && (this._delayedStore = void 0);
      try {
        this._store !== void 0 && (this._store.dispose(), this._store = void 0), this._value = this._computeFn(this, n);
      } finally {
        this._isReaderValid = !1;
        for (const a of this._dependenciesToBeRemoved)
          a.removeObserver(this);
        this._dependenciesToBeRemoved.clear(), o !== void 0 && o.dispose();
      }
      e = this._didReportChange || r && !this._equalityComparator(s, this._value), xi()?.handleObservableUpdated(this, {
        oldValue: s,
        newValue: this._value,
        change: void 0,
        didChange: e,
        hadValue: r
      });
    } catch (n) {
      Cp(n);
    }
    if (this._isComputing = !1, !this._didReportChange && e)
      for (const n of this._observers)
        n.handleChange(this, void 0);
    else
      this._didReportChange = !1;
  }
  toString() {
    return `LazyDerived<${this.debugName}>`;
  }
  beginUpdate(e) {
    if (this._isUpdating)
      throw new rn("Cyclic deriveds are not supported yet!");
    this._updateCount++, this._isUpdating = !0;
    try {
      const i = this._updateCount === 1;
      if (this._state === Bt.upToDate && (this._state = Bt.dependenciesMightHaveChanged, !i))
        for (const n of this._observers)
          n.handlePossibleChange(this);
      if (i)
        for (const n of this._observers)
          n.beginUpdate(this);
    } finally {
      this._isUpdating = !1;
    }
  }
  endUpdate(e) {
    if (this._updateCount--, this._updateCount === 0) {
      const i = [...this._observers];
      for (const n of i)
        n.endUpdate(this);
      if (this._removedObserverToCallEndUpdateOn) {
        const n = [...this._removedObserverToCallEndUpdateOn];
        this._removedObserverToCallEndUpdateOn = null;
        for (const r of n)
          r.endUpdate(this);
      }
    }
    t4(() => this._updateCount >= 0);
  }
  handlePossibleChange(e) {
    if (this._state === Bt.upToDate && this._dependencies.has(e) && !this._dependenciesToBeRemoved.has(e)) {
      this._state = Bt.dependenciesMightHaveChanged;
      for (const i of this._observers)
        i.handlePossibleChange(this);
    }
  }
  handleChange(e, i) {
    if (this._dependencies.has(e) && !this._dependenciesToBeRemoved.has(e) || this._isInBeforeUpdate) {
      xi()?.handleDerivedDependencyChanged(this, e, i);
      let n = !1;
      try {
        n = this._changeTracker ? this._changeTracker.handleChange({
          changedObservable: e,
          change: i,
          didChange: (s) => s === e
        }, this._changeSummary) : !0;
      } catch (s) {
        Cp(s);
      }
      const r = this._state === Bt.upToDate;
      if (n && (this._state === Bt.dependenciesMightHaveChanged || r) && (this._state = Bt.stale, r))
        for (const s of this._observers)
          s.handlePossibleChange(this);
    }
  }
  _ensureReaderValid() {
    if (!this._isReaderValid)
      throw new rn("The reader object cannot be used outside its compute function!");
  }
  readObservable(e) {
    this._ensureReaderValid(), e.addObserver(this);
    const i = e.get();
    return this._dependencies.add(e), this._dependenciesToBeRemoved.delete(e), i;
  }
  reportChange(e) {
    this._ensureReaderValid(), this._didReportChange = !0;
    for (const i of this._observers)
      i.handleChange(this, e);
  }
  get store() {
    return this._ensureReaderValid(), this._store === void 0 && (this._store = new De()), this._store;
  }
  get delayedStore() {
    return this._ensureReaderValid(), this._delayedStore === void 0 && (this._delayedStore = new De()), this._delayedStore;
  }
  addObserver(e) {
    const i = !this._observers.has(e) && this._updateCount > 0;
    super.addObserver(e), i && (this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(e) ? this._removedObserverToCallEndUpdateOn.delete(e) : e.beginUpdate(this));
  }
  removeObserver(e) {
    this._observers.has(e) && this._updateCount > 0 && (this._removedObserverToCallEndUpdateOn || (this._removedObserverToCallEndUpdateOn = /* @__PURE__ */ new Set()), this._removedObserverToCallEndUpdateOn.add(e)), super.removeObserver(e);
  }
  debugGetState() {
    return {
      state: this._state,
      updateCount: this._updateCount,
      isComputing: this._isComputing,
      dependencies: this._dependencies,
      value: this._value
    };
  }
  debugSetValue(e) {
    this._value = e;
  }
  debugRecompute() {
    this._isComputing ? this._state = Bt.stale : this._recompute();
  }
  setValue(e, i, n) {
    this._value = e;
    const r = this._observers;
    i.updateObserver(this, this);
    for (const s of r)
      s.handleChange(this, n);
  }
}
function IP(t, e) {
  return new Pr(new r1(t.owner, t.debugName, t.debugReferenceFn), e, void 0, t.onLastObserverRemoved, t.equalsFn ?? cE);
}
S6(IP);
function CP(t) {
  return new yb(new r1(void 0, void 0, t), t, void 0);
}
function nk(t) {
  const e = new Error("BugIndicatingErrorRecovery: " + t);
  Li(e), console.error("recovered from an error that indicates a bug", e);
}
function TP(t, e) {
  const i = new PP(t, e);
  try {
    t(i);
  } finally {
    i.finish();
  }
}
function C6(t, e, i) {
  t ? e(t) : TP(e, i);
}
class PP {
  constructor(e, i) {
    this._fn = e, this._getDebugName = i, this._updatingObservers = [], xi()?.handleBeginTransaction(this);
  }
  getDebugName() {
    return this._getDebugName ? this._getDebugName() : uE(this._fn);
  }
  updateObserver(e, i) {
    if (!this._updatingObservers) {
      nk("Transaction already finished!"), TP((n) => {
        n.updateObserver(e, i);
      });
      return;
    }
    this._updatingObservers.push({ observer: e, observable: i }), e.beginUpdate(i);
  }
  finish() {
    const e = this._updatingObservers;
    if (!e) {
      nk("transaction.finish() has already been called!");
      return;
    }
    for (let i = 0; i < e.length; i++) {
      const { observer: n, observable: r } = e[i];
      n.endUpdate(r);
    }
    this._updatingObservers = null, xi()?.handleEndTransaction(this);
  }
  debugGetUpdatingObservers() {
    return this._updatingObservers;
  }
}
function T6(t, e) {
  let i;
  return i = new r1(void 0, t, void 0), new Db(i, e, cE);
}
class Db extends dE {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "ObservableValue";
  }
  constructor(e, i, n) {
    super(), this._debugNameData = e, this._equalityComparator = n, this._value = i, xi()?.handleObservableUpdated(this, { hadValue: !1, newValue: i, change: void 0, didChange: !0, oldValue: void 0 });
  }
  get() {
    return this._value;
  }
  set(e, i, n) {
    if (n === void 0 && this._equalityComparator(this._value, e))
      return;
    let r;
    i || (i = r = new PP(() => {
    }, () => `Setting ${this.debugName}`));
    try {
      const s = this._value;
      this._setValue(e), xi()?.handleObservableUpdated(this, { oldValue: s, newValue: e, change: n, didChange: !0, hadValue: !0 });
      for (const o of this._observers)
        i.updateObserver(o, this), o.handleChange(this, n);
    } finally {
      r && r.finish();
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(e) {
    this._value = e;
  }
  debugGetState() {
    return {
      value: this._value
    };
  }
  debugSetValue(e) {
    this._value = e;
  }
}
function rk(...t) {
  let e, i, n;
  return t.length === 3 ? [e, i, n] = t : [i, n] = t, new wa(new r1(e, void 0, n), i, n, () => wa.globalTransaction, cE);
}
class wa extends dE {
  constructor(e, i, n, r, s) {
    super(), this._debugNameData = e, this.event = i, this._getValue = n, this._getTransaction = r, this._equalityComparator = s, this._hasValue = !1, this.handleEvent = (o) => {
      const a = this._getValue(o), l = this._value, c = !this._hasValue || !this._equalityComparator(l, a);
      let u = !1;
      c && (this._value = a, this._hasValue && (u = !0, C6(this._getTransaction(), (d) => {
        xi()?.handleObservableUpdated(this, { oldValue: l, newValue: a, change: void 0, didChange: c, hadValue: this._hasValue });
        for (const f of this._observers)
          d.updateObserver(f, this), f.handleChange(this, void 0);
      }, () => {
        const d = this.getDebugName();
        return "Event fired" + (d ? `: ${d}` : "");
      })), this._hasValue = !0), u || xi()?.handleObservableUpdated(this, { oldValue: l, newValue: a, change: void 0, didChange: c, hadValue: this._hasValue });
    };
  }
  getDebugName() {
    return this._debugNameData.getDebugName(this);
  }
  get debugName() {
    const e = this.getDebugName();
    return "From Event" + (e ? `: ${e}` : "");
  }
  onFirstObserverAdded() {
    this._subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this._subscription.dispose(), this._subscription = void 0, this._hasValue = !1, this._value = void 0;
  }
  get() {
    return this._subscription ? (this._hasValue || this.handleEvent(void 0), this._value) : this._getValue(void 0);
  }
  debugSetValue(e) {
    this._value = e;
  }
}
(function(t) {
  t.Observer = wa;
  function e(i, n) {
    let r = !1;
    wa.globalTransaction === void 0 && (wa.globalTransaction = i, r = !0);
    try {
      n();
    } finally {
      r && (wa.globalTransaction = void 0);
    }
  }
  t.batchEventsGlobally = e;
})(rk || (rk = {}));
function P6(t) {
  const e = new AP(!1, void 0);
  return t.addObserver(e), Ee(() => {
    t.removeObserver(e);
  });
}
k6(P6);
function A6(t, e) {
  const i = new AP(!0, e);
  t.addObserver(i);
  try {
    i.beginUpdate(t);
  } finally {
    i.endUpdate(t);
  }
  return Ee(() => {
    t.removeObserver(i);
  });
}
D6(A6);
class AP {
  constructor(e, i) {
    this._forceRecompute = e, this._handleValue = i, this._counter = 0;
  }
  beginUpdate(e) {
    this._counter++;
  }
  endUpdate(e) {
    this._counter === 1 && this._forceRecompute && (this._handleValue ? this._handleValue(e.get()) : e.reportChanges()), this._counter--;
  }
  handlePossibleChange(e) {
  }
  handleChange(e, i) {
  }
}
let Ff;
function R6(t) {
  Ff || (Ff = new L6(), EP(Ff)), Ff.addFilteredObj(t);
}
class L6 {
  constructor() {
    this.indentation = 0, this.changedObservablesSets = /* @__PURE__ */ new WeakMap();
  }
  addFilteredObj(e) {
    this._filteredObjects || (this._filteredObjects = /* @__PURE__ */ new Set()), this._filteredObjects.add(e);
  }
  _isIncluded(e) {
    return this._filteredObjects?.has(e) ?? !0;
  }
  textToConsoleArgs(e) {
    return N6([
      Tl(F6("|  ", this.indentation)),
      e
    ]);
  }
  formatInfo(e) {
    return e.hadValue ? e.didChange ? [
      Tl(" "),
      Hn(Ts(e.oldValue, 70), {
        color: "red",
        strikeThrough: !0
      }),
      Tl(" "),
      Hn(Ts(e.newValue, 60), {
        color: "green"
      })
    ] : [Tl(" (unchanged)")] : [
      Tl(" "),
      Hn(Ts(e.newValue, 60), {
        color: "green"
      }),
      Tl(" (initial)")
    ];
  }
  handleObservableCreated(e) {
    if (e instanceof Pr) {
      const i = e;
      this.changedObservablesSets.set(i, /* @__PURE__ */ new Set());
    }
  }
  handleOnListenerCountChanged(e, i) {
  }
  handleObservableUpdated(e, i) {
    if (this._isIncluded(e)) {
      if (e instanceof Pr) {
        this._handleDerivedRecomputed(e, i);
        return;
      }
      console.log(...this.textToConsoleArgs([
        Pl("observable value changed"),
        Hn(e.debugName, { color: "BlueViolet" }),
        ...this.formatInfo(i)
      ]));
    }
  }
  formatChanges(e) {
    if (e.size !== 0)
      return Hn(" (changed deps: " + [...e].map((i) => i.debugName).join(", ") + ")", { color: "gray" });
  }
  handleDerivedDependencyChanged(e, i, n) {
    this._isIncluded(e) && this.changedObservablesSets.get(e)?.add(i);
  }
  _handleDerivedRecomputed(e, i) {
    if (!this._isIncluded(e))
      return;
    const n = this.changedObservablesSets.get(e);
    n && (console.log(...this.textToConsoleArgs([
      Pl("derived recomputed"),
      Hn(e.debugName, { color: "BlueViolet" }),
      ...this.formatInfo(i),
      this.formatChanges(n),
      { data: [{ fn: e._debugNameData.referenceFn ?? e._computeFn }] }
    ])), n.clear());
  }
  handleDerivedCleared(e) {
    this._isIncluded(e) && console.log(...this.textToConsoleArgs([
      Pl("derived cleared"),
      Hn(e.debugName, { color: "BlueViolet" })
    ]));
  }
  handleFromEventObservableTriggered(e, i) {
    this._isIncluded(e) && console.log(...this.textToConsoleArgs([
      Pl("observable from event triggered"),
      Hn(e.debugName, { color: "BlueViolet" }),
      ...this.formatInfo(i),
      { data: [{ fn: e._getValue }] }
    ]));
  }
  handleAutorunCreated(e) {
    this._isIncluded(e) && this.changedObservablesSets.set(e, /* @__PURE__ */ new Set());
  }
  handleAutorunDisposed(e) {
  }
  handleAutorunDependencyChanged(e, i, n) {
    this._isIncluded(e) && this.changedObservablesSets.get(e).add(i);
  }
  handleAutorunStarted(e) {
    const i = this.changedObservablesSets.get(e);
    i && (this._isIncluded(e) && console.log(...this.textToConsoleArgs([
      Pl("autorun"),
      Hn(e.debugName, { color: "BlueViolet" }),
      this.formatChanges(i),
      { data: [{ fn: e._debugNameData.referenceFn ?? e._runFn }] }
    ])), i.clear(), this.indentation++);
  }
  handleAutorunFinished(e) {
    this.indentation--;
  }
  handleBeginTransaction(e) {
    let i = e.getDebugName();
    i === void 0 && (i = ""), this._isIncluded(e) && console.log(...this.textToConsoleArgs([
      Pl("transaction"),
      Hn(i, { color: "BlueViolet" }),
      { data: [{ fn: e._fn }] }
    ])), this.indentation++;
  }
  handleEndTransaction() {
    this.indentation--;
  }
}
function N6(t) {
  const e = new Array(), i = [];
  let n = "";
  function r(o) {
    if ("length" in o)
      for (const a of o)
        a && r(a);
    else "text" in o ? (n += `%c${o.text}`, e.push(o.style), o.data && i.push(...o.data)) : "data" in o && i.push(...o.data);
  }
  r(t);
  const s = [n, ...e];
  return s.push(...i), s;
}
function Tl(t) {
  return Hn(t, { color: "black" });
}
function Pl(t) {
  return Hn(U6(`${t}: `, 10), { color: "black", bold: !0 });
}
function Hn(t, e = {
  color: "black"
}) {
  function i(r) {
    return Object.entries(r).reduce((s, [o, a]) => `${s}${o}:${a};`, "");
  }
  const n = {
    color: e.color
  };
  return e.strikeThrough && (n["text-decoration"] = "line-through"), e.bold && (n["font-weight"] = "bold"), {
    text: t,
    style: i(n)
  };
}
function Ts(t, e) {
  switch (typeof t) {
    case "number":
      return "" + t;
    case "string":
      return t.length + 2 <= e ? `"${t}"` : `"${t.substr(0, e - 7)}"+...`;
    case "boolean":
      return t ? "true" : "false";
    case "undefined":
      return "undefined";
    case "object":
      return t === null ? "null" : Array.isArray(t) ? M6(t, e) : O6(t, e);
    case "symbol":
      return t.toString();
    case "function":
      return `[[Function${t.name ? " " + t.name : ""}]]`;
    default:
      return "" + t;
  }
}
function M6(t, e) {
  let i = "[ ", n = !0;
  for (const r of t) {
    if (n || (i += ", "), i.length - 5 > e) {
      i += "...";
      break;
    }
    n = !1, i += `${Ts(r, e - i.length)}`;
  }
  return i += " ]", i;
}
function O6(t, e) {
  if (typeof t.toString == "function" && t.toString !== Object.prototype.toString) {
    const s = t.toString();
    return s.length <= e ? s : s.substring(0, e - 3) + "...";
  }
  const i = SP(t);
  let n = i ? i + "(" : "{ ", r = !0;
  for (const [s, o] of Object.entries(t)) {
    if (r || (n += ", "), n.length - 5 > e) {
      n += "...";
      break;
    }
    r = !1, n += `${s}: ${Ts(o, e - n.length)}`;
  }
  return n += i ? ")" : " }", n;
}
function F6(t, e) {
  let i = "";
  for (let n = 1; n <= e; n++)
    i += t;
  return i;
}
function U6(t, e) {
  for (; t.length < e; )
    t += " ";
  return t;
}
class lm {
  static createHost(e, i) {
    return new lm(e, i);
  }
  static createClient(e, i) {
    return new lm(e, i);
  }
  constructor(e, i) {
    this._channelFactory = e, this._getHandler = i, this._channel = this._channelFactory({
      handleNotification: (s) => {
        const o = s, a = this._getHandler().notifications[o[0]];
        if (!a)
          throw new Error(`Unknown notification "${o[0]}"!`);
        a(...o[1]);
      },
      handleRequest: (s) => {
        const o = s;
        try {
          return { type: "result", value: this._getHandler().requests[o[0]](...o[1]) };
        } catch (a) {
          return { type: "error", value: a };
        }
      }
    });
    const n = new Proxy({}, {
      get: (s, o) => async (...a) => {
        const l = await this._channel.sendRequest([o, a]);
        if (l.type === "error")
          throw l.value;
        return l.value;
      }
    }), r = new Proxy({}, {
      get: (s, o) => (...a) => {
        this._channel.sendNotification([o, a]);
      }
    });
    this.api = { notifications: r, requests: n };
  }
}
function $6(t, e) {
  const i = globalThis;
  let n = [], r;
  const { channel: s, handler: o } = H6({
    sendNotification: (l) => {
      r ? r.sendNotification(l) : n.push(l);
    }
  });
  let a;
  return (i.$$debugValueEditor_debugChannels ?? (i.$$debugValueEditor_debugChannels = {}))[t] = (l) => {
    a = e(), r = l;
    for (const c of n)
      l.sendNotification(c);
    return n = [], o;
  }, lm.createClient(s, () => {
    if (!a)
      throw new Error("Not supported");
    return a;
  });
}
function H6(t) {
  let e;
  return {
    channel: (n) => (e = n, {
      sendNotification: (r) => {
        t.sendNotification(r);
      },
      sendRequest: (r) => {
        throw new Error("not supported");
      }
    }),
    handler: {
      handleRequest: (n) => n.type === "notification" ? e?.handleNotification(n.data) : e?.handleRequest(n.data)
    }
  };
}
function sk(t, e) {
  const i = t.split(`
`);
  for (let n = 1; n < i.length; n++) {
    const r = i[n];
    if (e && e.test(r))
      continue;
    const s = r.match(/\$show(\d+)FramesUp/);
    if (s) {
      const a = parseInt(s[1], 10);
      n += a - 1;
      continue;
    }
    const o = B6(r);
    if (o)
      return o;
  }
}
function B6(t) {
  const e = t.match(/\((.*):(\d+):(\d+)\)/);
  if (e)
    return {
      fileName: e[1],
      line: parseInt(e[2]),
      column: parseInt(e[3]),
      id: t
    };
  const i = t.match(/at ([^\(\)]*):(\d+):(\d+)/);
  if (i)
    return {
      fileName: i[1],
      line: parseInt(i[2]),
      column: parseInt(i[3]),
      id: t
    };
}
class W6 {
  constructor() {
    this._timeout = void 0;
  }
  throttle(e, i) {
    this._timeout === void 0 && (this._timeout = setTimeout(() => {
      this._timeout = void 0, e();
    }, i));
  }
  dispose() {
    this._timeout !== void 0 && clearTimeout(this._timeout);
  }
}
function RP(t, e) {
  for (const i in e)
    t[i] && typeof t[i] == "object" && e[i] && typeof e[i] == "object" ? RP(t[i], e[i]) : t[i] = e[i];
}
function LP(t, e) {
  for (const i in e)
    e[i] === null ? delete t[i] : t[i] && typeof t[i] == "object" && e[i] && typeof e[i] == "object" ? LP(t[i], e[i]) : t[i] = e[i];
}
const sa = class sa {
  static getInstance() {
    return sa._instance === void 0 && (sa._instance = new sa()), sa._instance;
  }
  getTransactionState() {
    const e = [], i = [...this._activeTransactions];
    if (i.length === 0)
      return;
    const n = i.flatMap((s) => s.debugGetUpdatingObservers() ?? []).map((s) => s.observer), r = /* @__PURE__ */ new Set();
    for (; n.length > 0; ) {
      const s = n.shift();
      if (r.has(s))
        continue;
      r.add(s);
      const o = this._getInfo(s, (a) => {
        r.has(a) || n.push(a);
      });
      o && e.push(o);
    }
    return { names: i.map((s) => s.getDebugName() ?? "tx"), affected: e };
  }
  _getObservableInfo(e) {
    const i = this._instanceInfos.get(e);
    if (!i) {
      Li(new rn("No info found"));
      return;
    }
    return i;
  }
  _getAutorunInfo(e) {
    const i = this._instanceInfos.get(e);
    if (!i) {
      Li(new rn("No info found"));
      return;
    }
    return i;
  }
  _getInfo(e, i) {
    if (e instanceof Pr) {
      const n = [...e.debugGetObservers()];
      for (const l of n)
        i(l);
      const r = this._getObservableInfo(e);
      if (!r)
        return;
      const s = e.debugGetState(), o = { name: e.debugName, instanceId: r.instanceId, updateCount: s.updateCount }, a = [...r.changedObservables].map((l) => this._instanceInfos.get(l)?.instanceId).filter(Tn);
      if (s.isComputing)
        return { ...o, type: "observable/derived", state: "updating", changedDependencies: a, initialComputation: !1 };
      switch (s.state) {
        case Bt.initial:
          return { ...o, type: "observable/derived", state: "noValue" };
        case Bt.upToDate:
          return { ...o, type: "observable/derived", state: "upToDate" };
        case Bt.stale:
          return { ...o, type: "observable/derived", state: "stale", changedDependencies: a };
        case Bt.dependenciesMightHaveChanged:
          return { ...o, type: "observable/derived", state: "possiblyStale" };
      }
    } else if (e instanceof yb) {
      const n = this._getAutorunInfo(e);
      if (!n)
        return;
      const r = { name: e.debugName, instanceId: n.instanceId, updateCount: n.updateCount }, s = [...n.changedObservables].map((o) => this._instanceInfos.get(o).instanceId);
      if (e.debugGetState().isRunning)
        return { ...r, type: "autorun", state: "updating", changedDependencies: s };
      switch (e.debugGetState().state) {
        case Di.upToDate:
          return { ...r, type: "autorun", state: "upToDate" };
        case Di.stale:
          return { ...r, type: "autorun", state: "stale", changedDependencies: s };
        case Di.dependenciesMightHaveChanged:
          return { ...r, type: "autorun", state: "possiblyStale" };
      }
    }
  }
  _formatObservable(e) {
    const i = this._getObservableInfo(e);
    if (i)
      return { name: e.debugName, instanceId: i.instanceId };
  }
  _formatObserver(e) {
    if (e instanceof Pr)
      return { name: e.toString(), instanceId: this._getObservableInfo(e)?.instanceId };
    const i = this._getAutorunInfo(e);
    if (i)
      return { name: e.toString(), instanceId: i.instanceId };
  }
  constructor() {
    this._declarationId = 0, this._instanceId = 0, this._declarations = /* @__PURE__ */ new Map(), this._instanceInfos = /* @__PURE__ */ new WeakMap(), this._aliveInstances = /* @__PURE__ */ new Map(), this._activeTransactions = /* @__PURE__ */ new Set(), this._channel = $6("observableDevTools", () => ({
      notifications: {
        setDeclarationIdFilter: (e) => {
        },
        logObservableValue: (e) => {
          console.log("logObservableValue", e);
        },
        flushUpdates: () => {
          this._flushUpdates();
        },
        resetUpdates: () => {
          this._pendingChanges = null, this._channel.api.notifications.handleChange(this._fullState, !0);
        }
      },
      requests: {
        getDeclarations: () => {
          const e = {};
          for (const i of this._declarations.values())
            e[i.id] = i;
          return { decls: e };
        },
        getSummarizedInstances: () => null,
        getObservableValueInfo: (e) => ({
          observers: [...this._aliveInstances.get(e).debugGetObservers()].map((n) => this._formatObserver(n)).filter(Tn)
        }),
        getDerivedInfo: (e) => {
          const i = this._aliveInstances.get(e);
          return {
            dependencies: [...i.debugGetState().dependencies].map((n) => this._formatObservable(n)).filter(Tn),
            observers: [...i.debugGetObservers()].map((n) => this._formatObserver(n)).filter(Tn)
          };
        },
        getAutorunInfo: (e) => ({
          dependencies: [...this._aliveInstances.get(e).debugGetState().dependencies].map((n) => this._formatObservable(n)).filter(Tn)
        }),
        getTransactionState: () => this.getTransactionState(),
        setValue: (e, i) => {
          const n = this._aliveInstances.get(e);
          if (n instanceof Pr)
            n.debugSetValue(i);
          else if (n instanceof Db)
            n.debugSetValue(i);
          else if (n instanceof wa)
            n.debugSetValue(i);
          else
            throw new rn("Observable is not supported");
          const r = [...n.debugGetObservers()];
          for (const s of r)
            s.beginUpdate(n);
          for (const s of r)
            s.handleChange(n, void 0);
          for (const s of r)
            s.endUpdate(n);
        },
        getValue: (e) => {
          const i = this._aliveInstances.get(e);
          if (i instanceof Pr)
            return Ts(i.debugGetState().value, 200);
          if (i instanceof Db)
            return Ts(i.debugGetState().value, 200);
        },
        logValue: (e) => {
          const i = this._aliveInstances.get(e);
          if (i && "get" in i)
            console.log("Logged Value:", i.get());
          else
            throw new rn("Observable is not supported");
        },
        rerun: (e) => {
          const i = this._aliveInstances.get(e);
          if (i instanceof Pr)
            i.debugRecompute();
          else if (i instanceof yb)
            i.debugRerun();
          else
            throw new rn("Observable is not supported");
        }
      }
    })), this._pendingChanges = null, this._changeThrottler = new W6(), this._fullState = {}, this._flushUpdates = () => {
      this._pendingChanges !== null && (this._channel.api.notifications.handleChange(this._pendingChanges, !1), this._pendingChanges = null);
    };
  }
  _handleChange(e) {
    LP(this._fullState, e), this._pendingChanges === null ? this._pendingChanges = e : RP(this._pendingChanges, e), this._changeThrottler.throttle(this._flushUpdates, 10);
  }
  _getDeclarationId(e) {
    let i = !0, n;
    const r = Error;
    for (; ; ) {
      const o = r.stackTraceLimit;
      r.stackTraceLimit = i ? 6 : 20;
      const a = new Error().stack;
      r.stackTraceLimit = o;
      let l = sk(a, /[/\\]observableInternal[/\\]|\.observe|[/\\]util(s)?\./);
      if (!i && !l && (l = sk(a, /[/\\]observableInternal[/\\]|\.observe/)), l) {
        n = l;
        break;
      }
      if (!i) {
        console.error("Could not find location for declaration", new Error().stack), n = { fileName: "unknown", line: 0, column: 0, id: "unknown" };
        break;
      }
      i = !1;
    }
    let s = this._declarations.get(n.id);
    return s === void 0 && (s = {
      id: this._declarationId++,
      type: e,
      url: n.fileName,
      line: n.line,
      column: n.column
    }, this._declarations.set(n.id, s), this._handleChange({ decls: { [s.id]: s } })), s.id;
  }
  handleObservableCreated(e) {
    const n = {
      declarationId: this._getDeclarationId("observable/value"),
      instanceId: this._instanceId++,
      listenerCount: 0,
      lastValue: void 0,
      updateCount: 0,
      changedObservables: /* @__PURE__ */ new Set()
    };
    this._instanceInfos.set(e, n);
  }
  handleOnListenerCountChanged(e, i) {
    const n = this._getObservableInfo(e);
    if (n) {
      if (n.listenerCount === 0 && i > 0) {
        const r = e instanceof Pr ? "observable/derived" : "observable/value";
        this._aliveInstances.set(n.instanceId, e), this._handleChange({
          instances: {
            [n.instanceId]: {
              instanceId: n.instanceId,
              declarationId: n.declarationId,
              formattedValue: n.lastValue,
              type: r,
              name: e.debugName
            }
          }
        });
      } else n.listenerCount > 0 && i === 0 && (this._handleChange({
        instances: { [n.instanceId]: null }
      }), this._aliveInstances.delete(n.instanceId));
      n.listenerCount = i;
    }
  }
  handleObservableUpdated(e, i) {
    if (e instanceof Pr) {
      this._handleDerivedRecomputed(e, i);
      return;
    }
    const n = this._getObservableInfo(e);
    n && i.didChange && (n.lastValue = Ts(i.newValue, 30), n.listenerCount > 0 && this._handleChange({
      instances: { [n.instanceId]: { formattedValue: n.lastValue } }
    }));
  }
  handleAutorunCreated(e) {
    const n = {
      declarationId: this._getDeclarationId("autorun"),
      instanceId: this._instanceId++,
      updateCount: 0,
      changedObservables: /* @__PURE__ */ new Set()
    };
    this._instanceInfos.set(e, n), this._aliveInstances.set(n.instanceId, e), n && this._handleChange({
      instances: {
        [n.instanceId]: {
          instanceId: n.instanceId,
          declarationId: n.declarationId,
          runCount: 0,
          type: "autorun",
          name: e.debugName
        }
      }
    });
  }
  handleAutorunDisposed(e) {
    const i = this._getAutorunInfo(e);
    i && (this._handleChange({
      instances: { [i.instanceId]: null }
    }), this._instanceInfos.delete(e), this._aliveInstances.delete(i.instanceId));
  }
  handleAutorunDependencyChanged(e, i, n) {
    const r = this._getAutorunInfo(e);
    r && r.changedObservables.add(i);
  }
  handleAutorunStarted(e) {
  }
  handleAutorunFinished(e) {
    const i = this._getAutorunInfo(e);
    i && (i.changedObservables.clear(), i.updateCount++, this._handleChange({
      instances: { [i.instanceId]: { runCount: i.updateCount } }
    }));
  }
  handleDerivedDependencyChanged(e, i, n) {
    const r = this._getObservableInfo(e);
    r && r.changedObservables.add(i);
  }
  _handleDerivedRecomputed(e, i) {
    const n = this._getObservableInfo(e);
    if (!n)
      return;
    const r = Ts(i.newValue, 30);
    n.updateCount++, n.changedObservables.clear(), n.lastValue = r, n.listenerCount > 0 && this._handleChange({
      instances: { [n.instanceId]: { formattedValue: r, recomputationCount: n.updateCount } }
    });
  }
  handleDerivedCleared(e) {
    const i = this._getObservableInfo(e);
    i && (i.lastValue = void 0, i.changedObservables.clear(), i.listenerCount > 0 && this._handleChange({
      instances: {
        [i.instanceId]: {
          formattedValue: void 0
        }
      }
    }));
  }
  handleBeginTransaction(e) {
    this._activeTransactions.add(e);
  }
  handleEndTransaction(e) {
    this._activeTransactions.delete(e);
  }
};
sa._instance = void 0;
let kb = sa;
v6(R6);
Vd && Vd.VSCODE_DEV_DEBUG && EP(kb.getInstance());
pe("IMcpService");
const V6 = pe("IMcpWorkbenchService");
pe("IMcpServerSampling");
pe("IMcpElicitationService");
var Kl;
(function(t) {
  t.LATEST_PROTOCOL_VERSION = "2025-06-18", t.JSONRPC_VERSION = "2.0", t.PARSE_ERROR = -32700, t.INVALID_REQUEST = -32600, t.METHOD_NOT_FOUND = -32601, t.INVALID_PARAMS = -32602, t.INTERNAL_ERROR = -32603;
})(Kl || (Kl = {}));
function z6(t, e) {
  return ht.toKey(t) + "/" + e;
}
var ok;
(function(t) {
  t[t.WorkspaceFolder = 0] = "WorkspaceFolder", t[t.Workspace = 100] = "Workspace", t[t.User = 200] = "User", t[t.Extension = 300] = "Extension", t[t.Filesystem = 400] = "Filesystem", t[t.RemoteBoost = -50] = "RemoteBoost";
})(ok || (ok = {}));
var ak;
(function(t) {
  function e(i, n) {
    return i.id === n.id && i.remoteAuthority === n.remoteAuthority && i.label === n.label && i.trustBehavior === n.trustBehavior;
  }
  t.equals = e;
})(ak || (ak = {}));
var lk;
(function(t) {
  function e(r) {
    return r;
  }
  t.toSerialized = e;
  function i(r) {
    return {
      id: r.id,
      label: r.label,
      cacheNonce: r.cacheNonce,
      launch: Nh.fromSerialized(r.launch),
      variableReplacement: r.variableReplacement ? Ib.fromSerialized(r.variableReplacement) : void 0
    };
  }
  t.fromSerialized = i;
  function n(r, s) {
    return r.id === s.id && r.label === s.label && An(r.roots, s.roots, (o, a) => o.toString() === a.toString()) && sn(r.launch, s.launch) && sn(r.presentation, s.presentation) && sn(r.variableReplacement, s.variableReplacement) && sn(r.devMode, s.devMode);
  }
  t.equals = n;
})(lk || (lk = {}));
var Ib;
(function(t) {
  function e(n) {
    return n;
  }
  t.toSerialized = e;
  function i(n) {
    return {
      section: n.section,
      folder: n.folder ? { ...n.folder, uri: x.revive(n.folder.uri) } : void 0,
      target: n.target
    };
  }
  t.fromSerialized = i;
})(Ib || (Ib = {}));
var ck;
(function(t) {
  t[t.HasUnknown = 0] = "HasUnknown", t[t.LoadingUnknown = 1] = "LoadingUnknown", t[t.AllKnown = 2] = "AllKnown";
})(ck || (ck = {}));
var uk;
(function(t) {
  (function(e) {
    e[e.Trusted = 0] = "Trusted", e[e.TrustedOnNonce = 1] = "TrustedOnNonce", e[e.Untrusted = 2] = "Untrusted", e[e.Unknown = 3] = "Unknown";
  })(t.Kind || (t.Kind = {}));
})(uk || (uk = {}));
var dk;
(function(t) {
  t[t.Unknown = 0] = "Unknown", t[t.Cached = 1] = "Cached", t[t.Outdated = 2] = "Outdated", t[t.RefreshingFromUnknown = 3] = "RefreshingFromUnknown", t[t.RefreshingFromCached = 4] = "RefreshingFromCached", t[t.Live = 5] = "Live";
})(dk || (dk = {}));
var sl;
(function(t) {
  t[t.Stdio = 1] = "Stdio", t[t.HTTP = 2] = "HTTP";
})(sl || (sl = {}));
var Nh;
(function(t) {
  function e(r) {
    return r;
  }
  t.toSerialized = e;
  function i(r) {
    switch (r.type) {
      case sl.HTTP:
        return { type: r.type, uri: x.revive(r.uri), headers: r.headers };
      case sl.Stdio:
        return {
          type: r.type,
          cwd: r.cwd,
          command: r.command,
          args: r.args,
          env: r.env,
          envFile: r.envFile
        };
    }
  }
  t.fromSerialized = i;
  async function n(r) {
    const s = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(JSON.stringify(r)));
    return c4(ue.wrap(new Uint8Array(s)));
  }
  t.hash = n;
})(Nh || (Nh = {}));
var ys;
(function(t) {
  let e;
  (function(i) {
    i[i.Stopped = 0] = "Stopped", i[i.Starting = 1] = "Starting", i[i.Running = 2] = "Running", i[i.Error = 3] = "Error";
  })(e = t.Kind || (t.Kind = {})), t.toString = (i) => {
    switch (i.state) {
      case e.Stopped:
        return h(8370, "Stopped");
      case e.Starting:
        return h(8371, "Starting");
      case e.Running:
        return h(8372, "Running");
      case e.Error:
        return h(8373, "Error {0}", i.message);
      default:
        vv();
    }
  }, t.toKindString = (i) => {
    switch (i) {
      case e.Stopped:
        return "stopped";
      case e.Starting:
        return "starting";
      case e.Running:
        return "running";
      case e.Error:
        return "error";
      default:
        vv();
    }
  }, t.canBeStarted = (i) => i === e.Error || i === e.Stopped, t.isRunning = (i) => !t.canBeStarted(i.state);
})(ys || (ys = {}));
var hk;
(function(t) {
  t[t.Installing = 0] = "Installing", t[t.Installed = 1] = "Installed", t[t.Uninstalling = 2] = "Uninstalling", t[t.Uninstalled = 3] = "Uninstalled";
})(hk || (hk = {}));
var fk;
(function(t) {
  t.Readme = "readme", t.Manifest = "manifest", t.Configuration = "configuration";
})(fk || (fk = {}));
let pk = class extends ve {
  constructor(e, i) {
    super(), this.containers = e, this._register(i.onChange(this.update, this));
  }
  set mcpServer(e) {
    this.containers.forEach((i) => i.mcpServer = e);
  }
  update(e) {
    for (const i of this.containers)
      e && i.mcpServer ? e.id === i.mcpServer.id && (i.mcpServer = e) : i.update();
  }
};
pk = W([
  M(1, V6)
], pk);
new T("mcpServersGalleryEnabled", !1);
new T("hasInstalledMcpServers", !0);
var gk;
(function(t) {
  t.scheme = "mcp-resource";
  const e = "dylo78gyp";
  function i(r, s) {
    return typeof s == "string" && (s = x.parse(s)), s.with({
      scheme: t.scheme,
      authority: c4(ue.fromString(r.id)),
      path: ["", s.scheme, s.authority || e].join("/") + s.path
    });
  }
  t.fromServer = i;
  function n(r) {
    if (typeof r == "string" && (r = x.parse(r)), r.scheme !== t.scheme)
      throw new Error(`Invalid MCP resource URI: ${r.toString()}`);
    const s = r.path.split("/");
    if (s.length < 3)
      throw new Error(`Invalid MCP resource URI: ${r.toString()}`);
    const [, o, a, ...l] = s, c = new URL(
      `${o}://${a.toLowerCase() === e ? "" : a}`
    );
    return c.pathname = l.length ? "/" + l.join("/") : "", c.search = r.query, c.hash = r.fragment, {
      definitionId: EA(r.authority).toString(),
      resourceURL: c
    };
  }
  t.toServer = n;
})(gk || (gk = {}));
var mk;
(function(t) {
  t[t.Logging = 1] = "Logging", t[t.Completions = 2] = "Completions", t[t.Prompts = 4] = "Prompts", t[t.PromptsListChanged = 8] = "PromptsListChanged", t[t.Resources = 16] = "Resources", t[t.ResourcesSubscribe = 32] = "ResourcesSubscribe", t[t.ResourcesListChanged = 64] = "ResourcesListChanged", t[t.Tools = 128] = "Tools", t[t.ToolsListChanged = 256] = "ToolsListChanged";
})(mk || (mk = {}));
var _k;
(function(t) {
  t.Prefix = "mcp_", t[t.MaxPrefixLen = 18] = "MaxPrefixLen", t[t.MaxLength = 64] = "MaxLength";
})(_k || (_k = {}));
var vr;
(function(t) {
  function e(n) {
    const { selectionStartLineNumber: r, selectionStartColumn: s, positionLineNumber: o, positionColumn: a } = n, l = new je(r - 1, s - 1), c = new je(o - 1, a - 1);
    return new Qr(l, c);
  }
  t.to = e;
  function i(n) {
    const { anchor: r, active: s } = n;
    return {
      selectionStartLineNumber: r.line + 1,
      selectionStartColumn: r.character + 1,
      positionLineNumber: s.line + 1,
      positionColumn: s.character + 1
    };
  }
  t.from = i;
})(vr || (vr = {}));
var z;
(function(t) {
  function e(n) {
    if (!n)
      return;
    const { start: r, end: s } = n;
    return {
      startLineNumber: r.line + 1,
      startColumn: r.character + 1,
      endLineNumber: s.line + 1,
      endColumn: s.character + 1
    };
  }
  t.from = e;
  function i(n) {
    if (!n)
      return;
    const { startLineNumber: r, startColumn: s, endLineNumber: o, endColumn: a } = n;
    return new Oe(r - 1, s - 1, o - 1, a - 1);
  }
  t.to = i;
})(z || (z = {}));
var Kr;
(function(t) {
  function e(n) {
    return {
      uri: n.uri,
      range: z.from(n.range)
    };
  }
  t.from = e;
  function i(n) {
    return new Ln(x.revive(n.uri), z.to(n.range));
  }
  t.to = i;
})(Kr || (Kr = {}));
var Cb;
(function(t) {
  function e(i) {
    switch (i) {
      case Bl.Comment:
        return po.Comment;
      case Bl.Other:
        return po.Other;
      case Bl.RegEx:
        return po.RegEx;
      case Bl.String:
        return po.String;
    }
  }
  t.to = e;
})(Cb || (Cb = {}));
var at;
(function(t) {
  function e(n) {
    return new je(n.lineNumber - 1, n.column - 1);
  }
  t.to = e;
  function i(n) {
    return { lineNumber: n.line + 1, column: n.character + 1 };
  }
  t.from = i;
})(at || (at = {}));
var iu;
(function(t) {
  function e(r, s, o) {
    return Kt(qn(r).map((a) => i(a, s, o)));
  }
  t.from = e;
  function i(r, s, o) {
    if (typeof r == "string")
      return {
        $serialized: !0,
        language: r,
        isBuiltin: o?.isBuiltin
      };
    if (r)
      return {
        $serialized: !0,
        language: r.language,
        scheme: n(r.scheme, s),
        pattern: vn.from(r.pattern) ?? void 0,
        exclusive: r.exclusive,
        notebookType: r.notebookType,
        isBuiltin: o?.isBuiltin
      };
  }
  function n(r, s) {
    return s && typeof r == "string" ? s.transformOutgoingScheme(r) : r;
  }
})(iu || (iu = {}));
var cm;
(function(t) {
  function e(n) {
    switch (n) {
      case fa.Unnecessary:
        return ql.Unnecessary;
      case fa.Deprecated:
        return ql.Deprecated;
    }
  }
  t.from = e;
  function i(n) {
    switch (n) {
      case ql.Unnecessary:
        return fa.Unnecessary;
      case ql.Deprecated:
        return fa.Deprecated;
      default:
        return;
    }
  }
  t.to = i;
})(cm || (cm = {}));
var nu;
(function(t) {
  function e(n) {
    let r;
    return n.code && (it(n.code) || xa(n.code) ? r = String(n.code) : r = {
      value: String(n.code.value),
      target: n.code.target
    }), {
      ...z.from(n.range),
      message: n.message,
      source: n.source,
      code: r,
      severity: Mh.from(n.severity),
      relatedInformation: n.relatedInformation && n.relatedInformation.map(um.from),
      tags: Array.isArray(n.tags) ? Kt(n.tags.map(cm.from)) : void 0
    };
  }
  t.from = e;
  function i(n) {
    const r = new Eg(z.to(n), n.message, Mh.to(n.severity));
    return r.source = n.source, r.code = it(n.code) ? n.code : n.code?.value, r.relatedInformation = n.relatedInformation && n.relatedInformation.map(um.to), r.tags = n.tags && Kt(n.tags.map(cm.to)), r;
  }
  t.to = i;
})(nu || (nu = {}));
var um;
(function(t) {
  function e(n) {
    return {
      ...z.from(n.location.range),
      message: n.message,
      resource: n.location.uri
    };
  }
  t.from = e;
  function i(n) {
    return new ih(new Ln(n.resource, z.to(n)), n.message);
  }
  t.to = i;
})(um || (um = {}));
var Mh;
(function(t) {
  function e(n) {
    switch (n) {
      case Ci.Error:
        return en.Error;
      case Ci.Warning:
        return en.Warning;
      case Ci.Information:
        return en.Info;
      case Ci.Hint:
        return en.Hint;
    }
    return en.Error;
  }
  t.from = e;
  function i(n) {
    switch (n) {
      case en.Info:
        return Ci.Information;
      case en.Warning:
        return Ci.Warning;
      case en.Error:
        return Ci.Error;
      case en.Hint:
        return Ci.Hint;
      default:
        return Ci.Error;
    }
  }
  t.to = i;
})(Mh || (Mh = {}));
var si;
(function(t) {
  function e(n) {
    return typeof n == "number" && n >= dh.One ? n - 1 : n === dh.Beside ? N9 : L9;
  }
  t.from = e;
  function i(n) {
    if (typeof n == "number" && n >= 0)
      return n + 1;
    throw new Error("invalid 'EditorGroupColumn'");
  }
  t.to = i;
})(si || (si = {}));
function q6(t) {
  return typeof t.range < "u";
}
function NP(t) {
  return t.length === 0 ? !0 : !!q6(t[0]);
}
var Ae;
(function(t) {
  function e(a) {
    return a.map(t.from);
  }
  t.fromMany = e;
  function i(a) {
    return a && typeof a == "object" && typeof a.language == "string" && typeof a.value == "string";
  }
  function n(a) {
    let l;
    if (i(a)) {
      const { language: d, value: f } = a;
      l = { value: "```" + d + `
` + f + "\n```\n" };
    } else bn.isMarkdownString(a) ? l = { value: a.value, isTrusted: a.isTrusted, supportThemeIcons: a.supportThemeIcons, supportHtml: a.supportHtml, baseUri: a.baseUri } : typeof a == "string" ? l = { value: a } : l = { value: "" };
    const c = /* @__PURE__ */ Object.create(null);
    l.uris = c;
    const u = ({ href: d }) => {
      try {
        let f = x.parse(d, !0);
        f = f.with({ query: r(f.query, c) }), c[d] = f;
      } catch {
      }
      return "";
    };
    return Et.walkTokens(Et.lexer(l.value), (d) => {
      d.type === "link" ? u({ href: d.href }) : d.type === "image" && typeof d.href == "string" && u(Q8(d.href));
    }), l;
  }
  t.from = n;
  function r(a, l) {
    if (!a)
      return a;
    let c;
    try {
      c = fT(a);
    } catch {
    }
    if (!c)
      return a;
    let u = !1;
    return c = Wc(c, (d) => {
      if (x.isUri(d)) {
        const f = `__uri_${Math.random().toString(16).slice(2, 8)}`;
        return l[f] = d, u = !0, f;
      } else
        return;
    }), u ? JSON.stringify(c) : a;
  }
  function s(a) {
    const l = new bn(a.value, a.supportThemeIcons);
    return l.isTrusted = a.isTrusted, l.supportHtml = a.supportHtml, l.baseUri = a.baseUri ? x.from(a.baseUri) : void 0, l;
  }
  t.to = s;
  function o(a) {
    if (a)
      return typeof a == "string" ? a : t.from(a);
  }
  t.fromStrict = o;
})(Ae || (Ae = {}));
function j6(t) {
  return NP(t) ? t.map((e) => ({
    range: z.from(e.range),
    hoverMessage: Array.isArray(e.hoverMessage) ? Ae.fromMany(e.hoverMessage) : e.hoverMessage ? Ae.from(e.hoverMessage) : void 0,
    renderOptions: e.renderOptions
  })) : t.map((e) => ({
    range: z.from(e)
  }));
}
function s1(t) {
  return typeof t > "u" ? t : typeof t == "string" ? x.file(t) : t;
}
var ru;
(function(t) {
  function e(i) {
    return typeof i > "u" ? i : {
      contentText: i.contentText,
      contentIconPath: i.contentIconPath ? s1(i.contentIconPath) : void 0,
      border: i.border,
      borderColor: i.borderColor,
      fontStyle: i.fontStyle,
      fontWeight: i.fontWeight,
      textDecoration: i.textDecoration,
      color: i.color,
      backgroundColor: i.backgroundColor,
      margin: i.margin,
      width: i.width,
      height: i.height
    };
  }
  t.from = e;
})(ru || (ru = {}));
var dm;
(function(t) {
  function e(i) {
    return typeof i > "u" ? i : {
      backgroundColor: i.backgroundColor,
      outline: i.outline,
      outlineColor: i.outlineColor,
      outlineStyle: i.outlineStyle,
      outlineWidth: i.outlineWidth,
      border: i.border,
      borderColor: i.borderColor,
      borderRadius: i.borderRadius,
      borderSpacing: i.borderSpacing,
      borderStyle: i.borderStyle,
      borderWidth: i.borderWidth,
      fontStyle: i.fontStyle,
      fontWeight: i.fontWeight,
      textDecoration: i.textDecoration,
      cursor: i.cursor,
      color: i.color,
      opacity: i.opacity,
      letterSpacing: i.letterSpacing,
      gutterIconPath: i.gutterIconPath ? s1(i.gutterIconPath) : void 0,
      gutterIconSize: i.gutterIconSize,
      overviewRulerColor: i.overviewRulerColor,
      before: i.before ? ru.from(i.before) : void 0,
      after: i.after ? ru.from(i.after) : void 0
    };
  }
  t.from = e;
})(dm || (dm = {}));
var Tb;
(function(t) {
  function e(i) {
    if (typeof i > "u")
      return i;
    switch (i) {
      case ga.OpenOpen:
        return zl.AlwaysGrowsWhenTypingAtEdges;
      case ga.ClosedClosed:
        return zl.NeverGrowsWhenTypingAtEdges;
      case ga.OpenClosed:
        return zl.GrowsOnlyWhenTypingBefore;
      case ga.ClosedOpen:
        return zl.GrowsOnlyWhenTypingAfter;
    }
  }
  t.from = e;
})(Tb || (Tb = {}));
var Pb;
(function(t) {
  function e(i) {
    return {
      isWholeLine: i.isWholeLine,
      rangeBehavior: i.rangeBehavior ? Tb.from(i.rangeBehavior) : void 0,
      overviewRulerLane: i.overviewRulerLane,
      light: i.light ? dm.from(i.light) : void 0,
      dark: i.dark ? dm.from(i.dark) : void 0,
      backgroundColor: i.backgroundColor,
      outline: i.outline,
      outlineColor: i.outlineColor,
      outlineStyle: i.outlineStyle,
      outlineWidth: i.outlineWidth,
      border: i.border,
      borderColor: i.borderColor,
      borderRadius: i.borderRadius,
      borderSpacing: i.borderSpacing,
      borderStyle: i.borderStyle,
      borderWidth: i.borderWidth,
      fontStyle: i.fontStyle,
      fontWeight: i.fontWeight,
      textDecoration: i.textDecoration,
      cursor: i.cursor,
      color: i.color,
      opacity: i.opacity,
      letterSpacing: i.letterSpacing,
      gutterIconPath: i.gutterIconPath ? s1(i.gutterIconPath) : void 0,
      gutterIconSize: i.gutterIconSize,
      overviewRulerColor: i.overviewRulerColor,
      before: i.before ? ru.from(i.before) : void 0,
      after: i.after ? ru.from(i.after) : void 0
    };
  }
  t.from = e;
})(Pb || (Pb = {}));
var hi;
(function(t) {
  function e(n) {
    return {
      text: n.newText,
      eol: n.newEol && au.from(n.newEol),
      range: z.from(n.range)
    };
  }
  t.from = e;
  function i(n) {
    const r = new Co(z.to(n.range), n.text);
    return r.newEol = typeof n.eol > "u" ? void 0 : au.to(n.eol), r;
  }
  t.to = i;
})(hi || (hi = {}));
var yn;
(function(t) {
  function e(n, r) {
    const s = {
      edits: []
    };
    if (n instanceof tl) {
      const o = new e4();
      for (const a of n._allEntries())
        a._type === Wt.File && x.isUri(a.to) && a.from === void 0 && o.add(a.to);
      for (const a of n._allEntries())
        if (a._type === Wt.File) {
          let l;
          a.options?.contents && (ArrayBuffer.isView(a.options.contents) ? l = { type: "base64", value: U_(ue.wrap(a.options.contents)) } : l = { type: "dataTransferItem", id: a.options.contents._itemId }), s.edits.push({
            oldResource: a.from,
            newResource: a.to,
            options: { ...a.options, contents: l },
            metadata: a.metadata
          });
        } else a._type === Wt.Text ? s.edits.push({
          resource: a.uri,
          textEdit: hi.from(a.edit),
          versionId: o.has(a.uri) ? void 0 : r?.getTextDocumentVersion(a.uri),
          metadata: a.metadata
        }) : a._type === Wt.Snippet ? s.edits.push({
          resource: a.uri,
          textEdit: {
            range: z.from(a.range),
            text: a.edit.value,
            insertAsSnippet: !0,
            keepWhitespace: a.keepWhitespace
          },
          versionId: o.has(a.uri) ? void 0 : r?.getTextDocumentVersion(a.uri),
          metadata: a.metadata
        }) : a._type === Wt.Cell ? s.edits.push({
          metadata: a.metadata,
          resource: a.uri,
          cellEdit: a.edit,
          notebookVersionId: r?.getNotebookDocumentVersion(a.uri)
        }) : a._type === Wt.CellReplace && s.edits.push({
          metadata: a.metadata,
          resource: a.uri,
          notebookVersionId: r?.getNotebookDocumentVersion(a.uri),
          cellEdit: {
            editType: bo.Replace,
            index: a.index,
            count: a.count,
            cells: a.cells.map(cu.from)
          }
        });
    }
    return s;
  }
  t.from = e;
  function i(n) {
    const r = new tl(), s = new fi();
    for (const o of n.edits)
      if (o.textEdit) {
        const a = o, l = x.revive(a.resource), c = z.to(a.textEdit.range), u = a.textEdit.text, d = a.textEdit.insertAsSnippet;
        let f;
        d ? f = Ta.replace(c, new il(u)) : f = Co.replace(c, u);
        const g = s.get(l);
        g ? g.push(f) : s.set(l, [f]);
      } else
        r.renameFile(x.revive(o.oldResource), x.revive(o.newResource), o.options);
    for (const [o, a] of s)
      r.set(o, a);
    return r;
  }
  t.to = i;
})(yn || (yn = {}));
var jn;
(function(t) {
  const e = /* @__PURE__ */ Object.create(null);
  e[bt.File] = G.File, e[bt.Module] = G.Module, e[bt.Namespace] = G.Namespace, e[bt.Package] = G.Package, e[bt.Class] = G.Class, e[bt.Method] = G.Method, e[bt.Property] = G.Property, e[bt.Field] = G.Field, e[bt.Constructor] = G.Constructor, e[bt.Enum] = G.Enum, e[bt.Interface] = G.Interface, e[bt.Function] = G.Function, e[bt.Variable] = G.Variable, e[bt.Constant] = G.Constant, e[bt.String] = G.String, e[bt.Number] = G.Number, e[bt.Boolean] = G.Boolean, e[bt.Array] = G.Array, e[bt.Object] = G.Object, e[bt.Key] = G.Key, e[bt.Null] = G.Null, e[bt.EnumMember] = G.EnumMember, e[bt.Struct] = G.Struct, e[bt.Event] = G.Event, e[bt.Operator] = G.Operator, e[bt.TypeParameter] = G.TypeParameter;
  function i(r) {
    return typeof e[r] == "number" ? e[r] : G.Property;
  }
  t.from = i;
  function n(r) {
    for (const s in e)
      if (e[s] === r)
        return Number(s);
    return bt.Property;
  }
  t.to = n;
})(jn || (jn = {}));
var Os;
(function(t) {
  function e(n) {
    switch (n) {
      case rh.Deprecated:
        return tg.Deprecated;
    }
  }
  t.from = e;
  function i(n) {
    switch (n) {
      case tg.Deprecated:
        return rh.Deprecated;
    }
  }
  t.to = i;
})(Os || (Os = {}));
var ol;
(function(t) {
  function e(n) {
    return {
      name: n.name,
      kind: jn.from(n.kind),
      tags: n.tags && n.tags.map(Os.from),
      containerName: n.containerName,
      location: an.from(n.location)
    };
  }
  t.from = e;
  function i(n) {
    const r = new sh(n.name, jn.to(n.kind), n.containerName, an.to(n.location));
    return r.tags = n.tags && n.tags.map(Os.to), r;
  }
  t.to = i;
})(ol || (ol = {}));
var Ab;
(function(t) {
  function e(n) {
    const r = {
      name: n.name || "!!MISSING: name!!",
      detail: n.detail,
      range: z.from(n.range),
      selectionRange: z.from(n.selectionRange),
      kind: jn.from(n.kind),
      tags: n.tags?.map(Os.from) ?? []
    };
    return n.children && (r.children = n.children.map(e)), r;
  }
  t.from = e;
  function i(n) {
    const r = new oh(n.name, n.detail, jn.to(n.kind), z.to(n.range), z.to(n.selectionRange));
    return of(n.tags) && (r.tags = n.tags.map(Os.to)), n.children && (r.children = n.children.map(i)), r;
  }
  t.to = i;
})(Ab || (Ab = {}));
var al;
(function(t) {
  function e(n) {
    const r = new Jx(jn.to(n.kind), n.name, n.detail || "", x.revive(n.uri), z.to(n.range), z.to(n.selectionRange));
    return r._sessionId = n._sessionId, r._itemId = n._itemId, r;
  }
  t.to = e;
  function i(n, r, s) {
    if (r = r ?? n._sessionId, s = s ?? n._itemId, r === void 0 || s === void 0)
      throw new Error("invalid item");
    return {
      _sessionId: r,
      _itemId: s,
      name: n.name,
      detail: n.detail,
      kind: jn.from(n.kind),
      uri: n.uri,
      range: z.from(n.range),
      selectionRange: z.from(n.selectionRange),
      tags: n.tags?.map(Os.from)
    };
  }
  t.from = i;
})(al || (al = {}));
var Rb;
(function(t) {
  function e(i) {
    return new GT(al.to(i.from), i.fromRanges.map((n) => z.to(n)));
  }
  t.to = e;
})(Rb || (Rb = {}));
var Lb;
(function(t) {
  function e(i) {
    return new QT(al.to(i.to), i.fromRanges.map((n) => z.to(n)));
  }
  t.to = e;
})(Lb || (Lb = {}));
var an;
(function(t) {
  function e(n) {
    return {
      range: n.range && z.from(n.range),
      uri: n.uri
    };
  }
  t.from = e;
  function i(n) {
    return new Ln(x.revive(n.uri), z.to(n.range));
  }
  t.to = i;
})(an || (an = {}));
var Oh;
(function(t) {
  function e(n) {
    const r = n, s = n;
    return {
      originSelectionRange: r.originSelectionRange ? z.from(r.originSelectionRange) : void 0,
      uri: r.targetUri ? r.targetUri : s.uri,
      range: z.from(r.targetRange ? r.targetRange : s.range),
      targetSelectionRange: r.targetSelectionRange ? z.from(r.targetSelectionRange) : void 0
    };
  }
  t.from = e;
  function i(n) {
    return {
      targetUri: x.revive(n.uri),
      targetRange: z.to(n.range),
      targetSelectionRange: n.targetSelectionRange ? z.to(n.targetSelectionRange) : void 0,
      originSelectionRange: n.originSelectionRange ? z.to(n.originSelectionRange) : void 0
    };
  }
  t.to = i;
})(Oh || (Oh = {}));
var Fh;
(function(t) {
  function e(n) {
    return {
      range: z.from(n.range),
      contents: Ae.fromMany(n.contents),
      canIncreaseVerbosity: n.canIncreaseVerbosity,
      canDecreaseVerbosity: n.canDecreaseVerbosity
    };
  }
  t.from = e;
  function i(n) {
    const r = n.contents.map(Ae.to), s = z.to(n.range), o = n.canIncreaseVerbosity, a = n.canDecreaseVerbosity;
    return new Dg(r, s, o, a);
  }
  t.to = i;
})(Fh || (Fh = {}));
var Nb;
(function(t) {
  function e(n) {
    return {
      range: z.from(n.range),
      expression: n.expression
    };
  }
  t.from = e;
  function i(n) {
    return new Vg(z.to(n.range), n.expression);
  }
  t.to = i;
})(Nb || (Nb = {}));
var hm;
(function(t) {
  function e(n) {
    if (n instanceof zg)
      return {
        type: "text",
        range: z.from(n.range),
        text: n.text
      };
    if (n instanceof qg)
      return {
        type: "variable",
        range: z.from(n.range),
        variableName: n.variableName,
        caseSensitiveLookup: n.caseSensitiveLookup
      };
    if (n instanceof jg)
      return {
        type: "expression",
        range: z.from(n.range),
        expression: n.expression
      };
    throw new Error("Unknown 'InlineValue' type");
  }
  t.from = e;
  function i(n) {
    switch (n.type) {
      case "text":
        return {
          range: z.to(n.range),
          text: n.text
        };
      case "variable":
        return {
          range: z.to(n.range),
          variableName: n.variableName,
          caseSensitiveLookup: n.caseSensitiveLookup
        };
      case "expression":
        return {
          range: z.to(n.range),
          expression: n.expression
        };
    }
  }
  t.to = i;
})(hm || (hm = {}));
var fm;
(function(t) {
  function e(n) {
    return {
      frameId: n.frameId,
      stoppedLocation: z.from(n.stoppedLocation)
    };
  }
  t.from = e;
  function i(n) {
    return new Uw(n.frameId, z.to(n.stoppedLocation));
  }
  t.to = i;
})(fm || (fm = {}));
var su;
(function(t) {
  function e(n) {
    return {
      range: z.from(n.range),
      kind: n.kind
    };
  }
  t.from = e;
  function i(n) {
    return new kg(z.to(n.range), n.kind);
  }
  t.to = i;
})(su || (su = {}));
var Mb;
(function(t) {
  function e(n) {
    return {
      uri: n.uri,
      highlights: n.highlights.map(su.from)
    };
  }
  t.from = e;
  function i(n) {
    return new Ig(x.revive(n.uri), n.highlights.map(su.to));
  }
  t.to = i;
})(Mb || (Mb = {}));
var Ob;
(function(t) {
  function e(i) {
    switch (i) {
      case dd.TriggerCharacter:
        return pc.TriggerCharacter;
      case dd.TriggerForIncompleteCompletions:
        return pc.TriggerForIncompleteCompletions;
      case dd.Invoke:
      default:
        return pc.Invoke;
    }
  }
  t.to = e;
})(Ob || (Ob = {}));
var Fb;
(function(t) {
  function e(i) {
    return {
      triggerKind: Ob.to(i.triggerKind),
      triggerCharacter: i.triggerCharacter
    };
  }
  t.to = e;
})(Fb || (Fb = {}));
var pm;
(function(t) {
  function e(n) {
    switch (n) {
      case uh.Deprecated:
        return Yp.Deprecated;
    }
  }
  t.from = e;
  function i(n) {
    switch (n) {
      case Yp.Deprecated:
        return uh.Deprecated;
    }
  }
  t.to = i;
})(pm || (pm = {}));
var Ub;
(function(t) {
  function e(i, n, r) {
    return "icon" in i && "command" in i ? {
      command: n.toInternal(i.command, r),
      icon: Wm.fromThemeIcon(i.icon)
    } : { command: n.toInternal(i, r) };
  }
  t.from = e;
})(Ub || (Ub = {}));
var gm;
(function(t) {
  const e = /* @__PURE__ */ new Map([
    [Ce.Method, O.Method],
    [Ce.Function, O.Function],
    [Ce.Constructor, O.Constructor],
    [Ce.Field, O.Field],
    [Ce.Variable, O.Variable],
    [Ce.Class, O.Class],
    [Ce.Interface, O.Interface],
    [Ce.Struct, O.Struct],
    [Ce.Module, O.Module],
    [Ce.Property, O.Property],
    [Ce.Unit, O.Unit],
    [Ce.Value, O.Value],
    [Ce.Constant, O.Constant],
    [Ce.Enum, O.Enum],
    [Ce.EnumMember, O.EnumMember],
    [Ce.Keyword, O.Keyword],
    [Ce.Snippet, O.Snippet],
    [Ce.Text, O.Text],
    [Ce.Color, O.Color],
    [Ce.File, O.File],
    [Ce.Reference, O.Reference],
    [Ce.Folder, O.Folder],
    [Ce.Event, O.Event],
    [Ce.Operator, O.Operator],
    [Ce.TypeParameter, O.TypeParameter],
    [Ce.Issue, O.Issue],
    [Ce.User, O.User]
  ]);
  function i(s) {
    return e.get(s) ?? O.Property;
  }
  t.from = i;
  const n = /* @__PURE__ */ new Map([
    [O.Method, Ce.Method],
    [O.Function, Ce.Function],
    [O.Constructor, Ce.Constructor],
    [O.Field, Ce.Field],
    [O.Variable, Ce.Variable],
    [O.Class, Ce.Class],
    [O.Interface, Ce.Interface],
    [O.Struct, Ce.Struct],
    [O.Module, Ce.Module],
    [O.Property, Ce.Property],
    [O.Unit, Ce.Unit],
    [O.Value, Ce.Value],
    [O.Constant, Ce.Constant],
    [O.Enum, Ce.Enum],
    [O.EnumMember, Ce.EnumMember],
    [O.Keyword, Ce.Keyword],
    [O.Snippet, Ce.Snippet],
    [O.Text, Ce.Text],
    [O.Color, Ce.Color],
    [O.File, Ce.File],
    [O.Reference, Ce.Reference],
    [O.Folder, Ce.Folder],
    [O.Event, Ce.Event],
    [O.Operator, Ce.Operator],
    [O.TypeParameter, Ce.TypeParameter],
    [O.User, Ce.User],
    [O.Issue, Ce.Issue]
  ]);
  function r(s) {
    return n.get(s) ?? Ce.Property;
  }
  t.to = r;
})(gm || (gm = {}));
var $b;
(function(t) {
  function e(i, n) {
    const r = new Ag(i.label);
    return r.insertText = i.insertText, r.kind = gm.to(i.kind), r.tags = i.tags?.map(pm.to), r.detail = i.detail, r.documentation = dl(i.documentation) ? Ae.to(i.documentation) : i.documentation, r.sortText = i.sortText, r.filterText = i.filterText, r.preselect = i.preselect, r.commitCharacters = i.commitCharacters, ut.isIRange(i.range) ? r.range = z.to(i.range) : typeof i.range == "object" && (r.range = { inserting: z.to(i.range.insert), replacing: z.to(i.range.replace) }), r.keepWhitespace = typeof i.insertTextRules > "u" ? !1 : !!(i.insertTextRules & Ia.KeepWhitespace), typeof i.insertTextRules < "u" && i.insertTextRules & Ia.InsertAsSnippet ? r.insertText = new il(i.insertText) : (r.insertText = i.insertText, r.textEdit = r.range instanceof Oe ? new Co(r.range, r.insertText) : void 0), i.additionalTextEdits && i.additionalTextEdits.length > 0 && (r.additionalTextEdits = i.additionalTextEdits.map((s) => hi.to(s))), r.command = n && i.command ? n.fromInternal(i.command) : void 0, r;
  }
  t.to = e;
})($b || ($b = {}));
var mm;
(function(t) {
  function e(n) {
    if (typeof n.label != "string" && !Array.isArray(n.label))
      throw new TypeError("Invalid label");
    return {
      label: n.label,
      documentation: Ae.fromStrict(n.documentation)
    };
  }
  t.from = e;
  function i(n) {
    return {
      label: n.label,
      documentation: dl(n.documentation) ? Ae.to(n.documentation) : n.documentation
    };
  }
  t.to = i;
})(mm || (mm = {}));
var _m;
(function(t) {
  function e(n) {
    return {
      label: n.label,
      documentation: Ae.fromStrict(n.documentation),
      parameters: Array.isArray(n.parameters) ? n.parameters.map(mm.from) : [],
      activeParameter: n.activeParameter
    };
  }
  t.from = e;
  function i(n) {
    return {
      label: n.label,
      documentation: dl(n.documentation) ? Ae.to(n.documentation) : n.documentation,
      parameters: Array.isArray(n.parameters) ? n.parameters.map(mm.to) : [],
      activeParameter: n.activeParameter
    };
  }
  t.to = i;
})(_m || (_m = {}));
var Uh;
(function(t) {
  function e(n) {
    return {
      activeSignature: n.activeSignature,
      activeParameter: n.activeParameter,
      signatures: Array.isArray(n.signatures) ? n.signatures.map(_m.from) : []
    };
  }
  t.from = e;
  function i(n) {
    return {
      activeSignature: n.activeSignature,
      activeParameter: n.activeParameter,
      signatures: Array.isArray(n.signatures) ? n.signatures.map(_m.to) : []
    };
  }
  t.to = i;
})(Uh || (Uh = {}));
var Hb;
(function(t) {
  function e(i, n) {
    const r = new Pg(at.to(n.position), typeof n.label == "string" ? n.label : n.label.map(Bb.to.bind(void 0, i)), n.kind && vm.to(n.kind));
    return r.textEdits = n.textEdits && n.textEdits.map(hi.to), r.tooltip = dl(n.tooltip) ? Ae.to(n.tooltip) : n.tooltip, r.paddingLeft = n.paddingLeft, r.paddingRight = n.paddingRight, r;
  }
  t.to = e;
})(Hb || (Hb = {}));
var Bb;
(function(t) {
  function e(i, n) {
    const r = new Tg(n.label);
    return r.tooltip = dl(n.tooltip) ? Ae.to(n.tooltip) : n.tooltip, Gv.is(n.command) && (r.command = i.fromInternal(n.command)), n.location && (r.location = an.to(n.location)), r;
  }
  t.to = e;
})(Bb || (Bb = {}));
var vm;
(function(t) {
  function e(n) {
    return n;
  }
  t.from = e;
  function i(n) {
    return n;
  }
  t.to = i;
})(vm || (vm = {}));
var La;
(function(t) {
  function e(n) {
    return {
      range: z.from(n.range),
      url: n.target,
      tooltip: n.tooltip
    };
  }
  t.from = e;
  function i(n) {
    let r;
    if (n.url)
      try {
        r = typeof n.url == "string" ? x.parse(n.url, !0) : x.revive(n.url);
      } catch {
      }
    const s = new Lg(z.to(n.range), r);
    return s.tooltip = n.tooltip, s;
  }
  t.to = i;
})(La || (La = {}));
var wm;
(function(t) {
  function e(n) {
    const r = new Mg(n.label);
    return n.textEdit && (r.textEdit = hi.to(n.textEdit)), n.additionalTextEdits && (r.additionalTextEdits = n.additionalTextEdits.map((s) => hi.to(s))), r;
  }
  t.to = e;
  function i(n) {
    return {
      label: n.label,
      textEdit: n.textEdit ? hi.from(n.textEdit) : void 0,
      additionalTextEdits: n.additionalTextEdits ? n.additionalTextEdits.map((r) => hi.from(r)) : void 0
    };
  }
  t.from = i;
})(wm || (wm = {}));
var ou;
(function(t) {
  function e(n) {
    return new Jc(n[0], n[1], n[2], n[3]);
  }
  t.to = e;
  function i(n) {
    return [n.red, n.green, n.blue, n.alpha];
  }
  t.from = i;
})(ou || (ou = {}));
var Wb;
(function(t) {
  function e(n) {
    return { range: z.from(n.range) };
  }
  t.from = e;
  function i(n) {
    return new ch(z.to(n.range));
  }
  t.to = i;
})(Wb || (Wb = {}));
var bm;
(function(t) {
  function e(i) {
    switch (i) {
      case jl.AUTO:
        return mc.AfterDelay;
      case jl.EXPLICIT:
        return mc.Manual;
      case jl.FOCUS_CHANGE:
      case jl.WINDOW_CHANGE:
        return mc.FocusOut;
    }
  }
  t.to = e;
})(bm || (bm = {}));
var Sc;
(function(t) {
  function e(n) {
    switch (n) {
      case rr.Off:
        return Mi.Off;
      case rr.Relative:
        return Mi.Relative;
      case rr.Interval:
        return Mi.Interval;
      case rr.On:
      default:
        return Mi.On;
    }
  }
  t.from = e;
  function i(n) {
    switch (n) {
      case Mi.Off:
        return rr.Off;
      case Mi.Relative:
        return rr.Relative;
      case Mi.Interval:
        return rr.Interval;
      case Mi.On:
      default:
        return rr.On;
    }
  }
  t.to = i;
})(Sc || (Sc = {}));
var au;
(function(t) {
  function e(n) {
    if (n === fr.CRLF)
      return Vl.CRLF;
    if (n === fr.LF)
      return Vl.LF;
  }
  t.from = e;
  function i(n) {
    if (n === Vl.CRLF)
      return fr.CRLF;
    if (n === Vl.LF)
      return fr.LF;
  }
  t.to = i;
})(au || (au = {}));
var ym;
(function(t) {
  function e(i) {
    if (typeof i == "object")
      return i.viewId;
    switch (i) {
      case xo.SourceControl:
        return pd.Scm;
      case xo.Window:
        return pd.Window;
      case xo.Notification:
        return pd.Notification;
    }
    throw new Error("Unknown 'ProgressLocation'");
  }
  t.from = e;
})(ym || (ym = {}));
var xm;
(function(t) {
  function e(n) {
    const r = { start: n.start + 1, end: n.end + 1 };
    return n.kind && (r.kind = Em.from(n.kind)), r;
  }
  t.from = e;
  function i(n) {
    const r = { start: n.start - 1, end: n.end - 1 };
    return n.kind && (r.kind = Em.to(n.kind)), r;
  }
  t.to = i;
})(xm || (xm = {}));
var Em;
(function(t) {
  function e(n) {
    if (n)
      switch (n) {
        case bs.Comment:
          return kl.Comment;
        case bs.Imports:
          return kl.Imports;
        case bs.Region:
          return kl.Region;
      }
  }
  t.from = e;
  function i(n) {
    if (n)
      switch (n.value) {
        case kl.Comment.value:
          return bs.Comment;
        case kl.Imports.value:
          return bs.Imports;
        case kl.Region.value:
          return bs.Region;
      }
  }
  t.to = i;
})(Em || (Em = {}));
var xd;
(function(t) {
  function e(i) {
    if (i)
      return {
        pinned: typeof i.preview == "boolean" ? !i.preview : void 0,
        inactive: i.background,
        preserveFocus: i.preserveFocus,
        selection: typeof i.selection == "object" ? z.from(i.selection) : void 0,
        override: typeof i.override == "boolean" ? X7.id : void 0
      };
  }
  t.from = e;
})(xd || (xd = {}));
var vn;
(function(t) {
  function e(s) {
    return s instanceof wc ? s.toJSON() : typeof s == "string" ? s : i(s) || n(s) ? new wc(s.baseUri ?? s.base, s.pattern).toJSON() : s;
  }
  t.from = e;
  function i(s) {
    const o = s;
    return o ? x.isUri(o.baseUri) && typeof o.pattern == "string" : !1;
  }
  function n(s) {
    const o = s;
    return o ? typeof o.base == "string" && typeof o.pattern == "string" : !1;
  }
  function r(s) {
    return typeof s == "string" ? s : new wc(x.revive(s.baseUri), s.pattern);
  }
  t.to = r;
})(vn || (vn = {}));
var Vb;
(function(t) {
  function e(i) {
    if (i) {
      if (Array.isArray(i))
        return i.map(e);
      if (typeof i == "string")
        return i;
      {
        const n = i;
        return {
          language: n.language,
          scheme: n.scheme,
          pattern: vn.from(n.pattern) ?? void 0,
          exclusive: n.exclusive,
          notebookType: n.notebookType
        };
      }
    } else return;
  }
  t.from = e;
})(Vb || (Vb = {}));
var Jr;
(function(t) {
  function e(n) {
    return { start: n.start, end: n.end };
  }
  t.from = e;
  function i(n) {
    return new Wr(n.start, n.end);
  }
  t.to = i;
})(Jr || (Jr = {}));
var lu;
(function(t) {
  function e(n) {
    return {
      timing: typeof n.runStartTime == "number" && typeof n.runEndTime == "number" ? { startTime: n.runStartTime, endTime: n.runEndTime } : void 0,
      executionOrder: n.executionOrder,
      success: n.lastRunSuccess
    };
  }
  t.to = e;
  function i(n) {
    return {
      lastRunSuccess: n.success,
      runStartTime: n.timing?.startTime,
      runEndTime: n.timing?.endTime,
      executionOrder: n.executionOrder
    };
  }
  t.from = i;
})(lu || (lu = {}));
var $h;
(function(t) {
  function e(n) {
    switch (n) {
      case va.Markup:
        return Ql.Markup;
      case va.Code:
      default:
        return Ql.Code;
    }
  }
  t.from = e;
  function i(n) {
    switch (n) {
      case Ql.Markup:
        return va.Markup;
      case Ql.Code:
      default:
        return va.Code;
    }
  }
  t.to = i;
})($h || ($h = {}));
var Zs;
(function(t) {
  function e(n) {
    const r = {
      metadata: n.metadata ?? /* @__PURE__ */ Object.create(null),
      cells: []
    };
    for (const s of n.cells)
      Y_.validate(s), r.cells.push(cu.from(s));
    return r;
  }
  t.from = e;
  function i(n) {
    const r = new eP(n.cells.map(cu.to));
    return n4(n.metadata) || (r.metadata = n.metadata), r;
  }
  t.to = i;
})(Zs || (Zs = {}));
var cu;
(function(t) {
  function e(n) {
    return {
      cellKind: $h.from(n.kind),
      language: n.languageId,
      mime: n.mime,
      source: n.value,
      metadata: n.metadata,
      internalMetadata: lu.from(n.executionSummary ?? {}),
      outputs: n.outputs ? n.outputs.map(Po.from) : []
    };
  }
  t.from = e;
  function i(n) {
    return new Y_($h.to(n.cellKind), n.source, n.language, n.mime, n.outputs ? n.outputs.map(Po.to) : void 0, n.metadata, n.internalMetadata ? lu.to(n.internalMetadata) : void 0);
  }
  t.to = i;
})(cu || (cu = {}));
var uu;
(function(t) {
  function e(n) {
    return {
      mime: n.mime,
      valueBytes: ue.wrap(n.data)
    };
  }
  t.from = e;
  function i(n) {
    return new tP(n.valueBytes.buffer, n.mime);
  }
  t.to = i;
})(uu || (uu = {}));
var Po;
(function(t) {
  function e(n) {
    return {
      outputId: n.id,
      items: n.items.map(uu.from),
      metadata: n.metadata
    };
  }
  t.from = e;
  function i(n) {
    const r = n.items.map(uu.to);
    return new Kg(r, n.outputId, n.metadata);
  }
  t.to = i;
})(Po || (Po = {}));
var Sm;
(function(t) {
  function e(r) {
    return n(r) ? {
      include: vn.from(r.include) ?? void 0,
      exclude: vn.from(r.exclude) ?? void 0
    } : vn.from(r) ?? void 0;
  }
  t.from = e;
  function i(r) {
    return n(r) ? {
      include: vn.to(r.include),
      exclude: vn.to(r.exclude)
    } : vn.to(r);
  }
  t.to = i;
  function n(r) {
    const s = r;
    return s ? !ni(s.include) && !ni(s.exclude) : !1;
  }
})(Sm || (Sm = {}));
var zb;
(function(t) {
  function e(i, n, r) {
    const s = typeof i.command == "string" ? { title: "", command: i.command } : i.command;
    return {
      alignment: i.alignment === Jg.Left ? ug.Left : ug.Right,
      command: n.toInternal(s, r),
      text: i.text,
      tooltip: i.tooltip,
      accessibilityInformation: i.accessibilityInformation,
      priority: i.priority
    };
  }
  t.from = e;
})(zb || (zb = {}));
var qb;
(function(t) {
  function e(i, n, r) {
    const s = typeof i.command == "string" ? { title: "", command: i.command } : i.command;
    return {
      command: n.toInternal(s, r),
      label: i.label,
      description: i.description,
      detail: i.detail,
      documentation: i.documentation
    };
  }
  t.from = e;
})(qb || (qb = {}));
var jb;
(function(t) {
  function e(i) {
    return {
      transientOutputs: i?.transientOutputs ?? !1,
      transientCellMetadata: i?.transientCellMetadata ?? {},
      transientDocumentMetadata: i?.transientDocumentMetadata ?? {},
      cellContentMetadata: i?.cellContentMetadata ?? {}
    };
  }
  t.from = e;
})(jb || (jb = {}));
var Dm;
(function(t) {
  function e(n) {
    return {
      uri: n.uri,
      provides: n.provides
    };
  }
  t.from = e;
  function i(n) {
    return new iP(x.revive(n.uri), n.provides);
  }
  t.to = i;
})(Dm || (Dm = {}));
var du;
(function(t) {
  function e(n) {
    return {
      message: Ae.fromStrict(n.message) || "",
      type: mr.Error,
      expected: n.expectedOutput,
      actual: n.actualOutput,
      contextValue: n.contextValue,
      location: n.location && { range: z.from(n.location.range), uri: n.location.uri },
      stackTrace: n.stackTrace?.map((r) => ({
        label: r.label,
        position: r.position && at.from(r.position),
        uri: r.uri && x.revive(r.uri).toJSON()
      }))
    };
  }
  t.from = e;
  function i(n) {
    const r = new tm(typeof n.message == "string" ? n.message : Ae.to(n.message));
    return r.actualOutput = n.actual, r.expectedOutput = n.expected, r.contextValue = n.contextValue, r.location = n.location ? an.to(n.location) : void 0, r;
  }
  t.to = i;
})(du || (du = {}));
var wr;
(function(t) {
  t.namespace = dp, t.denamespace = VT;
})(wr || (wr = {}));
var Gb;
(function(t) {
  function e(i) {
    return {
      controllerId: i.controllerId,
      profileId: i.profileId,
      group: hu.from(i.kind)
    };
  }
  t.from = e;
})(Gb || (Gb = {}));
var hu;
(function(t) {
  const e = {
    [Ec.Coverage]: Pi.Coverage,
    [Ec.Debug]: Pi.Debug,
    [Ec.Run]: Pi.Run
  };
  function i(n) {
    return e.hasOwnProperty(n) ? e[n] : Pi.Run;
  }
  t.from = i;
})(hu || (hu = {}));
var Ao;
(function(t) {
  function e(n) {
    const r = J_(n).controllerId;
    return {
      extId: Ne.fromExtHostTestItem(n, r).toString(),
      label: n.label,
      uri: x.revive(n.uri),
      busy: n.busy,
      tags: n.tags.map((s) => wr.namespace(r, s.id)),
      range: ut.lift(z.from(n.range)),
      description: n.description || null,
      sortText: n.sortText || null,
      error: n.error && Ae.fromStrict(n.error) || null
    };
  }
  t.from = e;
  function i(n) {
    return {
      parent: void 0,
      error: void 0,
      id: Ne.fromString(n.extId).localId,
      label: n.label,
      uri: x.revive(n.uri),
      tags: (n.tags || []).map((r) => {
        const { tagId: s } = wr.denamespace(r);
        return new Ih(s);
      }),
      children: {
        add: () => {
        },
        delete: () => {
        },
        forEach: () => {
        },
        *[Symbol.iterator]() {
        },
        get: () => {
        },
        replace: () => {
        },
        size: 0
      },
      range: z.to(n.range || void 0),
      canResolveChildren: !1,
      busy: n.busy,
      description: n.description || void 0,
      sortText: n.sortText || void 0
    };
  }
  t.toPlain = i;
})(Ao || (Ao = {}));
(function(t) {
  function e(n) {
    return { id: n.id };
  }
  t.from = e;
  function i(n) {
    return new Ih(n.id);
  }
  t.to = i;
})(wr || (wr = {}));
var Qb;
(function(t) {
  const e = (n, r) => {
    const s = n.value;
    if (!s)
      return;
    const o = {
      ...Ao.toPlain(s.item),
      parent: r,
      taskStates: s.tasks.map((a) => ({
        state: a.state,
        duration: a.duration,
        messages: a.messages.filter((l) => l.type === mr.Error).map(du.to)
      })),
      children: []
    };
    if (n.children)
      for (const a of n.children.values()) {
        const l = e(a, o);
        l && o.children.push(l);
      }
    return o;
  };
  function i(n) {
    const r = new AL();
    for (const a of n.items)
      r.insert(Ne.fromString(a.item.extId).path, a);
    const s = [r.nodes], o = [];
    for (; s.length; )
      for (const a of s.pop())
        a.value ? o.push(a) : a.children && s.push(a.children.values());
    return {
      completedAt: n.completedAt,
      results: o.map((a) => e(a)).filter(Tn)
    };
  }
  t.to = i;
})(Qb || (Qb = {}));
var Hh;
(function(t) {
  function e(a) {
    return { covered: a.covered, total: a.total };
  }
  function i(a) {
    return "line" in a ? at.from(a) : z.from(a);
  }
  function n(a) {
    if (a)
      return "endLineNumber" in a ? z.to(a) : at.to(a);
  }
  function r(a) {
    if (a.type === Ca.Statement) {
      const l = [];
      if (a.branches)
        for (const c of a.branches)
          l.push({
            executed: c.count,
            location: n(c.location),
            label: c.label
          });
      return new rP(a.count, n(a.location), a.branches?.map((c) => new sP(c.count, n(c.location), c.label)));
    } else
      return new oP(a.name, a.count, n(a.location));
  }
  t.to = r;
  function s(a) {
    if (typeof a.executed == "number" && a.executed < 0)
      throw new Error(`Invalid coverage count ${a.executed}`);
    return "branches" in a ? {
      count: a.executed,
      location: i(a.location),
      type: Ca.Statement,
      branches: a.branches.length ? a.branches.map(
        (l) => ({ count: l.executed, location: l.location && i(l.location), label: l.label })
      ) : void 0
    } : {
      type: Ca.Declaration,
      name: a.name,
      count: a.executed,
      location: i(a.location)
    };
  }
  t.fromDetails = s;
  function o(a, l, c) {
    return mp(c.statementCoverage), mp(c.branchCoverage), mp(c.declarationCoverage), {
      id: l,
      uri: c.uri,
      statement: e(c.statementCoverage),
      branch: c.branchCoverage && e(c.branchCoverage),
      declaration: c.declarationCoverage && e(c.declarationCoverage),
      testIds: c instanceof tu && c.includesTests.length ? c.includesTests.map((u) => Ne.fromExtHostTestItem(u, a).toString()) : void 0
    };
  }
  t.fromFile = o;
})(Hh || (Hh = {}));
var Kb;
(function(t) {
  function e(i) {
    switch (i) {
      case eg.Invoke:
        return ah.Invoke;
      case eg.Auto:
        return ah.Automatic;
    }
  }
  t.to = e;
})(Kb || (Kb = {}));
var Na;
(function(t) {
  function e(n) {
    const r = new Zx(jn.to(n.kind), n.name, n.detail || "", x.revive(n.uri), z.to(n.range), z.to(n.selectionRange));
    return r._sessionId = n._sessionId, r._itemId = n._itemId, r;
  }
  t.to = e;
  function i(n, r, s) {
    if (r = r ?? n._sessionId, s = s ?? n._itemId, r === void 0 || s === void 0)
      throw new Error("invalid item");
    return {
      _sessionId: r,
      _itemId: s,
      kind: jn.from(n.kind),
      name: n.name,
      detail: n.detail ?? "",
      uri: n.uri,
      range: z.from(n.range),
      selectionRange: z.from(n.selectionRange),
      tags: n.tags?.map(Os.from)
    };
  }
  t.from = i;
})(Na || (Na = {}));
var km;
(function(t) {
  function e(i) {
    if (i)
      return {
        value: i.value,
        tooltip: i.tooltip
      };
  }
  t.from = e;
})(km || (km = {}));
var Ma;
(function(t) {
  function e(s, o, a) {
    const l = o.fileData;
    return l ? new e6(new t6(l.name, x.revive(l.uri), l.id, vx(() => a(l.id)))) : s === gr.uriList && o.uriListData ? new $g(r(o.uriListData)) : new $g(o.asString);
  }
  t.to = e;
  async function i(s, o, a = on()) {
    const l = await o.asString();
    if (s === gr.uriList)
      return {
        id: a,
        asString: l,
        fileData: void 0,
        uriListData: n(l)
      };
    const c = o.asFile();
    return {
      id: a,
      asString: l,
      fileData: c ? {
        name: c.name,
        uri: c.uri,
        id: c._itemId ?? c.id
      } : void 0
    };
  }
  t.from = i;
  function n(s) {
    return $v.split(s).map((o) => {
      if (o.startsWith("#"))
        return o;
      try {
        return x.parse(o);
      } catch {
      }
      return o;
    });
  }
  function r(s) {
    return $v.create(s.map((o) => typeof o == "string" ? o : x.revive(o)));
  }
})(Ma || (Ma = {}));
var fu;
(function(t) {
  function e(r, s) {
    const o = r.items.map(([a, l]) => [a, Ma.to(a, l, s)]);
    return new Xc(o);
  }
  t.toDataTransfer = e;
  async function i(r) {
    return { items: await Promise.all(Array.from(r, async ([o, a]) => [o, await Ma.from(o, a)])) };
  }
  t.from = i;
  async function n(r) {
    return { items: await Promise.all(Array.from(r, async ([o, a]) => [o, await Ma.from(o, a, a.id)])) };
  }
  t.fromList = n;
})(fu || (fu = {}));
var Im;
(function(t) {
  function e(n, r) {
    return {
      kind: "reply",
      agentId: n.participant ?? r?.agentId ?? "",
      subCommand: n.command ?? r?.command,
      message: n.prompt,
      title: n.label
    };
  }
  t.from = e;
  function i(n) {
    return {
      prompt: n.message,
      label: n.title,
      participant: n.agentId,
      command: n.subCommand
    };
  }
  t.to = i;
})(Im || (Im = {}));
var pu;
(function(t) {
  function e(n) {
    switch (n) {
      case ps.System:
        return _n.System;
      case ps.User:
        return _n.User;
      case ps.Assistant:
        return _n.Assistant;
    }
  }
  t.to = e;
  function i(n) {
    switch (n) {
      case _n.System:
        return ps.System;
      case _n.User:
        return ps.User;
      case _n.Assistant:
        return ps.Assistant;
    }
    return ps.User;
  }
  t.from = i;
})(pu || (pu = {}));
var vk;
(function(t) {
  function e(n) {
    const r = n.content.map((a) => {
      if (a.type === "text")
        return new Ut(a.value, a.audience);
      if (a.type === "tool_result") {
        const l = a.value.map((c) => c.type === "text" ? new Ut(c.value, c.audience) : new ts(c.value));
        return new am(a.toolCallId, l, a.isError);
      } else {
        if (a.type === "image_url")
          return;
        if (a.type === "tool_use")
          return new rl(a.toolCallId, a.name, a.parameters);
      }
    }).filter((a) => a !== void 0), s = pu.to(n.role);
    return new vP(s, r, n.name);
  }
  t.to = e;
  function i(n) {
    const r = pu.from(n.role), s = n.name;
    let o = n.content;
    typeof o == "string" && (o = [new Ut(o)]);
    const a = o.map((l) => {
      if (l instanceof am)
        return {
          type: "tool_result",
          toolCallId: l.callId,
          value: Kt(l.content.map((c) => c instanceof Ut ? {
            type: "text",
            value: c.value,
            audience: c.audience
          } : c instanceof ts ? {
            type: "prompt_tsx",
            value: c.value
          } : void 0)),
          isError: l.isError
        };
      if (l instanceof rl)
        return {
          type: "tool_use",
          toolCallId: l.callId,
          name: l.name,
          parameters: l.input
        };
      if (l instanceof Ut)
        return {
          type: "text",
          value: l.value
        };
      if (typeof l != "string")
        throw new Error("Unexpected chat message content type");
      return {
        type: "text",
        value: l
      };
    });
    return {
      role: r,
      name: s,
      content: a
    };
  }
  t.from = i;
})(vk || (vk = {}));
var Cm;
(function(t) {
  function e(n) {
    const r = n.content.map((a) => {
      if (a.type === "text")
        return new Ut(a.value, a.audience);
      if (a.type === "tool_result") {
        const l = a.value.map((c) => c.type === "text" ? new Ut(c.value, c.audience) : c.type === "data" ? new wn(c.value.data.buffer, c.value.mimeType) : new ts(c.value));
        return new cb(a.toolCallId, l, a.isError);
      } else return a.type === "image_url" ? new wn(a.value.data.buffer, a.value.mimeType) : a.type === "data" ? new wn(a.data.buffer, a.mimeType) : new rl(a.toolCallId, a.name, a.parameters);
    }), s = pu.to(n.role);
    return new wP(s, r, n.name);
  }
  t.to = e;
  function i(n) {
    const r = pu.from(n.role), s = n.name;
    let o = n.content;
    typeof o == "string" && (o = [new Ut(o)]);
    const a = o.map((l) => {
      if (l instanceof cb || l instanceof am)
        return {
          type: "tool_result",
          toolCallId: l.callId,
          value: Kt(l.content.map((c) => c instanceof Ut ? {
            type: "text",
            value: c.value,
            audience: c.audience
          } : c instanceof ts ? {
            type: "prompt_tsx",
            value: c.value
          } : c instanceof wn ? {
            type: "data",
            value: {
              mimeType: c.mimeType,
              data: ue.wrap(c.data)
            },
            audience: c.audience
          } : void 0)),
          isError: l.isError
        };
      if (l instanceof wn)
        return G6(l) ? {
          type: "image_url",
          value: {
            mimeType: l.mimeType,
            data: ue.wrap(l.data)
          }
        } : {
          type: "data",
          mimeType: l.mimeType,
          data: ue.wrap(l.data),
          audience: l.audience
        };
      if (l instanceof rl)
        return {
          type: "tool_use",
          toolCallId: l.callId,
          name: l.name,
          parameters: l.input
        };
      if (l instanceof Ut)
        return {
          type: "text",
          value: l.value
        };
      if (typeof l != "string")
        throw new Error("Unexpected chat message content type llm 2");
      return {
        type: "text",
        value: l
      };
    });
    return {
      role: r,
      name: s,
      content: a
    };
  }
  t.from = i;
})(Cm || (Cm = {}));
function G6(t) {
  switch (t.mimeType) {
    case uo.PNG:
    case uo.JPEG:
    case uo.GIF:
    case uo.WEBP:
    case uo.BMP:
      return !0;
    default:
      return !1;
  }
}
var Bh;
(function(t) {
  function e(n) {
    return {
      kind: "markdownContent",
      content: Ae.from(n.value)
    };
  }
  t.from = e;
  function i(n) {
    return new X_(Ae.to(n.content));
  }
  t.to = i;
})(Bh || (Bh = {}));
var Tm;
(function(t) {
  function e(n) {
    return {
      kind: "codeblockUri",
      uri: n.value,
      isEdit: n.isEdit
    };
  }
  t.from = e;
  function i(n) {
    return new t1(x.revive(n.uri), n.isEdit);
  }
  t.to = i;
})(Tm || (Tm = {}));
var Pm;
(function(t) {
  function e(n) {
    return {
      kind: "markdownVuln",
      content: Ae.from(n.value),
      vulnerabilities: n.vulnerabilities
    };
  }
  t.from = e;
  function i(n) {
    return new Th(Ae.to(n.content), n.vulnerabilities);
  }
  t.to = i;
})(Pm || (Pm = {}));
var Am;
(function(t) {
  function e(i) {
    return {
      kind: "confirmation",
      title: i.title,
      message: Ae.from(i.message),
      data: i.data,
      buttons: i.buttons
    };
  }
  t.from = e;
})(Am || (Am = {}));
var Wh;
(function(t) {
  function e(n) {
    const { value: r, baseUri: s } = n;
    function o(a, l) {
      return a.map((c) => {
        const u = x.joinPath(l, c.name);
        return {
          label: c.name,
          uri: u,
          children: c.children && o(c.children, u)
        };
      });
    }
    return {
      kind: "treeData",
      treeData: {
        label: Fs(s),
        uri: s,
        children: o(r, s)
      }
    };
  }
  t.from = e;
  function i(n) {
    const r = Fi(n.treeData);
    function s(l) {
      return l.map((c) => ({
        name: c.label,
        children: c.children && s(c.children)
      }));
    }
    const o = r.uri, a = r.children ? s(r.children) : [];
    return new Z_(a, o);
  }
  t.to = i;
})(Wh || (Wh = {}));
var Jb;
(function(t) {
  function e(n) {
    return {
      kind: "multiDiffData",
      multiDiffData: {
        title: n.title,
        resources: n.value.map((r) => ({
          originalUri: r.originalUri,
          modifiedUri: r.modifiedUri,
          goToFileUri: r.goToFileUri
        }))
      }
    };
  }
  t.from = e;
  function i(n) {
    const r = n.multiDiffData.resources.map((s) => ({
      originalUri: s.originalUri ? x.revive(s.originalUri) : void 0,
      modifiedUri: s.modifiedUri ? x.revive(s.modifiedUri) : void 0,
      goToFileUri: s.goToFileUri ? x.revive(s.goToFileUri) : void 0
    }));
    return new rE(r, n.multiDiffData.title);
  }
  t.to = i;
})(Jb || (Jb = {}));
var gu;
(function(t) {
  function e(n) {
    const r = (o) => x.isUri(o), s = (o) => "name" in o;
    return {
      kind: "inlineReference",
      name: n.title,
      inlineReference: r(n.value) ? n.value : s(n.value) ? ol.from(n.value) : Kr.from(n.value)
    };
  }
  t.from = e;
  function i(n) {
    const r = Fi(n);
    return new Ph(x.isUri(r.inlineReference) ? r.inlineReference : "location" in r.inlineReference ? ol.to(r.inlineReference) : Kr.to(r.inlineReference), n.name);
  }
  t.to = i;
})(gu || (gu = {}));
var Vh;
(function(t) {
  function e(n) {
    return {
      kind: "progressMessage",
      content: Ae.from(n.value)
    };
  }
  t.from = e;
  function i(n) {
    return new sE(n.content.value);
  }
  t.to = i;
})(Vh || (Vh = {}));
var zh;
(function(t) {
  function e(n) {
    return {
      kind: "warning",
      content: Ae.from(n.value)
    };
  }
  t.from = e;
  function i(n) {
    return new Ah(n.content.value);
  }
  t.to = i;
})(zh || (zh = {}));
var Yb;
(function(t) {
  function e(i) {
    return {
      kind: "extensions",
      extensions: i.extensions
    };
  }
  t.from = e;
})(Yb || (Yb = {}));
var Xb;
(function(t) {
  function e(i) {
    return {
      kind: "pullRequest",
      author: i.author,
      title: i.title,
      description: i.description,
      uri: i.uri,
      linkTag: i.linkTag
    };
  }
  t.from = e;
})(Xb || (Xb = {}));
var Zb;
(function(t) {
  function e(n) {
    return {
      kind: "move",
      uri: n.uri,
      range: z.from(n.range)
    };
  }
  t.from = e;
  function i(n) {
    return new i1(x.revive(n.uri), z.to(n.range));
  }
  t.to = i;
})(Zb || (Zb = {}));
var qh;
(function(t) {
  function e(n) {
    return {
      kind: "prepareToolInvocation",
      toolName: n.toolName
    };
  }
  t.from = e;
  function i(n) {
    return new Lh(n.toolName);
  }
  t.to = i;
})(qh || (qh = {}));
var ey;
(function(t) {
  function e(s) {
    return {
      kind: "toolInvocationSerialized",
      toolCallId: s.toolCallId,
      toolId: s.toolName,
      invocationMessage: s.invocationMessage ? Ae.from(s.invocationMessage) : s.toolName,
      originMessage: s.originMessage ? Ae.from(s.originMessage) : void 0,
      pastTenseMessage: s.pastTenseMessage ? Ae.from(s.pastTenseMessage) : void 0,
      isConfirmed: s.isConfirmed,
      isComplete: s.isComplete ?? !0,
      isError: s.isError ?? !1,
      resultDetails: void 0,
      toolSpecificData: s.toolSpecificData ? i(s.toolSpecificData) : void 0,
      presentation: void 0
    };
  }
  t.from = e;
  function i(s) {
    return "command" in s && "language" in s ? {
      kind: "terminal",
      command: s.command,
      language: s.language
    } : "commandLine" in s && "language" in s ? {
      kind: "terminal",
      commandLine: s.commandLine,
      language: s.language
    } : s;
  }
  function n(s) {
    const o = new lE(s.toolId || s.toolName, s.toolCallId, s.isError);
    return s.invocationMessage && (o.invocationMessage = s.invocationMessage), s.originMessage && (o.originMessage = s.originMessage), s.pastTenseMessage && (o.pastTenseMessage = s.pastTenseMessage), s.isConfirmed !== void 0 && (o.isConfirmed = s.isConfirmed), s.isComplete !== void 0 && (o.isComplete = s.isComplete), s.toolSpecificData && (o.toolSpecificData = r(s.toolSpecificData)), o;
  }
  t.to = n;
  function r(s) {
    return s.kind === "terminal" ? {
      command: s.command,
      language: s.language
    } : s.kind === "terminal2" ? {
      commandLine: s.commandLine,
      language: s.language
    } : s;
  }
})(ey || (ey = {}));
var Rm;
(function(t) {
  function e(i) {
    return {
      kind: "progressTask",
      content: Ae.from(i.value)
    };
  }
  t.from = e;
})(Rm || (Rm = {}));
var ty;
(function(t) {
  function e(i) {
    return {
      kind: "progressTaskResult",
      content: typeof i == "string" ? Ae.from(i) : void 0
    };
  }
  t.from = e;
})(ty || (ty = {}));
var jh;
(function(t) {
  function e(n, r, s) {
    return {
      kind: "command",
      command: r.toInternal(n.value, s) ?? { command: n.value.command, title: n.value.title }
    };
  }
  t.from = e;
  function i(n, r) {
    return new e1(r.fromInternal(n.command) ?? { command: n.command.id, title: n.command.title });
  }
  t.to = i;
})(jh || (jh = {}));
var Lm;
(function(t) {
  function e(n) {
    return {
      kind: "textEdit",
      uri: n.uri,
      edits: n.edits.map((r) => hi.from(r)),
      done: n.isDone
    };
  }
  t.from = e;
  function i(n) {
    const r = new Rh(x.revive(n.uri), n.edits.map((s) => hi.to(s)));
    return r.isDone = n.done, r;
  }
  t.to = i;
})(Lm || (Lm = {}));
var Nm;
(function(t) {
  function e(i) {
    return i.newCellMetadata ? {
      editType: bo.Metadata,
      index: i.range.start,
      metadata: i.newCellMetadata
    } : i.newNotebookMetadata ? {
      editType: bo.DocumentMetadata,
      metadata: i.newNotebookMetadata
    } : {
      editType: bo.Replace,
      index: i.range.start,
      count: i.range.end - i.range.start,
      cells: i.newCells.map(cu.from)
    };
  }
  t.from = e;
})(Nm || (Nm = {}));
var Mm;
(function(t) {
  function e(i) {
    return {
      kind: "notebookEdit",
      uri: i.uri,
      edits: i.edits.map(Nm.from),
      done: i.isDone
    };
  }
  t.from = e;
})(Mm || (Mm = {}));
var Oa;
(function(t) {
  function e(n) {
    const r = oi.isThemeIcon(n.iconPath) ? n.iconPath : x.isUri(n.iconPath) ? { light: x.revive(n.iconPath) } : n.iconPath && "light" in n.iconPath && "dark" in n.iconPath && x.isUri(n.iconPath.light) && x.isUri(n.iconPath.dark) ? { light: x.revive(n.iconPath.light), dark: x.revive(n.iconPath.dark) } : void 0;
    return typeof n.value == "object" && "variableName" in n.value ? {
      kind: "reference",
      reference: {
        variableName: n.value.variableName,
        value: x.isUri(n.value.value) || !n.value.value ? n.value.value : Kr.from(n.value.value)
      },
      iconPath: r,
      options: n.options
    } : {
      kind: "reference",
      reference: x.isUri(n.value) || typeof n.value == "string" ? n.value : Kr.from(n.value),
      iconPath: r,
      options: n.options
    };
  }
  t.from = e;
  function i(n) {
    const r = Fi(n), s = (o) => x.isUri(o) ? o : Kr.to(o);
    return new Ra(typeof r.reference == "string" ? r.reference : "variableName" in r.reference ? {
      variableName: r.reference.variableName,
      value: r.reference.value && s(r.reference.value)
    } : s(r.reference));
  }
  t.to = i;
})(Oa || (Oa = {}));
var Om;
(function(t) {
  function e(i) {
    return {
      kind: "codeCitation",
      value: i.value,
      license: i.license,
      snippet: i.snippet
    };
  }
  t.from = e;
})(Om || (Om = {}));
var Gh;
(function(t) {
  function e(r, s, o) {
    return r instanceof X_ ? Bh.from(r) : r instanceof Ph ? gu.from(r) : r instanceof Ra ? Oa.from(r) : r instanceof sE ? Vh.from(r) : r instanceof Z_ ? Wh.from(r) : r instanceof rE ? Jb.from(r) : r instanceof e1 ? jh.from(r, s, o) : r instanceof Rh ? Lm.from(r) : r instanceof sm ? Mm.from(r) : r instanceof Th ? Pm.from(r) : r instanceof t1 ? Tm.from(r) : r instanceof Ah ? zh.from(r) : r instanceof nm ? Am.from(r) : r instanceof rm ? Om.from(r) : r instanceof i1 ? Zb.from(r) : r instanceof oE ? Yb.from(r) : r instanceof Lh ? qh.from(r) : r instanceof aE ? Xb.from(r) : r instanceof lE ? ey.from(r) : {
      kind: "markdownContent",
      content: Ae.from("")
    };
  }
  t.from = e;
  function i(r, s) {
    switch (r.kind) {
      case "reference":
        return Oa.to(r);
      case "markdownContent":
      case "inlineReference":
      case "progressMessage":
      case "treeData":
      case "command":
        return n(r, s);
    }
  }
  t.to = i;
  function n(r, s) {
    switch (r.kind) {
      case "markdownContent":
        return Bh.to(r);
      case "inlineReference":
        return gu.to(r);
      case "progressMessage":
        return;
      case "treeData":
        return Wh.to(r);
      case "command":
        return jh.to(r, s);
    }
  }
  t.toContent = n;
})(Gh || (Gh = {}));
var Qh;
(function(t) {
  function e(i, n, r, s, o, a, l) {
    const c = [], u = [];
    for (const f of i.variables.variables)
      f.kind === "tool" ? c.push(f) : f.kind === "toolset" ? c.push(...f.value) : u.push(f);
    const d = {
      id: i.requestId,
      prompt: i.message,
      command: i.command,
      attempt: i.attempt ?? 0,
      enableCommandDetection: i.enableCommandDetection ?? !0,
      isParticipantDetected: i.isParticipantDetected ?? !1,
      references: u.map((f) => Um.to(f, s, l)).filter(Tn),
      toolReferences: c.map(Kh.to),
      location: Fm.to(i.location),
      acceptedConfirmationData: i.acceptedConfirmationData,
      rejectedConfirmationData: i.rejectedConfirmationData,
      location2: n,
      toolInvocationToken: Object.freeze({ sessionId: i.sessionId }),
      tools: o,
      model: r,
      editedFileEvents: i.editedFileEvents,
      modeInstructions: i.modeInstructions
    };
    return lt(a, "chatParticipantPrivate") || (delete d.id, delete d.attempt, delete d.enableCommandDetection, delete d.isParticipantDetected, delete d.location, delete d.location2, delete d.editedFileEvents), lt(a, "chatParticipantAdditions") || (delete d.acceptedConfirmationData, delete d.rejectedConfirmationData, delete d.tools), d;
  }
  t.to = e;
})(Qh || (Qh = {}));
var iy;
(function(t) {
  function e(i) {
    return {
      prompt: i.prompt,
      files: i.files.map((n) => x.revive(n))
    };
  }
  t.to = e;
})(iy || (iy = {}));
var Fm;
(function(t) {
  function e(n) {
    switch (n) {
      case nn.Notebook:
        return sr.Notebook;
      case nn.Terminal:
        return sr.Terminal;
      case nn.Panel:
        return sr.Panel;
      case nn.Editor:
        return sr.Editor;
    }
  }
  t.to = e;
  function i(n) {
    switch (n) {
      case sr.Notebook:
        return nn.Notebook;
      case sr.Terminal:
        return nn.Terminal;
      case sr.Panel:
        return nn.Panel;
      case sr.Editor:
        return nn.Editor;
    }
  }
  t.from = i;
})(Fm || (Fm = {}));
var Um;
(function(t) {
  function e(i, n, r) {
    let s = i.value;
    if (!s) {
      let o;
      try {
        o = JSON.stringify(i);
      } catch {
        o = `kind=${i.kind}, id=${i.id}, name=${i.name}`;
      }
      r.error(`[ChatPromptReference] Ignoring invalid reference in variable: ${o}`);
      return;
    }
    if (Sv(s))
      s = x.revive(s);
    else if (s && typeof s == "object" && "uri" in s && "range" in s && Sv(s.uri))
      s = Kr.to(Fi(s));
    else if (o3(i)) {
      const o = i.references?.[0]?.reference;
      s = new mP(i.mimeType ?? "image/png", () => Promise.resolve(new Uint8Array(Object.values(i.value))), o && x.isUri(o) ? o : void 0);
    } else if (i.kind === "diagnostic") {
      const o = i.filterSeverity && Mh.to(i.filterSeverity), a = i.filterUri && x.revive(i.filterUri).toString();
      s = new _P(n.map(([l, c]) => i.filterUri && l.toString() !== a ? [l, []] : [l, c.filter((u) => !(o && u.severity > o || i.filterRange && !ut.areIntersectingOrTouching(i.filterRange, z.from(u.range))))]).filter(([, l]) => l.length > 0));
    }
    return {
      id: i.id,
      name: i.name,
      range: i.range && [i.range.start, i.range.endExclusive],
      value: s,
      modelDescription: i.modelDescription
    };
  }
  t.to = e;
})(Um || (Um = {}));
var Kh;
(function(t) {
  function e(i) {
    if (i.value)
      throw new Error("Invalid tool reference");
    return {
      name: i.id,
      range: i.range && [i.range.start, i.range.endExclusive]
    };
  }
  t.to = e;
})(Kh || (Kh = {}));
var ny;
(function(t) {
  function e(i, n, r) {
    return {
      id: i.id,
      label: i.label,
      fullName: i.fullName,
      icon: i.icon?.id,
      value: i.values[0].value,
      insertText: i.insertText,
      detail: i.detail,
      documentation: i.documentation,
      command: n.toInternal(i.command, r)
    };
  }
  t.from = e;
})(ny || (ny = {}));
var Dc;
(function(t) {
  function e(r) {
    return {
      errorDetails: r.errorDetails,
      metadata: n(r.metadata),
      nextQuestion: r.nextQuestion,
      details: r.details
    };
  }
  t.to = e;
  function i(r) {
    return {
      errorDetails: r.errorDetails,
      metadata: r.metadata,
      nextQuestion: r.nextQuestion,
      details: r.details
    };
  }
  t.from = i;
  function n(r) {
    return Wc(r, (s) => {
      if (s.$mid === tt.LanguageModelToolResult)
        return new n1(Wc(s.content, n));
      if (s.$mid === tt.LanguageModelTextPart)
        return new Ut(s.value, s.audience);
      if (s.$mid === tt.LanguageModelPromptTsxPart)
        return new ts(s.value);
    });
  }
})(Dc || (Dc = {}));
var ry;
(function(t) {
  function e(i, n, r) {
    if (n.action.kind === "vote")
      return;
    const s = Dc.to(i);
    if (n.action.kind === "command") {
      const o = n.action.commandButton.command;
      return { action: { kind: "command", commandButton: {
        command: r.fromInternal(o) ?? { command: o.id, title: o.title }
      } }, result: s };
    } else return n.action.kind === "followUp" ? { action: { kind: "followUp", followup: Im.to(n.action.followup) }, result: s } : n.action.kind === "inlineChat" ? { action: { kind: "editor", accepted: n.action.action === "accepted" }, result: s } : n.action.kind === "chatEditingSessionAction" ? {
      action: {
        kind: "chatEditingSessionAction",
        outcome: (/* @__PURE__ */ new Map([
          ["accepted", Tr.Accepted],
          ["rejected", Tr.Rejected],
          ["saved", Tr.Saved]
        ])).get(n.action.outcome) ?? Tr.Rejected,
        uri: x.revive(n.action.uri),
        hasRemainingEdits: n.action.hasRemainingEdits
      },
      result: s
    } : n.action.kind === "chatEditingHunkAction" ? {
      action: {
        kind: "chatEditingHunkAction",
        outcome: (/* @__PURE__ */ new Map([
          ["accepted", Tr.Accepted],
          ["rejected", Tr.Rejected]
        ])).get(n.action.outcome) ?? Tr.Rejected,
        uri: x.revive(n.action.uri),
        hasRemainingEdits: n.action.hasRemainingEdits,
        lineCount: n.action.lineCount
      },
      result: s
    } : { action: n.action, result: s };
  }
  t.to = e;
})(ry || (ry = {}));
var $m;
(function(t) {
  function e(i, n, r) {
    return "terminalCommand" in i ? { terminalCommand: i.terminalCommand, shouldExecute: i.shouldExecute } : "uri" in i ? { uri: i.uri } : n.toInternal(i, r);
  }
  t.from = e;
})($m || ($m = {}));
var Hm;
(function(t) {
  function e(i) {
    return {
      ...i,
      documentation: Ae.fromStrict(i.documentation)
    };
  }
  t.from = e;
})(Hm || (Hm = {}));
var sy;
(function(t) {
  function e(i, n) {
    return Array.isArray(i) ? {
      items: i.map((r) => Hm.from(r))
    } : {
      items: i.items.map((r) => Hm.from(r)),
      resourceRequestConfig: i.resourceRequestConfig ? oy.from(i.resourceRequestConfig, n) : void 0
    };
  }
  t.from = e;
})(sy || (sy = {}));
var oy;
(function(t) {
  function e(i, n) {
    return {
      ...i,
      pathSeparator: n,
      cwd: i.cwd
    };
  }
  t.from = e;
})(oy || (oy = {}));
var ay;
(function(t) {
  function e(i) {
    return {
      kind: ly.to(i.kind),
      acceptedLength: i.acceptedLength
    };
  }
  t.to = e;
})(ay || (ay = {}));
var ly;
(function(t) {
  function e(i) {
    switch (i) {
      case ud.Word:
        return pa.Word;
      case ud.Line:
        return pa.Line;
      case ud.Suggest:
        return pa.Suggest;
      default:
        return pa.Unknown;
    }
  }
  t.to = e;
})(ly || (ly = {}));
var cy;
(function(t) {
  function e(i, n) {
    if (i.kind === Zp.Ignored) {
      const r = i.supersededBy ? n(i.supersededBy) : void 0;
      return {
        kind: gc.Ignored,
        supersededBy: r,
        userTypingDisagreed: i.userTypingDisagreed
      };
    } else if (i.kind === Zp.Accepted)
      return {
        kind: gc.Accepted
      };
    return {
      kind: gc.Rejected
    };
  }
  t.to = e;
})(cy || (cy = {}));
var uy;
(function(t) {
  function e(i, n) {
    return {
      id: n,
      label: i.label,
      description: i.description,
      canEdit: i.canEdit,
      collapsibleState: i.collapsibleState || nw.None,
      contextValue: i.contextValue
    };
  }
  t.from = e;
})(uy || (uy = {}));
var dy;
(function(t) {
  function e(i) {
    return i.type === "mcp" ? new xP(i.label, i.serverLabel || i.label, i.instructions) : i.type === "extension" ? new yP(i.extensionId.value, i.label) : void 0;
  }
  t.to = e;
})(dy || (dy = {}));
var wk;
(function(t) {
  function e(n) {
    return new n1(n.content.map((r) => r.kind === "text" ? new Ut(r.value, r.audience) : new ts(r.value)));
  }
  t.to = e;
  function i(n, r) {
    n.toolResultMessage && $(r, "chatParticipantPrivate");
    const s = (o) => {
      o.audience && $(r, "languageModelToolResultAudience");
    };
    return {
      content: n.content.map((o) => {
        if (o instanceof Ut)
          return s(o), {
            kind: "text",
            value: o.value,
            audience: o.audience
          };
        if (o instanceof ts)
          return {
            kind: "promptTsx",
            value: o.value
          };
        throw new Error("Unknown LanguageModelToolResult part type");
      }),
      toolResultMessage: Ae.fromStrict(n.toolResultMessage),
      toolResultDetails: n.toolResultDetails?.map((o) => x.isUri(o) ? o : Kr.from(o))
    };
  }
  t.from = i;
})(wk || (wk = {}));
var Bm;
(function(t) {
  function e(n) {
    return new bP(n.content.map((r) => r.kind === "text" ? new Ut(r.value, r.audience) : r.kind === "data" ? new wn(r.value.data.buffer, r.value.mimeType, r.audience) : new ts(r.value)));
  }
  t.to = e;
  function i(n, r) {
    n.toolResultMessage && $(r, "chatParticipantPrivate");
    const s = (c) => {
      c.audience && $(r, "languageModelToolResultAudience");
    };
    let o = !1, a;
    Array.isArray(n.toolResultDetails) ? a = n.toolResultDetails?.map((c) => x.isUri(c) ? c : Kr.from(c)) : n.toolResultDetails2 && (a = {
      output: {
        type: "data",
        mimeType: n.toolResultDetails2.mime,
        value: ue.wrap(n.toolResultDetails2.value)
      }
    }, o = !0);
    const l = {
      content: n.content.map((c) => {
        if (c instanceof Ut)
          return s(c), {
            kind: "text",
            value: c.value,
            audience: c.audience
          };
        if (c instanceof ts)
          return {
            kind: "promptTsx",
            value: c.value
          };
        if (c instanceof wn)
          return s(c), o = !0, {
            kind: "data",
            value: {
              mimeType: c.mimeType,
              data: ue.wrap(c.data)
            },
            audience: c.audience
          };
        throw new Error("Unknown LanguageModelToolResult part type");
      }),
      toolResultMessage: Ae.fromStrict(n.toolResultMessage),
      toolResultDetails: a
    };
    return o ? new zi(l) : l;
  }
  t.from = i;
})(Bm || (Bm = {}));
var Wm;
(function(t) {
  function e(i) {
    return i;
  }
  t.fromThemeIcon = e;
})(Wm || (Wm = {}));
var hy;
(function(t) {
  function e(n) {
    return {
      query: n.query,
      kind: i(n.kind),
      settings: n.settings
    };
  }
  t.fromSettingsSearchResult = e;
  function i(n) {
    switch (n) {
      case Xs.EMBEDDED:
        return Xs.EMBEDDED;
      case Xs.LLM_RANKED:
        return Xs.LLM_RANKED;
      case Xs.CANCELED:
        return Xs.CANCELED;
      default:
        throw new Error("Unknown AiSettingsSearchResultKind");
    }
  }
})(hy || (hy = {}));
var Ed;
(function(t) {
  function e(n) {
    return !!n.uri;
  }
  function i(n) {
    return Nh.toSerialized(e(n) ? {
      type: sl.HTTP,
      uri: n.uri,
      headers: Object.entries(n.headers)
    } : {
      type: sl.Stdio,
      cwd: n.cwd?.fsPath,
      args: n.args,
      command: n.command,
      env: n.env,
      envFile: void 0
    });
  }
  t.from = i;
})(Ed || (Ed = {}));
class go {
  constructor(e, i, n) {
    this.uri = e, this.ranges = i, this.previewText = n;
  }
}
class hE {
  constructor(e, i, n) {
    this.uri = e, this.text = i, this.lineNumber = n;
  }
}
class fy {
  constructor(e) {
    this.keyword = e;
  }
}
var xs;
(function(t) {
  t[t.None = 1] = "None", t[t.FilesExclude = 2] = "FilesExclude", t[t.SearchAndFilesExclude = 3] = "SearchAndFilesExclude";
})(xs || (xs = {}));
var Vm;
(function(t) {
  t[t.Information = 1] = "Information", t[t.Warning = 2] = "Warning";
})(Vm || (Vm = {}));
const MP = 2e4, OP = "⟪ ", FP = " characters skipped ⟫", Q6 = (OP.length + FP.length + 5) * 2;
var bk;
(function(t) {
  t[t.file = 0] = "file", t[t.text = 1] = "text", t[t.aiText = 2] = "aiText";
})(bk || (bk = {}));
var Fa;
(function(t) {
  t[t.File = 1] = "File", t[t.Text = 2] = "Text", t[t.aiText = 3] = "aiText";
})(Fa || (Fa = {}));
function yk(t) {
  return !!t.rangeLocations && !!t.previewText;
}
var xk;
(function(t) {
  t[t.Normal = 0] = "Normal", t[t.NewSearchStarted = 1] = "NewSearchStarted";
})(xk || (xk = {}));
class K6 {
  constructor(e, i, n, r) {
    this.rangeLocations = [], this.webviewIndex = r;
    const s = Array.isArray(i) ? i : [i];
    if (n && n.matchLines === 1 && J6(s)) {
      e = AR(e, n.matchLines);
      let o = "", a = 0, l = 0;
      const c = Math.floor(n.charsPerLine / 5);
      for (const u of s) {
        const d = Math.max(u.startColumn - c, 0), f = u.startColumn + n.charsPerLine;
        if (d > l + c + Q6) {
          const g = OP + (d - l) + FP;
          o += g + e.slice(d, f), a += d - (l + g.length);
        } else
          o += e.slice(l, f);
        l = f, this.rangeLocations.push({
          source: u,
          preview: new Y6(0, u.startColumn - a, u.endColumn - a)
        });
      }
      this.previewText = o;
    } else {
      const o = Array.isArray(i) ? i[0].startLineNumber : i.startLineNumber, a = mv(i, (l) => ({
        preview: new UP(
          l.startLineNumber - o,
          l.startColumn,
          l.endLineNumber - o,
          l.endColumn
        ),
        source: l
      }));
      this.rangeLocations = Array.isArray(a) ? a : [a], this.previewText = e;
    }
  }
}
function J6(t) {
  const e = t[0].startLineNumber;
  for (const i of t)
    if (i.startLineNumber !== e || i.endLineNumber !== e)
      return !1;
  return !0;
}
class UP {
  constructor(e, i, n, r) {
    this.startLineNumber = e, this.startColumn = i, this.endLineNumber = n, this.endColumn = r;
  }
}
class Y6 extends UP {
  constructor(e, i, n) {
    super(e, i, e, n);
  }
}
var Ek;
(function(t) {
  t.List = "list", t.Tree = "tree";
})(Ek || (Ek = {}));
var Sk;
(function(t) {
  t.Default = "default", t.FileNames = "fileNames", t.Type = "type", t.Modified = "modified", t.CountDescending = "countDescending", t.CountAscending = "countAscending";
})(Sk || (Sk = {}));
var Dk;
(function(t) {
  t.Auto = "auto", t.Manual = "manual", t.RunOnEmpty = "runOnEmpty";
})(Dk || (Dk = {}));
function X6(t, e = !0) {
  const i = t && t.files && t.files.exclude, n = e && t && t.search && t.search.exclude;
  if (!i && !n)
    return;
  if (!i || !n)
    return i || n || void 0;
  let r = /* @__PURE__ */ Object.create(null);
  return r = Za(r, yt(i)), r = Za(r, yt(n), !0), r;
}
function kk(t, e) {
  return t.excludePattern && wd(t.excludePattern, e) ? !1 : t.includePattern || t.usingSearchPaths ? t.includePattern && wd(t.includePattern, e) ? !0 : t.usingSearchPaths ? !!t.folderQueries && t.folderQueries.some((i) => {
    const n = i.folder.fsPath;
    if (Hp(e, n)) {
      const r = zd(n, e);
      return !i.includePattern || !!wd(i.includePattern, r);
    } else
      return !1;
  }) : !1 : !0;
}
var Ik;
(function(t) {
  t[t.unknownEncoding = 1] = "unknownEncoding", t[t.regexParseError = 2] = "regexParseError", t[t.globParseError = 3] = "globParseError", t[t.invalidLiteral = 4] = "invalidLiteral", t[t.rgProcessError = 5] = "rgProcessError", t[t.other = 6] = "other", t[t.canceled = 7] = "canceled";
})(Ik || (Ik = {}));
function kc(t, e) {
  const i = {
    ...t || {},
    ...e || {}
  };
  return Object.keys(i).filter((n) => {
    const r = i[n];
    return typeof r == "boolean" && r;
  });
}
class $P {
  constructor(e, i) {
    this._parsedIncludeExpression = null, this._excludeExpression = i.excludePattern?.map((r) => ({
      ...e.excludePattern || {},
      ...r.pattern || {}
    })) ?? [], this._excludeExpression.length === 0 && (this._excludeExpression = [e.excludePattern || {}]), this._parsedExcludeExpression = this._excludeExpression.map((r) => qc(r));
    let n = e.includePattern;
    i.includePattern && (n ? n = {
      ...n,
      ...i.includePattern
    } : n = i.includePattern), n && (this._parsedIncludeExpression = qc(n));
  }
  _evalParsedExcludeExpression(e, i, n) {
    let r = null;
    for (const s of this._parsedExcludeExpression) {
      const o = s(e, i, n);
      if (typeof o == "string") {
        r = o;
        break;
      }
    }
    return r;
  }
  matchesExcludesSync(e, i, n) {
    return !!(this._parsedExcludeExpression && this._evalParsedExcludeExpression(e, i, n));
  }
  includedInQuerySync(e, i, n) {
    return !(this._parsedExcludeExpression && this._evalParsedExcludeExpression(e, i, n) || this._parsedIncludeExpression && !this._parsedIncludeExpression(e, i, n));
  }
  includedInQuery(e, i, n) {
    const r = () => this._parsedIncludeExpression ? !!this._parsedIncludeExpression(e, i, n) : !0;
    return Promise.all(this._parsedExcludeExpression.map((s) => {
      const o = s(e, i, n);
      return Do(o) ? o.then((a) => a ? !1 : r()) : r();
    })).then((s) => s.some((o) => !!o));
  }
  hasSiblingExcludeClauses() {
    return this._excludeExpression.reduce((e, i) => Z6(i) || e, !1);
  }
}
function Z6(t) {
  for (const e in t)
    if (typeof t[e] != "boolean")
      return !0;
  return !1;
}
function eN(t) {
  if (!t)
    return;
  let e;
  return (i) => (e || (e = (t() || Promise.resolve([])).then((n) => n ? HP(n) : {})), e.then((n) => !!n[i]));
}
function tN(t) {
  if (!t)
    return;
  let e;
  return (i) => {
    if (!e) {
      const n = t();
      e = n ? HP(n) : {};
    }
    return !!e[i];
  };
}
function HP(t) {
  const e = {};
  for (const i of t)
    e[i] = !0;
  return e;
}
function BP(t) {
  return t.flatMap((e) => e.patterns.map((i) => e.baseUri ? {
    baseUri: e.baseUri,
    pattern: i
  } : i));
}
const py = {
  matchLines: 100,
  charsPerLine: 1e4
}, o1 = "utf8", fE = "utf8bom", zm = "utf16be", qm = "utf16le", vp = [254, 255], gy = [255, 254], Yu = [239, 187, 191], iN = 512, nN = 512, rN = 512 * 8, sN = 512 * 128;
var my;
(function(t) {
  t[t.STREAM_IS_BINARY = 1] = "STREAM_IS_BINARY";
})(my || (my = {}));
class oN extends Error {
  constructor(e, i) {
    super(e), this.decodeStreamErrorKind = i;
  }
}
class pE {
  static async create(e) {
    let i;
    if (e !== o1)
      i = (await import("./iconv-lite-umd-Crggf1UA.js").then(function(r) {
        return r.i;
      }).then((r) => r.default ?? r)).getDecoder(WP(e));
    else {
      const n = new TextDecoder();
      i = {
        write(r) {
          return n.decode(r, {
            stream: !0
          });
        },
        end() {
          return n.decode();
        }
      };
    }
    return new pE(i);
  }
  constructor(e) {
    this.iconvLiteDecoder = e;
  }
  write(e) {
    return this.iconvLiteDecoder.write(e);
  }
  end() {
    return this.iconvLiteDecoder.end();
  }
}
function aN(t, e) {
  const i = e.minBytesRequiredForDetection ?? e.guessEncoding ? rN : nN;
  return new Promise((n, r) => {
    const s = a4((d) => d.join("")), o = [];
    let a = 0, l;
    const c = new Pt(), u = async () => {
      try {
        const d = await mN({
          buffer: ue.concat(o),
          bytesRead: a
        }, e.guessEncoding, e.candidateGuessEncodings);
        if (d.seemsBinary && e.acceptTextOnly)
          throw new oN(
            "Stream is binary but only text is accepted for decoding",
            my.STREAM_IS_BINARY
          );
        d.encoding = await e.overwriteEncoding(d.encoding), l = await pE.create(d.encoding);
        const f = l.write(ue.concat(o).buffer);
        s.write(f), o.length = 0, a = 0, n({
          stream: s,
          detected: d
        });
      } catch (d) {
        c.cancel(), s.destroy(), r(d);
      }
    };
    l4(t, {
      onData: async (d) => {
        l ? s.write(l.write(d.buffer)) : (o.push(d), a += d.byteLength, a >= i && (t.pause(), await u(), setTimeout(() => t.resume())));
      },
      onError: (d) => s.error(d),
      onEnd: async () => {
        l || await u(), s.end(l?.end());
      }
    }, c.token);
  });
}
async function lN(t, e, i) {
  const r = (await import("./iconv-lite-umd-Crggf1UA.js").then(function(a) {
    return a.i;
  }).then((a) => a.default ?? a)).getEncoder(WP(e), i);
  let s = !1, o = !1;
  return {
    read() {
      if (o)
        return null;
      const a = t.read();
      if (typeof a != "string") {
        if (o = !0, !s && i?.addBOM)
          switch (e) {
            case o1:
            case fE:
              return ue.wrap(Uint8Array.from(Yu));
            case zm:
              return ue.wrap(Uint8Array.from(vp));
            case qm:
              return ue.wrap(Uint8Array.from(gy));
          }
        const l = r.end();
        return l && l.length > 0 ? (s = !0, ue.wrap(l)) : null;
      }
      return s = !0, ue.wrap(r.write(a));
    }
  };
}
function WP(t) {
  return t === fE || t === null ? o1 : t;
}
function cN(t, e) {
  if (!t || e < vp.length)
    return null;
  const i = t.readUInt8(0), n = t.readUInt8(1);
  if (i === vp[0] && n === vp[1])
    return zm;
  if (i === gy[0] && n === gy[1])
    return qm;
  if (e < Yu.length)
    return null;
  const r = t.readUInt8(2);
  return i === Yu[0] && n === Yu[1] && r === Yu[2] ? fE : null;
}
const uN = ["ascii", "utf-16", "utf-32"];
async function dN(t, e) {
  const i = await import("./index-CWW5ytBx.js").then(function(a) {
    return a.i;
  }).then((a) => a.default ?? a), n = t.slice(0, sN), r = gN(n.buffer);
  e && (e = Kt(e.map((a) => pN(a))), e.length === 0 && (e = void 0));
  let s;
  try {
    s = i.detect(r, e ? { detectEncodings: e } : void 0);
  } catch {
    return null;
  }
  if (!s || !s.encoding)
    return null;
  const o = s.encoding.toLowerCase();
  return 0 <= uN.indexOf(o) ? null : fN(s.encoding);
}
const hN = {
  ibm866: "cp866",
  big5: "cp950"
};
function VP(t) {
  return t.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
}
function fN(t) {
  const e = VP(t);
  return hN[e] || e;
}
function pN(t) {
  const e = VP(t), i = _N[e];
  return i ? i.guessableName : void 0;
}
function gN(t) {
  let e = "";
  for (let i = 0; i < t.length; i++)
    e += String.fromCharCode(t[i]);
  return e;
}
function mN({ buffer: t, bytesRead: e }, i, n) {
  let r = cN(t, e), s = !1;
  if (r !== zm && r !== qm && t) {
    let o = !0, a = !0, l = !1;
    for (let c = 0; c < e && c < iN; c++) {
      const u = c % 2 === 1, d = t.readUInt8(c) === 0;
      if (d && (l = !0), o && (u && !d || !u && d) && (o = !1), a && (u && d || !u && !d) && (a = !1), d && !o && !a)
        break;
    }
    l && (o ? r = qm : a ? r = zm : s = !0);
  }
  return i && !s && !r && t ? dN(t.slice(0, e), n).then((o) => ({
    seemsBinary: !1,
    encoding: o
  })) : { seemsBinary: s, encoding: r };
}
const j1 = {
  utf8: {
    labelLong: "UTF-8",
    labelShort: "UTF-8",
    order: 1,
    alias: "utf8bom",
    guessableName: "UTF-8"
  },
  utf8bom: {
    labelLong: "UTF-8 with BOM",
    labelShort: "UTF-8 with BOM",
    encodeOnly: !0,
    order: 2,
    alias: "utf8"
  },
  utf16le: {
    labelLong: "UTF-16 LE",
    labelShort: "UTF-16 LE",
    order: 3,
    guessableName: "UTF-16LE"
  },
  utf16be: {
    labelLong: "UTF-16 BE",
    labelShort: "UTF-16 BE",
    order: 4,
    guessableName: "UTF-16BE"
  },
  windows1252: {
    labelLong: "Western (Windows 1252)",
    labelShort: "Windows 1252",
    order: 5,
    guessableName: "windows-1252"
  },
  iso88591: {
    labelLong: "Western (ISO 8859-1)",
    labelShort: "ISO 8859-1",
    order: 6
  },
  iso88593: {
    labelLong: "Western (ISO 8859-3)",
    labelShort: "ISO 8859-3",
    order: 7
  },
  iso885915: {
    labelLong: "Western (ISO 8859-15)",
    labelShort: "ISO 8859-15",
    order: 8
  },
  macroman: {
    labelLong: "Western (Mac Roman)",
    labelShort: "Mac Roman",
    order: 9
  },
  cp437: {
    labelLong: "DOS (CP 437)",
    labelShort: "CP437",
    order: 10
  },
  windows1256: {
    labelLong: "Arabic (Windows 1256)",
    labelShort: "Windows 1256",
    order: 11
  },
  iso88596: {
    labelLong: "Arabic (ISO 8859-6)",
    labelShort: "ISO 8859-6",
    order: 12
  },
  windows1257: {
    labelLong: "Baltic (Windows 1257)",
    labelShort: "Windows 1257",
    order: 13
  },
  iso88594: {
    labelLong: "Baltic (ISO 8859-4)",
    labelShort: "ISO 8859-4",
    order: 14
  },
  iso885914: {
    labelLong: "Celtic (ISO 8859-14)",
    labelShort: "ISO 8859-14",
    order: 15
  },
  windows1250: {
    labelLong: "Central European (Windows 1250)",
    labelShort: "Windows 1250",
    order: 16,
    guessableName: "windows-1250"
  },
  iso88592: {
    labelLong: "Central European (ISO 8859-2)",
    labelShort: "ISO 8859-2",
    order: 17,
    guessableName: "ISO-8859-2"
  },
  cp852: {
    labelLong: "Central European (CP 852)",
    labelShort: "CP 852",
    order: 18
  },
  windows1251: {
    labelLong: "Cyrillic (Windows 1251)",
    labelShort: "Windows 1251",
    order: 19,
    guessableName: "windows-1251"
  },
  cp866: {
    labelLong: "Cyrillic (CP 866)",
    labelShort: "CP 866",
    order: 20,
    guessableName: "IBM866"
  },
  cp1125: {
    labelLong: "Cyrillic (CP 1125)",
    labelShort: "CP 1125",
    order: 21,
    guessableName: "IBM1125"
  },
  iso88595: {
    labelLong: "Cyrillic (ISO 8859-5)",
    labelShort: "ISO 8859-5",
    order: 22,
    guessableName: "ISO-8859-5"
  },
  koi8r: {
    labelLong: "Cyrillic (KOI8-R)",
    labelShort: "KOI8-R",
    order: 23,
    guessableName: "KOI8-R"
  },
  koi8u: {
    labelLong: "Cyrillic (KOI8-U)",
    labelShort: "KOI8-U",
    order: 24
  },
  iso885913: {
    labelLong: "Estonian (ISO 8859-13)",
    labelShort: "ISO 8859-13",
    order: 25
  },
  windows1253: {
    labelLong: "Greek (Windows 1253)",
    labelShort: "Windows 1253",
    order: 26,
    guessableName: "windows-1253"
  },
  iso88597: {
    labelLong: "Greek (ISO 8859-7)",
    labelShort: "ISO 8859-7",
    order: 27,
    guessableName: "ISO-8859-7"
  },
  windows1255: {
    labelLong: "Hebrew (Windows 1255)",
    labelShort: "Windows 1255",
    order: 28,
    guessableName: "windows-1255"
  },
  iso88598: {
    labelLong: "Hebrew (ISO 8859-8)",
    labelShort: "ISO 8859-8",
    order: 29,
    guessableName: "ISO-8859-8"
  },
  iso885910: {
    labelLong: "Nordic (ISO 8859-10)",
    labelShort: "ISO 8859-10",
    order: 30
  },
  iso885916: {
    labelLong: "Romanian (ISO 8859-16)",
    labelShort: "ISO 8859-16",
    order: 31
  },
  windows1254: {
    labelLong: "Turkish (Windows 1254)",
    labelShort: "Windows 1254",
    order: 32
  },
  iso88599: {
    labelLong: "Turkish (ISO 8859-9)",
    labelShort: "ISO 8859-9",
    order: 33
  },
  windows1258: {
    labelLong: "Vietnamese (Windows 1258)",
    labelShort: "Windows 1258",
    order: 34
  },
  gbk: {
    labelLong: "Simplified Chinese (GBK)",
    labelShort: "GBK",
    order: 35
  },
  gb18030: {
    labelLong: "Simplified Chinese (GB18030)",
    labelShort: "GB18030",
    order: 36
  },
  cp950: {
    labelLong: "Traditional Chinese (Big5)",
    labelShort: "Big5",
    order: 37,
    guessableName: "Big5"
  },
  big5hkscs: {
    labelLong: "Traditional Chinese (Big5-HKSCS)",
    labelShort: "Big5-HKSCS",
    order: 38
  },
  shiftjis: {
    labelLong: "Japanese (Shift JIS)",
    labelShort: "Shift JIS",
    order: 39,
    guessableName: "SHIFT_JIS"
  },
  eucjp: {
    labelLong: "Japanese (EUC-JP)",
    labelShort: "EUC-JP",
    order: 40,
    guessableName: "EUC-JP"
  },
  euckr: {
    labelLong: "Korean (EUC-KR)",
    labelShort: "EUC-KR",
    order: 41,
    guessableName: "EUC-KR"
  },
  windows874: {
    labelLong: "Thai (Windows 874)",
    labelShort: "Windows 874",
    order: 42
  },
  iso885911: {
    labelLong: "Latin/Thai (ISO 8859-11)",
    labelShort: "ISO 8859-11",
    order: 43
  },
  koi8ru: {
    labelLong: "Cyrillic (KOI8-RU)",
    labelShort: "KOI8-RU",
    order: 44
  },
  koi8t: {
    labelLong: "Tajik (KOI8-T)",
    labelShort: "KOI8-T",
    order: 45
  },
  gb2312: {
    labelLong: "Simplified Chinese (GB 2312)",
    labelShort: "GB 2312",
    order: 46,
    guessableName: "GB2312"
  },
  cp865: {
    labelLong: "Nordic DOS (CP 865)",
    labelShort: "CP 865",
    order: 47
  },
  cp850: {
    labelLong: "Western European DOS (CP 850)",
    labelShort: "CP 850",
    order: 48
  }
}, _N = (() => {
  const t = {};
  for (const e in j1)
    j1[e].guessableName && (t[e] = j1[e]);
  return t;
})();
var Ck;
(function(t) {
  t[t.FILE_IS_BINARY = 0] = "FILE_IS_BINARY";
})(Ck || (Ck = {}));
var Tk;
(function(t) {
  t[t.SAVED = 0] = "SAVED", t[t.DIRTY = 1] = "DIRTY", t[t.PENDING_SAVE = 2] = "PENDING_SAVE", t[t.CONFLICT = 3] = "CONFLICT", t[t.ORPHAN = 4] = "ORPHAN", t[t.ERROR = 5] = "ERROR";
})(Tk || (Tk = {}));
var Pk;
(function(t) {
  t[t.EDITOR = 1] = "EDITOR", t[t.REFERENCE = 2] = "REFERENCE", t[t.OTHER = 3] = "OTHER";
})(Pk || (Pk = {}));
var Ak;
(function(t) {
  t[t.Encode = 0] = "Encode", t[t.Decode = 1] = "Decode";
})(Ak || (Ak = {}));
function vN(t) {
  let e = !1;
  return {
    read() {
      return e ? null : (e = !0, t);
    }
  };
}
function Jh(t, e, i) {
  return new cf((n) => gE(n, i)).isEqual(t, e);
}
function wN(t, e, i) {
  return Jh(t.uri, e.uri, i) ? 0 : Ya(t.uri.toString(), e.uri.toString());
}
function bN(t, e, i) {
  return t.index !== e.index ? t.index < e.index ? -1 : 1 : Jh(t.uri, e.uri, i) ? Ya(t.name, e.name) : Ya(t.uri.toString(), e.uri.toString());
}
function zP(t, e, i, n) {
  const r = t.slice(0).sort((o, a) => i(o, a, n)), s = e.slice(0).sort((o, a) => i(o, a, n));
  return j5(r, s, (o, a) => i(o, a, n));
}
function gE(t, e) {
  const i = e.getCapabilities(t.scheme);
  return !(i && i & Rr.PathCaseSensitive);
}
class Ic extends P8 {
  static toExtHostWorkspace(e, i, n, r) {
    if (!e)
      return { workspace: null, added: [], removed: [] };
    const { id: s, name: o, folders: a, configuration: l, transient: c, isUntitled: u } = e, d = [], f = i;
    i ? a.forEach((v, S) => {
      const E = x.revive(v.uri), A = Ic._findFolder(n || i, E, r);
      A ? (A.name = v.name, A.index = v.index, d.push(A)) : d.push({ uri: E, name: v.name, index: S });
    }) : d.push(...a.map(({ uri: v, name: S, index: E }) => ({ uri: x.revive(v), name: S, index: E }))), d.sort((v, S) => v.index < S.index ? -1 : 1);
    const g = new Ic(
      s,
      o,
      d,
      !!c,
      l ? x.revive(l) : null,
      !!u,
      (v) => gE(v, r)
    ), { added: _, removed: w } = zP(f ? f.workspaceFolders : [], g.workspaceFolders, wN, r);
    return { workspace: g, added: _, removed: w };
  }
  static _findFolder(e, i, n) {
    for (let r = 0; r < e.folders.length; r++) {
      const s = e.workspaceFolders[r];
      if (Jh(s.uri, i, n))
        return s;
    }
  }
  constructor(e, i, n, r, s, o, a) {
    super(e, n.map((l) => new Q4(l)), r, s, a), this._name = i, this._isUntitled = o, this._workspaceFolders = [], this._structure = $r.forUris(a, () => !0), n.forEach((l) => {
      this._workspaceFolders.push(l), this._structure.set(l.uri, l);
    });
  }
  get name() {
    return this._name;
  }
  get isUntitled() {
    return this._isUntitled;
  }
  get workspaceFolders() {
    return this._workspaceFolders.slice(0);
  }
  getWorkspaceFolder(e, i) {
    return i && this._structure.get(e) && (e = H_(e)), this._structure.findSubstr(e);
  }
  resolveWorkspaceFolder(e) {
    return this._structure.get(e);
  }
}
let _y = class {
  constructor(e, i, n, r, s) {
    this._onDidChangeWorkspace = new N(), this.onDidChangeWorkspace = this._onDidChangeWorkspace.event, this._onDidGrantWorkspaceTrust = new N(), this.onDidGrantWorkspaceTrust = this._onDidGrantWorkspaceTrust.event, this._activeSearchCallbacks = [], this._trusted = !1, this._editSessionIdentityProviders = /* @__PURE__ */ new Map(), this._providerHandlePool = 0, this._onWillCreateEditSessionIdentityEvent = new id(), this._canonicalUriProviders = /* @__PURE__ */ new Map(), this._logService = r, this._extHostFileSystemInfo = n, this._uriTransformerService = s, this._requestIdProvider = new D8(), this._barrier = new Ur(), this._proxy = e.getProxy(ee.MainThreadWorkspace), this._messageService = e.getProxy(ee.MainThreadMessageService);
    const o = i.workspace;
    this._confirmedWorkspace = o ? new Ic(
      o.id,
      o.name,
      [],
      !!o.transient,
      o.configuration ? x.revive(o.configuration) : null,
      !!o.isUntitled,
      (a) => gE(a, n)
    ) : void 0;
  }
  $initializeWorkspace(e, i) {
    this._trusted = i, this.$acceptWorkspaceData(e), this._barrier.open();
  }
  waitForInitializeCall() {
    return this._barrier.wait();
  }
  get workspace() {
    return this._actualWorkspace;
  }
  get name() {
    return this._actualWorkspace ? this._actualWorkspace.name : void 0;
  }
  get workspaceFile() {
    if (this._actualWorkspace && this._actualWorkspace.configuration)
      return this._actualWorkspace.isUntitled ? x.from(
        { scheme: de.untitled, path: Fs(H_(this._actualWorkspace.configuration)) }
      ) : this._actualWorkspace.configuration;
  }
  get _actualWorkspace() {
    return this._unconfirmedWorkspace || this._confirmedWorkspace;
  }
  getWorkspaceFolders() {
    if (this._actualWorkspace)
      return this._actualWorkspace.workspaceFolders.slice(0);
  }
  async getWorkspaceFolders2() {
    if (await this._barrier.wait(), !!this._actualWorkspace)
      return this._actualWorkspace.workspaceFolders.slice(0);
  }
  updateWorkspaceFolders(e, i, n, ...r) {
    const s = [];
    if (Array.isArray(r) && r.forEach((u) => {
      x.isUri(u.uri) && !s.some((d) => Jh(d.uri, u.uri, this._extHostFileSystemInfo)) && s.push({ uri: u.uri, name: u.name || Av(u.uri) });
    }), this._unconfirmedWorkspace || [i, n].some((u) => typeof u != "number" || u < 0) || n === 0 && s.length === 0)
      return !1;
    const o = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : [];
    if (i + n > o.length)
      return !1;
    const a = o.slice(0);
    a.splice(i, n, ...s.map(
      (u) => ({ uri: u.uri, name: u.name || Av(u.uri), index: void 0 })
    ));
    for (let u = 0; u < a.length; u++) {
      const d = a[u];
      if (a.some(
        (f, g) => g !== u && Jh(d.uri, f.uri, this._extHostFileSystemInfo)
      ))
        return !1;
    }
    a.forEach((u, d) => u.index = d);
    const { added: l, removed: c } = zP(o, a, bN, this._extHostFileSystemInfo);
    if (l.length === 0 && c.length === 0)
      return !1;
    if (this._proxy) {
      const u = e.displayName || e.name;
      this._proxy.$updateWorkspaceFolders(u, i, n, s).then(void 0, (d) => {
        this._unconfirmedWorkspace = void 0;
        const f = { source: { identifier: e.identifier, label: e.displayName || e.name } };
        this._messageService.$showMessage(Qt.Error, h(
          2640,
          "Extension '{0}' failed to update workspace folders: {1}",
          u,
          d.toString()
        ), f, []);
      });
    }
    return this.trySetWorkspaceFolders(a), !0;
  }
  getWorkspaceFolder(e, i) {
    if (this._actualWorkspace)
      return this._actualWorkspace.getWorkspaceFolder(e, i);
  }
  async getWorkspaceFolder2(e, i) {
    if (await this._barrier.wait(), !!this._actualWorkspace)
      return this._actualWorkspace.getWorkspaceFolder(e, i);
  }
  async resolveWorkspaceFolder(e) {
    if (await this._barrier.wait(), !!this._actualWorkspace)
      return this._actualWorkspace.resolveWorkspaceFolder(e);
  }
  getPath() {
    if (!this._actualWorkspace)
      return;
    const { folders: e } = this._actualWorkspace;
    if (e.length !== 0)
      return e[0].uri.fsPath;
  }
  getRelativePath(e, i) {
    let n, r = "";
    if (typeof e == "string" ? (n = x.file(e), r = e) : typeof e < "u" && (n = e, r = e.fsPath), !n)
      return r;
    const s = this.getWorkspaceFolder(n, !0);
    if (!s)
      return r;
    typeof i > "u" && this._actualWorkspace && (i = this._actualWorkspace.folders.length > 1);
    let o = O4(s.uri, n);
    return i && s.name && (o = `${s.name}/${o}`), o;
  }
  trySetWorkspaceFolders(e) {
    this._actualWorkspace && (this._unconfirmedWorkspace = Ic.toExtHostWorkspace({
      id: this._actualWorkspace.id,
      name: this._actualWorkspace.name,
      configuration: this._actualWorkspace.configuration,
      folders: e,
      isUntitled: this._actualWorkspace.isUntitled
    }, this._actualWorkspace, void 0, this._extHostFileSystemInfo).workspace || void 0);
  }
  $acceptWorkspaceData(e) {
    const { workspace: i, added: n, removed: r } = Ic.toExtHostWorkspace(e, this._confirmedWorkspace, this._unconfirmedWorkspace, this._extHostFileSystemInfo);
    this._confirmedWorkspace = i || void 0, this._unconfirmedWorkspace = void 0, this._onDidChangeWorkspace.fire(Object.freeze({
      added: n,
      removed: r
    }));
  }
  findFiles(e, i, n, r, s = xt.None) {
    this._logService.trace(`extHostWorkspace#findFiles: fileSearch, extension: ${r.value}, entryPoint: findFiles`);
    let o = "", a = !0;
    return i === null ? a = !1 : i !== void 0 && (typeof i == "string" ? o = i : o = i.pattern), this._findFilesImpl({ type: "include", value: e }, {
      exclude: [o],
      maxResults: n,
      useExcludeSettings: a ? xs.FilesExclude : xs.None,
      useIgnoreFiles: {
        local: !1
      }
    }, s);
  }
  findFiles2(e, i = {}, n, r = xt.None) {
    return this._logService.trace(`extHostWorkspace#findFiles2New: fileSearch, extension: ${n.value}, entryPoint: findFiles2New`), this._findFilesImpl({ type: "filePatterns", value: e }, i, r);
  }
  async _findFilesImpl(e, i, n) {
    if (n.isCancellationRequested)
      return Promise.resolve([]);
    const r = e.type === "include" ? [e.value] : e.value ?? [];
    if (!Array.isArray(r))
      throw console.error("Invalid file pattern provided", r), new Error(`Invalid file pattern provided ${JSON.stringify(r)}`);
    const s = r.map((o) => {
      const a = Rk(i.exclude), l = {
        ignoreSymlinks: typeof i.followSymlinks == "boolean" ? !i.followSymlinks : void 0,
        disregardIgnoreFiles: typeof i.useIgnoreFiles?.local == "boolean" ? !i.useIgnoreFiles.local : void 0,
        disregardGlobalIgnoreFiles: typeof i.useIgnoreFiles?.global == "boolean" ? !i.useIgnoreFiles.global : void 0,
        disregardParentIgnoreFiles: typeof i.useIgnoreFiles?.parent == "boolean" ? !i.useIgnoreFiles.parent : void 0,
        disregardExcludeSettings: i.useExcludeSettings !== void 0 && i.useExcludeSettings === xs.None,
        disregardSearchExcludeSettings: i.useExcludeSettings !== void 0 && i.useExcludeSettings !== xs.SearchAndFilesExclude,
        maxResults: i.maxResults,
        excludePattern: a.length > 0 ? a : void 0,
        _reason: "startFileSearch",
        shouldGlobSearch: e.type === "include" ? void 0 : !0
      }, c = wp(vn.from(o)), u = c?.folder;
      return e.type === "include" ? l.includePattern = c?.pattern : l.filePattern = c?.pattern, {
        folder: u,
        options: l
      };
    });
    return this._findFilesBase(s, n);
  }
  async _findFilesBase(e, i) {
    return (await Promise.all(e?.map((r) => this._proxy.$startFileSearch(r.folder ?? null, r.options, i).then((s) => Array.isArray(s) ? s.map((o) => x.revive(o)) : [])) ?? [])).flat();
  }
  findTextInFiles2(e, i, n, r = xt.None) {
    this._logService.trace(`extHostWorkspace#findTextInFiles2: textSearch, extension: ${n.value}, entryPoint: findTextInFiles2`);
    const s = (f) => {
      if (!i)
        return {
          folder: void 0,
          options: {}
        };
      const g = f ? wp(vn.from(f)) : void 0, _ = i.exclude ? Rk(i.exclude) : void 0;
      return {
        options: {
          ignoreSymlinks: typeof i.followSymlinks == "boolean" ? !i.followSymlinks : void 0,
          disregardIgnoreFiles: typeof i.useIgnoreFiles == "boolean" ? !i.useIgnoreFiles : void 0,
          disregardGlobalIgnoreFiles: typeof i.useIgnoreFiles?.global == "boolean" ? !i.useIgnoreFiles?.global : void 0,
          disregardParentIgnoreFiles: typeof i.useIgnoreFiles?.parent == "boolean" ? !i.useIgnoreFiles?.parent : void 0,
          disregardExcludeSettings: i.useExcludeSettings !== void 0 && i.useExcludeSettings === xs.None,
          disregardSearchExcludeSettings: i.useExcludeSettings !== void 0 && i.useExcludeSettings !== xs.SearchAndFilesExclude,
          fileEncoding: i.encoding,
          maxResults: i.maxResults,
          previewOptions: i.previewOptions ? {
            matchLines: i.previewOptions?.numMatchLines ?? 100,
            charsPerLine: i.previewOptions?.charsPerLine ?? 1e4
          } : void 0,
          surroundingContext: i.surroundingContext,
          includePattern: g?.pattern,
          excludePattern: _
        },
        folder: g?.folder
      };
    }, a = (i?.include?.map((f) => s(f)) ?? [s(void 0)]).filter((f) => !!f), l = new De(), c = l.add(new N()), u = this.findTextInFilesBase(e, a, (f, g) => c.fire({ result: f, uri: g }), r);
    return {
      results: new Xa(async (f) => {
        l.add(c.event((g) => {
          const _ = g.result, w = g.uri;
          yk(_) ? f.emitOne(new go(w, _.rangeLocations.map((v) => ({
            previewRange: new Oe(
              v.preview.startLineNumber,
              v.preview.startColumn,
              v.preview.endLineNumber,
              v.preview.endColumn
            ),
            sourceRange: new Oe(
              v.source.startLineNumber,
              v.source.startColumn,
              v.source.endLineNumber,
              v.source.endColumn
            )
          })), _.previewText)) : f.emitOne(new hE(w, _.text, _.lineNumber));
        })), await u;
      }),
      complete: u.then((f) => (l.dispose(), {
        limitHit: f?.limitHit ?? !1
      }))
    };
  }
  async findTextInFilesBase(e, i, n, r = xt.None) {
    const s = this._requestIdProvider.getNext();
    let o = !1;
    if (r.onCancellationRequested((a) => {
      o = !0;
    }), this._activeSearchCallbacks[s] = (a) => {
      if (o)
        return;
      const l = x.revive(a.resource);
      a.results.forEach((c) => {
        const u = Fi(c);
        n(u, l);
      });
    }, r.isCancellationRequested)
      return {};
    try {
      const a = await Promise.all(i?.map((l) => this._proxy.$startTextSearch(e, l.folder ?? null, l.options, s, r) || {}) ?? []);
      return delete this._activeSearchCallbacks[s], a.reduce((l, c) => ({
        limitHit: l?.limitHit || (c?.limitHit ?? !1),
        message: [l?.message ?? [], c?.message ?? []].flat()
      }), {}) ?? { limitHit: !1 };
    } catch (a) {
      throw delete this._activeSearchCallbacks[s], a;
    }
  }
  async findTextInFiles(e, i, n, r, s = xt.None) {
    this._logService.trace(`extHostWorkspace#findTextInFiles: textSearch, extension: ${r.value}, entryPoint: findTextInFiles`);
    const o = typeof i.previewOptions > "u" ? {
      matchLines: 100,
      charsPerLine: 1e4
    } : i.previewOptions, a = wp(vn.from(i.include)), l = typeof i.exclude == "string" ? i.exclude : i.exclude ? i.exclude.pattern : void 0, c = {
      ignoreSymlinks: typeof i.followSymlinks == "boolean" ? !i.followSymlinks : void 0,
      disregardIgnoreFiles: typeof i.useIgnoreFiles == "boolean" ? !i.useIgnoreFiles : void 0,
      disregardGlobalIgnoreFiles: typeof i.useGlobalIgnoreFiles == "boolean" ? !i.useGlobalIgnoreFiles : void 0,
      disregardParentIgnoreFiles: typeof i.useParentIgnoreFiles == "boolean" ? !i.useParentIgnoreFiles : void 0,
      disregardExcludeSettings: typeof i.useDefaultExcludes == "boolean" ? !i.useDefaultExcludes : !0,
      disregardSearchExcludeSettings: typeof i.useSearchExclude == "boolean" ? !i.useSearchExclude : !0,
      fileEncoding: i.encoding,
      maxResults: i.maxResults,
      previewOptions: o,
      surroundingContext: i.afterContext,
      includePattern: a?.pattern,
      excludePattern: l ? [{ pattern: l }] : void 0
    }, u = (d, f) => {
      yk(d) ? n({
        uri: f,
        preview: {
          text: d.previewText,
          matches: mv(d.rangeLocations, (g) => new Oe(
            g.preview.startLineNumber,
            g.preview.startColumn,
            g.preview.endLineNumber,
            g.preview.endColumn
          ))
        },
        ranges: mv(d.rangeLocations, (g) => new Oe(
          g.source.startLineNumber,
          g.source.startColumn,
          g.source.endLineNumber,
          g.source.endColumn
        ))
      }) : n({
        uri: f,
        text: d.text,
        lineNumber: d.lineNumber
      });
    };
    return this.findTextInFilesBase(e, [{ options: c, folder: a?.folder }], u, s);
  }
  $handleTextSearchResult(e, i) {
    this._activeSearchCallbacks[i]?.(e);
  }
  async save(e) {
    const i = await this._proxy.$save(e, { saveAs: !1 });
    return x.revive(i);
  }
  async saveAs(e) {
    const i = await this._proxy.$save(e, { saveAs: !0 });
    return x.revive(i);
  }
  saveAll(e) {
    return this._proxy.$saveAll(e);
  }
  resolveProxy(e) {
    return this._proxy.$resolveProxy(e);
  }
  lookupAuthorization(e) {
    return this._proxy.$lookupAuthorization(e);
  }
  lookupKerberosAuthorization(e) {
    return this._proxy.$lookupKerberosAuthorization(e);
  }
  loadCertificates() {
    return this._proxy.$loadCertificates();
  }
  get trusted() {
    return this._trusted;
  }
  requestWorkspaceTrust(e) {
    return this._proxy.$requestWorkspaceTrust(e);
  }
  $onDidGrantWorkspaceTrust() {
    this._trusted || (this._trusted = !0, this._onDidGrantWorkspaceTrust.fire());
  }
  registerEditSessionIdentityProvider(e, i) {
    if (this._editSessionIdentityProviders.has(e))
      throw new Error(`A provider has already been registered for scheme ${e}`);
    this._editSessionIdentityProviders.set(e, i);
    const n = this._uriTransformerService.transformOutgoingScheme(e), r = this._providerHandlePool++;
    return this._proxy.$registerEditSessionIdentityProvider(r, n), Ee(() => {
      this._editSessionIdentityProviders.delete(e), this._proxy.$unregisterEditSessionIdentityProvider(r);
    });
  }
  async $getEditSessionIdentifier(e, i) {
    this._logService.info("Getting edit session identifier for workspaceFolder", e);
    const n = await this.resolveWorkspaceFolder(x.revive(e));
    if (!n) {
      this._logService.warn("Unable to resolve workspace folder");
      return;
    }
    this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", n);
    const r = this._editSessionIdentityProviders.get(n.uri.scheme);
    if (this._logService.info(`Provider for scheme ${n.uri.scheme} is defined: `, !!r), !r)
      return;
    const s = await r.provideEditSessionIdentity(n, i);
    if (this._logService.info("Provider returned edit session identifier: ", s), !!s)
      return s;
  }
  async $provideEditSessionIdentityMatch(e, i, n, r) {
    this._logService.info("Getting edit session identifier for workspaceFolder", e);
    const s = await this.resolveWorkspaceFolder(x.revive(e));
    if (!s) {
      this._logService.warn("Unable to resolve workspace folder");
      return;
    }
    this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", s);
    const o = this._editSessionIdentityProviders.get(s.uri.scheme);
    if (this._logService.info(`Provider for scheme ${s.uri.scheme} is defined: `, !!o), !o)
      return;
    const a = await o.provideEditSessionIdentityMatch?.(i, n, r);
    if (this._logService.info("Provider returned edit session identifier match result: ", a), !!a)
      return a;
  }
  getOnWillCreateEditSessionIdentityEvent(e) {
    return (i, n, r) => {
      const s = function(a) {
        i.call(n, a);
      };
      return s.extension = e, this._onWillCreateEditSessionIdentityEvent.event(s, void 0, r);
    };
  }
  async $onWillCreateEditSessionIdentity(e, i, n) {
    const r = await this.resolveWorkspaceFolder(x.revive(e));
    if (r === void 0)
      throw new Error("Unable to resolve workspace folder");
    await this._onWillCreateEditSessionIdentityEvent.fireAsync({ workspaceFolder: r }, i, async (s, o) => {
      const a = Date.now();
      await Promise.resolve(s), Date.now() - a > n && this._logService.warn("SLOW edit session create-participant", o.extension.identifier);
    }), i.isCancellationRequested;
  }
  registerCanonicalUriProvider(e, i) {
    if (this._canonicalUriProviders.has(e))
      throw new Error(`A provider has already been registered for scheme ${e}`);
    this._canonicalUriProviders.set(e, i);
    const n = this._uriTransformerService.transformOutgoingScheme(e), r = this._providerHandlePool++;
    return this._proxy.$registerCanonicalUriProvider(r, n), Ee(() => {
      this._canonicalUriProviders.delete(e), this._proxy.$unregisterCanonicalUriProvider(r);
    });
  }
  async provideCanonicalUri(e, i, n) {
    const r = this._canonicalUriProviders.get(e.scheme);
    if (!r)
      return;
    const s = await r.provideCanonicalUri?.(x.revive(e), i, n);
    if (s)
      return s;
  }
  async $provideCanonicalUri(e, i, n) {
    return this.provideCanonicalUri(x.revive(e), { targetScheme: i }, n);
  }
  async decode(e, i) {
    const [n, r] = this.toEncodeDecodeParameters(i), s = await this._proxy.$resolveDecoding(n, r), o = (await aN(bA(ue.wrap(e)), {
      ...s,
      acceptTextOnly: !0,
      overwriteEncoding: (a) => a === null || a === s.preferredEncoding ? Promise.resolve(s.preferredEncoding) : this._proxy.$validateDetectedEncoding(n, a, r)
    })).stream;
    return cA(o, (a) => a.join(""));
  }
  async encode(e, i) {
    const [n, r] = this.toEncodeDecodeParameters(i), { encoding: s, addBOM: o } = await this._proxy.$resolveEncoding(n, r);
    if (s === o1 && !o)
      return ue.fromString(e).buffer;
    const a = await lN(vN(e), s, { addBOM: o });
    return wA(a).buffer;
  }
  toEncodeDecodeParameters(e) {
    const i = Sv(e?.uri) ? e.uri : void 0, n = typeof e?.encoding == "string" ? e.encoding : void 0;
    return [i, n ? { encoding: n } : void 0];
  }
};
_y = W([
  M(0, Ye),
  M(1, pi),
  M(2, wu),
  M(3, nt),
  M(4, B_)
], _y);
const Us = pe("IExtHostWorkspace");
function wp(t) {
  let e, i;
  if (t)
    return typeof t == "string" ? e = t : (e = t.pattern, i = x.revive(t.baseUri)), {
      pattern: e,
      folder: i
    };
}
function Rk(t) {
  return (t?.map((e) => {
    if (typeof e == "string")
      return e === "" ? void 0 : {
        pattern: e,
        uri: void 0
      };
    {
      const i = wp(e);
      return i ? {
        pattern: i.pattern,
        uri: i.folder
      } : void 0;
    }
  }) ?? []).filter((e) => !!e);
}
var _i;
(function(t) {
  t[t.None = 0] = "None", t[t.UnexpectedEndOfComment = 1] = "UnexpectedEndOfComment", t[t.UnexpectedEndOfString = 2] = "UnexpectedEndOfString", t[t.UnexpectedEndOfNumber = 3] = "UnexpectedEndOfNumber", t[t.InvalidUnicode = 4] = "InvalidUnicode", t[t.InvalidEscapeCharacter = 5] = "InvalidEscapeCharacter", t[t.InvalidCharacter = 6] = "InvalidCharacter";
})(_i || (_i = {}));
var we;
(function(t) {
  t[t.OpenBraceToken = 1] = "OpenBraceToken", t[t.CloseBraceToken = 2] = "CloseBraceToken", t[t.OpenBracketToken = 3] = "OpenBracketToken", t[t.CloseBracketToken = 4] = "CloseBracketToken", t[t.CommaToken = 5] = "CommaToken", t[t.ColonToken = 6] = "ColonToken", t[t.NullKeyword = 7] = "NullKeyword", t[t.TrueKeyword = 8] = "TrueKeyword", t[t.FalseKeyword = 9] = "FalseKeyword", t[t.StringLiteral = 10] = "StringLiteral", t[t.NumericLiteral = 11] = "NumericLiteral", t[t.LineCommentTrivia = 12] = "LineCommentTrivia", t[t.BlockCommentTrivia = 13] = "BlockCommentTrivia", t[t.LineBreakTrivia = 14] = "LineBreakTrivia", t[t.Trivia = 15] = "Trivia", t[t.Unknown = 16] = "Unknown", t[t.EOF = 17] = "EOF";
})(we || (we = {}));
var Rt;
(function(t) {
  t[t.InvalidSymbol = 1] = "InvalidSymbol", t[t.InvalidNumberFormat = 2] = "InvalidNumberFormat", t[t.PropertyNameExpected = 3] = "PropertyNameExpected", t[t.ValueExpected = 4] = "ValueExpected", t[t.ColonExpected = 5] = "ColonExpected", t[t.CommaExpected = 6] = "CommaExpected", t[t.CloseBraceExpected = 7] = "CloseBraceExpected", t[t.CloseBracketExpected = 8] = "CloseBracketExpected", t[t.EndOfFileExpected = 9] = "EndOfFileExpected", t[t.InvalidCommentToken = 10] = "InvalidCommentToken", t[t.UnexpectedEndOfComment = 11] = "UnexpectedEndOfComment", t[t.UnexpectedEndOfString = 12] = "UnexpectedEndOfString", t[t.UnexpectedEndOfNumber = 13] = "UnexpectedEndOfNumber", t[t.InvalidUnicode = 14] = "InvalidUnicode", t[t.InvalidEscapeCharacter = 15] = "InvalidEscapeCharacter", t[t.InvalidCharacter = 16] = "InvalidCharacter";
})(Rt || (Rt = {}));
var vy;
(function(t) {
  t.DEFAULT = {
    allowTrailingComma: !0
  };
})(vy || (vy = {}));
function yN(t, e = !1) {
  let i = 0;
  const n = t.length;
  let r = "", s = 0, o = we.Unknown, a = _i.None;
  function l(w) {
    let v = 0, S = 0;
    for (; v < w; ) {
      const E = t.charCodeAt(i);
      if (E >= ae._0 && E <= ae._9)
        S = S * 16 + E - ae._0;
      else if (E >= ae.A && E <= ae.F)
        S = S * 16 + E - ae.A + 10;
      else if (E >= ae.a && E <= ae.f)
        S = S * 16 + E - ae.a + 10;
      else
        break;
      i++, v++;
    }
    return v < w && (S = -1), S;
  }
  function c(w) {
    i = w, r = "", s = 0, o = we.Unknown, a = _i.None;
  }
  function u() {
    const w = i;
    if (t.charCodeAt(i) === ae._0)
      i++;
    else
      for (i++; i < t.length && Al(t.charCodeAt(i)); )
        i++;
    if (i < t.length && t.charCodeAt(i) === ae.dot)
      if (i++, i < t.length && Al(t.charCodeAt(i)))
        for (i++; i < t.length && Al(t.charCodeAt(i)); )
          i++;
      else
        return a = _i.UnexpectedEndOfNumber, t.substring(w, i);
    let v = i;
    if (i < t.length && (t.charCodeAt(i) === ae.E || t.charCodeAt(i) === ae.e))
      if (i++, (i < t.length && t.charCodeAt(i) === ae.plus || t.charCodeAt(i) === ae.minus) && i++, i < t.length && Al(t.charCodeAt(i))) {
        for (i++; i < t.length && Al(t.charCodeAt(i)); )
          i++;
        v = i;
      } else
        a = _i.UnexpectedEndOfNumber;
    return t.substring(w, v);
  }
  function d() {
    let w = "", v = i;
    for (; ; ) {
      if (i >= n) {
        w += t.substring(v, i), a = _i.UnexpectedEndOfString;
        break;
      }
      const S = t.charCodeAt(i);
      if (S === ae.doubleQuote) {
        w += t.substring(v, i), i++;
        break;
      }
      if (S === ae.backslash) {
        if (w += t.substring(v, i), i++, i >= n) {
          a = _i.UnexpectedEndOfString;
          break;
        }
        switch (t.charCodeAt(i++)) {
          case ae.doubleQuote:
            w += '"';
            break;
          case ae.backslash:
            w += "\\";
            break;
          case ae.slash:
            w += "/";
            break;
          case ae.b:
            w += "\b";
            break;
          case ae.f:
            w += "\f";
            break;
          case ae.n:
            w += `
`;
            break;
          case ae.r:
            w += "\r";
            break;
          case ae.t:
            w += "	";
            break;
          case ae.u: {
            const A = l(4);
            A >= 0 ? w += String.fromCharCode(A) : a = _i.InvalidUnicode;
            break;
          }
          default:
            a = _i.InvalidEscapeCharacter;
        }
        v = i;
        continue;
      }
      if (S >= 0 && S <= 31)
        if (Uf(S)) {
          w += t.substring(v, i), a = _i.UnexpectedEndOfString;
          break;
        } else
          a = _i.InvalidCharacter;
      i++;
    }
    return w;
  }
  function f() {
    if (r = "", a = _i.None, s = i, i >= n)
      return s = n, o = we.EOF;
    let w = t.charCodeAt(i);
    if (G1(w)) {
      do
        i++, r += String.fromCharCode(w), w = t.charCodeAt(i);
      while (G1(w));
      return o = we.Trivia;
    }
    if (Uf(w))
      return i++, r += String.fromCharCode(w), w === ae.carriageReturn && t.charCodeAt(i) === ae.lineFeed && (i++, r += `
`), o = we.LineBreakTrivia;
    switch (w) {
      case ae.openBrace:
        return i++, o = we.OpenBraceToken;
      case ae.closeBrace:
        return i++, o = we.CloseBraceToken;
      case ae.openBracket:
        return i++, o = we.OpenBracketToken;
      case ae.closeBracket:
        return i++, o = we.CloseBracketToken;
      case ae.colon:
        return i++, o = we.ColonToken;
      case ae.comma:
        return i++, o = we.CommaToken;
      case ae.doubleQuote:
        return i++, r = d(), o = we.StringLiteral;
      case ae.slash: {
        const v = i - 1;
        if (t.charCodeAt(i + 1) === ae.slash) {
          for (i += 2; i < n && !Uf(t.charCodeAt(i)); )
            i++;
          return r = t.substring(v, i), o = we.LineCommentTrivia;
        }
        if (t.charCodeAt(i + 1) === ae.asterisk) {
          i += 2;
          const S = n - 1;
          let E = !1;
          for (; i < S; ) {
            if (t.charCodeAt(i) === ae.asterisk && t.charCodeAt(i + 1) === ae.slash) {
              i += 2, E = !0;
              break;
            }
            i++;
          }
          return E || (i++, a = _i.UnexpectedEndOfComment), r = t.substring(v, i), o = we.BlockCommentTrivia;
        }
        return r += String.fromCharCode(w), i++, o = we.Unknown;
      }
      case ae.minus:
        if (r += String.fromCharCode(w), i++, i === n || !Al(t.charCodeAt(i)))
          return o = we.Unknown;
      case ae._0:
      case ae._1:
      case ae._2:
      case ae._3:
      case ae._4:
      case ae._5:
      case ae._6:
      case ae._7:
      case ae._8:
      case ae._9:
        return r += u(), o = we.NumericLiteral;
      default:
        for (; i < n && g(w); )
          i++, w = t.charCodeAt(i);
        if (s !== i) {
          switch (r = t.substring(s, i), r) {
            case "true":
              return o = we.TrueKeyword;
            case "false":
              return o = we.FalseKeyword;
            case "null":
              return o = we.NullKeyword;
          }
          return o = we.Unknown;
        }
        return r += String.fromCharCode(w), i++, o = we.Unknown;
    }
  }
  function g(w) {
    if (G1(w) || Uf(w))
      return !1;
    switch (w) {
      case ae.closeBrace:
      case ae.closeBracket:
      case ae.openBrace:
      case ae.openBracket:
      case ae.doubleQuote:
      case ae.colon:
      case ae.comma:
      case ae.slash:
        return !1;
    }
    return !0;
  }
  function _() {
    let w;
    do
      w = f();
    while (w >= we.LineCommentTrivia && w <= we.Trivia);
    return w;
  }
  return {
    setPosition: c,
    getPosition: () => i,
    scan: e ? _ : f,
    getToken: () => o,
    getTokenValue: () => r,
    getTokenOffset: () => s,
    getTokenLength: () => i - s,
    getTokenError: () => a
  };
}
function G1(t) {
  return t === ae.space || t === ae.tab || t === ae.verticalTab || t === ae.formFeed || t === ae.nonBreakingSpace || t === ae.ogham || t >= ae.enQuad && t <= ae.zeroWidthSpace || t === ae.narrowNoBreakSpace || t === ae.mathematicalSpace || t === ae.ideographicSpace || t === ae.byteOrderMark;
}
function Uf(t) {
  return t === ae.lineFeed || t === ae.carriageReturn || t === ae.lineSeparator || t === ae.paragraphSeparator;
}
function Al(t) {
  return t >= ae._0 && t <= ae._9;
}
var ae;
(function(t) {
  t[t.nullCharacter = 0] = "nullCharacter", t[t.maxAsciiCharacter = 127] = "maxAsciiCharacter", t[t.lineFeed = 10] = "lineFeed", t[t.carriageReturn = 13] = "carriageReturn", t[t.lineSeparator = 8232] = "lineSeparator", t[t.paragraphSeparator = 8233] = "paragraphSeparator", t[t.nextLine = 133] = "nextLine", t[t.space = 32] = "space", t[t.nonBreakingSpace = 160] = "nonBreakingSpace", t[t.enQuad = 8192] = "enQuad", t[t.emQuad = 8193] = "emQuad", t[t.enSpace = 8194] = "enSpace", t[t.emSpace = 8195] = "emSpace", t[t.threePerEmSpace = 8196] = "threePerEmSpace", t[t.fourPerEmSpace = 8197] = "fourPerEmSpace", t[t.sixPerEmSpace = 8198] = "sixPerEmSpace", t[t.figureSpace = 8199] = "figureSpace", t[t.punctuationSpace = 8200] = "punctuationSpace", t[t.thinSpace = 8201] = "thinSpace", t[t.hairSpace = 8202] = "hairSpace", t[t.zeroWidthSpace = 8203] = "zeroWidthSpace", t[t.narrowNoBreakSpace = 8239] = "narrowNoBreakSpace", t[t.ideographicSpace = 12288] = "ideographicSpace", t[t.mathematicalSpace = 8287] = "mathematicalSpace", t[t.ogham = 5760] = "ogham", t[t._ = 95] = "_", t[t.$ = 36] = "$", t[t._0 = 48] = "_0", t[t._1 = 49] = "_1", t[t._2 = 50] = "_2", t[t._3 = 51] = "_3", t[t._4 = 52] = "_4", t[t._5 = 53] = "_5", t[t._6 = 54] = "_6", t[t._7 = 55] = "_7", t[t._8 = 56] = "_8", t[t._9 = 57] = "_9", t[t.a = 97] = "a", t[t.b = 98] = "b", t[t.c = 99] = "c", t[t.d = 100] = "d", t[t.e = 101] = "e", t[t.f = 102] = "f", t[t.g = 103] = "g", t[t.h = 104] = "h", t[t.i = 105] = "i", t[t.j = 106] = "j", t[t.k = 107] = "k", t[t.l = 108] = "l", t[t.m = 109] = "m", t[t.n = 110] = "n", t[t.o = 111] = "o", t[t.p = 112] = "p", t[t.q = 113] = "q", t[t.r = 114] = "r", t[t.s = 115] = "s", t[t.t = 116] = "t", t[t.u = 117] = "u", t[t.v = 118] = "v", t[t.w = 119] = "w", t[t.x = 120] = "x", t[t.y = 121] = "y", t[t.z = 122] = "z", t[t.A = 65] = "A", t[t.B = 66] = "B", t[t.C = 67] = "C", t[t.D = 68] = "D", t[t.E = 69] = "E", t[t.F = 70] = "F", t[t.G = 71] = "G", t[t.H = 72] = "H", t[t.I = 73] = "I", t[t.J = 74] = "J", t[t.K = 75] = "K", t[t.L = 76] = "L", t[t.M = 77] = "M", t[t.N = 78] = "N", t[t.O = 79] = "O", t[t.P = 80] = "P", t[t.Q = 81] = "Q", t[t.R = 82] = "R", t[t.S = 83] = "S", t[t.T = 84] = "T", t[t.U = 85] = "U", t[t.V = 86] = "V", t[t.W = 87] = "W", t[t.X = 88] = "X", t[t.Y = 89] = "Y", t[t.Z = 90] = "Z", t[t.ampersand = 38] = "ampersand", t[t.asterisk = 42] = "asterisk", t[t.at = 64] = "at", t[t.backslash = 92] = "backslash", t[t.bar = 124] = "bar", t[t.caret = 94] = "caret", t[t.closeBrace = 125] = "closeBrace", t[t.closeBracket = 93] = "closeBracket", t[t.closeParen = 41] = "closeParen", t[t.colon = 58] = "colon", t[t.comma = 44] = "comma", t[t.dot = 46] = "dot", t[t.doubleQuote = 34] = "doubleQuote", t[t.equals = 61] = "equals", t[t.exclamation = 33] = "exclamation", t[t.greaterThan = 62] = "greaterThan", t[t.lessThan = 60] = "lessThan", t[t.minus = 45] = "minus", t[t.openBrace = 123] = "openBrace", t[t.openBracket = 91] = "openBracket", t[t.openParen = 40] = "openParen", t[t.percent = 37] = "percent", t[t.plus = 43] = "plus", t[t.question = 63] = "question", t[t.semicolon = 59] = "semicolon", t[t.singleQuote = 39] = "singleQuote", t[t.slash = 47] = "slash", t[t.tilde = 126] = "tilde", t[t.backspace = 8] = "backspace", t[t.formFeed = 12] = "formFeed", t[t.byteOrderMark = 65279] = "byteOrderMark", t[t.tab = 9] = "tab", t[t.verticalTab = 11] = "verticalTab";
})(ae || (ae = {}));
function xN(t, e, i = vy.DEFAULT) {
  const n = yN(t, !1);
  function r(K) {
    return K ? () => K(n.getTokenOffset(), n.getTokenLength()) : () => !0;
  }
  function s(K) {
    return K ? (ye) => K(ye, n.getTokenOffset(), n.getTokenLength()) : () => !0;
  }
  const o = r(e.onObjectBegin), a = s(e.onObjectProperty), l = r(e.onObjectEnd), c = r(e.onArrayBegin), u = r(e.onArrayEnd), d = s(e.onLiteralValue), f = s(e.onSeparator), g = r(e.onComment), _ = s(e.onError), w = i && i.disallowComments, v = i && i.allowTrailingComma;
  function S() {
    for (; ; ) {
      const K = n.scan();
      switch (n.getTokenError()) {
        case _i.InvalidUnicode:
          E(Rt.InvalidUnicode);
          break;
        case _i.InvalidEscapeCharacter:
          E(Rt.InvalidEscapeCharacter);
          break;
        case _i.UnexpectedEndOfNumber:
          E(Rt.UnexpectedEndOfNumber);
          break;
        case _i.UnexpectedEndOfComment:
          w || E(Rt.UnexpectedEndOfComment);
          break;
        case _i.UnexpectedEndOfString:
          E(Rt.UnexpectedEndOfString);
          break;
        case _i.InvalidCharacter:
          E(Rt.InvalidCharacter);
          break;
      }
      switch (K) {
        case we.LineCommentTrivia:
        case we.BlockCommentTrivia:
          w ? E(Rt.InvalidCommentToken) : g();
          break;
        case we.Unknown:
          E(Rt.InvalidSymbol);
          break;
        case we.Trivia:
        case we.LineBreakTrivia:
          break;
        default:
          return K;
      }
    }
  }
  function E(K, ye = [], Fe = []) {
    if (_(K), ye.length + Fe.length > 0) {
      let Te = n.getToken();
      for (; Te !== we.EOF; ) {
        if (ye.indexOf(Te) !== -1) {
          S();
          break;
        } else if (Fe.indexOf(Te) !== -1)
          break;
        Te = S();
      }
    }
  }
  function A(K) {
    const ye = n.getTokenValue();
    return K ? d(ye) : a(ye), S(), !0;
  }
  function j() {
    switch (n.getToken()) {
      case we.NumericLiteral: {
        let K = 0;
        try {
          K = JSON.parse(n.getTokenValue()), typeof K != "number" && (E(Rt.InvalidNumberFormat), K = 0);
        } catch {
          E(Rt.InvalidNumberFormat);
        }
        d(K);
        break;
      }
      case we.NullKeyword:
        d(null);
        break;
      case we.TrueKeyword:
        d(!0);
        break;
      case we.FalseKeyword:
        d(!1);
        break;
      default:
        return !1;
    }
    return S(), !0;
  }
  function V() {
    return n.getToken() !== we.StringLiteral ? (E(Rt.PropertyNameExpected, [], [we.CloseBraceToken, we.CommaToken]), !1) : (A(!1), n.getToken() === we.ColonToken ? (f(":"), S(), re() || E(Rt.ValueExpected, [], [we.CloseBraceToken, we.CommaToken])) : E(Rt.ColonExpected, [], [we.CloseBraceToken, we.CommaToken]), !0);
  }
  function le() {
    o(), S();
    let K = !1;
    for (; n.getToken() !== we.CloseBraceToken && n.getToken() !== we.EOF; ) {
      if (n.getToken() === we.CommaToken) {
        if (K || E(Rt.ValueExpected, [], []), f(","), S(), n.getToken() === we.CloseBraceToken && v)
          break;
      } else K && E(Rt.CommaExpected, [], []);
      V() || E(Rt.ValueExpected, [], [we.CloseBraceToken, we.CommaToken]), K = !0;
    }
    return l(), n.getToken() !== we.CloseBraceToken ? E(Rt.CloseBraceExpected, [we.CloseBraceToken], []) : S(), !0;
  }
  function Q() {
    c(), S();
    let K = !1;
    for (; n.getToken() !== we.CloseBracketToken && n.getToken() !== we.EOF; ) {
      if (n.getToken() === we.CommaToken) {
        if (K || E(Rt.ValueExpected, [], []), f(","), S(), n.getToken() === we.CloseBracketToken && v)
          break;
      } else K && E(Rt.CommaExpected, [], []);
      re() || E(Rt.ValueExpected, [], [we.CloseBracketToken, we.CommaToken]), K = !0;
    }
    return u(), n.getToken() !== we.CloseBracketToken ? E(Rt.CloseBracketExpected, [we.CloseBracketToken], []) : S(), !0;
  }
  function re() {
    switch (n.getToken()) {
      case we.OpenBracketToken:
        return Q();
      case we.OpenBraceToken:
        return le();
      case we.StringLiteral:
        return A(!0);
      default:
        return j();
    }
  }
  return S(), n.getToken() === we.EOF ? i.allowEmptyContent ? !0 : (E(Rt.ValueExpected, [], []), !1) : re() ? (n.getToken() !== we.EOF && E(Rt.EndOfFileExpected, [], []), !0) : (E(Rt.ValueExpected, [], []), !1);
}
function Xu(t) {
  return Object.isFrozen(t) ? t : Ov(t);
}
class Cn {
  static createEmptyModel(e) {
    return new Cn({}, [], [], void 0, e);
  }
  constructor(e, i, n, r, s) {
    this._contents = e, this._keys = i, this._overrides = n, this.raw = r, this.logService = s, this.overrideConfigurations = /* @__PURE__ */ new Map();
  }
  get rawConfiguration() {
    if (!this._rawConfiguration)
      if (this.raw) {
        const e = (Array.isArray(this.raw) ? this.raw : [this.raw]).map((i) => {
          if (i instanceof Cn)
            return i;
          const n = new EN("", this.logService);
          return n.parseRaw(i), n.configurationModel;
        });
        this._rawConfiguration = e.reduce((i, n) => n === i ? n : i.merge(n), e[0]);
      } else
        this._rawConfiguration = this;
    return this._rawConfiguration;
  }
  get contents() {
    return this._contents;
  }
  get overrides() {
    return this._overrides;
  }
  get keys() {
    return this._keys;
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(e) {
    return e ? sg(this.contents, e) : this.contents;
  }
  inspect(e, i) {
    const n = this;
    return {
      get value() {
        return Xu(n.rawConfiguration.getValue(e));
      },
      get override() {
        return i ? Xu(n.rawConfiguration.getOverrideValue(e, i)) : void 0;
      },
      get merged() {
        return Xu(i ? n.rawConfiguration.override(i).getValue(e) : n.rawConfiguration.getValue(e));
      },
      get overrides() {
        const r = [];
        for (const { contents: s, identifiers: o, keys: a } of n.rawConfiguration.overrides) {
          const l = new Cn(s, a, [], void 0, n.logService).getValue(e);
          l !== void 0 && r.push({ identifiers: o, value: l });
        }
        return r.length ? Xu(r) : void 0;
      }
    };
  }
  getOverrideValue(e, i) {
    const n = this.getContentsForOverrideIdentifer(i);
    return n ? e ? sg(n, e) : n : void 0;
  }
  getKeysForOverrideIdentifier(e) {
    const i = [];
    for (const n of this.overrides)
      n.identifiers.includes(e) && i.push(...n.keys);
    return Fl(i);
  }
  getAllOverrideIdentifiers() {
    const e = [];
    for (const i of this.overrides)
      e.push(...i.identifiers);
    return Fl(e);
  }
  override(e) {
    let i = this.overrideConfigurations.get(e);
    return i || (i = this.createOverrideConfigurationModel(e), this.overrideConfigurations.set(e, i)), i;
  }
  merge(...e) {
    const i = yt(this.contents), n = yt(this.overrides), r = [...this.keys], s = this.raw ? Array.isArray(this.raw) ? [...this.raw] : [this.raw] : [this];
    for (const o of e)
      if (s.push(...o.raw ? Array.isArray(o.raw) ? o.raw : [o.raw] : [o]), !o.isEmpty()) {
        this.mergeContents(i, o.contents);
        for (const a of o.overrides) {
          const [l] = n.filter((c) => An(c.identifiers, a.identifiers));
          l ? (this.mergeContents(l.contents, a.contents), l.keys.push(...a.keys), l.keys = Fl(l.keys)) : n.push(yt(a));
        }
        for (const a of o.keys)
          r.indexOf(a) === -1 && r.push(a);
      }
    return new Cn(
      i,
      r,
      n,
      !s.length || s.every((o) => o instanceof Cn) ? void 0 : s,
      this.logService
    );
  }
  createOverrideConfigurationModel(e) {
    const i = this.getContentsForOverrideIdentifer(e);
    if (!i || typeof i != "object" || !Object.keys(i).length)
      return this;
    const n = {};
    for (const r of Fl([...Object.keys(this.contents), ...Object.keys(i)])) {
      let s = this.contents[r];
      const o = i[r];
      o && (typeof s == "object" && typeof o == "object" ? (s = yt(s), this.mergeContents(s, o)) : s = o), n[r] = s;
    }
    return new Cn(n, this.keys, this.overrides, void 0, this.logService);
  }
  mergeContents(e, i) {
    for (const n of Object.keys(i)) {
      if (n in e && ri(e[n]) && ri(i[n])) {
        this.mergeContents(e[n], i[n]);
        continue;
      }
      e[n] = yt(i[n]);
    }
  }
  getContentsForOverrideIdentifer(e) {
    let i = null, n = null;
    const r = (s) => {
      s && (n ? this.mergeContents(n, s) : n = yt(s));
    };
    for (const s of this.overrides)
      s.identifiers.length === 1 && s.identifiers[0] === e ? i = s.contents : s.identifiers.includes(e) && r(s.contents);
    return r(i), n;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  addValue(e, i) {
    this.updateValue(e, i, !0);
  }
  setValue(e, i) {
    this.updateValue(e, i, !1);
  }
  removeValue(e) {
    const i = this.keys.indexOf(e);
    i !== -1 && (this.keys.splice(i, 1), m3(this.contents, e), jr.test(e) && this.overrides.splice(this.overrides.findIndex((n) => An(n.identifiers, Xd(e))), 1));
  }
  updateValue(e, i, n) {
    if (DT(this.contents, e, i, (r) => this.logService.error(r)), n = n || this.keys.indexOf(e) === -1, n && this.keys.push(e), jr.test(e)) {
      const r = Xd(e), s = {
        identifiers: r,
        keys: Object.keys(this.contents[e]),
        contents: Yv(this.contents[e], (a) => this.logService.error(a))
      }, o = this.overrides.findIndex((a) => An(a.identifiers, r));
      o !== -1 ? this.overrides[o] = s : this.overrides.push(s);
    }
  }
}
class EN {
  constructor(e, i) {
    this._name = e, this.logService = i, this._raw = null, this._configurationModel = null, this._restrictedConfigurations = [], this._parseErrors = [];
  }
  get configurationModel() {
    return this._configurationModel || Cn.createEmptyModel(this.logService);
  }
  get restrictedConfigurations() {
    return this._restrictedConfigurations;
  }
  get errors() {
    return this._parseErrors;
  }
  parse(e, i) {
    if (!ni(e)) {
      const n = this.doParseContent(e);
      this.parseRaw(n, i);
    }
  }
  reparse(e) {
    this._raw && this.parseRaw(this._raw, e);
  }
  parseRaw(e, i) {
    this._raw = e;
    const { contents: n, keys: r, overrides: s, restricted: o, hasExcludedProperties: a } = this.doParseRaw(e, i);
    this._configurationModel = new Cn(
      n,
      r,
      s,
      a ? [e] : void 0,
      this.logService
    ), this._restrictedConfigurations = o || [];
  }
  doParseContent(e) {
    let i = {}, n = null, r = [];
    const s = [];
    function o(l) {
      Array.isArray(r) ? r.push(l) : n !== null && (r[n] = l);
    }
    const a = {
      onObjectBegin: () => {
        const l = {};
        o(l), s.push(r), r = l, n = null;
      },
      onObjectProperty: (l) => {
        n = l;
      },
      onObjectEnd: () => {
        r = s.pop();
      },
      onArrayBegin: () => {
        const l = [];
        o(l), s.push(r), r = l, n = null;
      },
      onArrayEnd: () => {
        r = s.pop();
      },
      onLiteralValue: o,
      onError: (l, c, u) => {
      }
    };
    if (e)
      try {
        xN(e, a), i = r[0] || {};
      } catch (l) {
        this.logService.error(`Error while parsing settings file ${this._name}: ${l}`), this._parseErrors = [l];
      }
    return i;
  }
  doParseRaw(e, i) {
    const n = ai.as(ml.Configuration).getConfigurationProperties(), r = this.filter(e, n, !0, i);
    e = r.raw;
    const s = Yv(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`)), o = Object.keys(e), a = this.toOverrides(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`));
    return { contents: s, keys: o, overrides: a, restricted: r.restricted, hasExcludedProperties: r.hasExcludedProperties };
  }
  filter(e, i, n, r) {
    let s = !1;
    if (!r?.scopes && !r?.skipRestricted && !r?.exclude?.length)
      return { raw: e, restricted: [], hasExcludedProperties: s };
    const o = {}, a = [];
    for (const l in e)
      if (jr.test(l) && n) {
        const c = this.filter(e[l], i, !1, r);
        o[l] = c.raw, s = s || c.hasExcludedProperties, a.push(...c.restricted);
      } else {
        const c = i[l];
        c?.restricted && a.push(l), this.shouldInclude(l, c, r) ? o[l] = e[l] : s = !0;
      }
    return { raw: o, restricted: a, hasExcludedProperties: s };
  }
  shouldInclude(e, i, n) {
    if (n.exclude?.includes(e))
      return !1;
    if (n.include?.includes(e))
      return !0;
    if (n.skipRestricted && i?.restricted || n.skipUnregistered && !i)
      return !1;
    const r = i ? typeof i.scope < "u" ? i.scope : Lt.WINDOW : void 0;
    return r === void 0 || n.scopes === void 0 ? !0 : n.scopes.includes(r);
  }
  toOverrides(e, i) {
    const n = [];
    for (const r of Object.keys(e))
      if (jr.test(r)) {
        const s = {};
        for (const o in e[r])
          s[o] = e[r][o];
        n.push({
          identifiers: Xd(r),
          keys: Object.keys(s),
          contents: Yv(s, i)
        });
      }
    return n;
  }
}
class SN {
  constructor(e, i, n, r, s, o, a, l, c, u, d, f, g) {
    this.key = e, this.overrides = i, this._value = n, this.overrideIdentifiers = r, this.defaultConfiguration = s, this.policyConfiguration = o, this.applicationConfiguration = a, this.userConfiguration = l, this.localUserConfiguration = c, this.remoteUserConfiguration = u, this.workspaceConfiguration = d, this.folderConfigurationModel = f, this.memoryConfigurationModel = g;
  }
  get value() {
    return Xu(this._value);
  }
  toInspectValue(e) {
    return e?.value !== void 0 || e?.override !== void 0 || e?.overrides !== void 0 ? e : void 0;
  }
  get defaultInspectValue() {
    return this._defaultInspectValue || (this._defaultInspectValue = this.defaultConfiguration.inspect(this.key, this.overrides.overrideIdentifier)), this._defaultInspectValue;
  }
  get defaultValue() {
    return this.defaultInspectValue.merged;
  }
  get default() {
    return this.toInspectValue(this.defaultInspectValue);
  }
  get policyInspectValue() {
    return this._policyInspectValue === void 0 && (this._policyInspectValue = this.policyConfiguration ? this.policyConfiguration.inspect(this.key) : null), this._policyInspectValue;
  }
  get policyValue() {
    return this.policyInspectValue?.merged;
  }
  get policy() {
    return this.policyInspectValue?.value !== void 0 ? { value: this.policyInspectValue.value } : void 0;
  }
  get applicationInspectValue() {
    return this._applicationInspectValue === void 0 && (this._applicationInspectValue = this.applicationConfiguration ? this.applicationConfiguration.inspect(this.key) : null), this._applicationInspectValue;
  }
  get applicationValue() {
    return this.applicationInspectValue?.merged;
  }
  get application() {
    return this.toInspectValue(this.applicationInspectValue);
  }
  get userInspectValue() {
    return this._userInspectValue || (this._userInspectValue = this.userConfiguration.inspect(this.key, this.overrides.overrideIdentifier)), this._userInspectValue;
  }
  get userValue() {
    return this.userInspectValue.merged;
  }
  get user() {
    return this.toInspectValue(this.userInspectValue);
  }
  get userLocalInspectValue() {
    return this._userLocalInspectValue || (this._userLocalInspectValue = this.localUserConfiguration.inspect(this.key, this.overrides.overrideIdentifier)), this._userLocalInspectValue;
  }
  get userLocalValue() {
    return this.userLocalInspectValue.merged;
  }
  get userLocal() {
    return this.toInspectValue(this.userLocalInspectValue);
  }
  get userRemoteInspectValue() {
    return this._userRemoteInspectValue || (this._userRemoteInspectValue = this.remoteUserConfiguration.inspect(this.key, this.overrides.overrideIdentifier)), this._userRemoteInspectValue;
  }
  get userRemoteValue() {
    return this.userRemoteInspectValue.merged;
  }
  get userRemote() {
    return this.toInspectValue(this.userRemoteInspectValue);
  }
  get workspaceInspectValue() {
    return this._workspaceInspectValue === void 0 && (this._workspaceInspectValue = this.workspaceConfiguration ? this.workspaceConfiguration.inspect(this.key, this.overrides.overrideIdentifier) : null), this._workspaceInspectValue;
  }
  get workspaceValue() {
    return this.workspaceInspectValue?.merged;
  }
  get workspace() {
    return this.toInspectValue(this.workspaceInspectValue);
  }
  get workspaceFolderInspectValue() {
    return this._workspaceFolderInspectValue === void 0 && (this._workspaceFolderInspectValue = this.folderConfigurationModel ? this.folderConfigurationModel.inspect(this.key, this.overrides.overrideIdentifier) : null), this._workspaceFolderInspectValue;
  }
  get workspaceFolderValue() {
    return this.workspaceFolderInspectValue?.merged;
  }
  get workspaceFolder() {
    return this.toInspectValue(this.workspaceFolderInspectValue);
  }
  get memoryInspectValue() {
    return this._memoryInspectValue === void 0 && (this._memoryInspectValue = this.memoryConfigurationModel.inspect(this.key, this.overrides.overrideIdentifier)), this._memoryInspectValue;
  }
  get memoryValue() {
    return this.memoryInspectValue.merged;
  }
  get memory() {
    return this.toInspectValue(this.memoryInspectValue);
  }
}
let wy = class qP {
  constructor(e, i, n, r, s, o, a, l, c, u) {
    this._defaultConfiguration = e, this._policyConfiguration = i, this._applicationConfiguration = n, this._localUserConfiguration = r, this._remoteUserConfiguration = s, this._workspaceConfiguration = o, this._folderConfigurations = a, this._memoryConfiguration = l, this._memoryConfigurationByResource = c, this.logService = u, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new fi(), this._userConfiguration = null;
  }
  getValue(e, i, n) {
    return this.getConsolidatedConfigurationModel(e, i, n).getValue(e);
  }
  updateValue(e, i, n = {}) {
    let r;
    n.resource ? (r = this._memoryConfigurationByResource.get(n.resource), r || (r = Cn.createEmptyModel(this.logService), this._memoryConfigurationByResource.set(n.resource, r))) : r = this._memoryConfiguration, i === void 0 ? r.removeValue(e) : r.setValue(e, i), n.resource || (this._workspaceConsolidatedConfiguration = null);
  }
  inspect(e, i, n) {
    const r = this.getConsolidatedConfigurationModel(e, i, n), s = this.getFolderConfigurationModelForResource(i.resource, n), o = i.resource ? this._memoryConfigurationByResource.get(i.resource) || this._memoryConfiguration : this._memoryConfiguration, a = /* @__PURE__ */ new Set();
    for (const l of r.overrides)
      for (const c of l.identifiers)
        r.getOverrideValue(e, c) !== void 0 && a.add(c);
    return new SN(
      e,
      i,
      r.getValue(e),
      a.size ? [...a] : void 0,
      this._defaultConfiguration,
      this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration,
      this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration,
      this.userConfiguration,
      this.localUserConfiguration,
      this.remoteUserConfiguration,
      n ? this._workspaceConfiguration : void 0,
      s || void 0,
      o
    );
  }
  keys(e) {
    const i = this.getFolderConfigurationModelForResource(void 0, e);
    return {
      default: this._defaultConfiguration.keys.slice(0),
      user: this.userConfiguration.keys.slice(0),
      workspace: this._workspaceConfiguration.keys.slice(0),
      workspaceFolder: i ? i.keys.slice(0) : []
    };
  }
  updateDefaultConfiguration(e) {
    this._defaultConfiguration = e, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations.clear();
  }
  updatePolicyConfiguration(e) {
    this._policyConfiguration = e;
  }
  updateApplicationConfiguration(e) {
    this._applicationConfiguration = e, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations.clear();
  }
  updateLocalUserConfiguration(e) {
    this._localUserConfiguration = e, this._userConfiguration = null, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations.clear();
  }
  updateRemoteUserConfiguration(e) {
    this._remoteUserConfiguration = e, this._userConfiguration = null, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations.clear();
  }
  updateWorkspaceConfiguration(e) {
    this._workspaceConfiguration = e, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations.clear();
  }
  updateFolderConfiguration(e, i) {
    this._folderConfigurations.set(e, i), this._foldersConsolidatedConfigurations.delete(e);
  }
  deleteFolderConfiguration(e) {
    this.folderConfigurations.delete(e), this._foldersConsolidatedConfigurations.delete(e);
  }
  compareAndUpdateDefaultConfiguration(e, i) {
    const n = [];
    if (!i) {
      const { added: r, updated: s, removed: o } = js(this._defaultConfiguration, e);
      i = [...r, ...s, ...o];
    }
    for (const r of i)
      for (const s of Xd(r)) {
        const o = this._defaultConfiguration.getKeysForOverrideIdentifier(s), a = e.getKeysForOverrideIdentifier(s), l = [
          ...a.filter((c) => o.indexOf(c) === -1),
          ...o.filter((c) => a.indexOf(c) === -1),
          ...o.filter((c) => !sn(this._defaultConfiguration.override(s).getValue(c), e.override(s).getValue(c)))
        ];
        n.push([s, l]);
      }
    return this.updateDefaultConfiguration(e), { keys: i, overrides: n };
  }
  compareAndUpdatePolicyConfiguration(e) {
    const { added: i, updated: n, removed: r } = js(this._policyConfiguration, e), s = [...i, ...n, ...r];
    return s.length && this.updatePolicyConfiguration(e), { keys: s, overrides: [] };
  }
  compareAndUpdateApplicationConfiguration(e) {
    const { added: i, updated: n, removed: r, overrides: s } = js(this.applicationConfiguration, e), o = [...i, ...n, ...r];
    return o.length && this.updateApplicationConfiguration(e), { keys: o, overrides: s };
  }
  compareAndUpdateLocalUserConfiguration(e) {
    const { added: i, updated: n, removed: r, overrides: s } = js(this.localUserConfiguration, e), o = [...i, ...n, ...r];
    return o.length && this.updateLocalUserConfiguration(e), { keys: o, overrides: s };
  }
  compareAndUpdateRemoteUserConfiguration(e) {
    const { added: i, updated: n, removed: r, overrides: s } = js(this.remoteUserConfiguration, e), o = [...i, ...n, ...r];
    return o.length && this.updateRemoteUserConfiguration(e), { keys: o, overrides: s };
  }
  compareAndUpdateWorkspaceConfiguration(e) {
    const { added: i, updated: n, removed: r, overrides: s } = js(this.workspaceConfiguration, e), o = [...i, ...n, ...r];
    return o.length && this.updateWorkspaceConfiguration(e), { keys: o, overrides: s };
  }
  compareAndUpdateFolderConfiguration(e, i) {
    const n = this.folderConfigurations.get(e), { added: r, updated: s, removed: o, overrides: a } = js(n, i), l = [...r, ...s, ...o];
    return (l.length || !n) && this.updateFolderConfiguration(e, i), { keys: l, overrides: a };
  }
  compareAndDeleteFolderConfiguration(e) {
    const i = this.folderConfigurations.get(e);
    if (!i)
      throw new Error("Unknown folder");
    this.deleteFolderConfiguration(e);
    const { added: n, updated: r, removed: s, overrides: o } = js(i, void 0);
    return { keys: [...n, ...r, ...s], overrides: o };
  }
  get defaults() {
    return this._defaultConfiguration;
  }
  get applicationConfiguration() {
    return this._applicationConfiguration;
  }
  get userConfiguration() {
    if (!this._userConfiguration)
      if (this._remoteUserConfiguration.isEmpty())
        this._userConfiguration = this._localUserConfiguration;
      else {
        const e = this._localUserConfiguration.merge(this._remoteUserConfiguration);
        this._userConfiguration = new Cn(e.contents, e.keys, e.overrides, void 0, this.logService);
      }
    return this._userConfiguration;
  }
  get localUserConfiguration() {
    return this._localUserConfiguration;
  }
  get remoteUserConfiguration() {
    return this._remoteUserConfiguration;
  }
  get workspaceConfiguration() {
    return this._workspaceConfiguration;
  }
  get folderConfigurations() {
    return this._folderConfigurations;
  }
  getConsolidatedConfigurationModel(e, i, n) {
    let r = this.getConsolidatedConfigurationModelForResource(i, n);
    if (i.overrideIdentifier && (r = r.override(i.overrideIdentifier)), !this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(e) !== void 0) {
      r = r.merge();
      for (const s of this._policyConfiguration.keys)
        r.setValue(s, this._policyConfiguration.getValue(s));
    }
    return r;
  }
  getConsolidatedConfigurationModelForResource({ resource: e }, i) {
    let n = this.getWorkspaceConsolidatedConfiguration();
    if (i && e) {
      const r = i.getFolder(e);
      r && (n = this.getFolderConsolidatedConfiguration(r.uri) || n);
      const s = this._memoryConfigurationByResource.get(e);
      s && (n = n.merge(s));
    }
    return n;
  }
  getWorkspaceConsolidatedConfiguration() {
    return this._workspaceConsolidatedConfiguration || (this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration)), this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(e) {
    let i = this._foldersConsolidatedConfigurations.get(e);
    if (!i) {
      const n = this.getWorkspaceConsolidatedConfiguration(), r = this._folderConfigurations.get(e);
      r ? (i = n.merge(r), this._foldersConsolidatedConfigurations.set(e, i)) : i = n;
    }
    return i;
  }
  getFolderConfigurationModelForResource(e, i) {
    if (i && e) {
      const n = i.getFolder(e);
      if (n)
        return this._folderConfigurations.get(n.uri);
    }
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      policy: {
        contents: this._policyConfiguration.contents,
        overrides: this._policyConfiguration.overrides,
        keys: this._policyConfiguration.keys
      },
      application: {
        contents: this.applicationConfiguration.contents,
        overrides: this.applicationConfiguration.overrides,
        keys: this.applicationConfiguration.keys,
        raw: Array.isArray(this.applicationConfiguration.raw) ? void 0 : this.applicationConfiguration.raw
      },
      userLocal: {
        contents: this.localUserConfiguration.contents,
        overrides: this.localUserConfiguration.overrides,
        keys: this.localUserConfiguration.keys,
        raw: Array.isArray(this.localUserConfiguration.raw) ? void 0 : this.localUserConfiguration.raw
      },
      userRemote: {
        contents: this.remoteUserConfiguration.contents,
        overrides: this.remoteUserConfiguration.overrides,
        keys: this.remoteUserConfiguration.keys,
        raw: Array.isArray(this.remoteUserConfiguration.raw) ? void 0 : this.remoteUserConfiguration.raw
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((e, i) => {
        const { contents: n, overrides: r, keys: s } = this._folderConfigurations.get(i);
        return e.push([i, { contents: n, overrides: r, keys: s }]), e;
      }, [])
    };
  }
  allKeys() {
    const e = /* @__PURE__ */ new Set();
    return this._defaultConfiguration.keys.forEach((i) => e.add(i)), this.userConfiguration.keys.forEach((i) => e.add(i)), this._workspaceConfiguration.keys.forEach((i) => e.add(i)), this._folderConfigurations.forEach((i) => i.keys.forEach((n) => e.add(n))), [...e.values()];
  }
  allOverrideIdentifiers() {
    const e = /* @__PURE__ */ new Set();
    return this._defaultConfiguration.getAllOverrideIdentifiers().forEach((i) => e.add(i)), this.userConfiguration.getAllOverrideIdentifiers().forEach((i) => e.add(i)), this._workspaceConfiguration.getAllOverrideIdentifiers().forEach((i) => e.add(i)), this._folderConfigurations.forEach((i) => i.getAllOverrideIdentifiers().forEach((n) => e.add(n))), [...e.values()];
  }
  getAllKeysForOverrideIdentifier(e) {
    const i = /* @__PURE__ */ new Set();
    return this._defaultConfiguration.getKeysForOverrideIdentifier(e).forEach((n) => i.add(n)), this.userConfiguration.getKeysForOverrideIdentifier(e).forEach((n) => i.add(n)), this._workspaceConfiguration.getKeysForOverrideIdentifier(e).forEach((n) => i.add(n)), this._folderConfigurations.forEach((n) => n.getKeysForOverrideIdentifier(e).forEach((r) => i.add(r))), [...i.values()];
  }
  static parse(e, i) {
    const n = this.parseConfigurationModel(e.defaults, i), r = this.parseConfigurationModel(e.policy, i), s = this.parseConfigurationModel(e.application, i), o = this.parseConfigurationModel(e.userLocal, i), a = this.parseConfigurationModel(e.userRemote, i), l = this.parseConfigurationModel(e.workspace, i), c = e.folders.reduce((u, d) => (u.set(x.revive(d[0]), this.parseConfigurationModel(d[1], i)), u), new fi());
    return new qP(
      n,
      r,
      s,
      o,
      a,
      l,
      c,
      Cn.createEmptyModel(i),
      new fi(),
      i
    );
  }
  static parseConfigurationModel(e, i) {
    return new Cn(e.contents, e.keys, e.overrides, e.raw, i);
  }
};
class DN {
  constructor(e, i, n, r, s) {
    this.change = e, this.previous = i, this.currentConfiguraiton = n, this.currentWorkspace = r, this.logService = s, this._marker = `
`, this._markerCode1 = this._marker.charCodeAt(0), this._markerCode2 = 46, this.affectedKeys = /* @__PURE__ */ new Set(), this._previousConfiguration = void 0;
    for (const o of e.keys)
      this.affectedKeys.add(o);
    for (const [, o] of e.overrides)
      for (const a of o)
        this.affectedKeys.add(a);
    this._affectsConfigStr = this._marker;
    for (const o of this.affectedKeys)
      this._affectsConfigStr += o + this._marker;
  }
  get previousConfiguration() {
    return !this._previousConfiguration && this.previous && (this._previousConfiguration = wy.parse(this.previous.data, this.logService)), this._previousConfiguration;
  }
  affectsConfiguration(e, i) {
    const n = this._marker + e, r = this._affectsConfigStr.indexOf(n);
    if (r < 0)
      return !1;
    const s = r + n.length;
    if (s >= this._affectsConfigStr.length)
      return !1;
    const o = this._affectsConfigStr.charCodeAt(s);
    if (o !== this._markerCode1 && o !== this._markerCode2)
      return !1;
    if (i) {
      const a = this.previousConfiguration ? this.previousConfiguration.getValue(e, i, this.previous?.workspace) : void 0, l = this.currentConfiguraiton.getValue(e, i, this.currentWorkspace);
      return !sn(a, l);
    }
    return !0;
  }
}
function js(t, e) {
  const { added: i, removed: n, updated: r } = Lk(e?.rawConfiguration, t?.rawConfiguration), s = [], o = t?.getAllOverrideIdentifiers() || [], a = e?.getAllOverrideIdentifiers() || [];
  if (e) {
    const l = a.filter((c) => !o.includes(c));
    for (const c of l)
      s.push([c, e.getKeysForOverrideIdentifier(c)]);
  }
  if (t) {
    const l = o.filter((c) => !a.includes(c));
    for (const c of l)
      s.push([c, t.getKeysForOverrideIdentifier(c)]);
  }
  if (e && t) {
    for (const l of o)
      if (a.includes(l)) {
        const c = Lk({ contents: t.getOverrideValue(void 0, l) || {}, keys: t.getKeysForOverrideIdentifier(l) }, { contents: e.getOverrideValue(void 0, l) || {}, keys: e.getKeysForOverrideIdentifier(l) });
        s.push([l, [...c.added, ...c.removed, ...c.updated]]);
      }
  }
  return { added: i, removed: n, updated: r, overrides: s };
}
function Lk(t, e) {
  const i = t ? e ? t.keys.filter((s) => e.keys.indexOf(s) === -1) : [...t.keys] : [], n = e ? t ? e.keys.filter((s) => t.keys.indexOf(s) === -1) : [...e.keys] : [], r = [];
  if (t && e) {
    for (const s of e.keys)
      if (t.keys.indexOf(s) !== -1) {
        const o = sg(e.contents, s), a = sg(t.contents, s);
        sn(o, a) || r.push(s);
      }
  }
  return { added: i, removed: n, updated: r };
}
function $f(t, e) {
  if (e) {
    const i = e.split(".");
    let n = t;
    for (let r = 0; n && r < i.length; r++)
      n = n[i[r]];
    return n;
  }
}
function kN(t) {
  return t instanceof x;
}
function IN(t) {
  return t && t.uri instanceof x && t.languageId && typeof t.languageId == "string";
}
function CN(t) {
  return t && !t.uri && t.languageId && typeof t.languageId == "string";
}
function TN(t) {
  return t && t.uri instanceof x && (!t.name || typeof t.name == "string") && (!t.index || typeof t.index == "number");
}
function Nk(t) {
  if (kN(t))
    return { resource: t };
  if (IN(t))
    return { resource: t.uri, overrideIdentifier: t.languageId };
  if (CN(t))
    return { overrideIdentifier: t.languageId };
  if (TN(t))
    return { resource: t.uri };
  if (t === null)
    return { resource: null };
}
let by = class {
  constructor(e, i, n) {
    this._proxy = e.getProxy(ee.MainThreadConfiguration), this._extHostWorkspace = i, this._logService = n, this._barrier = new Ur(), this._actual = null;
  }
  getConfigProvider() {
    return this._barrier.wait().then((e) => this._actual);
  }
  $initializeConfiguration(e) {
    this._actual = new PN(this._proxy, this._extHostWorkspace, e, this._logService), this._barrier.open();
  }
  $acceptConfigurationChanged(e, i) {
    this.getConfigProvider().then((n) => n.$acceptConfigurationChanged(e, i));
  }
};
by = W([
  M(0, Ye),
  M(1, Us),
  M(2, nt)
], by);
class PN {
  constructor(e, i, n, r) {
    this._onDidChangeConfiguration = new N(), this._proxy = e, this._logService = r, this._extHostWorkspace = i, this._configuration = wy.parse(n, r), this._configurationScopes = this._toMap(n.configurationScopes);
  }
  get onDidChangeConfiguration() {
    return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event;
  }
  $acceptConfigurationChanged(e, i) {
    const n = { data: this._configuration.toData(), workspace: this._extHostWorkspace.workspace };
    this._configuration = wy.parse(e, this._logService), this._configurationScopes = this._toMap(e.configurationScopes), this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(i, n));
  }
  getConfiguration(e, i, n) {
    const r = Nk(i) || {}, s = this._toReadonlyValue(this._configuration.getValue(e, r, this._extHostWorkspace.workspace));
    e && this._validateConfigurationAccess(e, r, n?.identifier);
    function o(l) {
      if (l == null)
        return null;
      if (typeof l == "boolean")
        return l ? ti.USER : ti.WORKSPACE;
      switch (l) {
        case vc.Global:
          return ti.USER;
        case vc.Workspace:
          return ti.WORKSPACE;
        case vc.WorkspaceFolder:
          return ti.WORKSPACE_FOLDER;
      }
    }
    const a = {
      has(l) {
        return typeof $f(s, l) < "u";
      },
      get: (l, c) => {
        this._validateConfigurationAccess(e ? `${e}.${l}` : l, r, n?.identifier);
        let u = $f(s, l);
        if (typeof u > "u")
          u = c;
        else {
          let d;
          const f = (g, _) => {
            if (ri(g)) {
              let w;
              const v = () => {
                d = d || yt(s), w = w || $f(d, _);
              };
              return new Proxy(g, {
                get: (S, E) => {
                  if (typeof E == "string" && E.toLowerCase() === "tojson")
                    return v(), () => w;
                  if (d)
                    return w = w || $f(d, _), w[E];
                  const A = S[E];
                  return typeof E == "string" ? f(A, `${_}.${E}`) : A;
                },
                set: (S, E, A) => (v(), w && (w[E] = A), !0),
                deleteProperty: (S, E) => (v(), w && delete w[E], !0),
                defineProperty: (S, E, A) => (v(), w && Object.defineProperty(w, E, A), !0)
              });
            }
            return Array.isArray(g) ? yt(g) : g;
          };
          u = f(u, l);
        }
        return u;
      },
      update: (l, c, u, d) => {
        l = e ? `${e}.${l}` : l;
        const f = o(u);
        return c !== void 0 ? this._proxy.$updateConfigurationOption(f, l, c, r, d) : this._proxy.$removeConfigurationOption(f, l, r, d);
      },
      inspect: (l) => {
        l = e ? `${e}.${l}` : l;
        const c = this._configuration.inspect(l, r, this._extHostWorkspace.workspace);
        if (c)
          return {
            key: l,
            defaultValue: yt(c.policy?.value ?? c.default?.value),
            globalLocalValue: yt(c.userLocal?.value),
            globalRemoteValue: yt(c.userRemote?.value),
            globalValue: yt(c.user?.value ?? c.application?.value),
            workspaceValue: yt(c.workspace?.value),
            workspaceFolderValue: yt(c.workspaceFolder?.value),
            defaultLanguageValue: yt(c.default?.override),
            globalLocalLanguageValue: yt(c.userLocal?.override),
            globalRemoteLanguageValue: yt(c.userRemote?.override),
            globalLanguageValue: yt(c.user?.override ?? c.application?.override),
            workspaceLanguageValue: yt(c.workspace?.override),
            workspaceFolderLanguageValue: yt(c.workspaceFolder?.override),
            languageIds: yt(c.overrideIdentifiers)
          };
      }
    };
    return typeof s == "object" && Za(a, s, !1), Object.freeze(a);
  }
  _toReadonlyValue(e) {
    const i = (n) => ri(n) ? new Proxy(n, {
      get: (r, s) => i(r[s]),
      set: (r, s, o) => {
        throw new Error(
          `TypeError: Cannot assign to read only property '${String(s)}' of object`
        );
      },
      deleteProperty: (r, s) => {
        throw new Error(
          `TypeError: Cannot delete read only property '${String(s)}' of object`
        );
      },
      defineProperty: (r, s) => {
        throw new Error(
          `TypeError: Cannot define property '${String(s)}' for a readonly object`
        );
      },
      setPrototypeOf: (r) => {
        throw new Error("TypeError: Cannot set prototype for a readonly object");
      },
      isExtensible: () => !1,
      preventExtensions: () => !0
    }) : n;
    return i(e);
  }
  _validateConfigurationAccess(e, i, n) {
    const r = jr.test(e) ? Lt.RESOURCE : this._configurationScopes.get(e), s = n ? `[${n.value}] ` : "";
    if (Lt.RESOURCE === r) {
      typeof i?.resource > "u" && this._logService.warn(`${s}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${e}', provide the URI of a resource or 'null' for any resource.`);
      return;
    }
    if (Lt.WINDOW === r) {
      i?.resource && this._logService.warn(`${s}Accessing a window scoped configuration for a resource is not expected. To associate '${e}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`);
      return;
    }
  }
  _toConfigurationChangeEvent(e, i) {
    const n = new DN(
      e,
      i,
      this._configuration,
      this._extHostWorkspace.workspace,
      this._logService
    );
    return Object.freeze({
      affectsConfiguration: (r, s) => n.affectsConfiguration(r, Nk(s))
    });
  }
  _toMap(e) {
    return e.reduce((i, n) => (i.set(n[0], n[1]), i), /* @__PURE__ */ new Map());
  }
}
const $s = pe("IExtHostConfiguration");
class AN {
  constructor(e, i) {
    this.versionId = e, this.removedDueToLooping = i;
  }
}
class Ua extends ve {
  static isHostExtension(e, i, n) {
    if (i.getExtensionDescription(e))
      return !1;
    const r = n.getExtensionDescription(e);
    return r ? !!((r.main || r.browser) && r.api === "none") : !1;
  }
  constructor(e, i) {
    super(), this._activationEventsReader = e, this._onDidChange = this._register(new N()), this.onDidChange = this._onDidChange.event, this._versionId = 0, this._extensionDescriptions = i, this._initialize();
  }
  _initialize() {
    this._extensionDescriptions.sort(LN), this._extensionsMap = new Io(), this._extensionsArr = [], this._activationMap = /* @__PURE__ */ new Map();
    for (const e of this._extensionDescriptions) {
      if (this._extensionsMap.has(e.identifier)) {
        console.error("Extension `" + e.identifier.value + "` is already registered");
        continue;
      }
      this._extensionsMap.set(e.identifier, e), this._extensionsArr.push(e);
      const i = this._activationEventsReader.readActivationEvents(e);
      for (const n of i)
        this._activationMap.has(n) || this._activationMap.set(n, []), this._activationMap.get(n).push(e);
    }
  }
  set(e) {
    return this._extensionDescriptions = e, this._initialize(), this._versionId++, this._onDidChange.fire(void 0), {
      versionId: this._versionId
    };
  }
  deltaExtensions(e, i) {
    this._extensionDescriptions = Mk(this._extensionDescriptions, i), this._extensionDescriptions = this._extensionDescriptions.concat(e);
    const n = Ua._findLoopingExtensions(this._extensionDescriptions);
    return this._extensionDescriptions = Mk(this._extensionDescriptions, n.map((r) => r.identifier)), this._initialize(), this._versionId++, this._onDidChange.fire(void 0), new AN(this._versionId, n);
  }
  static _findLoopingExtensions(e) {
    const i = new class {
      constructor() {
        this._arcs = /* @__PURE__ */ new Map(), this._nodesSet = /* @__PURE__ */ new Set(), this._nodesArr = [];
      }
      addNode(a) {
        this._nodesSet.has(a) || (this._nodesSet.add(a), this._nodesArr.push(a));
      }
      addArc(a, l) {
        this.addNode(a), this.addNode(l), this._arcs.has(a) ? this._arcs.get(a).push(l) : this._arcs.set(a, [l]);
      }
      getArcs(a) {
        return this._arcs.has(a) ? this._arcs.get(a) : [];
      }
      hasOnlyGoodArcs(a, l) {
        const c = i.getArcs(a);
        for (let u = 0; u < c.length; u++)
          if (!l.has(c[u]))
            return !1;
        return !0;
      }
      getNodes() {
        return this._nodesArr;
      }
    }(), n = new Io();
    for (const a of e)
      if (n.set(a.identifier, a), a.extensionDependencies)
        for (const l of a.extensionDependencies)
          i.addArc(ht.toKey(a.identifier), ht.toKey(l));
    const r = /* @__PURE__ */ new Set();
    i.getNodes().filter((a) => i.getArcs(a).length === 0).forEach((a) => r.add(a));
    const s = i.getNodes().filter((a) => !r.has(a));
    let o;
    do {
      o = !1;
      for (let a = 0; a < s.length; a++) {
        const l = s[a];
        i.hasOnlyGoodArcs(l, r) && (s.splice(a, 1), a--, r.add(l), o = !0);
      }
    } while (o);
    return s.map((a) => n.get(a));
  }
  containsActivationEvent(e) {
    return this._activationMap.has(e);
  }
  containsExtension(e) {
    return this._extensionsMap.has(e);
  }
  getExtensionDescriptionsForActivationEvent(e) {
    const i = this._activationMap.get(e);
    return i ? i.slice(0) : [];
  }
  getAllExtensionDescriptions() {
    return this._extensionsArr.slice(0);
  }
  getSnapshot() {
    return new RN(this._versionId, this.getAllExtensionDescriptions());
  }
  getExtensionDescription(e) {
    const i = this._extensionsMap.get(e);
    return i || void 0;
  }
  getExtensionDescriptionByUUID(e) {
    for (const i of this._extensionsArr)
      if (i.uuid === e)
        return i;
  }
  getExtensionDescriptionByIdOrUUID(e, i) {
    return this.getExtensionDescription(e) ?? (i ? this.getExtensionDescriptionByUUID(i) : void 0);
  }
}
class RN {
  constructor(e, i) {
    this.versionId = e, this.extensions = i;
  }
}
var eo;
(function(t) {
  t[t.Builtin = 0] = "Builtin", t[t.User = 1] = "User", t[t.Dev = 2] = "Dev";
})(eo || (eo = {}));
function LN(t, e) {
  const i = t.isBuiltin ? eo.Builtin : t.isUnderDevelopment ? eo.Dev : eo.User, n = e.isBuiltin ? eo.Builtin : e.isUnderDevelopment ? eo.Dev : eo.User;
  if (i !== n)
    return i - n;
  const r = dt.basename(t.extensionLocation.path), s = dt.basename(e.extensionLocation.path);
  return r < s ? -1 : r > s ? 1 : 0;
}
function Mk(t, e) {
  const i = new ul(e);
  return t.filter((n) => !i.has(n.identifier));
}
const w_ = class w_ {
  constructor(e, i, n, r) {
    this.startup = e, this.codeLoadingTime = i, this.activateCallTime = n, this.activateResolvedTime = r;
  }
};
w_.NONE = new w_(!1, -1, -1, -1);
let mu = w_;
class Q1 {
  constructor(e) {
    this._startup = e, this._codeLoadingStart = -1, this._codeLoadingStop = -1, this._activateCallStart = -1, this._activateCallStop = -1, this._activateResolveStart = -1, this._activateResolveStop = -1;
  }
  _delta(e, i) {
    return e === -1 || i === -1 ? -1 : i - e;
  }
  build() {
    return new mu(
      this._startup,
      this._delta(this._codeLoadingStart, this._codeLoadingStop),
      this._delta(this._activateCallStart, this._activateCallStop),
      this._delta(this._activateResolveStart, this._activateResolveStop)
    );
  }
  codeLoadingStart() {
    this._codeLoadingStart = Date.now();
  }
  codeLoadingStop() {
    this._codeLoadingStop = Date.now();
  }
  activateCallStart() {
    this._activateCallStart = Date.now();
  }
  activateCallStop() {
    this._activateCallStop = Date.now();
  }
  activateResolveStart() {
    this._activateResolveStart = Date.now();
  }
  activateResolveStop() {
    this._activateResolveStop = Date.now();
  }
}
class a1 {
  constructor(e, i, n, r, s, o) {
    this.activationFailed = e, this.activationFailedError = i, this.activationTimes = n, this.module = r, this.exports = s, this.disposable = o;
  }
}
class NN extends a1 {
  constructor(e) {
    super(!1, null, e, { activate: void 0, deactivate: void 0 }, void 0, ve.None);
  }
}
class MN extends a1 {
  constructor() {
    super(!1, null, mu.NONE, { activate: void 0, deactivate: void 0 }, void 0, ve.None);
  }
}
class jm extends a1 {
  constructor(e) {
    super(!0, e, mu.NONE, { activate: void 0, deactivate: void 0 }, void 0, ve.None);
  }
}
let yy = class {
  constructor(e, i, n, r) {
    this._logService = r, this._registry = e, this._globalRegistry = i, this._host = n, this._operations = new Io(), this._alreadyActivatedEvents = /* @__PURE__ */ Object.create(null);
  }
  dispose() {
    for (const [e, i] of this._operations)
      i.dispose();
  }
  async waitForActivatingExtensions() {
    const e = [];
    for (const [i, n] of this._operations)
      e.push(n.wait());
    await Promise.all(e);
  }
  isActivated(e) {
    const i = this._operations.get(e);
    return !!(i && i.value);
  }
  getActivatedExtension(e) {
    const i = this._operations.get(e);
    if (!i || !i.value)
      throw new Error(`Extension '${e.value}' is not known or not activated`);
    return i.value;
  }
  async activateByEvent(e, i) {
    if (this._alreadyActivatedEvents[e])
      return;
    const n = this._registry.getExtensionDescriptionsForActivationEvent(e);
    await this._activateExtensions(n.map((r) => ({
      id: r.identifier,
      reason: { startup: i, extensionId: r.identifier, activationEvent: e }
    }))), this._alreadyActivatedEvents[e] = !0;
  }
  activateById(e, i) {
    const n = this._registry.getExtensionDescription(e);
    if (!n)
      throw new Error(`Extension '${e.value}' is not known`);
    return this._activateExtensions([{ id: n.identifier, reason: i }]);
  }
  async _activateExtensions(e) {
    const i = e.filter((n) => !this.isActivated(n.id)).map((n) => this._handleActivationRequest(n));
    await Promise.all(i.map((n) => n.wait()));
  }
  _handleActivationRequest(e) {
    if (this._operations.has(e.id))
      return this._operations.get(e.id);
    if (this._isHostExtension(e.id))
      return this._createAndSaveOperation(e, null, [], null);
    const i = this._registry.getExtensionDescription(e.id);
    if (!i) {
      const s = new Error(`Cannot activate unknown extension '${e.id.value}'`), o = this._createAndSaveOperation(e, null, [], new jm(s));
      return this._host.onExtensionActivationError(e.id, s, new Y2(e.id.value)), o;
    }
    const n = [], r = typeof i.extensionDependencies > "u" ? [] : i.extensionDependencies;
    for (const s of r) {
      if (this._isResolvedExtension(s))
        continue;
      const o = this._operations.get(s);
      if (o) {
        n.push(o);
        continue;
      }
      if (this._isHostExtension(s)) {
        n.push(this._handleActivationRequest({
          id: this._globalRegistry.getExtensionDescription(s).identifier,
          reason: e.reason
        }));
        continue;
      }
      const a = this._registry.getExtensionDescription(s);
      if (a) {
        if (!a.main && !a.browser)
          continue;
        n.push(this._handleActivationRequest({
          id: a.identifier,
          reason: e.reason
        }));
        continue;
      }
      const l = i.displayName || i.identifier.value, c = new Error(
        `Cannot activate the '${l}' extension because it depends on unknown extension '${s}'`
      ), u = this._createAndSaveOperation(e, i.displayName, [], new jm(c));
      return this._host.onExtensionActivationError(i.identifier, c, new Y2(s)), u;
    }
    return this._createAndSaveOperation(e, i.displayName, n, null);
  }
  _createAndSaveOperation(e, i, n, r) {
    const s = new xy(
      e.id,
      i,
      e.reason,
      n,
      r,
      this._host,
      this._logService
    );
    return this._operations.set(e.id, s), s;
  }
  _isHostExtension(e) {
    return Ua.isHostExtension(e, this._registry, this._globalRegistry);
  }
  _isResolvedExtension(e) {
    const i = this._globalRegistry.getExtensionDescription(e);
    return i ? !i.main && !i.browser : !1;
  }
};
yy = W([
  M(3, nt)
], yy);
let xy = class {
  get value() {
    return this._value;
  }
  get friendlyName() {
    return this._displayName || this._id.value;
  }
  constructor(e, i, n, r, s, o, a) {
    this._id = e, this._displayName = i, this._reason = n, this._deps = r, this._value = s, this._host = o, this._logService = a, this._barrier = new Ur(), this._isDisposed = !1, this._initialize();
  }
  dispose() {
    this._isDisposed = !0;
  }
  wait() {
    return this._barrier.wait();
  }
  async _initialize() {
    await this._waitForDepsThenActivate(), this._barrier.open();
  }
  async _waitForDepsThenActivate() {
    if (!this._value) {
      for (; this._deps.length > 0; ) {
        for (let e = 0; e < this._deps.length; e++) {
          const i = this._deps[e];
          if (i.value && !i.value.activationFailed) {
            this._deps.splice(e, 1), e--;
            continue;
          }
          if (i.value && i.value.activationFailed) {
            const n = new Error(
              `Cannot activate the '${this.friendlyName}' extension because its dependency '${i.friendlyName}' failed to activate`
            );
            n.detail = i.value.activationFailedError, this._value = new jm(n), this._host.onExtensionActivationError(this._id, n, null);
            return;
          }
        }
        this._deps.length > 0 && await Promise.race(this._deps.map((e) => e.wait()));
      }
      await this._activate();
    }
  }
  async _activate() {
    try {
      this._value = await this._host.actualActivateExtension(this._id, this._reason);
    } catch (e) {
      const i = new Error();
      if (e && e.name && (i.name = e.name), e && e.message ? i.message = `Activating extension '${this._id.value}' failed: ${e.message}.` : i.message = `Activating extension '${this._id.value}' failed: ${e}.`, e && e.stack && (i.stack = e.stack), this._value = new jm(i), this._isDisposed && Yr(e))
        return;
      this._host.onExtensionActivationError(this._id, i, null), this._logService.error(`Activating extension ${this._id.value} failed due to an error:`), this._logService.error(e);
    }
  }
};
xy = W([
  M(6, nt)
], xy);
class jP {
  constructor(e, i) {
    this._logService = i, this._onDidChangeStorage = new N(), this.onDidChangeStorage = this._onDidChangeStorage.event, this._proxy = e.getProxy(ee.MainThreadStorage);
  }
  registerExtensionStorageKeysToSync(e, i) {
    this._proxy.$registerExtensionStorageKeysToSync(e, i);
  }
  async initializeExtensionStorage(e, i, n) {
    const r = await this._proxy.$initializeExtensionStorage(e, i);
    let s;
    return r && (s = this.safeParseValue(e, i, r)), s || n;
  }
  setValue(e, i, n) {
    return this._proxy.$setValue(e, i, n);
  }
  $acceptValue(e, i, n) {
    const r = this.safeParseValue(e, i, n);
    r && this._onDidChangeStorage.fire({ shared: e, key: i, value: r });
  }
  safeParseValue(e, i, n) {
    try {
      return JSON.parse(n);
    } catch (r) {
      this._logService.error(`[extHostStorage] unexpected error parsing storage contents (extensionId: ${i}, global: ${e}): ${r}`);
    }
  }
}
const mE = pe("IExtHostStorage");
class GP {
  constructor(e, i, n) {
    this._deferredPromises = /* @__PURE__ */ new Map(), this._id = e, this._shared = i, this._storage = n, this._init = this._storage.initializeExtensionStorage(this._shared, this._id, /* @__PURE__ */ Object.create(null)).then((r) => (this._value = r, this)), this._storageListener = this._storage.onDidChangeStorage((r) => {
      r.shared === this._shared && r.key === this._id && (this._value = r.value);
    }), this._scheduler = new cl(() => {
      const r = this._deferredPromises;
      this._deferredPromises = /* @__PURE__ */ new Map(), (async () => {
        try {
          await this._storage.setValue(this._shared, this._id, this._value);
          for (const s of r.values())
            s.complete();
        } catch (s) {
          for (const o of r.values())
            o.error(s);
        }
      })();
    }, 0);
  }
  keys() {
    return Object.entries(this._value ?? {}).filter(([, e]) => e !== void 0).map(([e]) => e);
  }
  get whenReady() {
    return this._init;
  }
  get(e, i) {
    let n = this._value[e];
    return typeof n > "u" && (n = i), n;
  }
  update(e, i) {
    i !== null && typeof i == "object" ? this._value[e] = JSON.parse(JSON.stringify(i)) : this._value[e] = i;
    const n = this._deferredPromises.get(e);
    if (n !== void 0)
      return n.p;
    const r = new ko();
    return this._deferredPromises.set(e, r), this._scheduler.isScheduled() || this._scheduler.schedule(), r.p;
  }
  dispose() {
    this._storageListener.dispose();
  }
}
class ON extends GP {
  setKeysForSync(e) {
    this._storage.registerExtensionStorageKeysToSync({ id: this._id, version: this._extension.version }, e);
  }
  constructor(e, i) {
    super(e.identifier.value, !0, i), this._extension = e;
  }
}
var Dr;
let Ey = Dr = class {
  constructor(e, i) {
    this._fileSystemProvider = /* @__PURE__ */ new Map(), this._writeQueue = new r8(), this._proxy = e.getProxy(ee.MainThreadFileSystem);
    const n = this;
    this.value = Object.freeze({
      async stat(r) {
        try {
          let s;
          const o = n._fileSystemProvider.get(r.scheme);
          return o ? (await n._proxy.$ensureActivation(r.scheme), s = await o.impl.stat(r)) : s = await n._proxy.$stat(r), {
            type: s.type,
            ctime: s.ctime,
            mtime: s.mtime,
            size: s.size,
            permissions: s.permissions === Vc.Readonly ? 1 : void 0
          };
        } catch (s) {
          Dr._handleError(s);
        }
      },
      async readDirectory(r) {
        try {
          const s = n._fileSystemProvider.get(r.scheme);
          return s ? (await n._proxy.$ensureActivation(r.scheme), (await s.impl.readDirectory(r)).slice()) : await n._proxy.$readdir(r);
        } catch (s) {
          return Dr._handleError(s);
        }
      },
      async createDirectory(r) {
        try {
          const s = n._fileSystemProvider.get(r.scheme);
          return s && !s.isReadonly ? (await n._proxy.$ensureActivation(r.scheme), await n.mkdirp(s.impl, s.extUri, r)) : await n._proxy.$mkdir(r);
        } catch (s) {
          return Dr._handleError(s);
        }
      },
      async readFile(r) {
        try {
          const s = n._fileSystemProvider.get(r.scheme);
          return s ? (await n._proxy.$ensureActivation(r.scheme), (await s.impl.readFile(r)).slice()) : (await n._proxy.$readFile(r)).buffer;
        } catch (s) {
          return Dr._handleError(s);
        }
      },
      async writeFile(r, s) {
        try {
          const o = n._fileSystemProvider.get(r.scheme);
          return o && !o.isReadonly ? (await n._proxy.$ensureActivation(r.scheme), await n.mkdirp(o.impl, o.extUri, o.extUri.dirname(r)), await n._writeQueue.queueFor(r, () => Promise.resolve(o.impl.writeFile(r, s, { create: !0, overwrite: !0 })))) : await n._proxy.$writeFile(r, ue.wrap(s));
        } catch (o) {
          return Dr._handleError(o);
        }
      },
      async delete(r, s) {
        try {
          const o = n._fileSystemProvider.get(r.scheme);
          return o && !o.isReadonly && !s?.useTrash ? (await n._proxy.$ensureActivation(r.scheme), await o.impl.delete(r, { recursive: !1, ...s })) : await n._proxy.$delete(r, { recursive: !1, useTrash: !1, atomic: !1, ...s });
        } catch (o) {
          return Dr._handleError(o);
        }
      },
      async rename(r, s, o) {
        try {
          return await n._proxy.$rename(r, s, { overwrite: !1, ...o });
        } catch (a) {
          return Dr._handleError(a);
        }
      },
      async copy(r, s, o) {
        try {
          return await n._proxy.$copy(r, s, { overwrite: !1, ...o });
        } catch (a) {
          return Dr._handleError(a);
        }
      },
      isWritableFileSystem(r) {
        const s = i.getCapabilities(r);
        if (typeof s == "number")
          return !(s & Rr.Readonly);
      }
    });
  }
  async mkdirp(e, i, n) {
    const r = [];
    for (; !i.isEqual(n, i.dirname(n)); )
      try {
        if (((await e.stat(n)).type & Da.Directory) === 0)
          throw ui.FileExists(`Unable to create folder '${n.scheme === de.file ? n.fsPath : n.toString(!0)}' that already exists but is not a directory`);
        break;
      } catch (s) {
        if (Wp(s) !== Me.FileNotFound)
          throw s;
        r.push(i.basename(n)), n = i.dirname(n);
      }
    for (let s = r.length - 1; s >= 0; s--) {
      n = i.joinPath(n, r[s]);
      try {
        await e.createDirectory(n);
      } catch (o) {
        if (Wp(o) !== Me.FileExists)
          throw o;
      }
    }
  }
  static _handleError(e) {
    if (e instanceof ui)
      throw e;
    if (e instanceof W_)
      switch (e.code) {
        case Me.FileExists:
          throw ui.FileExists(e.message);
        case Me.FileNotFound:
          throw ui.FileNotFound(e.message);
        case Me.FileNotADirectory:
          throw ui.FileNotADirectory(e.message);
        case Me.FileIsADirectory:
          throw ui.FileIsADirectory(e.message);
        case Me.NoPermissions:
          throw ui.NoPermissions(e.message);
        case Me.Unavailable:
          throw ui.Unavailable(e.message);
        default:
          throw new ui(e.message, e.name);
      }
    if (!(e instanceof Error))
      throw new ui(String(e));
    if (e.name === "ENOPRO" || e.message.includes("ENOPRO"))
      throw ui.Unavailable(e.message);
    switch (e.name) {
      case Me.FileExists:
        throw ui.FileExists(e.message);
      case Me.FileNotFound:
        throw ui.FileNotFound(e.message);
      case Me.FileNotADirectory:
        throw ui.FileNotADirectory(e.message);
      case Me.FileIsADirectory:
        throw ui.FileIsADirectory(e.message);
      case Me.NoPermissions:
        throw ui.NoPermissions(e.message);
      case Me.Unavailable:
        throw ui.Unavailable(e.message);
      default:
        throw new ui(e.message, e.name);
    }
  }
  addFileSystemProvider(e, i, n) {
    return this._fileSystemProvider.set(e, { impl: i, extUri: n?.isCaseSensitive ? ot : WR, isReadonly: !!n?.isReadonly }), Ee(() => this._fileSystemProvider.delete(e));
  }
  getFileSystemProviderExtUri(e) {
    return this._fileSystemProvider.get(e)?.extUri ?? ot;
  }
};
Ey = Dr = W([
  M(0, Ye),
  M(1, wu)
], Ey);
const l1 = pe("IExtHostConsumerFileSystem"), _E = pe("IExtensionStoragePaths");
let Sy = class {
  constructor(e, i, n) {
    this._logService = i, this._extHostFileSystem = n, this._workspace = e.workspace ?? void 0, this._environment = e.environment, this.whenReady = this._getOrCreateWorkspaceStoragePath().then((r) => this._value = r);
  }
  async _getWorkspaceStorageURI(e) {
    return x.joinPath(this._environment.workspaceStorageHome, e);
  }
  async _getOrCreateWorkspaceStoragePath() {
    if (!this._workspace)
      return Promise.resolve(void 0);
    const e = this._workspace.id, i = await this._getWorkspaceStorageURI(e);
    try {
      return await this._extHostFileSystem.value.stat(i), this._logService.trace("[ExtHostStorage] storage dir already exists", i), i;
    } catch {
    }
    try {
      return this._logService.trace("[ExtHostStorage] creating dir and metadata-file", i), await this._extHostFileSystem.value.createDirectory(i), await this._extHostFileSystem.value.writeFile(x.joinPath(i, "meta.json"), new TextEncoder().encode(JSON.stringify({
        id: this._workspace.id,
        configuration: x.revive(this._workspace.configuration)?.toString(),
        name: this._workspace.name
      }, void 0, 2))), i;
    } catch (n) {
      this._logService.error("[ExtHostStorage]", n);
      return;
    }
  }
  workspaceValue(e) {
    if (this._value)
      return x.joinPath(this._value, e.identifier.value);
  }
  globalValue(e) {
    return x.joinPath(this._environment.globalStorageHome, e.identifier.value.toLowerCase());
  }
  onWillDeactivateAll() {
  }
};
Sy = W([
  M(0, pi),
  M(1, nt),
  M(2, l1)
], Sy);
const c1 = pe("configurationService");
var Ok;
(function(t) {
  t.Http = "http", t.Https = "https";
})(Ok || (Ok = {}));
var ba;
(function(t) {
  t.ConstantPrivate = "constantPrivate", t.Private = "private", t.Public = "public";
})(ba || (ba = {}));
var Fk;
(function(t) {
  t[t.Notify = 1] = "Notify", t[t.OpenBrowser = 2] = "OpenBrowser", t[t.OpenPreview = 3] = "OpenPreview", t[t.Silent = 4] = "Silent", t[t.Ignore = 5] = "Ignore", t[t.OpenBrowserOnce = 6] = "OpenBrowserOnce";
})(Fk || (Fk = {}));
function FN(t) {
  if (t.scheme !== "http" && t.scheme !== "https")
    return;
  const e = /^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(t.authority);
  if (e)
    return {
      address: e[1],
      port: +e[2]
    };
}
const Dy = ["localhost", "127.0.0.1", "0:0:0:0:0:0:0:1", "::1"];
function Uk(t) {
  return Dy.indexOf(t) >= 0;
}
const ky = ["0.0.0.0", "0:0:0:0:0:0:0:0", "::"];
function $k(t) {
  return ky.indexOf(t) >= 0;
}
class UN {
  constructor(e, i, n) {
    this.remoteAddress = e, this.localAddress = i, this._dispose = n, this._onDispose = new N(), this.onDidDispose = this._onDispose.event;
  }
  dispose() {
    return this._onDispose.fire(), this._dispose();
  }
}
let Hk = class extends ve {
  constructor(e, i) {
    super(), this.logService = e, this.configurationService = i, this._onTunnelOpened = new N(), this.onTunnelOpened = this._onTunnelOpened.event, this._onTunnelClosed = new N(), this.onTunnelClosed = this._onTunnelClosed.event, this._onAddedTunnelProvider = new N(), this.onAddedTunnelProvider = this._onAddedTunnelProvider.event, this._tunnels = /* @__PURE__ */ new Map(), this._canElevate = !1, this._canChangeProtocol = !0, this._privacyOptions = [], this._factoryInProgress = /* @__PURE__ */ new Set();
  }
  get hasTunnelProvider() {
    return !!this._tunnelProvider;
  }
  get defaultTunnelHost() {
    const e = this.configurationService.getValue("remote.localPortHost");
    return !e || e === "localhost" ? "127.0.0.1" : "0.0.0.0";
  }
  setTunnelProvider(e) {
    return this._tunnelProvider = e, e ? (this._onAddedTunnelProvider.fire(), {
      dispose: () => {
        this._tunnelProvider = void 0, this._canElevate = !1, this._privacyOptions = [];
      }
    }) : (this._canElevate = !1, this._privacyOptions = [], this._onAddedTunnelProvider.fire(), {
      dispose: () => {
      }
    });
  }
  setTunnelFeatures(e) {
    this._canElevate = e.elevation, this._privacyOptions = e.privacyOptions, this._canChangeProtocol = e.protocol;
  }
  get canChangeProtocol() {
    return this._canChangeProtocol;
  }
  get canElevate() {
    return this._canElevate;
  }
  get canChangePrivacy() {
    return this._privacyOptions.length > 0;
  }
  get privacyOptions() {
    return this._privacyOptions;
  }
  get tunnels() {
    return this.getTunnels();
  }
  async getTunnels() {
    const e = [], i = Array.from(this._tunnels.values());
    for (const n of i) {
      const r = Array.from(n.values());
      for (const s of r) {
        const o = await s.value;
        o && typeof o != "string" && e.push(o);
      }
    }
    return e;
  }
  async dispose() {
    super.dispose();
    for (const e of this._tunnels.values()) {
      for (const { value: i } of e.values())
        await i.then((n) => typeof n != "string" ? n?.dispose() : void 0);
      e.clear();
    }
    this._tunnels.clear();
  }
  setEnvironmentTunnel(e, i, n, r, s) {
    this.addTunnelToMap(e, i, Promise.resolve({
      tunnelRemoteHost: e,
      tunnelRemotePort: i,
      localAddress: n,
      privacy: r,
      protocol: s,
      dispose: () => Promise.resolve()
    }));
  }
  async getExistingTunnel(e, i) {
    ($k(e) || Uk(e)) && (e = Dy[0]);
    const n = this.getTunnelFromMap(e, i);
    if (n)
      return ++n.refcount, n.value;
  }
  openTunnel(e, i, n, r, s, o = !1, a, l) {
    this.logService.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${i}:${n} on local port ${s}.`);
    const c = this._tunnelProvider ?? e;
    if (!c)
      return;
    if (i || (i = "localhost"), r || (r = this.defaultTunnelHost), this._tunnelProvider && this._factoryInProgress.has(n)) {
      this.logService.debug("ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.");
      return;
    }
    const u = this.retainOrCreateTunnel(c, i, n, r, s, o, a, l);
    return u ? u.then((d) => {
      if (d) {
        if (typeof d == "string")
          return this.logService.trace("ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel."), this.removeEmptyOrErrorTunnelFromMap(i, n), d;
      } else {
        this.logService.trace("ForwardedPorts: (TunnelService) New tunnel is undefined."), this.removeEmptyOrErrorTunnelFromMap(i, n);
        return;
      }
      this.logService.trace("ForwardedPorts: (TunnelService) New tunnel established.");
      const f = this.makeTunnel(d);
      return (d.tunnelRemoteHost !== i || d.tunnelRemotePort !== n) && this.logService.warn("ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch."), a && d.privacy !== a && this.logService.warn("ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch."), this._onTunnelOpened.fire(f), f;
    }) : (this.logService.trace("ForwardedPorts: (TunnelService) Tunnel was not created."), u);
  }
  makeTunnel(e) {
    return {
      tunnelRemotePort: e.tunnelRemotePort,
      tunnelRemoteHost: e.tunnelRemoteHost,
      tunnelLocalPort: e.tunnelLocalPort,
      localAddress: e.localAddress,
      privacy: e.privacy,
      protocol: e.protocol,
      dispose: async () => {
        this.logService.trace(`ForwardedPorts: (TunnelService) dispose request for ${e.tunnelRemoteHost}:${e.tunnelRemotePort} `);
        const i = this._tunnels.get(e.tunnelRemoteHost);
        if (i) {
          const n = i.get(e.tunnelRemotePort);
          n && (n.refcount--, await this.tryDisposeTunnel(e.tunnelRemoteHost, e.tunnelRemotePort, n));
        }
      }
    };
  }
  async tryDisposeTunnel(e, i, n) {
    if (n.refcount <= 0) {
      this.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${e}:${i}.`);
      const r = n.value.then(async (s) => {
        s && typeof s != "string" && (await s.dispose(!0), this._onTunnelClosed.fire({ host: s.tunnelRemoteHost, port: s.tunnelRemotePort }));
      });
      return this._tunnels.has(e) && this._tunnels.get(e).delete(i), r;
    }
  }
  async closeTunnel(e, i) {
    this.logService.trace(`ForwardedPorts: (TunnelService) close request for ${e}:${i} `);
    const n = this._tunnels.get(e);
    if (n && n.has(i)) {
      const r = n.get(i);
      r.refcount = 0, await this.tryDisposeTunnel(e, i, r);
    }
  }
  addTunnelToMap(e, i, n) {
    this._tunnels.has(e) || this._tunnels.set(e, /* @__PURE__ */ new Map()), this._tunnels.get(e).set(i, { refcount: 1, value: n });
  }
  async removeEmptyOrErrorTunnelFromMap(e, i) {
    const n = this._tunnels.get(e);
    if (n) {
      const r = n.get(i), s = r ? await r.value : void 0;
      (!s || typeof s == "string") && n.delete(i), n.size === 0 && this._tunnels.delete(e);
    }
  }
  getTunnelFromMap(e, i) {
    const n = [e];
    Uk(e) ? (n.push(...Dy), n.push(...ky)) : $k(e) && n.push(...ky);
    const r = n.map((s) => this._tunnels.get(s));
    for (const s of r) {
      const o = s?.get(i);
      if (o)
        return o;
    }
  }
  canTunnel(e) {
    return !!FN(e);
  }
  createWithProvider(e, i, n, r, s, o, a) {
    this.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${i}:${n} on local port ${r}.`);
    const l = n;
    this._factoryInProgress.add(l);
    const c = r === void 0 ? n : r, u = { elevationRequired: s ? this.isPortPrivileged(c) : !1 }, d = { remoteAddress: { host: i, port: n }, localAddressPort: r, privacy: o, public: o ? o !== ba.Private : void 0, protocol: a }, f = e.forwardPort(d, u);
    return f ? (this.addTunnelToMap(i, n, f), f.finally(() => {
      this.logService.trace("ForwardedPorts: (TunnelService) Tunnel created by provider."), this._factoryInProgress.delete(l);
    })) : this._factoryInProgress.delete(l), f;
  }
};
Hk = W([
  M(0, nt),
  M(1, c1)
], Hk);
class $N extends UN {
}
var Iy;
(function(t) {
  function e(n) {
    return {
      remoteAddress: n.remoteAddress,
      localAddress: n.localAddress,
      public: !!n.public,
      privacy: n.privacy ?? (n.public ? ba.Public : ba.Private),
      protocol: n.protocol
    };
  }
  t.fromApiTunnel = e;
  function i(n) {
    return {
      remoteAddress: {
        host: n.tunnelRemoteHost,
        port: n.tunnelRemotePort
      },
      localAddress: n.localAddress,
      public: n.privacy !== ba.ConstantPrivate && n.privacy !== ba.ConstantPrivate,
      privacy: n.privacy,
      protocol: n.protocol
    };
  }
  t.fromServiceTunnel = i;
})(Iy || (Iy = {}));
const vE = pe("IExtHostTunnelService");
let Cy = class extends ve {
  constructor(e, i, n) {
    super(), this.logService = n, this._showCandidatePort = () => Promise.resolve(!0), this._extensionTunnels = /* @__PURE__ */ new Map(), this._onDidChangeTunnels = new N(), this.onDidChangeTunnels = this._onDidChangeTunnels.event, this._providerHandleCounter = 0, this._portAttributesProviders = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadTunnelService);
  }
  async openTunnel(e, i) {
    this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) ${e.identifier.value} called openTunnel API for ${i.remoteAddress.host}:${i.remoteAddress.port}.`);
    const n = await this._proxy.$openTunnel(i, e.displayName);
    if (n) {
      const r = new $N(n.remoteAddress, n.localAddress, () => this._proxy.$closeTunnel(n.remoteAddress));
      return this._register(r), r;
    }
  }
  async getTunnels() {
    return this._proxy.$getTunnels();
  }
  nextPortAttributesProviderHandle() {
    return this._providerHandleCounter++;
  }
  registerPortsAttributesProvider(e, i) {
    e.portRange === void 0 && e.commandPattern === void 0 && this.logService.error("PortAttributesProvider must specify either a portRange or a commandPattern");
    const n = this.nextPortAttributesProviderHandle();
    return this._portAttributesProviders.set(n, { selector: e, provider: i }), this._proxy.$registerPortsAttributesProvider(e, n), new Ve(() => {
      this._portAttributesProviders.delete(n), this._proxy.$unregisterPortsAttributesProvider(n);
    });
  }
  async $providePortAttributes(e, i, n, r, s) {
    const o = [];
    for (const l of e) {
      const c = this._portAttributesProviders.get(l);
      if (!c)
        return [];
      o.push(...await Promise.all(i.map(async (u) => {
        let d;
        try {
          d = await c.provider.providePortAttributes({ port: u, pid: n, commandLine: r }, s);
        } catch {
          d = await c.provider.providePortAttributes(u, n, r, s);
        }
        return { providedAttributes: d, port: u };
      })));
    }
    const a = o.filter((l) => !!l.providedAttributes);
    return a.length > 0 ? a.map((l) => ({
      autoForwardAction: l.providedAttributes.autoForwardAction,
      port: l.port
    })) : [];
  }
  async $registerCandidateFinder(e) {
  }
  registerTunnelProvider(e, i) {
    if (this._forwardPortProvider)
      throw new Error(
        "A tunnel provider has already been registered. Only the first tunnel provider to be registered will be used."
      );
    this._forwardPortProvider = async (r, s) => await e.provideTunnel(r, s, xt.None) ?? void 0;
    const n = i.tunnelFeatures ? {
      elevation: !!i.tunnelFeatures?.elevation,
      privacyOptions: i.tunnelFeatures?.privacyOptions,
      protocol: i.tunnelFeatures.protocol === void 0 ? !0 : i.tunnelFeatures.protocol
    } : void 0;
    return this._proxy.$setTunnelProvider(n, !0), Promise.resolve(Ee(() => {
      this._forwardPortProvider = void 0, this._proxy.$setTunnelProvider(void 0, !1);
    }));
  }
  async setTunnelFactory(e, i) {
    if (e) {
      e.candidatePortSource !== void 0 && this._proxy.$setCandidatePortSource(e.candidatePortSource), e.showCandidatePort && (this._showCandidatePort = e.showCandidatePort, this._proxy.$setCandidateFilter());
      const n = e.tunnelFactory ?? (i ? this.makeManagedTunnelFactory(i) : void 0);
      if (n) {
        this._forwardPortProvider = n;
        let r = e.tunnelFeatures?.privacyOptions ?? [];
        e.tunnelFeatures?.public && r.length === 0 && (r = [
          {
            id: "private",
            label: h(2638, "Private"),
            themeIcon: "lock"
          },
          {
            id: "public",
            label: h(2639, "Public"),
            themeIcon: "eye"
          }
        ]);
        const s = e.tunnelFeatures ? {
          elevation: !!e.tunnelFeatures?.elevation,
          public: !!e.tunnelFeatures?.public,
          privacyOptions: r,
          protocol: !0
        } : void 0;
        this._proxy.$setTunnelProvider(s, !!e.tunnelFactory);
      }
    } else
      this._forwardPortProvider = void 0;
    return Ee(() => {
      this._forwardPortProvider = void 0;
    });
  }
  makeManagedTunnelFactory(e) {
  }
  async $closeTunnel(e, i) {
    if (this._extensionTunnels.has(e.host)) {
      const n = this._extensionTunnels.get(e.host);
      n.has(e.port) && (i && n.get(e.port).disposeListener.dispose(), await n.get(e.port).tunnel.dispose(), n.delete(e.port));
    }
  }
  async $onDidTunnelsChange() {
    this._onDidChangeTunnels.fire();
  }
  async $forwardPort(e, i) {
    if (this._forwardPortProvider)
      try {
        this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Getting tunnel from provider.");
        const n = this._forwardPortProvider(e, i);
        if (this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Got tunnel promise from provider."), n !== void 0) {
          const r = await n;
          if (this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Successfully awaited tunnel from provider."), r === void 0) {
            this.logService.error("ForwardedPorts: (ExtHostTunnelService) Resolved tunnel is undefined");
            return;
          }
          this._extensionTunnels.has(e.remoteAddress.host) || this._extensionTunnels.set(e.remoteAddress.host, /* @__PURE__ */ new Map());
          const s = this._register(r.onDidDispose(() => (this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Extension fired tunnel's onDidDispose."), this._proxy.$closeTunnel(r.remoteAddress))));
          return this._extensionTunnels.get(e.remoteAddress.host).set(e.remoteAddress.port, { tunnel: r, disposeListener: s }), Iy.fromApiTunnel(r);
        } else
          this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Tunnel is undefined");
      } catch (n) {
        if (this.logService.trace("ForwardedPorts: (ExtHostTunnelService) tunnel provider error"), n instanceof Error)
          return n.message;
      }
  }
  async $applyCandidateFilter(e) {
    const i = await Promise.all(e.map(
      (r) => this._showCandidatePort(r.host, r.port, r.detail ?? "")
    )), n = e.filter((r, s) => i[s]);
    return this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) filtered from ${e.map((r) => r.port).join(", ")} to ${n.map((r) => r.port).join(", ")}`), n;
  }
};
Cy = W([
  M(0, Ye),
  M(1, pi),
  M(2, nt)
], Cy);
function HN(t) {
  return [...t.entries()];
}
function BN(t) {
  return t ? [...t.entries()] : [];
}
var Bk;
(function(t) {
  t.AutomationProfile = "terminal.integrated.automationProfile.", t.DefaultProfile = "terminal.integrated.defaultProfile.", t.Profiles = "terminal.integrated.profiles.";
})(Bk || (Bk = {}));
var Wk;
(function(t) {
  t.SendKeybindingsToShell = "terminal.integrated.sendKeybindingsToShell", t.AutomationProfileLinux = "terminal.integrated.automationProfile.linux", t.AutomationProfileMacOs = "terminal.integrated.automationProfile.osx", t.AutomationProfileWindows = "terminal.integrated.automationProfile.windows", t.ProfilesWindows = "terminal.integrated.profiles.windows", t.ProfilesMacOs = "terminal.integrated.profiles.osx", t.ProfilesLinux = "terminal.integrated.profiles.linux", t.DefaultProfileLinux = "terminal.integrated.defaultProfile.linux", t.DefaultProfileMacOs = "terminal.integrated.defaultProfile.osx", t.DefaultProfileWindows = "terminal.integrated.defaultProfile.windows", t.UseWslProfiles = "terminal.integrated.useWslProfiles", t.TabsDefaultColor = "terminal.integrated.tabs.defaultColor", t.TabsDefaultIcon = "terminal.integrated.tabs.defaultIcon", t.TabsEnabled = "terminal.integrated.tabs.enabled", t.TabsEnableAnimation = "terminal.integrated.tabs.enableAnimation", t.TabsHideCondition = "terminal.integrated.tabs.hideCondition", t.TabsShowActiveTerminal = "terminal.integrated.tabs.showActiveTerminal", t.TabsShowActions = "terminal.integrated.tabs.showActions", t.TabsLocation = "terminal.integrated.tabs.location", t.TabsFocusMode = "terminal.integrated.tabs.focusMode", t.MacOptionIsMeta = "terminal.integrated.macOptionIsMeta", t.MacOptionClickForcesSelection = "terminal.integrated.macOptionClickForcesSelection", t.AltClickMovesCursor = "terminal.integrated.altClickMovesCursor", t.CopyOnSelection = "terminal.integrated.copyOnSelection", t.EnableMultiLinePasteWarning = "terminal.integrated.enableMultiLinePasteWarning", t.DrawBoldTextInBrightColors = "terminal.integrated.drawBoldTextInBrightColors", t.FontFamily = "terminal.integrated.fontFamily", t.FontSize = "terminal.integrated.fontSize", t.LetterSpacing = "terminal.integrated.letterSpacing", t.LineHeight = "terminal.integrated.lineHeight", t.MinimumContrastRatio = "terminal.integrated.minimumContrastRatio", t.TabStopWidth = "terminal.integrated.tabStopWidth", t.FastScrollSensitivity = "terminal.integrated.fastScrollSensitivity", t.MouseWheelScrollSensitivity = "terminal.integrated.mouseWheelScrollSensitivity", t.BellDuration = "terminal.integrated.bellDuration", t.FontWeight = "terminal.integrated.fontWeight", t.FontWeightBold = "terminal.integrated.fontWeightBold", t.CursorBlinking = "terminal.integrated.cursorBlinking", t.CursorStyle = "terminal.integrated.cursorStyle", t.CursorStyleInactive = "terminal.integrated.cursorStyleInactive", t.CursorWidth = "terminal.integrated.cursorWidth", t.Scrollback = "terminal.integrated.scrollback", t.DetectLocale = "terminal.integrated.detectLocale", t.DefaultLocation = "terminal.integrated.defaultLocation", t.GpuAcceleration = "terminal.integrated.gpuAcceleration", t.TerminalTitleSeparator = "terminal.integrated.tabs.separator", t.TerminalTitle = "terminal.integrated.tabs.title", t.TerminalDescription = "terminal.integrated.tabs.description", t.RightClickBehavior = "terminal.integrated.rightClickBehavior", t.MiddleClickBehavior = "terminal.integrated.middleClickBehavior", t.Cwd = "terminal.integrated.cwd", t.ConfirmOnExit = "terminal.integrated.confirmOnExit", t.ConfirmOnKill = "terminal.integrated.confirmOnKill", t.EnableBell = "terminal.integrated.enableBell", t.EnableVisualBell = "terminal.integrated.enableVisualBell", t.CommandsToSkipShell = "terminal.integrated.commandsToSkipShell", t.AllowChords = "terminal.integrated.allowChords", t.AllowMnemonics = "terminal.integrated.allowMnemonics", t.TabFocusMode = "terminal.integrated.tabFocusMode", t.EnvMacOs = "terminal.integrated.env.osx", t.EnvLinux = "terminal.integrated.env.linux", t.EnvWindows = "terminal.integrated.env.windows", t.EnvironmentChangesIndicator = "terminal.integrated.environmentChangesIndicator", t.EnvironmentChangesRelaunch = "terminal.integrated.environmentChangesRelaunch", t.ShowExitAlert = "terminal.integrated.showExitAlert", t.SplitCwd = "terminal.integrated.splitCwd", t.WindowsEnableConpty = "terminal.integrated.windowsEnableConpty", t.WindowsUseConptyDll = "terminal.integrated.windowsUseConptyDll", t.WordSeparators = "terminal.integrated.wordSeparators", t.EnableFileLinks = "terminal.integrated.enableFileLinks", t.AllowedLinkSchemes = "terminal.integrated.allowedLinkSchemes", t.UnicodeVersion = "terminal.integrated.unicodeVersion", t.EnablePersistentSessions = "terminal.integrated.enablePersistentSessions", t.PersistentSessionReviveProcess = "terminal.integrated.persistentSessionReviveProcess", t.HideOnStartup = "terminal.integrated.hideOnStartup", t.HideOnLastClosed = "terminal.integrated.hideOnLastClosed", t.CustomGlyphs = "terminal.integrated.customGlyphs", t.RescaleOverlappingGlyphs = "terminal.integrated.rescaleOverlappingGlyphs", t.PersistentSessionScrollback = "terminal.integrated.persistentSessionScrollback", t.InheritEnv = "terminal.integrated.inheritEnv", t.ShowLinkHover = "terminal.integrated.showLinkHover", t.IgnoreProcessNames = "terminal.integrated.ignoreProcessNames", t.ShellIntegrationEnabled = "terminal.integrated.shellIntegration.enabled", t.ShellIntegrationShowWelcome = "terminal.integrated.shellIntegration.showWelcome", t.ShellIntegrationDecorationsEnabled = "terminal.integrated.shellIntegration.decorationsEnabled", t.ShellIntegrationEnvironmentReporting = "terminal.integrated.shellIntegration.environmentReporting", t.EnableImages = "terminal.integrated.enableImages", t.SmoothScrolling = "terminal.integrated.smoothScrolling", t.IgnoreBracketedPasteMode = "terminal.integrated.ignoreBracketedPasteMode", t.FocusAfterRun = "terminal.integrated.focusAfterRun", t.FontLigaturesEnabled = "terminal.integrated.fontLigatures.enabled", t.FontLigaturesFeatureSettings = "terminal.integrated.fontLigatures.featureSettings", t.FontLigaturesFallbackLigatures = "terminal.integrated.fontLigatures.fallbackLigatures", t.DeveloperPtyHostLatency = "terminal.integrated.developer.ptyHost.latency", t.DeveloperPtyHostStartupDelay = "terminal.integrated.developer.ptyHost.startupDelay", t.DevMode = "terminal.integrated.developer.devMode";
})(Wk || (Wk = {}));
var Vk;
(function(t) {
  t.Bash = "bash", t.Fish = "fish", t.Sh = "sh", t.Csh = "csh", t.Ksh = "ksh", t.Zsh = "zsh";
})(Vk || (Vk = {}));
var Ty;
(function(t) {
  t.CommandPrompt = "cmd", t.Wsl = "wsl", t.GitBash = "gitbash";
})(Ty || (Ty = {}));
var zk;
(function(t) {
  t.PowerShell = "pwsh", t.Python = "python", t.Julia = "julia", t.NuShell = "nu", t.Node = "node";
})(zk || (zk = {}));
var qk;
(function(t) {
  t[t.Api = 0] = "Api", t[t.Process = 1] = "Process", t[t.Sequence = 2] = "Sequence", t[t.Config = 3] = "Config";
})(qk || (qk = {}));
var jk;
(function(t) {
  t.LocalPty = "localPty", t.PtyHost = "ptyHost", t.PtyHostWindow = "ptyHostWindow", t.Logger = "logger", t.Heartbeat = "heartbeat";
})(jk || (jk = {}));
var _u;
(function(t) {
  t.Cwd = "cwd", t.InitialCwd = "initialCwd", t.FixedDimensions = "fixedDimensions", t.Title = "title", t.ShellType = "shellType", t.HasChildProcesses = "hasChildProcesses", t.ResolvedShellLaunchConfig = "resolvedShellLaunchConfig", t.OverrideDimensions = "overrideDimensions", t.FailedShellIntegrationActivation = "failedShellIntegrationActivation", t.UsedShellIntegrationInjection = "usedShellIntegrationInjection", t.ShellIntegrationInjectionFailureReason = "shellIntegrationInjectionFailureReason";
})(_u || (_u = {}));
var Gk;
(function(t) {
  t[t.BeatInterval = 5e3] = "BeatInterval", t[t.ConnectingBeatInterval = 2e4] = "ConnectingBeatInterval", t[t.FirstWaitMultiplier = 1.2] = "FirstWaitMultiplier", t[t.SecondWaitMultiplier = 1] = "SecondWaitMultiplier", t[t.CreateProcessTimeout = 5e3] = "CreateProcessTimeout";
})(Gk || (Gk = {}));
var Qk;
(function(t) {
  t[t.Panel = 1] = "Panel", t[t.Editor = 2] = "Editor";
})(Qk || (Qk = {}));
var Kk;
(function(t) {
  t.TerminalView = "view", t.Editor = "editor";
})(Kk || (Kk = {}));
var Jk;
(function(t) {
  t[t.GraceTime = 6e4] = "GraceTime", t[t.ShortGraceTime = 6e3] = "ShortGraceTime";
})(Jk || (Jk = {}));
var Yk;
(function(t) {
  t[t.HighWatermarkChars = 1e5] = "HighWatermarkChars", t[t.LowWatermarkChars = 5e3] = "LowWatermarkChars", t[t.CharCountAckSize = 5e3] = "CharCountAckSize";
})(Yk || (Yk = {}));
var Xk;
(function(t) {
  t.GitBash = "Git Bash", t.Pwsh = "PowerShell";
})(Xk || (Xk = {}));
var Zk;
(function(t) {
  t[t.Off = 0] = "Off", t[t.FinalTerm = 1] = "FinalTerm", t[t.VSCode = 2] = "VSCode";
})(Zk || (Zk = {}));
var eI;
(function(t) {
  t.InjectionSettingDisabled = "injectionSettingDisabled", t.NoExecutable = "noExecutable", t.FeatureTerminal = "featureTerminal", t.IgnoreShellIntegrationFlag = "ignoreShellIntegrationFlag", t.Winpty = "winpty", t.UnsupportedArgs = "unsupportedArgs", t.UnsupportedShell = "unsupportedShell", t.FailedToSetStickyBit = "failedToSetStickyBit", t.FailedToCreateTmpDir = "failedToCreateTmpDir";
})(eI || (eI = {}));
var tI;
(function(t) {
  t[t.Unknown = 0] = "Unknown", t[t.Shutdown = 1] = "Shutdown", t[t.Process = 2] = "Process", t[t.User = 3] = "User", t[t.Extension = 4] = "Extension";
})(tI || (tI = {}));
const WN = {
  Backend: "workbench.contributions.terminal.processBackend"
};
function Py(t) {
  return t?.toLowerCase() ?? "";
}
class VN {
  constructor(e) {
    this.remoteAuthority = e;
  }
  affects(e) {
    return Py(e) === this.remoteAuthority;
  }
}
class zN {
  constructor() {
    this._backends = /* @__PURE__ */ new Map(), this._onDidChangeBackends = new N(), this.onDidChangeBackends = this._onDidChangeBackends.event;
  }
  get backends() {
    return this._backends;
  }
  registerTerminalBackend(e) {
    const i = Py(e.remoteAuthority);
    if (this._backends.has(i))
      throw new Error(
        `A terminal backend with remote authority '${i}' was already registered.`
      );
    this._backends.set(i, e), this._onDidChangeBackends.fire(new VN(i));
  }
  getTerminalBackend(e) {
    return this._backends.get(Py(e));
  }
}
ai.add(WN.Backend, new zN());
class qN {
  constructor(e) {
    this._callback = e, this._terminalBufferMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    for (const e of this._terminalBufferMap.values())
      e.dispose();
  }
  startBuffering(e, i, n = 5) {
    const r = i((s) => {
      const o = typeof s == "string" ? s : s.data;
      let a = this._terminalBufferMap.get(e);
      if (a) {
        a.data.push(o);
        return;
      }
      const l = setTimeout(() => this.flushBuffer(e), n);
      a = {
        data: [o],
        timeoutId: l,
        dispose: () => {
          clearTimeout(l), this.flushBuffer(e), r.dispose();
        }
      }, this._terminalBufferMap.set(e, a);
    });
    return r;
  }
  stopBuffering(e) {
    this._terminalBufferMap.get(e)?.dispose();
  }
  flushBuffer(e) {
    const i = this._terminalBufferMap.get(e);
    i && (this._terminalBufferMap.delete(e), this._callback(e, i.data.join("")));
  }
}
const Bo = (t, e, i, n) => {
  let r = e;
  return {
    enumerable: !0,
    configurable: !1,
    get() {
      return r;
    },
    set(s) {
      if (!i(r, s)) {
        const o = r;
        r = s, t.listener?.(n(s, o));
      }
    }
  };
}, Rl = (t, e) => t === e, Gs = {
  range: (t, e) => t === e ? !0 : !t || !e ? !1 : t.isEqual(e),
  label: Rl,
  description: Rl,
  sortText: Rl,
  busy: Rl,
  error: Rl,
  canResolveChildren: Rl,
  tags: (t, e) => !(t.length !== e.length || t.some((i) => !e.find((n) => i.id === n.id)))
}, Ll = (t) => (e) => ({ op: yi.SetProp, update: t(e) }), jN = (t, e) => ({
  range: (() => {
    let i;
    const n = Ll((r) => ({ range: ut.lift(z.from(r)) }));
    return {
      enumerable: !0,
      configurable: !1,
      get() {
        return i;
      },
      set(r) {
        t.listener?.({ op: yi.DocumentSynced }), Gs.range(i, r) || (i = r, t.listener?.(n(r)));
      }
    };
  })(),
  label: Bo(t, e, Gs.label, Ll((i) => ({ label: i }))),
  description: Bo(t, void 0, Gs.description, Ll((i) => ({ description: i }))),
  sortText: Bo(t, void 0, Gs.sortText, Ll((i) => ({ sortText: i }))),
  canResolveChildren: Bo(t, !1, Gs.canResolveChildren, (i) => ({
    op: yi.UpdateCanResolveChildren,
    state: i
  })),
  busy: Bo(t, !1, Gs.busy, Ll((i) => ({ busy: i }))),
  error: Bo(t, void 0, Gs.error, Ll((i) => ({ error: Ae.fromStrict(i) || null }))),
  tags: Bo(t, [], Gs.tags, (i, n) => ({
    op: yi.SetTags,
    new: i.map(wr.from),
    old: n.map(wr.from)
  }))
}), GN = (t) => {
  const e = Ne.fromString(t.extId), i = new _l(
    e.controllerId,
    e.localId,
    t.label,
    x.revive(t.uri) || void 0
  );
  return i.range = z.to(t.range || void 0), i.description = t.description || void 0, i.sortText = t.sortText || void 0, i.tags = t.tags.map((n) => wr.to({ id: VT(n).tagId })), i;
}, iI = (t) => {
  let e;
  for (const i of t.tests) {
    const n = GN(i.item);
    J_(n).parent = e, e = n;
  }
  return e;
};
class _l {
  constructor(e, i, n, r) {
    if (i.includes(Sn.Delimiter))
      throw new Error(`Test IDs may not include the ${JSON.stringify(i)} symbol`);
    const s = W9(this, e);
    Object.defineProperties(this, {
      id: {
        value: i,
        enumerable: !0,
        writable: !1
      },
      uri: {
        value: r,
        enumerable: !0,
        writable: !1
      },
      parent: {
        enumerable: !1,
        get() {
          return s.parent instanceof wE ? void 0 : s.parent;
        }
      },
      children: {
        value: B9(s, J_, _l),
        enumerable: !0,
        writable: !1
      },
      ...jN(s, n)
    });
  }
}
class wE extends _l {
  constructor(e, i) {
    super(e, e, i, void 0), this._isRoot = !0;
  }
}
class QN extends U9 {
  constructor(e, i, n) {
    super({
      controllerId: e,
      getDocumentVersion: (r) => r && n.getDocument(r)?.version,
      getApiFor: J_,
      getChildren: (r) => r.children,
      root: new wE(e, i),
      toITestItem: Ao.from
    });
  }
}
let Ay = class extends ve {
  constructor(e, i, n) {
    super(), this.initData = i, this._onDidChangeTelemetryEnabled = this._register(new N()), this.onDidChangeTelemetryEnabled = this._onDidChangeTelemetryEnabled.event, this._onDidChangeTelemetryConfiguration = this._register(new N()), this.onDidChangeTelemetryConfiguration = this._onDidChangeTelemetryConfiguration.event, this._productConfig = { usage: !0, error: !0 }, this._level = lo.NONE, this._inLoggingOnlyMode = !1, this._telemetryLoggers = /* @__PURE__ */ new Map(), this._inLoggingOnlyMode = this.initData.environment.isExtensionTelemetryLoggingOnly;
    const r = i.remote.isRemote ? "remoteExtHostTelemetry" : e ? "workerExtHostTelemetry" : "extHostTelemetry";
    this._outputLogger = this._register(n.createLogger(r, {
      name: h(
        2635,
        "Extension Telemetry{0}",
        this._inLoggingOnlyMode ? " (Not Sent)" : ""
      ),
      hidden: !0,
      group: T3
    }));
  }
  getTelemetryConfiguration() {
    return this._level === lo.USAGE;
  }
  getTelemetryDetails() {
    return {
      isCrashEnabled: this._level >= lo.CRASH,
      isErrorsEnabled: this._productConfig.error ? this._level >= lo.ERROR : !1,
      isUsageEnabled: this._productConfig.usage ? this._level >= lo.USAGE : !1
    };
  }
  instantiateLogger(e, i, n) {
    const r = this.getTelemetryDetails(), s = new QP(
      i,
      n,
      e,
      this._outputLogger,
      this._inLoggingOnlyMode,
      this.getBuiltInCommonProperties(e),
      { isUsageEnabled: r.isUsageEnabled, isErrorsEnabled: r.isErrorsEnabled }
    ), o = this._telemetryLoggers.get(e.identifier.value) ?? [];
    return this._telemetryLoggers.set(e.identifier.value, [...o, s]), s.apiTelemetryLogger;
  }
  $initializeTelemetryLevel(e, i, n) {
    this._level = e, this._productConfig = n ?? { usage: !0, error: !0 };
  }
  getBuiltInCommonProperties(e) {
    const i = /* @__PURE__ */ Object.create(null);
    switch (i["common.extname"] = `${e.publisher}.${e.name}`, i["common.extversion"] = e.version, i["common.vscodemachineid"] = this.initData.telemetryInfo.machineId, i["common.vscodesessionid"] = this.initData.telemetryInfo.sessionId, i["common.vscodecommithash"] = this.initData.commit, i["common.sqmid"] = this.initData.telemetryInfo.sqmId, i["common.devDeviceId"] = this.initData.telemetryInfo.devDeviceId, i["common.vscodeversion"] = this.initData.version, i["common.vscodereleasedate"] = this.initData.date, i["common.isnewappinstall"] = KP(this.initData.telemetryInfo.firstSessionDate), i["common.product"] = this.initData.environment.appHost, this.initData.uiKind) {
      case $d.Web:
        i["common.uikind"] = "web";
        break;
      case $d.Desktop:
        i["common.uikind"] = "desktop";
        break;
      default:
        i["common.uikind"] = "unknown";
    }
    return i["common.remotename"] = Tx(A3(this.initData.remote.authority)), i;
  }
  $onDidChangeTelemetryLevel(e) {
    this._oldTelemetryEnablement = this.getTelemetryConfiguration(), this._level = e;
    const i = this.getTelemetryDetails();
    this._telemetryLoggers.forEach((n, r) => {
      const s = n.filter((o) => !o.isDisposed);
      s.length === 0 ? this._telemetryLoggers.delete(r) : this._telemetryLoggers.set(r, s);
    }), this._telemetryLoggers.forEach((n) => {
      for (const r of n)
        r.updateTelemetryEnablements(i.isUsageEnabled, i.isErrorsEnabled);
    }), this._oldTelemetryEnablement !== this.getTelemetryConfiguration() && this._onDidChangeTelemetryEnabled.fire(this.getTelemetryConfiguration()), this._onDidChangeTelemetryConfiguration.fire(this.getTelemetryDetails());
  }
  onExtensionError(e, i) {
    const r = this._telemetryLoggers.get(e.value)?.filter((o) => !o.isDisposed);
    if (!r)
      return this._telemetryLoggers.delete(e.value), !1;
    let s = !1;
    for (const o of r)
      o.ignoreUnhandledExtHostErrors || (o.logError(i), s = !0);
    return s;
  }
};
Ay = W([
  M(1, pi),
  M(2, Lo)
], Ay);
class QP {
  static validateSender(e) {
    if (typeof e != "object")
      throw new TypeError("TelemetrySender argument is invalid");
    if (typeof e.sendEventData != "function")
      throw new TypeError("TelemetrySender.sendEventData must be a function");
    if (typeof e.sendErrorData != "function")
      throw new TypeError("TelemetrySender.sendErrorData must be a function");
    if (typeof e.flush < "u" && typeof e.flush != "function")
      throw new TypeError("TelemetrySender.flush must be a function or undefined");
  }
  constructor(e, i, n, r, s, o, a) {
    this._extension = n, this._logger = r, this._inLoggingOnlyMode = s, this._commonProperties = o, this._onDidChangeEnableStates = new N(), this.ignoreUnhandledExtHostErrors = i?.ignoreUnhandledErrors ?? !1, this._ignoreBuiltinCommonProperties = i?.ignoreBuiltInCommonProperties ?? !1, this._additionalCommonProperties = i?.additionalCommonProperties, this._sender = e, this._telemetryEnablements = { isUsageEnabled: a.isUsageEnabled, isErrorsEnabled: a.isErrorsEnabled };
  }
  updateTelemetryEnablements(e, i) {
    this._apiObject && (this._telemetryEnablements = { isUsageEnabled: e, isErrorsEnabled: i }, this._onDidChangeEnableStates.fire(this._apiObject));
  }
  mixInCommonPropsAndCleanData(e) {
    let i = "properties" in e ? e.properties ?? {} : e;
    return i = J2(i, []), this._additionalCommonProperties && (i = Za(i, this._additionalCommonProperties)), this._ignoreBuiltinCommonProperties || (i = Za(i, this._commonProperties)), "properties" in e ? e.properties = i : e = i, e;
  }
  logEvent(e, i) {
    this._sender && (this._extension.publisher === "vscode" ? e = this._extension.name + "/" + e : e = this._extension.identifier.value + "/" + e, i = this.mixInCommonPropsAndCleanData(i || {}), this._inLoggingOnlyMode || this._sender?.sendEventData(e, i), this._logger.trace(e, i));
  }
  logUsage(e, i) {
    this._telemetryEnablements.isUsageEnabled && this.logEvent(e, i);
  }
  logError(e, i) {
    if (!(!this._telemetryEnablements.isErrorsEnabled || !this._sender))
      if (typeof e == "string")
        this.logEvent(e, i);
      else {
        const n = {
          name: e.name,
          message: e.message,
          stack: e.stack,
          cause: e.cause
        }, r = J2(n, []), s = new Error(r.message, {
          cause: r.cause
        });
        s.stack = r.stack, s.name = r.name, i = this.mixInCommonPropsAndCleanData(i || {}), this._inLoggingOnlyMode || this._sender.sendErrorData(s, i), this._logger.trace("exception", i);
      }
  }
  get apiTelemetryLogger() {
    if (!this._apiObject) {
      const e = this, i = {
        logUsage: e.logUsage.bind(e),
        get isUsageEnabled() {
          return e._telemetryEnablements.isUsageEnabled;
        },
        get isErrorsEnabled() {
          return e._telemetryEnablements.isErrorsEnabled;
        },
        logError: e.logError.bind(e),
        dispose: e.dispose.bind(e),
        onDidChangeEnableStates: e._onDidChangeEnableStates.event.bind(e)
      };
      this._apiObject = Object.freeze(i);
    }
    return this._apiObject;
  }
  get isDisposed() {
    return !this._sender;
  }
  dispose() {
    if (this._sender?.flush) {
      let e = this._sender;
      this._sender = void 0, Promise.resolve(e.flush()).then(e = void 0), this._apiObject = void 0;
    } else
      this._sender = void 0;
  }
}
function KP(t) {
  const e = Date.now() - new Date(t).getTime();
  return isNaN(e) ? !1 : e < 1e3 * 60 * 60 * 24;
}
const u1 = pe("IExtHostTelemetry");
let Ry = class {
  #e;
  #t;
  #i;
  constructor(e, i, n) {
    this._commands = /* @__PURE__ */ new Map(), this._apiCommands = /* @__PURE__ */ new Map(), this.#e = e.getProxy(ee.MainThreadCommands), this._logService = i, this.#i = n, this.#t = e.getProxy(ee.MainThreadTelemetry), this.converter = new KN(this, (r) => {
      const s = this._apiCommands.get(r);
      return s?.result === Se.Void ? s : void 0;
    }, i), this._argumentProcessors = [
      {
        processArgument(r) {
          return Fi(r);
        }
      },
      {
        processArgument(r) {
          return Wc(r, function(s) {
            if (ut.isIRange(s))
              return z.to(s);
            if (Pn.isIPosition(s))
              return at.to(s);
            if (ut.isIRange(s.range) && x.isUri(s.uri))
              return an.to(s);
            if (s instanceof ue)
              return s.buffer.buffer;
            if (!Array.isArray(s))
              return s;
          });
        }
      }
    ];
  }
  registerArgumentProcessor(e) {
    this._argumentProcessors.push(e);
  }
  registerApiCommand(e) {
    const i = this.registerCommand(!1, e.id, async (...n) => {
      const r = e.args.map((o, a) => {
        if (!o.validate(n[a]))
          throw new Error(
            `Invalid argument '${o.name}' when running '${e.id}', received: ${typeof n[a] == "object" ? JSON.stringify(n[a], null, "	") : n[a]} `
          );
        return o.convert(n[a]);
      }), s = await this.executeCommand(e.internalId, ...r);
      return e.result.convert(s, n, this.converter);
    }, void 0, {
      description: e.description,
      args: e.args,
      returns: e.result.description
    });
    return this._apiCommands.set(e.id, e), new Ve(() => {
      i.dispose(), this._apiCommands.delete(e.id);
    });
  }
  registerCommand(e, i, n, r, s, o) {
    if (this._logService.trace("ExtHostCommands#registerCommand", i), !i.trim().length)
      throw new Error("invalid id");
    if (this._commands.has(i))
      throw new Error(`command '${i}' already exists`);
    return this._commands.set(i, { callback: n, thisArg: r, metadata: s, extension: o }), e && this.#e.$registerCommand(i), new Ve(() => {
      this._commands.delete(i) && e && this.#e.$unregisterCommand(i);
    });
  }
  executeCommand(e, ...i) {
    return this._logService.trace("ExtHostCommands#executeCommand", e), this._doExecuteCommand(e, i, !0);
  }
  async _doExecuteCommand(e, i, n) {
    if (this._commands.has(e))
      return this.#e.$fireCommandActivationEvent(e), this._executeContributedCommand(e, i, !1);
    {
      let r = !1;
      const s = Wc(i, function(o) {
        if (o instanceof je)
          return at.from(o);
        if (o instanceof Oe)
          return z.from(o);
        if (o instanceof Ln)
          return an.from(o);
        if (Wr.isNotebookRange(o))
          return Jr.from(o);
        if (o instanceof ArrayBuffer)
          return r = !0, ue.wrap(new Uint8Array(o));
        if (o instanceof Uint8Array)
          return r = !0, ue.wrap(o);
        if (o instanceof ue)
          return r = !0, o;
        if (!Array.isArray(o))
          return o;
      });
      try {
        const o = await this.#e.$executeCommand(e, r ? new zi(s) : s, n);
        return Fi(o);
      } catch (o) {
        if (o instanceof Error && o.message === "$executeCommand:retry")
          return this._doExecuteCommand(e, i, !1);
        throw o;
      }
    }
  }
  async _executeContributedCommand(e, i, n) {
    const r = this._commands.get(e);
    if (!r)
      throw new Error("Unknown command");
    const { callback: s, thisArg: o, metadata: a } = r;
    if (a?.args)
      for (let c = 0; c < a.args.length; c++)
        try {
          s4(i[c], a.args[c].constraint);
        } catch {
          throw new Error(
            `Running the contributed command: '${e}' failed. Illegal argument '${a.args[c].name}' - ${a.args[c].description}`
          );
        }
    const l = Ms.create();
    try {
      return await s.apply(o, i);
    } catch (c) {
      if (e === this.converter.delegatingCommandId) {
        const u = this.converter.getActualCommand(...i);
        u && (e = u.command);
      }
      if (Yr(c) || this._logService.error(c, e, r.extension?.identifier), !n)
        throw c;
      if (r.extension?.identifier) {
        const u = this.#i.onExtensionError(r.extension.identifier, c);
        this._logService.trace("forwarded error to extension?", u, r.extension?.identifier);
      }
      throw new class extends Error {
        constructor() {
          super(xu(c)), this.id = e, this.source = r.extension?.displayName ?? r.extension?.name;
        }
      }();
    } finally {
      this._reportTelemetry(r, e, l.elapsed());
    }
  }
  _reportTelemetry(e, i, n) {
    e.extension && (i.startsWith("code.copilot.logStructured") || this.#t.$publicLog2("Extension:ActionExecuted", {
      extensionId: e.extension.identifier.value,
      id: new qx(i),
      duration: n
    }));
  }
  $executeContributedCommand(e, ...i) {
    this._logService.trace("ExtHostCommands#$executeContributedCommand", e);
    const n = this._commands.get(e);
    return n ? (i = i.map(
      (r) => this._argumentProcessors.reduce((s, o) => o.processArgument(s, n.extension), r)
    ), this._executeContributedCommand(e, i, !0)) : Promise.reject(new Error(`Contributed command '${e}' does not exist.`));
  }
  getCommands(e = !1) {
    return this._logService.trace("ExtHostCommands#getCommands", e), this.#e.$getCommands().then((i) => (e && (i = i.filter((n) => n[0] !== "_")), i));
  }
  $getContributedCommandMetadata() {
    const e = /* @__PURE__ */ Object.create(null);
    for (const [i, n] of this._commands) {
      const { metadata: r } = n;
      r && (e[i] = r);
    }
    return Promise.resolve(e);
  }
};
Ry = W([
  M(0, Ye),
  M(1, nt),
  M(2, u1)
], Ry);
const vl = pe("IExtHostCommands");
class KN {
  constructor(e, i, n) {
    this._commands = e, this._lookupApiCommand = i, this._logService = n, this.delegatingCommandId = `__vsc${on()}`, this._cache = /* @__PURE__ */ new Map(), this._cachIdPool = 0, this._commands.registerCommand(!0, this.delegatingCommandId, this._executeConvertedCommand, this);
  }
  toInternal(e, i) {
    if (!e)
      return;
    const n = {
      $ident: void 0,
      id: e.command,
      title: e.title,
      tooltip: e.tooltip
    };
    if (!e.command)
      return n;
    const r = this._lookupApiCommand(e.command);
    if (r)
      n.id = r.internalId, n.arguments = r.args.map((s, o) => s.convert(e.arguments && e.arguments[o]));
    else if (of(e.arguments)) {
      const s = `${e.command} /${++this._cachIdPool}`;
      this._cache.set(s, e), i.add(Ee(() => {
        this._cache.delete(s), this._logService.trace("CommandsConverter#DISPOSE", s);
      })), n.$ident = s, n.id = this.delegatingCommandId, n.arguments = [s], this._logService.trace("CommandsConverter#CREATE", e.command, s);
    }
    return n;
  }
  fromInternal(e) {
    return typeof e.$ident == "string" ? this._cache.get(e.$ident) : {
      command: e.id,
      title: e.title,
      arguments: e.arguments
    };
  }
  getActualCommand(...e) {
    return this._cache.get(e[0]);
  }
  _executeConvertedCommand(...e) {
    const i = this.getActualCommand(...e);
    return this._logService.trace("CommandsConverter#EXECUTE", e[0], i ? i.command : "MISSING"), i ? this._commands.executeCommand(i.command, ...i.arguments || []) : Promise.reject(`Actual command not found, wanted to execute ${e[0]}`);
  }
}
const Mt = class Mt {
  static Arr(e) {
    return new Mt(
      `${e.name}_array`,
      `Array of ${e.name}, ${e.description}`,
      (i) => Array.isArray(i) && i.every((n) => e.validate(n)),
      (i) => i.map((n) => e.convert(n))
    );
  }
  constructor(e, i, n, r) {
    this.name = e, this.description = i, this.validate = n, this.convert = r;
  }
  optional() {
    return new Mt(
      this.name,
      `(optional) ${this.description}`,
      (e) => e == null || this.validate(e),
      (e) => e === void 0 ? void 0 : e === null ? null : this.convert(e)
    );
  }
  with(e, i) {
    return new Mt(
      e ?? this.name,
      i ?? this.description,
      this.validate,
      this.convert
    );
  }
};
Mt.Uri = new Mt("uri", "Uri of a text document", (e) => x.isUri(e), (e) => e), Mt.Position = new Mt(
  "position",
  "A position in a text document",
  (e) => je.isPosition(e),
  at.from
), Mt.Range = new Mt(
  "range",
  "A range in a text document",
  (e) => Oe.isRange(e),
  z.from
), Mt.Selection = new Mt(
  "selection",
  "A selection in a text document",
  (e) => Qr.isSelection(e),
  vr.from
), Mt.Number = new Mt("number", "", (e) => typeof e == "number", (e) => e), Mt.String = new Mt("string", "", (e) => typeof e == "string", (e) => e), Mt.CallHierarchyItem = new Mt(
  "item",
  "A call hierarchy item",
  (e) => e instanceof Jx,
  al.from
), Mt.TypeHierarchyItem = new Mt(
  "item",
  "A type hierarchy item",
  (e) => e instanceof Zx,
  Na.from
), Mt.TestItem = new Mt(
  "testItem",
  "A VS Code TestItem",
  (e) => e instanceof _l,
  Ao.from
), Mt.TestProfile = new Mt(
  "testProfile",
  "A VS Code test profile",
  (e) => e instanceof nP,
  Gb.from
);
let q = Mt;
const b_ = class b_ {
  constructor(e, i) {
    this.description = e, this.convert = i;
  }
};
b_.Void = new b_("no result", (e) => e);
let Se = b_;
class Pe {
  constructor(e, i, n, r, s) {
    this.id = e, this.internalId = i, this.description = n, this.args = r, this.result = s;
  }
}
const Eu = pe("IExtHostTerminalService");
class nI extends ve {
  constructor(e, i, n, r) {
    super(), this._proxy = e, this._id = i, this._creationOptions = n, this._name = r, this._disposed = !1, this._state = { isInteractedWith: !1, shell: void 0 }, this.isOpen = !1, this._onWillDispose = this._register(new N()), this.onWillDispose = this._onWillDispose.event, this._creationOptions = Object.freeze(this._creationOptions), this._pidPromise = new Promise((o) => this._pidPromiseComplete = o);
    const s = this;
    this.value = {
      get name() {
        return s._name || "";
      },
      get processId() {
        return s._pidPromise;
      },
      get creationOptions() {
        return s._creationOptions;
      },
      get exitStatus() {
        return s._exitStatus;
      },
      get state() {
        return s._state;
      },
      get selection() {
        return s._selection;
      },
      get shellIntegration() {
        return s.shellIntegration;
      },
      sendText(o, a = !0) {
        s._checkDisposed(), s._proxy.$sendText(s._id, o, a);
      },
      show(o) {
        s._checkDisposed(), s._proxy.$show(s._id, o);
      },
      hide() {
        s._checkDisposed(), s._proxy.$hide(s._id);
      },
      dispose() {
        s._disposed || (s._disposed = !0, s._proxy.$dispose(s._id));
      },
      get dimensions() {
        if (!(s._cols === void 0 || s._rows === void 0))
          return {
            columns: s._cols,
            rows: s._rows
          };
      }
    };
  }
  dispose() {
    this._onWillDispose.fire(), super.dispose();
  }
  async create(e, i) {
    if (typeof this._id != "string")
      throw new Error("Terminal has already been created");
    await this._proxy.$createTerminal(this._id, {
      name: e.name,
      shellPath: e.shellPath ?? void 0,
      shellArgs: e.shellArgs ?? void 0,
      cwd: e.cwd ?? i?.cwd ?? void 0,
      env: e.env ?? void 0,
      icon: JP(e.iconPath) ?? void 0,
      color: zc.isThemeColor(e.color) ? e.color.id : void 0,
      initialText: e.message ?? void 0,
      strictEnv: e.strictEnv ?? void 0,
      hideFromUser: e.hideFromUser ?? void 0,
      forceShellIntegration: i?.forceShellIntegration ?? void 0,
      isFeatureTerminal: i?.isFeatureTerminal ?? void 0,
      isExtensionOwnedTerminal: !0,
      useShellEnvironment: i?.useShellEnvironment ?? void 0,
      location: i?.location || this._serializeParentTerminal(e.location, i?.resolvedExtHostIdentifier),
      isTransient: e.isTransient ?? void 0
    });
  }
  async createExtensionTerminal(e, i, n, r, s) {
    if (typeof this._id != "string")
      throw new Error("Terminal has already been created");
    if (await this._proxy.$createTerminal(this._id, {
      name: this._name,
      isExtensionCustomPtyTerminal: !0,
      icon: r,
      color: zc.isThemeColor(s) ? s.id : void 0,
      location: i?.location || this._serializeParentTerminal(e, n),
      isTransient: !0
    }), typeof this._id == "string")
      throw new Error("Terminal creation failed");
    return this._id;
  }
  _serializeParentTerminal(e, i) {
    return typeof e == "object" ? "parentTerminal" in e && e.parentTerminal && i ? { parentTerminal: i } : "viewColumn" in e ? { viewColumn: si.from(e.viewColumn), preserveFocus: e.preserveFocus } : void 0 : e;
  }
  _checkDisposed() {
    if (this._disposed)
      throw new Error("Terminal has already been disposed");
  }
  set name(e) {
    this._name = e;
  }
  setExitStatus(e, i) {
    this._exitStatus = Object.freeze({ code: e, reason: i });
  }
  setDimensions(e, i) {
    return e === this._cols && i === this._rows || e === 0 || i === 0 ? !1 : (this._cols = e, this._rows = i, !0);
  }
  setInteractedWith() {
    return this._state.isInteractedWith ? !1 : (this._state = {
      ...this._state,
      isInteractedWith: !0
    }, !0);
  }
  setShellType(e) {
    return this._state.shell !== e ? (this._state = {
      ...this._state,
      shell: e
    }, !0) : !1;
  }
  setSelection(e) {
    this._selection = e;
  }
  _setProcessId(e) {
    this._pidPromiseComplete ? (this._pidPromiseComplete(e), this._pidPromiseComplete = void 0) : this._pidPromise.then((i) => {
      i !== e && (this._pidPromise = Promise.resolve(e));
    });
  }
}
class K1 {
  get onProcessReady() {
    return this._onProcessReady.event;
  }
  constructor(e) {
    this._pty = e, this.id = 0, this.shouldPersist = !1, this._onProcessData = new N(), this.onProcessData = this._onProcessData.event, this._onProcessReady = new N(), this._onDidChangeProperty = new N(), this.onDidChangeProperty = this._onDidChangeProperty.event, this._onProcessExit = new N(), this.onProcessExit = this._onProcessExit.event;
  }
  refreshProperty(e) {
    throw new Error(
      `refreshProperty is not suppported in extension owned terminals. property: ${e}`
    );
  }
  updateProperty(e, i) {
    throw new Error(
      `updateProperty is not suppported in extension owned terminals. property: ${e}, value: ${i}`
    );
  }
  async start() {
  }
  shutdown() {
    this._pty.close();
  }
  input(e) {
    this._pty.handleInput?.(e);
  }
  sendSignal(e) {
  }
  resize(e, i) {
    this._pty.setDimensions?.({ columns: e, rows: i });
  }
  clearBuffer() {
  }
  async processBinary(e) {
  }
  acknowledgeDataEvent(e) {
  }
  async setUnicodeVersion(e) {
  }
  getInitialCwd() {
    return Promise.resolve("");
  }
  getCwd() {
    return Promise.resolve("");
  }
  startSendingEvents(e) {
    this._pty.onDidWrite((i) => this._onProcessData.fire(i)), this._pty.onDidClose?.((i = void 0) => {
      this._onProcessExit.fire(i === void 0 ? void 0 : i);
    }), this._pty.onDidOverrideDimensions?.((i) => {
      i && this._onDidChangeProperty.fire({ type: _u.OverrideDimensions, value: { cols: i.columns, rows: i.rows } });
    }), this._pty.onDidChangeName?.((i) => {
      this._onDidChangeProperty.fire({ type: _u.Title, value: i });
    }), this._pty.open(e || void 0), e && this._pty.setDimensions?.(e), this._onProcessReady.fire({ pid: -1, cwd: "", windowsPty: void 0 });
  }
}
let JN = 1, Ly = class extends ve {
  get activeTerminal() {
    return this._activeTerminal?.value;
  }
  get terminals() {
    return this._terminals.map((e) => e.value);
  }
  constructor(e, i, n) {
    super(), this._extHostCommands = i, this._terminals = [], this._terminalProcesses = /* @__PURE__ */ new Map(), this._terminalProcessDisposables = {}, this._extensionTerminalAwaitingStart = {}, this._getTerminalPromises = {}, this._environmentVariableCollections = /* @__PURE__ */ new Map(), this._lastQuickFixCommands = this._register(new Ss()), this._linkProviders = /* @__PURE__ */ new Set(), this._completionProviders = /* @__PURE__ */ new Map(), this._profileProviders = /* @__PURE__ */ new Map(), this._quickFixProviders = /* @__PURE__ */ new Map(), this._terminalLinkCache = /* @__PURE__ */ new Map(), this._terminalLinkCancellationSource = /* @__PURE__ */ new Map(), this._onDidCloseTerminal = new N(), this.onDidCloseTerminal = this._onDidCloseTerminal.event, this._onDidOpenTerminal = new N(), this.onDidOpenTerminal = this._onDidOpenTerminal.event, this._onDidChangeActiveTerminal = new N(), this.onDidChangeActiveTerminal = this._onDidChangeActiveTerminal.event, this._onDidChangeTerminalDimensions = new N(), this.onDidChangeTerminalDimensions = this._onDidChangeTerminalDimensions.event, this._onDidChangeTerminalState = new N(), this.onDidChangeTerminalState = this._onDidChangeTerminalState.event, this._onDidChangeShell = new N(), this.onDidChangeShell = this._onDidChangeShell.event, this._onDidWriteTerminalData = new N({
      onWillAddFirstListener: () => this._proxy.$startSendingDataEvents(),
      onDidRemoveLastListener: () => this._proxy.$stopSendingDataEvents()
    }), this.onDidWriteTerminalData = this._onDidWriteTerminalData.event, this._onDidExecuteCommand = new N({
      onWillAddFirstListener: () => this._proxy.$startSendingCommandEvents(),
      onDidRemoveLastListener: () => this._proxy.$stopSendingCommandEvents()
    }), this.onDidExecuteTerminalCommand = this._onDidExecuteCommand.event, this._proxy = n.getProxy(ee.MainThreadTerminalService), this._bufferer = new qN(this._proxy.$sendProcessData), this._proxy.$registerProcessSupport(e), this._extHostCommands.registerArgumentProcessor({
      processArgument: (r) => {
        const s = (o) => {
          const a = o;
          return this.getTerminalById(a.instanceId)?.value;
        };
        switch (r?.$mid) {
          case tt.TerminalContext:
            return s(r);
          default: {
            if (Array.isArray(r))
              for (let o = 0; o < r.length && r[o].$mid === tt.TerminalContext; o++)
                r[o] = s(r[o]);
            return r;
          }
        }
      }
    }), this._register({
      dispose: () => {
        for (const [r, s] of this._terminalProcesses)
          s.shutdown(!0);
      }
    });
  }
  getDefaultShell(e) {
    return (e ? this._defaultAutomationProfile : this._defaultProfile)?.path || "";
  }
  getDefaultShellArgs(e) {
    return (e ? this._defaultAutomationProfile : this._defaultProfile)?.args || [];
  }
  createExtensionTerminal(e, i) {
    const n = new nI(this._proxy, on(), e, e.name), r = new K1(e.pty);
    return n.createExtensionTerminal(e.location, i, this._serializeParentTerminal(e, i).resolvedExtHostIdentifier, JP(e.iconPath), XN(e.color)).then((s) => {
      const o = this._setupExtHostProcessListeners(s, r);
      this._terminalProcessDisposables[s] = o;
    }), this._terminals.push(n), n.value;
  }
  _serializeParentTerminal(e, i) {
    if (i = i || {}, e.location && typeof e.location == "object" && "parentTerminal" in e.location) {
      const n = e.location.parentTerminal;
      if (n) {
        const r = this._terminals.find((s) => s.value === n);
        r && (i.resolvedExtHostIdentifier = r._id);
      }
    } else e.location && typeof e.location != "object" ? i.location = e.location : i.location && typeof i.location == "object" && "splitActiveTerminal" in i.location && (i.location = { splitActiveTerminal: !0 });
    return i;
  }
  attachPtyToTerminal(e, i) {
    if (!this.getTerminalById(e))
      throw new Error(`Cannot resolve terminal with id ${e} for virtual process`);
    const r = new K1(i), s = this._setupExtHostProcessListeners(e, r);
    this._terminalProcessDisposables[e] = s;
  }
  async $acceptActiveTerminalChanged(e) {
    const i = this._activeTerminal;
    if (e === null) {
      this._activeTerminal = void 0, i !== this._activeTerminal && this._onDidChangeActiveTerminal.fire(this._activeTerminal);
      return;
    }
    const n = this.getTerminalById(e);
    n && (this._activeTerminal = n, i !== this._activeTerminal && this._onDidChangeActiveTerminal.fire(this._activeTerminal.value));
  }
  async $acceptTerminalProcessData(e, i) {
    const n = this.getTerminalById(e);
    n && this._onDidWriteTerminalData.fire({ terminal: n.value, data: i });
  }
  async $acceptTerminalDimensions(e, i, n) {
    const r = this.getTerminalById(e);
    r && r.setDimensions(i, n) && this._onDidChangeTerminalDimensions.fire({
      terminal: r.value,
      dimensions: r.value.dimensions
    });
  }
  async $acceptDidExecuteCommand(e, i) {
    const n = this.getTerminalById(e);
    n && this._onDidExecuteCommand.fire({ terminal: n.value, ...i });
  }
  async $acceptTerminalMaximumDimensions(e, i, n) {
    this._terminalProcesses.get(e)?.resize(i, n);
  }
  async $acceptTerminalTitleChange(e, i) {
    const n = this.getTerminalById(e);
    n && (n.name = i);
  }
  async $acceptTerminalClosed(e, i, n) {
    const r = this._getTerminalObjectIndexById(this._terminals, e);
    if (r !== null) {
      const s = this._terminals.splice(r, 1)[0];
      s.setExitStatus(i, n), this._onDidCloseTerminal.fire(s.value);
    }
  }
  $acceptTerminalOpened(e, i, n, r) {
    if (i) {
      const a = this._getTerminalObjectIndexById(this._terminals, i);
      if (a !== null) {
        this._terminals[a]._id = e, this._onDidOpenTerminal.fire(this.terminals[a]), this._terminals[a].isOpen = !0;
        return;
      }
    }
    const s = {
      name: r.name,
      shellPath: r.executable,
      shellArgs: r.args,
      cwd: typeof r.cwd == "string" ? r.cwd : x.revive(r.cwd),
      env: r.env,
      hideFromUser: r.hideFromUser
    }, o = new nI(this._proxy, e, s, n);
    this._terminals.push(o), this._onDidOpenTerminal.fire(o.value), o.isOpen = !0;
  }
  async $acceptTerminalProcessId(e, i) {
    this.getTerminalById(e)?._setProcessId(i);
  }
  async $startExtensionTerminal(e, i) {
    const n = this.getTerminalById(e);
    if (!n)
      return { message: h(2636, "Could not find the terminal with id {0} on the extension host", e) };
    n.isOpen || await new Promise((s) => {
      const o = this.onDidOpenTerminal(async (a) => {
        a === n.value && (o.dispose(), s());
      });
    });
    const r = this._terminalProcesses.get(e);
    r ? r.startSendingEvents(i) : this._extensionTerminalAwaitingStart[e] = { initialDimensions: i };
  }
  _setupExtHostProcessListeners(e, i) {
    const n = new De();
    n.add(i.onProcessReady((s) => this._proxy.$sendProcessReady(e, s.pid, s.cwd, s.windowsPty))), n.add(i.onDidChangeProperty((s) => this._proxy.$sendProcessProperty(e, s))), this._bufferer.startBuffering(e, i.onProcessData), n.add(i.onProcessExit((s) => this._onProcessExit(e, s))), this._terminalProcesses.set(e, i);
    const r = this._extensionTerminalAwaitingStart[e];
    return r && i instanceof K1 && (i.startSendingEvents(r.initialDimensions), delete this._extensionTerminalAwaitingStart[e]), n;
  }
  $acceptProcessAckDataEvent(e, i) {
    this._terminalProcesses.get(e)?.acknowledgeDataEvent(i);
  }
  $acceptProcessInput(e, i) {
    this._terminalProcesses.get(e)?.input(i);
  }
  $acceptTerminalInteraction(e) {
    const i = this.getTerminalById(e);
    i?.setInteractedWith() && this._onDidChangeTerminalState.fire(i.value);
  }
  $acceptTerminalSelection(e, i) {
    this.getTerminalById(e)?.setSelection(i);
  }
  $acceptProcessResize(e, i, n) {
    try {
      this._terminalProcesses.get(e)?.resize(i, n);
    } catch (r) {
      if (r.code !== "EPIPE" && r.code !== "ERR_IPC_CHANNEL_CLOSED")
        throw r;
    }
  }
  $acceptProcessShutdown(e, i) {
    this._terminalProcesses.get(e)?.shutdown(i);
  }
  $acceptProcessRequestInitialCwd(e) {
    this._terminalProcesses.get(e)?.getInitialCwd().then((i) => this._proxy.$sendProcessProperty(e, { type: _u.InitialCwd, value: i }));
  }
  $acceptProcessRequestCwd(e) {
    this._terminalProcesses.get(e)?.getCwd().then((i) => this._proxy.$sendProcessProperty(e, { type: _u.Cwd, value: i }));
  }
  $acceptProcessRequestLatency(e) {
    return Promise.resolve(e);
  }
  registerProfileProvider(e, i, n) {
    if (this._profileProviders.has(i))
      throw new Error(`Terminal profile provider "${i}" already registered`);
    return this._profileProviders.set(i, n), this._proxy.$registerProfileProvider(i, e.identifier.value), new Ve(() => {
      this._profileProviders.delete(i), this._proxy.$unregisterProfileProvider(i);
    });
  }
  registerTerminalCompletionProvider(e, i, ...n) {
    if (this._completionProviders.has(i.id))
      throw new Error(`Terminal completion provider "${i.id}" already registered`);
    return this._completionProviders.set(i.id, i), this._proxy.$registerCompletionProvider(i.id, e.identifier.value, ...n), new Ve(() => {
      this._completionProviders.delete(i.id), this._proxy.$unregisterCompletionProvider(i.id);
    });
  }
  async $provideTerminalCompletions(e, i) {
    const n = new Pt().token;
    if (n.isCancellationRequested || !this.activeTerminal)
      return;
    const r = this._completionProviders.get(e);
    if (!r)
      return;
    const s = await r.provideTerminalCompletions(this.activeTerminal, i, n);
    if (s == null)
      return;
    const o = !ji || this.activeTerminal.state?.shell === Ty.GitBash ? "/" : "\\";
    return sy.from(s, o);
  }
  $acceptTerminalShellType(e, i) {
    const n = this.getTerminalById(e);
    n?.setShellType(i) && this._onDidChangeTerminalState.fire(n.value);
  }
  registerTerminalQuickFixProvider(e, i, n) {
    if (this._quickFixProviders.has(e))
      throw new Error(`Terminal quick fix provider "${e}" is already registered`);
    return this._quickFixProviders.set(e, n), this._proxy.$registerQuickFixProvider(e, i), new Ve(() => {
      this._quickFixProviders.delete(e), this._proxy.$unregisterQuickFixProvider(e);
    });
  }
  async $provideTerminalQuickFixes(e, i) {
    const n = new Pt().token;
    if (n.isCancellationRequested)
      return;
    const r = this._quickFixProviders.get(e);
    if (!r)
      return;
    const s = await r.provideTerminalQuickFixes(i, n);
    if (s === null || Array.isArray(s) && s.length === 0)
      return;
    const o = new De();
    if (this._lastQuickFixCommands.value = o, !Array.isArray(s))
      return s ? $m.from(s, this._extHostCommands.converter, o) : void 0;
    const a = [];
    for (const l of s) {
      const c = $m.from(l, this._extHostCommands.converter, o);
      c && a.push(c);
    }
    return a;
  }
  async $createContributedProfileTerminal(e, i) {
    const n = new Pt().token;
    let r = await this._profileProviders.get(e)?.provideTerminalProfile(n);
    if (!n.isCancellationRequested) {
      if (r && !("options" in r) && (r = { options: r }), !r || !("options" in r))
        throw new Error(`No terminal profile options provided for id "${e}"`);
      if ("pty" in r.options) {
        this.createExtensionTerminal(r.options, i);
        return;
      }
      this.createTerminalFromOptions(r.options, i);
    }
  }
  registerLinkProvider(e) {
    return this._linkProviders.add(e), this._linkProviders.size === 1 && this._proxy.$startLinkProvider(), new Ve(() => {
      this._linkProviders.delete(e), this._linkProviders.size === 0 && this._proxy.$stopLinkProvider();
    });
  }
  async $provideLinks(e, i) {
    const n = this.getTerminalById(e);
    if (!n)
      return [];
    this._terminalLinkCache.delete(e), this._terminalLinkCancellationSource.get(e)?.dispose(!0);
    const s = new Pt();
    this._terminalLinkCancellationSource.set(e, s);
    const o = [], a = { terminal: n.value, line: i }, l = [];
    for (const d of this._linkProviders)
      l.push(Bc.withAsyncBody(async (f) => {
        s.token.onCancellationRequested(() => f({ provider: d, links: [] }));
        const g = await d.provideTerminalLinks(a, s.token) || [];
        s.token.isCancellationRequested || f({ provider: d, links: g });
      }));
    const c = await Promise.all(l);
    if (s.token.isCancellationRequested)
      return [];
    const u = /* @__PURE__ */ new Map();
    for (const d of c)
      d && d.links.length > 0 && o.push(...d.links.map((f) => {
        const g = {
          id: JN++,
          startIndex: f.startIndex,
          length: f.length,
          label: f.tooltip
        };
        return u.set(g.id, {
          provider: d.provider,
          link: f
        }), g;
      }));
    return this._terminalLinkCache.set(e, u), o;
  }
  $activateLink(e, i) {
    const n = this._terminalLinkCache.get(e)?.get(i);
    n && n.provider.handleTerminalLink(n.link);
  }
  _onProcessExit(e, i) {
    this._bufferer.stopBuffering(e), this._terminalProcesses.delete(e), delete this._extensionTerminalAwaitingStart[e];
    const n = this._terminalProcessDisposables[e];
    n && (n.dispose(), delete this._terminalProcessDisposables[e]), this._proxy.$sendProcessExit(e, i);
  }
  getTerminalById(e) {
    return this._getTerminalObjectById(this._terminals, e);
  }
  getTerminalIdByApiObject(e) {
    const i = this._terminals.findIndex((n) => n.value === e);
    return i >= 0 ? i : null;
  }
  _getTerminalObjectById(e, i) {
    const n = this._getTerminalObjectIndexById(e, i);
    return n !== null ? e[n] : null;
  }
  _getTerminalObjectIndexById(e, i) {
    const n = e.findIndex((r) => r._id === i);
    return n >= 0 ? n : null;
  }
  getEnvironmentVariableCollection(e) {
    let i = this._environmentVariableCollections.get(e.identifier.value);
    return i || (i = this._register(new rI()), this._setEnvironmentVariableCollection(e.identifier.value, i)), i.getScopedEnvironmentVariableCollection(void 0);
  }
  _syncEnvironmentVariableCollection(e, i) {
    const n = HN(i.map), r = BN(i.descriptionMap);
    this._proxy.$setEnvironmentVariableCollection(e, i.persistent, n.length === 0 ? void 0 : n, r);
  }
  $initEnvironmentVariableCollections(e) {
    e.forEach((i) => {
      const n = i[0], r = this._register(new rI(i[1]));
      this._setEnvironmentVariableCollection(n, r);
    });
  }
  $acceptDefaultProfile(e, i) {
    const n = this._defaultProfile;
    this._defaultProfile = e, this._defaultAutomationProfile = i, n?.path !== e.path && this._onDidChangeShell.fire(e.path);
  }
  _setEnvironmentVariableCollection(e, i) {
    this._environmentVariableCollections.set(e, i), this._register(i.onDidChangeCollection(() => {
      this._syncEnvironmentVariableCollection(e, i);
    }));
  }
};
Ly = W([
  M(1, vl),
  M(2, Ye)
], Ly);
class rI extends ve {
  get persistent() {
    return this._persistent;
  }
  set persistent(e) {
    this._persistent = e, this._onDidChangeCollection.fire();
  }
  get onDidChangeCollection() {
    return this._onDidChangeCollection && this._onDidChangeCollection.event;
  }
  constructor(e) {
    super(), this.map = /* @__PURE__ */ new Map(), this.scopedCollections = /* @__PURE__ */ new Map(), this.descriptionMap = /* @__PURE__ */ new Map(), this._persistent = !0, this._onDidChangeCollection = new N(), this.map = new Map(e);
  }
  getScopedEnvironmentVariableCollection(e) {
    const i = this.getScopeKey(e);
    let n = this.scopedCollections.get(i);
    return n || (n = new YN(this, e), this.scopedCollections.set(i, n), this._register(n.onDidChangeCollection(() => this._onDidChangeCollection.fire()))), n;
  }
  replace(e, i, n, r) {
    this._setIfDiffers(e, { value: i, type: hc.Replace, options: n ?? { applyAtProcessCreation: !0 }, scope: r });
  }
  append(e, i, n, r) {
    this._setIfDiffers(e, { value: i, type: hc.Append, options: n ?? { applyAtProcessCreation: !0 }, scope: r });
  }
  prepend(e, i, n, r) {
    this._setIfDiffers(e, { value: i, type: hc.Prepend, options: n ?? { applyAtProcessCreation: !0 }, scope: r });
  }
  _setIfDiffers(e, i) {
    if (i.options && i.options.applyAtProcessCreation === !1 && !i.options.applyAtShellIntegration)
      throw new Error(
        "EnvironmentVariableMutatorOptions must apply at either process creation or shell integration"
      );
    const n = this.getKey(e, i.scope), r = this.map.get(n), s = i.options ? {
      applyAtProcessCreation: i.options.applyAtProcessCreation ?? !1,
      applyAtShellIntegration: i.options.applyAtShellIntegration ?? !1
    } : {
      applyAtProcessCreation: !0
    };
    if (!r || r.value !== i.value || r.type !== i.type || r.options?.applyAtProcessCreation !== s.applyAtProcessCreation || r.options?.applyAtShellIntegration !== s.applyAtShellIntegration || r.scope?.workspaceFolder?.index !== i.scope?.workspaceFolder?.index) {
      const o = this.getKey(e, i.scope), a = {
        variable: e,
        ...i,
        options: s
      };
      this.map.set(o, a), this._onDidChangeCollection.fire();
    }
  }
  get(e, i) {
    const n = this.getKey(e, i), r = this.map.get(n);
    return r ? sI(r) : void 0;
  }
  getKey(e, i) {
    const n = this.getScopeKey(i);
    return n.length ? `${e}:::${n}` : e;
  }
  getScopeKey(e) {
    return this.getWorkspaceKey(e?.workspaceFolder) ?? "";
  }
  getWorkspaceKey(e) {
    return e ? e.uri.toString() : void 0;
  }
  getVariableMap(e) {
    const i = /* @__PURE__ */ new Map();
    for (const [n, r] of this.map)
      this.getScopeKey(r.scope) === this.getScopeKey(e) && i.set(r.variable, sI(r));
    return i;
  }
  delete(e, i) {
    const n = this.getKey(e, i);
    this.map.delete(n), this._onDidChangeCollection.fire();
  }
  clear(e) {
    if (e?.workspaceFolder) {
      for (const [i, n] of this.map)
        n.scope?.workspaceFolder?.index === e.workspaceFolder.index && this.map.delete(i);
      this.clearDescription(e);
    } else
      this.map.clear(), this.descriptionMap.clear();
    this._onDidChangeCollection.fire();
  }
  setDescription(e, i) {
    const n = this.getScopeKey(i), r = this.descriptionMap.get(n);
    if (!r || r.description !== e) {
      let s;
      typeof e == "string" ? s = e : s = e?.value.split(`

`)[0];
      const o = { description: s, scope: i };
      this.descriptionMap.set(n, o), this._onDidChangeCollection.fire();
    }
  }
  getDescription(e) {
    const i = this.getScopeKey(e);
    return this.descriptionMap.get(i)?.description;
  }
  clearDescription(e) {
    const i = this.getScopeKey(e);
    this.descriptionMap.delete(i);
  }
}
class YN {
  get persistent() {
    return this.collection.persistent;
  }
  set persistent(e) {
    this.collection.persistent = e;
  }
  get onDidChangeCollection() {
    return this._onDidChangeCollection && this._onDidChangeCollection.event;
  }
  constructor(e, i) {
    this.collection = e, this.scope = i, this._onDidChangeCollection = new N();
  }
  getScoped(e) {
    return this.collection.getScopedEnvironmentVariableCollection(e);
  }
  replace(e, i, n) {
    this.collection.replace(e, i, n, this.scope);
  }
  append(e, i, n) {
    this.collection.append(e, i, n, this.scope);
  }
  prepend(e, i, n) {
    this.collection.prepend(e, i, n, this.scope);
  }
  get(e) {
    return this.collection.get(e, this.scope);
  }
  forEach(e, i) {
    this.collection.getVariableMap(this.scope).forEach((n, r) => e.call(i, r, n, this), this.scope);
  }
  [Symbol.iterator]() {
    return this.collection.getVariableMap(this.scope).entries();
  }
  delete(e) {
    this.collection.delete(e, this.scope), this._onDidChangeCollection.fire(void 0);
  }
  clear() {
    this.collection.clear(this.scope);
  }
  set description(e) {
    this.collection.setDescription(e, this.scope);
  }
  get description() {
    return this.collection.getDescription(this.scope);
  }
}
let Ny = class extends Ly {
  constructor(e, i) {
    super(!1, e, i);
  }
  createTerminal(e, i, n) {
    throw new gv();
  }
  createTerminalFromOptions(e, i) {
    throw new gv();
  }
};
Ny = W([
  M(0, vl),
  M(1, Ye)
], Ny);
function JP(t) {
  if (!(!t || typeof t == "string"))
    return "id" in t ? {
      id: t.id,
      color: t.color
    } : t;
}
function XN(t) {
  return zc.isThemeColor(t) ? t : void 0;
}
function sI(t) {
  const e = { ...t };
  return delete e.scope, e.options = e.options ?? void 0, delete e.variable, e;
}
const YP = "__", XP = "/.well-known", ZN = `${XP}/oauth-authorization-server`, oI = `${XP}/openid-configuration`, eM = " ";
var Gm;
(function(t) {
  t.InvalidRequest = "invalid_request", t.InvalidClient = "invalid_client", t.InvalidGrant = "invalid_grant", t.UnauthorizedClient = "unauthorized_client", t.UnsupportedGrantType = "unsupported_grant_type", t.InvalidScope = "invalid_scope";
})(Gm || (Gm = {}));
var aI;
(function(t) {
  t.AuthorizationPending = "authorization_pending", t.SlowDown = "slow_down", t.AccessDenied = "access_denied", t.ExpiredToken = "expired_token";
})(aI || (aI = {}));
var lI;
(function(t) {
  t.InvalidRedirectUri = "invalid_redirect_uri", t.InvalidClientMetadata = "invalid_client_metadata", t.InvalidSoftwareStatement = "invalid_software_statement", t.UnapprovedSoftwareStatement = "unapproved_software_statement";
})(lI || (lI = {}));
function tM(t) {
  return typeof t != "object" || t === null ? !1 : t.resource !== void 0;
}
function iM(t) {
  return typeof t != "object" || t === null ? !1 : t.issuer !== void 0;
}
function nM(t) {
  return typeof t != "object" || t === null ? !1 : t.client_id !== void 0;
}
function cI(t) {
  if (typeof t != "object" || t === null)
    return !1;
  const e = t;
  return e.access_token !== void 0 && e.token_type !== void 0;
}
function uI(t) {
  return typeof t != "object" || t === null ? !1 : t.error !== void 0;
}
function rM(t) {
  return typeof t != "object" || t === null ? !1 : t.error !== void 0;
}
function sM(t) {
  return {
    issuer: t.toString(),
    authorization_endpoint: new URL("/authorize", t).toString(),
    token_endpoint: new URL("/token", t).toString(),
    registration_endpoint: new URL("/register", t).toString(),
    response_types_supported: ["code", "id_token", "id_token token"]
  };
}
const dI = ["authorization_code", "refresh_token", "urn:ietf:params:oauth:grant-type:device_code"], hI = 33418;
async function ZP(t, e, i) {
  if (!t.registration_endpoint)
    throw new Error("Server does not support dynamic registration");
  const n = await fetch(t.registration_endpoint, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      client_name: e,
      client_uri: "https://code.visualstudio.com",
      grant_types: t.grant_types_supported ? t.grant_types_supported.filter((s) => dI.includes(s)) : dI,
      response_types: ["code"],
      redirect_uris: [
        "https://insiders.vscode.dev/redirect",
        "https://vscode.dev/redirect",
        "http://localhost",
        "http://127.0.0.1",
        `http://localhost:${hI}`,
        `http://127.0.0.1:${hI}`
      ],
      scope: i?.join(eM),
      token_endpoint_auth_method: "none",
      application_type: "native"
    })
  });
  if (!n.ok) {
    const s = await n.text();
    let o = s;
    try {
      const a = JSON.parse(s);
      rM(a) && (o = `${a.error}${a.error_description ? `: ${a.error_description}` : ""}`);
    } catch {
    }
    throw new Error(
      `Registration to ${t.registration_endpoint} failed: ${o}`
    );
  }
  const r = await n.json();
  if (nM(r))
    return r;
  throw new Error(
    `Invalid authorization dynamic client registration response: ${JSON.stringify(r)}`
  );
}
function oM(t) {
  const e = t.split(" "), i = e[0], n = {};
  return e.length > 1 && e.slice(1).join(" ").split(",").forEach((s) => {
    const [o, a] = s.split("=").map((l) => l.trim().replace(/"/g, ""));
    n[o] = a;
  }), { scheme: i, params: n };
}
function fI(t) {
  const e = t.split(".");
  if (e.length !== 3)
    throw new Error("Invalid JWT token format: token must have three parts separated by dots");
  const [i, n, r] = e;
  try {
    if (typeof JSON.parse(Uc(i).toString()) != "object")
      throw new Error("Invalid JWT token format: header is not a JSON object");
    const o = JSON.parse(Uc(n).toString());
    if (typeof o != "object")
      throw new Error("Invalid JWT token format: payload is not a JSON object");
    return o;
  } catch (s) {
    throw s instanceof Error ? new Error(`Failed to parse JWT token: ${s.message}`) : new Error("Failed to parse JWT token");
  }
}
var My, qa;
let Oy = (qa = class {
  getState() {
    const e = this._state;
    return {
      get focused() {
        return e.focused;
      },
      get active() {
        return e.active;
      }
    };
  }
  constructor(e, i) {
    this._onDidChangeWindowState = new N(), this.onDidChangeWindowState = this._onDidChangeWindowState.event, this._state = My.InitialState, e.handle && (this._nativeHandle = Uc(e.handle).buffer), this._proxy = i.getProxy(ee.MainThreadWindow), this._proxy.$getInitialState().then(({ isFocused: n, isActive: r }) => {
      this.onDidChangeWindowProperty("focused", n), this.onDidChangeWindowProperty("active", r);
    });
  }
  get nativeHandle() {
    return this._nativeHandle;
  }
  $onDidChangeActiveNativeWindowHandle(e) {
    this._nativeHandle = e ? Uc(e).buffer : void 0;
  }
  $onDidChangeWindowFocus(e) {
    this.onDidChangeWindowProperty("focused", e);
  }
  $onDidChangeWindowActive(e) {
    this.onDidChangeWindowProperty("active", e);
  }
  onDidChangeWindowProperty(e, i) {
    i !== this._state[e] && (this._state = { ...this._state, [e]: i }, this._onDidChangeWindowState.fire(this._state));
  }
  openUri(e, i) {
    let n;
    if (typeof e == "string") {
      n = e;
      try {
        e = x.parse(e);
      } catch {
        return Promise.reject(`Invalid uri - '${e}'`);
      }
    }
    return qd(e.scheme) ? Promise.reject("Invalid scheme - cannot be empty") : e.scheme === de.command ? Promise.reject(`Invalid scheme '${e.scheme}'`) : this._proxy.$openUri(e, n, i);
  }
  async asExternalUri(e, i) {
    if (qd(e.scheme))
      return Promise.reject("Invalid scheme - cannot be empty");
    const n = await this._proxy.$asExternalUri(e, i);
    return x.from(n);
  }
}, My = qa, qa.InitialState = {
  focused: !0,
  active: !0
}, qa);
Oy = My = W([
  M(0, pi),
  M(1, Ye)
], Oy);
const d1 = pe("IExtHostWindow");
var Fy, ja;
let Uy = (ja = class {
  constructor(e) {
    this.handles = new ul(), this.handlers = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadUrls);
  }
  registerUriHandler(e, i) {
    const n = e.identifier;
    if (this.handles.has(n))
      throw new Error(`Protocol handler already registered for extension ${n}`);
    const r = Fy.HandlePool++;
    return this.handles.add(n), this.handlers.set(r, i), this._proxy.$registerUriHandler(r, n, e.displayName || e.name), Ee(() => {
      this.handles.delete(n), this.handlers.delete(r), this._proxy.$unregisterUriHandler(r);
    });
  }
  $handleExternalUri(e, i) {
    const n = this.handlers.get(e);
    if (!n)
      return Promise.resolve(void 0);
    try {
      n.handleUri(x.revive(i));
    } catch (r) {
      Li(r);
    }
    return Promise.resolve(void 0);
  }
  async createAppUri(e) {
    return x.revive(await this._proxy.$createAppUri(e));
  }
}, Fy = ja, ja.HandlePool = 0, ja);
Uy = Fy = W([
  M(0, Ye)
], Uy);
const h1 = pe("IExtHostUrlsService");
function e5(t) {
  return (e, i, n) => {
    let r = null, s = null;
    if (typeof n.value == "function" ? (r = "value", s = n.value) : typeof n.get == "function" && (r = "get", s = n.get), !s || typeof i == "symbol")
      throw new Error("not supported");
    n[r] = t(s, i);
  };
}
function t5(t, e, i) {
  return e5((n, r) => {
    const s = `$debounce$${r}`, o = `$debounce$result$${r}`;
    return function(...a) {
      this[o] || (this[o] = void 0), clearTimeout(this[s]), this[s] = setTimeout(() => {
        n.apply(this, a), this[o] = void 0;
      }, t);
    };
  });
}
function aM(t, e, i) {
  return e5((n, r) => {
    const s = `$throttle$timer$${r}`, o = `$throttle$result$${r}`, a = `$throttle$lastRun$${r}`, l = `$throttle$pending$${r}`;
    return function(...c) {
      if (this[o] || (this[o] = i ? i() : void 0), (this[a] === null || this[a] === void 0) && (this[a] = -Number.MAX_VALUE), e && (this[o] = e(this[o], ...c)), this[l])
        return;
      const u = this[a] + t;
      u <= Date.now() ? (this[a] = Date.now(), n.apply(this, [this[o]]), this[o] = i ? i() : void 0) : (this[l] = !0, this[s] = setTimeout(() => {
        this[l] = !1, this[a] = Date.now(), n.apply(this, [this[o]]), this[o] = i ? i() : void 0;
      }, u - Date.now()));
    };
  });
}
const f1 = pe("IExtHostProgress");
let $y = class {
  constructor(e) {
    this._handles = 0, this._mapHandleToCancellationSource = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadProgress);
  }
  async withProgress(e, i, n) {
    const r = this._handles++, { title: s, location: o, cancellable: a } = i, l = { label: e.displayName || e.name, id: e.identifier.value };
    return this._proxy.$startProgress(r, { location: ym.from(o), title: s, source: l, cancellable: a }, e.isUnderDevelopment ? void 0 : e.identifier.value).catch(pv), this._withProgress(r, n, !!a);
  }
  async withProgressFromSource(e, i, n) {
    const r = this._handles++, { title: s, location: o, cancellable: a } = i;
    return this._proxy.$startProgress(r, { location: ym.from(o), title: s, source: e, cancellable: a }, void 0).catch(pv), this._withProgress(r, n, !!a);
  }
  _withProgress(e, i, n) {
    let r;
    n && (r = new Pt(), this._mapHandleToCancellationSource.set(e, r));
    const s = (a) => {
      this._proxy.$progressEnd(a), this._mapHandleToCancellationSource.delete(a), r?.dispose();
    };
    let o;
    try {
      o = i(new Hy(this._proxy, e), n && r ? r.token : xt.None);
    } catch (a) {
      throw s(e), a;
    }
    return o.then((a) => s(e), (a) => s(e)), o;
  }
  $acceptProgressCanceled(e) {
    const i = this._mapHandleToCancellationSource.get(e);
    i && (i.cancel(), this._mapHandleToCancellationSource.delete(e));
  }
};
$y = W([
  M(0, Ye)
], $y);
function lM(t, e) {
  return t.message = e.message, typeof e.increment == "number" && (typeof t.increment == "number" ? t.increment += e.increment : t.increment = e.increment), t;
}
class Hy extends Jd {
  constructor(e, i) {
    super((n) => this.throttledReport(n)), this._proxy = e, this._handle = i;
  }
  throttledReport(e) {
    this._proxy.$progressReport(this._handle, e);
  }
}
Hy.__decorator = W([
  aM(100, (t, e) => lM(t, e), () => /* @__PURE__ */ Object.create(null))
], Hy.prototype, "throttledReport", null);
const bE = pe("IExtHostAuthentication");
let By = class {
  constructor(e, i, n, r, s, o, a) {
    this._initData = i, this._extHostWindow = n, this._extHostUrls = r, this._extHostProgress = s, this._extHostLoggerService = o, this._logService = a, this._dynamicAuthProviderCtor = Wy, this._authenticationProviders = /* @__PURE__ */ new Map(), this._providerOperations = new YR(), this._onDidChangeSessions = new N(), this._getSessionTaskSingler = new cM(), this._onDidDynamicAuthProviderTokensChange = new N(), this._proxy = e.getProxy(ee.MainThreadAuthentication);
  }
  getExtensionScopedSessionsEvent(e) {
    const i = e.toLowerCase();
    return It.chain(this._onDidChangeSessions.event, (n) => n.filter((r) => !r.extensionIdFilter || r.extensionIdFilter.includes(i)).map((r) => ({ provider: r.provider })));
  }
  async getSession(e, i, n, r = {}) {
    const s = ht.toKey(e.identifier), o = [...n].sort().join(" "), l = Object.keys(r).sort().map((c) => `${c}:${!!r[c]}`).join(", ");
    return await this._getSessionTaskSingler.getOrCreate(`${s} ${i} ${o} ${l}`, async () => {
      await this._proxy.$ensureProvider(i);
      const c = e.displayName || e.name;
      return this._proxy.$getSession(i, n, s, c, r);
    });
  }
  async getAccounts(e) {
    return await this._proxy.$ensureProvider(e), await this._proxy.$getAccounts(e);
  }
  registerAuthenticationProvider(e, i, n, r) {
    return this._providerOperations.queue(e, async () => {
      if (this._authenticationProviders.get(e)) {
        this._logService.error(`An authentication provider with id '${e}' is already registered. The existing provider will not be replaced.`);
        return;
      }
      const s = n.onDidChangeSessions((o) => this._proxy.$sendDidChangeSessions(e, o));
      this._authenticationProviders.set(e, { label: i, provider: n, disposable: s, options: r ?? { supportsMultipleAccounts: !1 } }), await this._proxy.$registerAuthenticationProvider(e, i, r?.supportsMultipleAccounts ?? !1, r?.supportedAuthorizationServers);
    }), new Ve(() => {
      this._providerOperations.queue(e, async () => {
        const s = this._authenticationProviders.get(e);
        s && (s.disposable?.dispose(), this._authenticationProviders.delete(e), await this._proxy.$unregisterAuthenticationProvider(e));
      });
    });
  }
  $createSession(e, i, n) {
    return this._providerOperations.queue(e, async () => {
      const r = this._authenticationProviders.get(e);
      if (r)
        return n.authorizationServer = x.revive(n.authorizationServer), await r.provider.createSession(i, n);
      throw new Error(`Unable to find authentication provider with handle: ${e}`);
    });
  }
  $removeSession(e, i) {
    return this._providerOperations.queue(e, async () => {
      const n = this._authenticationProviders.get(e);
      if (n)
        return await n.provider.removeSession(i);
      throw new Error(`Unable to find authentication provider with handle: ${e}`);
    });
  }
  $getSessions(e, i, n) {
    return this._providerOperations.queue(e, async () => {
      const r = this._authenticationProviders.get(e);
      if (r)
        return n.authorizationServer = x.revive(n.authorizationServer), await r.provider.getSessions(i, n);
      throw new Error(`Unable to find authentication provider with handle: ${e}`);
    });
  }
  $onDidChangeAuthenticationSessions(e, i, n) {
    return e.startsWith(YP) || this._onDidChangeSessions.fire({ provider: { id: e, label: i }, extensionIdFilter: n }), Promise.resolve();
  }
  $onDidUnregisterAuthenticationProvider(e) {
    return this._providerOperations.queue(e, async () => {
      const i = this._authenticationProviders.get(e);
      i && (i.disposable?.dispose(), this._authenticationProviders.delete(e));
    });
  }
  async $registerDynamicAuthProvider(e, i, n, r, s, o) {
    if (!r) {
      const l = x.revive(e);
      if (i.registration_endpoint)
        try {
          const c = await ZP(i, this._initData.environment.appName, n?.scopes_supported);
          r = c.client_id, s = c.client_secret;
        } catch (c) {
          this._logService.warn(`Dynamic registration failed for ${l.toString()}: ${c.message}. Prompting user for client ID and client secret...`);
        }
      if (!r) {
        this._logService.info(`Prompting user for client registration details for ${l.toString()}`);
        const c = await this._proxy.$promptForClientRegistration(l.toString());
        if (!c)
          throw new Error("User did not provide client details");
        r = c.clientId, s = c.clientSecret, this._logService.info(`User provided client registration for ${l.toString()}`), s ? this._logService.trace(`User provided client secret for ${l.toString()}`) : this._logService.trace(`User did not provide client secret for ${l.toString()}`);
      }
    }
    const a = new this._dynamicAuthProviderCtor(this._extHostWindow, this._extHostUrls, this._initData, this._extHostProgress, this._extHostLoggerService, this._proxy, x.revive(e), i, n, r, s, this._onDidDynamicAuthProviderTokensChange, o || []);
    return await this._providerOperations.queue(a.id, async () => {
      this._authenticationProviders.set(a.id, {
        label: a.label,
        provider: a,
        disposable: Ve.from(a, a.onDidChangeSessions((l) => this._proxy.$sendDidChangeSessions(a.id, l)), a.onDidChangeClientId(() => this._proxy.$sendDidChangeDynamicProviderInfo({
          providerId: a.id,
          clientId: a.clientId,
          clientSecret: a.clientSecret
        }))),
        options: { supportsMultipleAccounts: !1 }
      }), await this._proxy.$registerDynamicAuthenticationProvider(a.id, a.label, a.authorizationServer, a.clientId, a.clientSecret);
    }), a.id;
  }
  async $onDidChangeDynamicAuthProviderTokens(e, i, n) {
    this._onDidDynamicAuthProviderTokensChange.fire({ authProviderId: e, clientId: i, tokens: n });
  }
};
By = W([
  M(0, Ye),
  M(1, pi),
  M(2, d1),
  M(3, h1),
  M(4, f1),
  M(5, Lo),
  M(6, nt)
], By);
class cM {
  constructor() {
    this._inFlightPromises = /* @__PURE__ */ new Map();
  }
  getOrCreate(e, i) {
    const n = this._inFlightPromises.get(e);
    if (n)
      return n;
    const r = i().finally(() => this._inFlightPromises.delete(e));
    return this._inFlightPromises.set(e, r), r;
  }
}
let Wy = class {
  constructor(e, i, n, r, s, o, a, l, c, u, d, f, g) {
    this._extHostWindow = e, this._extHostUrls = i, this._initData = n, this._extHostProgress = r, this._proxy = o, this.authorizationServer = a, this._serverMetadata = l, this._resourceMetadata = c, this._clientId = u, this._clientSecret = d, this._onDidChangeSessions = new N(), this.onDidChangeSessions = this._onDidChangeSessions.event, this._onDidChangeClientId = new N(), this.onDidChangeClientId = this._onDidChangeClientId.event;
    const _ = a.toString(!0);
    this.id = c?.resource ? _ + " " + c?.resource : _, this.label = c?.resource_name ?? this.authorizationServer.authority, this._logger = s.createLogger(this.id, { name: this.label }), this._disposable = new De(), this._disposable.add(this._onDidChangeSessions);
    const w = It.chain(f.event, (v) => v.filter((S) => S.authProviderId === this.id && S.clientId === u).map((S) => S.tokens));
    this._tokenStore = this._disposable.add(new uM({
      onDidChange: w,
      set: (v) => o.$setSessionsForDynamicAuthProvider(this.id, this.clientId, v)
    }, g, this._logger)), this._disposable.add(this._tokenStore.onDidChangeSessions((v) => this._onDidChangeSessions.fire(v))), this._createFlows = [], l.authorization_endpoint && this._createFlows.push({
      label: h(2617, "URL Handler"),
      handler: (v, S, E) => this._createWithUrlHandler(v, S, E)
    });
  }
  get clientId() {
    return this._clientId;
  }
  get clientSecret() {
    return this._clientSecret;
  }
  async getSessions(e, i) {
    if (this._logger.info(`Getting sessions for scopes: ${e?.join(" ") ?? "all"}`), !e)
      return this._tokenStore.sessions;
    const n = [...e].sort(), r = e.join(" ");
    let s = this._tokenStore.sessions.filter((o) => An([...o.scopes].sort(), n));
    if (this._logger.info(`Found ${s.length} sessions for scopes: ${r}`), s.length) {
      const o = [], a = [], l = new Map(this._tokenStore.tokens.map((c) => [c.access_token, c]));
      for (const c of s) {
        const u = l.get(c.accessToken);
        if (u && u.expires_in) {
          const d = Date.now(), f = u.expires_in * 1e3;
          if (d > u.created_at + f - 5 * 60 * 1e3) {
            if (this._logger.info(`Token for session ${c.id} is about to expire, refreshing...`), a.push(u), !u.refresh_token) {
              this._logger.warn(`No refresh token available for scopes ${c.scopes.join(" ")}. Throwing away token.`);
              continue;
            }
            try {
              const g = await this.exchangeRefreshTokenForToken(u.refresh_token);
              g.scope !== r && (this._logger.warn(`Token scopes '${g.scope}' do not match requested scopes '${r}'. Overwriting token with what was requested...`), g.scope = r), this._logger.info(`Successfully created a new token for scopes ${c.scopes.join(" ")}.`), o.push(g);
            } catch (g) {
              this._logger.error(`Failed to refresh token: ${g}`);
            }
          }
        }
      }
      return (o.length || a.length) && (this._tokenStore.update({ added: o, removed: a }), s = this._tokenStore.sessions.filter((c) => An([...c.scopes].sort(), n))), this._logger.info(`Found ${s.length} sessions for scopes: ${r}`), s;
    }
    return [];
  }
  async createSession(e, i) {
    this._logger.info(`Creating session for scopes: ${e.join(" ")}`);
    let n;
    for (let s = 0; s < this._createFlows.length; s++) {
      const { handler: o } = this._createFlows[s];
      try {
        if (n = await this._extHostProgress.withProgressFromSource({ label: this.label, id: this.id }, {
          location: xo.Notification,
          title: h(2618, "Authenticating to '{0}'", this.label),
          cancellable: !0
        }, (a, l) => o(e, a, l)), n)
          break;
      } catch (a) {
        const l = this._createFlows[s + 1]?.label;
        if (!l)
          break;
        const c = Yr(a) ? h(
          2619,
          "Having trouble authenticating to '{0}'? Would you like to try a different way? ({1})",
          this.label,
          l
        ) : h(
          2620,
          "You have not yet finished authenticating to '{0}'. Would you like to try a different way? ({1})",
          this.label,
          l
        );
        if (!await this._proxy.$showContinueNotification(c))
          throw new zn();
        this._logger.error(`Failed to create token via flow '${l}': ${a}`);
      }
    }
    if (!n)
      throw new Error("Failed to create authentication token");
    n.scope !== e.join(" ") && (this._logger.warn(`Token scopes '${n.scope}' do not match requested scopes '${e.join(" ")}'. Overwriting token with what was requested...`), n.scope = e.join(" ")), this._tokenStore.update({ added: [{ ...n, created_at: Date.now() }], removed: [] });
    const r = this._tokenStore.sessions.find((s) => s.accessToken === n.access_token);
    return this._logger.info(`Created session for scopes: ${n.scope}`), r;
  }
  async removeSession(e) {
    this._logger.info(`Removing session with id: ${e}`);
    const i = this._tokenStore.sessions.find((r) => r.id === e);
    if (!i) {
      this._logger.error(`Session with id ${e} not found`);
      return;
    }
    const n = this._tokenStore.tokens.find((r) => r.access_token === i.accessToken);
    if (!n) {
      this._logger.error(`Failed to retrieve token for removed session: ${i.id}`);
      return;
    }
    this._tokenStore.update({ added: [], removed: [n] }), this._logger.info(`Removed token for session: ${i.id} with scopes: ${i.scopes.join(" ")}`);
  }
  dispose() {
    this._disposable.dispose();
  }
  async _createWithUrlHandler(e, i, n) {
    if (!this._serverMetadata.authorization_endpoint)
      throw new Error("Authorization Endpoint required");
    if (!this._serverMetadata.token_endpoint)
      throw new Error("Token endpoint not available in server metadata");
    const r = this.generateRandomString(64), s = await this.generateCodeChallenge(r), o = this.generateRandomString(32), a = x.parse(
      `${this._initData.environment.appUriScheme}://dynamicauthprovider/${this.authorizationServer.authority}/authorize?nonce=${o}`
    );
    let l;
    try {
      l = await this._extHostUrls.createAppUri(a);
    } catch (v) {
      throw new Error(`Failed to create external URI: ${v}`);
    }
    const c = new URL(this._serverMetadata.authorization_endpoint);
    c.searchParams.append("client_id", this._clientId), c.searchParams.append("response_type", "code"), c.searchParams.append("state", l.toString()), c.searchParams.append("code_challenge", s), c.searchParams.append("code_challenge_method", "S256");
    const u = e.join(" ");
    u && c.searchParams.append("scope", u), this._resourceMetadata?.resource && c.searchParams.append("resource", this._resourceMetadata.resource);
    const d = "https://vscode.dev/redirect";
    c.searchParams.append("redirect_uri", d);
    const f = this.waitForAuthorizationCode(a);
    if (this._logger.info(`Opening authorization URL for scopes: ${u}`), this._logger.trace(`Authorization URL: ${c.toString()}`), !await this._extHostWindow.openUri(c.toString(), {}))
      throw new zn();
    i.report({
      message: h(2621, "Complete the authentication in the browser window that has opened.")
    });
    let _;
    try {
      _ = (await Ix(f, n)).code;
    } catch (v) {
      throw Yr(v) ? (this._logger.info("Authorization code request was cancelled by the user."), v) : (this._logger.error(`Failed to receive authorization code: ${v}`), new Error(`Failed to receive authorization code: ${v}`));
    }
    return this._logger.info(`Authorization code received for scopes: ${u}`), await this.exchangeCodeForToken(_, r, d);
  }
  generateRandomString(e) {
    const i = new Uint8Array(e);
    return crypto.getRandomValues(i), Array.from(i).map((n) => n.toString(16).padStart(2, "0")).join("").substring(0, e);
  }
  async generateCodeChallenge(e) {
    const n = new TextEncoder().encode(e), r = await crypto.subtle.digest("SHA-256", n);
    return U_(ue.wrap(new Uint8Array(r)), !1, !1).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  async waitForAuthorizationCode(e) {
    const i = await this._proxy.$waitForUriHandler(e), n = /[?&]code=([^&]+)/.exec(i.query || "");
    if (!n || n.length < 2)
      throw new Error("Authentication failed: No authorization code received");
    return { code: n[1] };
  }
  async exchangeCodeForToken(e, i, n) {
    if (!this._serverMetadata.token_endpoint)
      throw new Error("Token endpoint not available in server metadata");
    const r = new URLSearchParams();
    r.append("client_id", this._clientId), r.append("grant_type", "authorization_code"), r.append("code", e), r.append("redirect_uri", n), r.append("code_verifier", i), this._clientSecret && r.append("client_secret", this._clientSecret), this._logger.info("Exchanging authorization code for token..."), this._logger.trace(`Url: ${this._serverMetadata.token_endpoint}`), this._logger.trace(`Token request body: ${r.toString()}`);
    let s;
    try {
      s = await fetch(this._serverMetadata.token_endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Accept: "application/json"
        },
        body: r.toString()
      });
    } catch (a) {
      throw this._logger.error(`Failed to exchange authorization code for token: ${a}`), new Error(`Failed to exchange authorization code for token: ${a}`);
    }
    if (!s.ok) {
      const a = await s.text();
      throw new Error(
        `Token exchange failed: ${s.status} ${s.statusText} - ${a}`
      );
    }
    const o = await s.json();
    if (cI(o))
      return this._logger.info("Successfully exchanged authorization code for token."), o;
    throw uI(o) && o.error === Gm.InvalidClient ? (this._logger.warn(`Client ID (${this._clientId}) was invalid, generated a new one.`), await this._generateNewClientId(), new Error("Client ID was invalid, generated a new one. Please try again.")) : new Error(`Invalid authorization token response: ${JSON.stringify(o)}`);
  }
  async exchangeRefreshTokenForToken(e) {
    if (!this._serverMetadata.token_endpoint)
      throw new Error("Token endpoint not available in server metadata");
    const i = new URLSearchParams();
    i.append("client_id", this._clientId), i.append("grant_type", "refresh_token"), i.append("refresh_token", e), this._clientSecret && i.append("client_secret", this._clientSecret);
    const r = await (await fetch(this._serverMetadata.token_endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        Accept: "application/json"
      },
      body: i.toString()
    })).json();
    if (cI(r))
      return {
        ...r,
        created_at: Date.now()
      };
    throw uI(r) && r.error === Gm.InvalidClient ? (this._logger.warn(`Client ID (${this._clientId}) was invalid, generated a new one.`), await this._generateNewClientId(), new Error("Client ID was invalid, generated a new one. Please try again.")) : new Error(`Invalid authorization token response: ${JSON.stringify(r)}`);
  }
  async _generateNewClientId() {
    try {
      const e = await ZP(this._serverMetadata, this._initData.environment.appName, this._resourceMetadata?.scopes_supported);
      this._clientId = e.client_id, this._clientSecret = e.client_secret, this._onDidChangeClientId.fire();
    } catch (e) {
      this._logger.info(`Dynamic registration failed for ${this.authorizationServer.toString()}: ${e}. Prompting user for client ID and client secret.`);
      try {
        const i = await this._proxy.$promptForClientRegistration(this.authorizationServer.toString());
        if (!i)
          throw new Error("User did not provide client details");
        this._clientId = i.clientId, this._clientSecret = i.clientSecret, this._logger.info(`User provided client ID for ${this.authorizationServer.toString()}`), i.clientSecret ? this._logger.info(`User provided client secret for ${this.authorizationServer.toString()}`) : this._logger.info(`User did not provide client secret for ${this.authorizationServer.toString()} (optional)`), this._onDidChangeClientId.fire();
      } catch {
        throw this._logger.error(`Failed to fetch new client ID and user did not provide one: ${e}`), new Error(`Failed to fetch new client ID and user did not provide one: ${e}`);
      }
    }
  }
};
Wy = W([
  M(0, d1),
  M(1, h1),
  M(2, pi),
  M(3, f1),
  M(4, Lo)
], Wy);
class uM {
  constructor(e, i, n) {
    this._persistence = e, this._logger = n, this._onDidChangeSessions = new N(), this.onDidChangeSessions = this._onDidChangeSessions.event, this._disposable = new De(), this._tokensObservable = T6("tokens", i), this._sessionsObservable = IP({ equalsFn: (r, s) => An(r, s, (o, a) => o.accessToken === a.accessToken) }, (r) => this._tokensObservable.read(r).map((s) => this._getSessionFromToken(s))), this._disposable.add(this._registerChangeEventAutorun()), this._disposable.add(this._persistence.onDidChange((r) => this._tokensObservable.set(r, void 0)));
  }
  get tokens() {
    return this._tokensObservable.get();
  }
  get sessions() {
    return this._sessionsObservable.get();
  }
  dispose() {
    this._disposable.dispose();
  }
  update({ added: e, removed: i }) {
    this._logger.trace(`Updating tokens: added ${e.length}, removed ${i.length}`);
    const n = [...this._tokensObservable.get()];
    for (const r of i) {
      const s = n.findIndex((o) => o.access_token === r.access_token);
      s !== -1 && n.splice(s, 1);
    }
    for (const r of e) {
      const s = n.findIndex((o) => o.access_token === r.access_token);
      s === -1 ? n.push(r) : n[s] = r;
    }
    (e.length || i.length) && (this._tokensObservable.set(n, void 0), this._persistence.set(n)), this._logger.trace(`Tokens updated: ${n.length} tokens stored.`);
  }
  _registerChangeEventAutorun() {
    let e = [];
    return CP((i) => {
      this._logger.trace("Checking for session changes...");
      const n = this._sessionsObservable.read(i);
      if (e === n) {
        this._logger.trace("No session changes detected.");
        return;
      }
      if (!n || n.length === 0) {
        this._logger.trace("All sessions removed."), e.length > 0 && (this._onDidChangeSessions.fire({
          added: [],
          removed: e,
          changed: []
        }), e = []);
        return;
      }
      const r = [], s = [];
      for (const o of n)
        e.some((l) => l.accessToken === o.accessToken) || r.push(o);
      for (const o of e)
        n.some((l) => l.accessToken === o.accessToken) || s.push(o);
      (r.length > 0 || s.length > 0) && (this._logger.trace(`Sessions changed: added ${r.length}, removed ${s.length}`), this._onDidChangeSessions.fire({ added: r, removed: s, changed: [] })), e = n;
    });
  }
  _getSessionFromToken(e) {
    let i;
    if (e.id_token)
      try {
        i = fI(e.id_token);
      } catch {
      }
    if (!i)
      try {
        i = fI(e.access_token);
      } catch {
      }
    const n = e.scope ? e.scope.split(" ") : i?.scope ? i.scope.split(" ") : [];
    return {
      id: zx(e.access_token, 0).toString(),
      accessToken: e.access_token,
      account: {
        id: i?.sub || "unknown",
        label: i?.preferred_username || i?.name || i?.email || "MCP"
      },
      scopes: n,
      idToken: e.id_token
    };
  }
}
const dM = { label: h(5437, "Other Models"), order: Number.MAX_SAFE_INTEGER };
var Vy;
const yE = pe("IExtHostLanguageModels");
class pI {
  constructor(e, i) {
    this.option = e, this.stream = new Rv(), this.stream = i ?? new Rv();
  }
}
class hM {
  constructor() {
    this._responseStreams = /* @__PURE__ */ new Map(), this._defaultStream = new Rv(), this._isDone = !1;
    const e = this;
    this.apiObject = {
      get stream() {
        return e._defaultStream.asyncIterable;
      },
      get text() {
        return Xa.map(e._defaultStream.asyncIterable, (i) => {
          if (i instanceof Ut)
            return i.value;
        }).coalesce();
      }
    };
  }
  *_streams() {
    if (this._responseStreams.size > 0)
      for (const [, e] of this._responseStreams)
        yield e.stream;
    else
      yield this._defaultStream;
  }
  handleFragment(e) {
    if (this._isDone)
      return;
    const i = /* @__PURE__ */ new Map();
    for (const n of Oi.wrap(e)) {
      let r;
      n.part.type === "text" ? r = new Ut(n.part.value, n.part.audience) : n.part.type === "data" ? r = new Ut("") : r = new rl(n.part.toolCallId, n.part.name, n.part.parameters);
      const s = i.get(n.index);
      s ? s.push(r) : i.set(n.index, [r]);
    }
    for (const [n, r] of i) {
      let s = this._responseStreams.get(n);
      s || (this._responseStreams.size === 0 ? s = new pI(n, this._defaultStream) : s = new pI(n), this._responseStreams.set(n, s)), s.stream.emitMany(r);
    }
  }
  reject(e) {
    this._isDone = !0;
    for (const i of this._streams())
      i.reject(e);
  }
  resolve() {
    this._isDone = !0;
    for (const e of this._streams())
      e.resolve();
  }
}
var Ga;
let zy = (Ga = class {
  constructor(e, i, n) {
    this._logService = i, this._extHostAuthentication = n, this._onDidChangeModelAccess = new N(), this._onDidChangeProviders = new N(), this.onDidChangeProviders = this._onDidChangeProviders.event, this._languageModelProviders = /* @__PURE__ */ new Map(), this._localModels = /* @__PURE__ */ new Map(), this._modelAccessList = new Io(), this._pendingRequest = /* @__PURE__ */ new Map(), this._ignoredFileProviders = /* @__PURE__ */ new Map(), this._languageAccessInformationExtensions = /* @__PURE__ */ new Set(), this._proxy = e.getProxy(ee.MainThreadLanguageModels);
  }
  dispose() {
    this._onDidChangeModelAccess.dispose(), this._onDidChangeProviders.dispose();
  }
  registerLanguageModelProvider(e, i, n) {
    this._languageModelProviders.set(i, { extension: e.identifier, extensionName: e.displayName || e.name, provider: n }), this._proxy.$registerLanguageModelProvider(i);
    let r;
    return n.onDidChange && (r = n.onDidChange(() => {
      this._proxy.$onLMProviderChange(i);
    })), Ee(() => {
      this._languageModelProviders.delete(i), this._clearModelCache(i), r?.dispose(), this._proxy.$unregisterProvider(i);
    });
  }
  _clearModelCache(e) {
    this._localModels.forEach((i, n) => {
      i.metadata.vendor === e && this._localModels.delete(n);
    });
  }
  async $prepareLanguageModelProvider(e, i, n) {
    const r = this._languageModelProviders.get(e);
    if (!r)
      return [];
    this._clearModelCache(e);
    const s = await r.provider.prepareLanguageModelChat(i, n) ?? [], o = s.map((a) => {
      let l;
      return a.auth && (l = {
        providerLabel: r.extensionName,
        accountLabel: typeof a.auth == "object" ? a.auth.label : void 0
      }), {
        metadata: {
          extension: r.extension,
          id: a.id,
          vendor: e,
          name: a.name ?? "",
          family: a.family ?? "",
          cost: a.cost,
          description: a.description,
          version: a.version,
          maxInputTokens: a.maxInputTokens,
          maxOutputTokens: a.maxOutputTokens,
          auth: l,
          isDefault: a.isDefault,
          isUserSelectable: a.isUserSelectable,
          modelPickerCategory: a.category ?? dM,
          capabilities: a.capabilities ? {
            vision: a.capabilities.vision,
            toolCalling: !!a.capabilities.toolCalling,
            agentMode: !!a.capabilities.toolCalling
          } : void 0
        },
        identifier: `${e}/${a.id}`
      };
    });
    for (let a = 0; a < o.length; a++)
      this._localModels.set(o[a].identifier, {
        metadata: o[a].metadata,
        info: s[a]
      });
    return o;
  }
  async $startChatRequest(e, i, n, r, s, o) {
    const a = this._localModels.get(e);
    if (!a)
      throw new Error("Model not found");
    const l = this._languageModelProviders.get(a.metadata.vendor);
    if (!l)
      throw new Error(`Language model provider for '${a.metadata.id}' not found.`);
    const c = [], u = () => {
      c.length > 0 && (this._proxy.$reportResponsePart(i, c), c.length = 0);
    }, d = new cl(u, 30), f = (w) => {
      c.push(w) > 30 ? (u(), d.cancel()) : d.schedule();
    }, g = new Jd(async (w) => {
      if (o.isCancellationRequested) {
        this._logService.warn(`[CHAT](${l.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`);
        return;
      }
      let v;
      if (w.part instanceof rl ? v = { type: "tool_use", name: w.part.name, parameters: w.part.input, toolCallId: w.part.callId } : w.part instanceof Ut ? v = { type: "text", value: w.part.value, audience: w.part.audience } : w.part instanceof wn && (v = { type: "data", value: { mimeType: w.part.mimeType, data: ue.wrap(w.part.data) }, audience: w.part.audience }), !v) {
        this._logService.warn(`[CHAT](${l.extension.value}) UNKNOWN part ${JSON.stringify(w)}`);
        return;
      }
      f({ index: w.index, part: v });
    });
    let _;
    try {
      _ = l.provider.provideLanguageModelChatResponse(a.info, r.value.map(Cm.to), { ...s, modelOptions: s.modelOptions ?? {}, extensionId: ht.toKey(n) }, g, o);
    } catch (w) {
      throw w;
    }
    Promise.resolve(_).then(() => {
      u(), this._proxy.$reportResponseDone(i, void 0);
    }, (w) => {
      u(), this._proxy.$reportResponseDone(i, Oc(w));
    });
  }
  $provideTokenLength(e, i, n) {
    const r = this._localModels.get(e);
    if (!r)
      return Promise.resolve(0);
    const s = this._languageModelProviders.get(r.metadata.vendor);
    return s ? Promise.resolve(s.provider.provideTokenCount(r.info, i, n)) : Promise.resolve(0);
  }
  async getDefaultLanguageModel(e, i) {
    let n;
    i && await this.selectLanguageModels(e, {});
    for (const [r, s] of this._localModels)
      if (s.metadata.isDefault) {
        n = r;
        break;
      }
    return n ? this.getLanguageModelByIdentifier(e, n) : this.getDefaultLanguageModel(e, !0);
  }
  async getLanguageModelByIdentifier(e, i) {
    const n = this._localModels.get(i);
    if (!n)
      return;
    this._isUsingAuth(e.identifier, n.metadata) && await this._fakeAuthPopulate(n.metadata);
    let r;
    if (!r) {
      const s = this;
      r = {
        id: n.info.id,
        vendor: n.metadata.vendor,
        family: n.info.family,
        version: n.info.version,
        name: n.info.name,
        capabilities: {
          supportsImageToText: n.metadata.capabilities?.vision ?? !1,
          supportsToolCalling: !!n.metadata.capabilities?.toolCalling
        },
        maxInputTokens: n.metadata.maxInputTokens,
        countTokens(o, a) {
          if (!s._localModels.has(i))
            throw bi.NotFound(i);
          return s._computeTokenLength(i, o, a ?? xt.None);
        },
        sendRequest(o, a, l) {
          if (!s._localModels.has(i))
            throw bi.NotFound(i);
          return s._sendChatRequest(e, i, o, a ?? {}, l ?? xt.None);
        }
      };
    }
    return r;
  }
  async selectLanguageModels(e, i) {
    const n = await this._proxy.$selectChatModels({ ...i, extension: e.identifier }), r = [];
    for (const s of n) {
      const o = await this.getLanguageModelByIdentifier(e, s);
      o && r.push(o);
    }
    return r;
  }
  async _sendChatRequest(e, i, n, r, s) {
    const o = this._convertMessages(e, n), a = e.identifier, l = this._localModels.get(i)?.metadata;
    if (!l || !this._localModels.has(i))
      throw bi.NotFound(`Language model '${i}' is unknown.`);
    if (this._isUsingAuth(a, l) && (!await this._getAuthAccess(e, { identifier: l.extension, displayName: l.auth.providerLabel }, r.justification, !1) || !this._modelAccessList.get(a)?.has(l.extension)))
      throw bi.NoPermissions(`Language model '${i}' cannot be used by '${a.value}'.`);
    const c = Math.random() * 1e6 | 0, u = new hM();
    this._pendingRequest.set(c, { languageModelId: i, res: u });
    try {
      await this._proxy.$tryStartChatRequest(a, i, c, new zi(o), r, s);
    } catch (d) {
      throw this._pendingRequest.delete(c), bi.tryDeserialize(d) ?? d;
    }
    return u.apiObject;
  }
  _convertMessages(e, i) {
    const n = [];
    for (const r of i)
      r.role === _n.System && $(e, "languageModelSystem"), n.push(Cm.from(r));
    return n;
  }
  async $acceptResponsePart(e, i) {
    const n = this._pendingRequest.get(e);
    n && n.res.handleFragment(i);
  }
  async $acceptResponseDone(e, i) {
    const n = this._pendingRequest.get(e);
    n && (this._pendingRequest.delete(e), i ? n.res.reject(bi.tryDeserialize(i) ?? XC(i)) : n.res.resolve());
  }
  async _getAuthAccess(e, i, n, r) {
    const s = YP + i.identifier.value;
    if (await this._extHostAuthentication.getSession(e, s, [], { silent: !0 }))
      return this.$updateModelAccesslist([{ from: e.identifier, to: i.identifier, enabled: !0 }]), !0;
    if (r)
      return !1;
    try {
      const a = n ? h(2627, "Justification: {1}", i.displayName, n) : void 0;
      return await this._extHostAuthentication.getSession(e, s, [], { forceNewSession: { detail: a } }), this.$updateModelAccesslist([{ from: e.identifier, to: i.identifier, enabled: !0 }]), !0;
    } catch {
      return !1;
    }
  }
  _isUsingAuth(e, i) {
    return !!i.auth && !ht.equals(i.extension, e);
  }
  async _fakeAuthPopulate(e) {
    if (e.auth)
      for (const i of this._languageAccessInformationExtensions)
        try {
          await this._getAuthAccess(i, { identifier: e.extension, displayName: "" }, void 0, !0);
        } catch (n) {
          this._logService.error("Fake Auth request failed"), this._logService.error(n);
        }
  }
  async _computeTokenLength(e, i, n) {
    const r = this._localModels.get(e);
    if (!r)
      throw bi.NotFound(`Language model '${e}' is unknown.`);
    return this._languageModelProviders.get(r.metadata.vendor)?.provider.provideTokenCount(r.info, i, n) ?? 0;
  }
  $updateModelAccesslist(e) {
    const i = new Array();
    for (const { from: n, to: r, enabled: s } of e) {
      const o = this._modelAccessList.get(n) ?? new ul();
      if (o.has(r) !== s) {
        s ? o.add(r) : o.delete(r), this._modelAccessList.set(n, o);
        const l = { from: n, to: r };
        i.push(l), this._onDidChangeModelAccess.fire(l);
      }
    }
  }
  createLanguageModelAccessInformation(e) {
    this._languageAccessInformationExtensions.add(e);
    const i = It.signal(It.filter(this._onDidChangeModelAccess.event, (r) => ht.equals(r.from, e.identifier))), n = It.signal(this._onDidChangeProviders.event);
    return {
      get onDidChange() {
        return It.any(i, n);
      },
      canSendRequest(r) {
        return !0;
      }
    };
  }
  fileIsIgnored(e, i, n = xt.None) {
    return $(e, "chatParticipantAdditions"), this._proxy.$fileIsIgnored(i, n);
  }
  async $isFileIgnored(e, i, n) {
    const r = this._ignoredFileProviders.get(e);
    if (!r)
      throw new Error("Unknown LanguageModelIgnoredFileProvider");
    return await r.provideFileIgnored(x.revive(i), n) ?? !1;
  }
  registerIgnoredFileProvider(e, i) {
    $(e, "chatParticipantPrivate");
    const n = Vy._idPool++;
    return this._proxy.$registerFileIgnoreProvider(n), this._ignoredFileProviders.set(n, i), Ee(() => {
      this._proxy.$unregisterFileIgnoreProvider(n), this._ignoredFileProviders.delete(n);
    });
  }
}, Vy = Ga, Ga._idPool = 1, Ga);
zy = Vy = W([
  M(0, Ye),
  M(1, nt),
  M(2, bE)
], zy);
function fM(t) {
  return t.getFullYear() + "-" + String(t.getMonth() + 1).padStart(2, "0") + "-" + String(t.getDate()).padStart(2, "0") + "T" + String(t.getHours()).padStart(2, "0") + ":" + String(t.getMinutes()).padStart(2, "0") + ":" + String(t.getSeconds()).padStart(2, "0") + "." + (t.getMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
}
const i5 = {
  DateTimeFormat(t, e) {
    return new Vi(() => {
      try {
        return new Intl.DateTimeFormat(t, e);
      } catch {
        return new Intl.DateTimeFormat(void 0, e);
      }
    });
  },
  Collator(t, e) {
    return new Vi(() => {
      try {
        return new Intl.Collator(t, e);
      } catch {
        return new Intl.Collator(void 0, e);
      }
    });
  },
  Segmenter(t, e) {
    return new Vi(() => {
      try {
        return new Intl.Segmenter(t, e);
      } catch {
        return new Intl.Segmenter(void 0, e);
      }
    });
  },
  Locale(t, e) {
    return new Vi(() => {
      try {
        return new Intl.Locale(t, e);
      } catch {
        return new Intl.Locale(ho, e);
      }
    });
  },
  NumberFormat(t, e) {
    return new Vi(() => {
      try {
        return new Intl.NumberFormat(t, e);
      } catch {
        return new Intl.NumberFormat(void 0, e);
      }
    });
  }
};
class p1 {
  constructor(e) {
    const i = lS(e);
    this._defaultValue = i, this._asciiMap = p1._createAsciiMap(i), this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(e) {
    const i = new Uint8Array(256);
    return i.fill(e), i;
  }
  set(e, i) {
    const n = lS(i);
    e >= 0 && e < 256 ? this._asciiMap[e] = n : this._map.set(e, n);
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
  }
  clear() {
    this._asciiMap.fill(this._defaultValue), this._map.clear();
  }
}
var gI;
(function(t) {
  t[t.False = 0] = "False", t[t.True = 1] = "True";
})(gI || (gI = {}));
var Vr;
(function(t) {
  t[t.Regular = 0] = "Regular", t[t.Whitespace = 1] = "Whitespace", t[t.WordSeparator = 2] = "WordSeparator";
})(Vr || (Vr = {}));
class pM extends p1 {
  constructor(e, i) {
    super(Vr.Regular), this._segmenter = null, this._cachedLine = null, this._cachedSegments = [], this.intlSegmenterLocales = i, this.intlSegmenterLocales.length > 0 ? this._segmenter = i5.Segmenter(this.intlSegmenterLocales, { granularity: "word" }) : this._segmenter = null;
    for (let n = 0, r = e.length; n < r; n++)
      this.set(e.charCodeAt(n), Vr.WordSeparator);
    this.set(L.Space, Vr.Whitespace), this.set(L.Tab, Vr.Whitespace);
  }
  findPrevIntlWordBeforeOrAtOffset(e, i) {
    let n = null;
    for (const r of this._getIntlSegmenterWordsOnLine(e)) {
      if (r.index > i)
        break;
      n = r;
    }
    return n;
  }
  findNextIntlWordAtOrAfterOffset(e, i) {
    for (const n of this._getIntlSegmenterWordsOnLine(e))
      if (!(n.index < i))
        return n;
    return null;
  }
  _getIntlSegmenterWordsOnLine(e) {
    return this._segmenter ? this._cachedLine === e ? this._cachedSegments : (this._cachedLine = e, this._cachedSegments = this._filterWordSegments(this._segmenter.value.segment(e)), this._cachedSegments) : [];
  }
  _filterWordSegments(e) {
    const i = [];
    for (const n of e)
      this._isWordLike(n) && i.push(n);
    return i;
  }
  _isWordLike(e) {
    return !!e.isWordLike;
  }
}
const mI = new _x(10);
function gM(t, e) {
  const i = `${t}/${e.join(",")}`;
  let n = mI.get(i);
  return n || (n = new pM(t, e), mI.set(i, n)), n;
}
class _I {
  constructor(e, i, n, r) {
    this.searchString = e, this.isRegex = i, this.matchCase = n, this.wordSeparators = r;
  }
  parseSearchRequest() {
    if (this.searchString === "")
      return null;
    let e;
    this.isRegex ? e = n5(this.searchString) : e = this.searchString.indexOf(`
`) >= 0;
    let i = null;
    try {
      i = wR(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: !1,
        multiline: e,
        global: !0,
        unicode: !0
      });
    } catch {
      return null;
    }
    if (!i)
      return null;
    let n = !this.isRegex && !e;
    return n && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (n = this.matchCase), new j7(
      i,
      this.wordSeparators ? gM(this.wordSeparators, []) : null,
      n ? this.searchString : null
    );
  }
}
function n5(t) {
  if (!t || t.length === 0)
    return !1;
  for (let e = 0, i = t.length; e < i; e++) {
    const n = t.charCodeAt(e);
    if (n === L.LineFeed)
      return !0;
    if (n === L.Backslash) {
      if (e++, e >= i)
        break;
      const r = t.charCodeAt(e);
      if (r === L.n || r === L.r || r === L.W)
        return !0;
    }
  }
  return !1;
}
function vI(t, e, i) {
  if (!i)
    return new Kv(t, null);
  const n = [];
  for (let r = 0, s = e.length; r < s; r++)
    n[r] = e[r];
  return new Kv(t, n);
}
function mM(t, e, i, n, r) {
  if (n === 0)
    return !0;
  const s = e.charCodeAt(n - 1);
  if (t.get(s) !== Vr.Regular || s === L.CarriageReturn || s === L.LineFeed)
    return !0;
  if (r > 0) {
    const o = e.charCodeAt(n);
    if (t.get(o) !== Vr.Regular)
      return !0;
  }
  return !1;
}
function _M(t, e, i, n, r) {
  if (n + r === i)
    return !0;
  const s = e.charCodeAt(n + r);
  if (t.get(s) !== Vr.Regular || s === L.CarriageReturn || s === L.LineFeed)
    return !0;
  if (r > 0) {
    const o = e.charCodeAt(n + r - 1);
    if (t.get(o) !== Vr.Regular)
      return !0;
  }
  return !1;
}
function r5(t, e, i, n, r) {
  return mM(t, e, i, n, r) && _M(t, e, i, n, r);
}
class vM {
  constructor(e, i) {
    this._wordSeparators = e, this._searchRegex = i, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  reset(e) {
    this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  next(e) {
    const i = e.length;
    let n;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === i || (n = this._searchRegex.exec(e), !n))
        return null;
      const r = n.index, s = n[0].length;
      if (r === this._prevMatchStartIndex && s === this._prevMatchLength) {
        if (s === 0) {
          A4(e, i, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
          continue;
        }
        return null;
      }
      if (this._prevMatchStartIndex = r, this._prevMatchLength = s, !this._wordSeparators || r5(this._wordSeparators, e, i, r, s))
        return n;
    } while (n);
    return null;
  }
}
const s5 = pe("contextService"), wM = pe("editorGroupsService"), bM = pe("pathService");
function yM(t) {
  return typeof t == "object" && "uri" in t && "pattern" in t;
}
let wI = class {
  constructor(e, i, n, r, s, o) {
    this.configurationService = e, this.workspaceContextService = i, this.editorGroupsService = n, this.logService = r, this.pathService = s, this.uriIdentityService = o;
  }
  aiText(e, i, n = {}) {
    return {
      ...this.commonQuery(i?.map($1), n),
      type: Fa.aiText,
      contentPattern: e
    };
  }
  text(e, i, n = {}) {
    e = this.getContentPattern(e, n);
    const r = this.configurationService.getValue(), s = i && i.some((a) => !this.configurationService.getValue({ resource: a }).search.useRipgrep);
    return {
      ...this.commonQuery(i?.map($1), n),
      type: Fa.Text,
      contentPattern: e,
      previewOptions: n.previewOptions,
      maxFileSize: n.maxFileSize,
      usePCRE2: r.search.usePCRE2 || s || !1,
      surroundingContext: n.surroundingContext,
      userDisabledExcludesAndIgnoreFiles: n.disregardExcludeSettings && n.disregardIgnoreFiles
    };
  }
  getContentPattern(e, i) {
    const n = this.configurationService.getValue();
    e.isRegExp && (e.pattern = e.pattern.replace(/\r?\n/g, "\\n"));
    const r = {
      ...e,
      wordSeparators: n.editor.wordSeparators
    };
    return this.isCaseSensitive(e, i) && (r.isCaseSensitive = !0), this.isMultiline(e) && (r.isMultiline = !0), i.notebookSearchConfig?.includeMarkupInput && (r.notebookInfo || (r.notebookInfo = {}), r.notebookInfo.isInNotebookMarkdownInput = i.notebookSearchConfig.includeMarkupInput), i.notebookSearchConfig?.includeMarkupPreview && (r.notebookInfo || (r.notebookInfo = {}), r.notebookInfo.isInNotebookMarkdownPreview = i.notebookSearchConfig.includeMarkupPreview), i.notebookSearchConfig?.includeCodeInput && (r.notebookInfo || (r.notebookInfo = {}), r.notebookInfo.isInNotebookCellInput = i.notebookSearchConfig.includeCodeInput), i.notebookSearchConfig?.includeOutput && (r.notebookInfo || (r.notebookInfo = {}), r.notebookInfo.isInNotebookCellOutput = i.notebookSearchConfig.includeOutput), r;
  }
  file(e, i = {}) {
    return {
      ...this.commonQuery(e, i),
      type: Fa.File,
      filePattern: i.filePattern ? i.filePattern.trim() : i.filePattern,
      exists: i.exists,
      sortByScore: i.sortByScore,
      cacheKey: i.cacheKey,
      shouldGlobMatchFilePattern: i.shouldGlobSearch
    };
  }
  handleIncludeExclude(e, i) {
    if (!e)
      return {};
    if (Array.isArray(e)) {
      if (e = e.filter((n) => n.length > 0).map(bp), !e.length)
        return {};
    } else
      e = bp(e);
    return i ? this.parseSearchPaths(e) : { pattern: J1(...Array.isArray(e) ? e : [e]) };
  }
  commonQuery(e = [], i = {}) {
    let n = Array.isArray(i.excludePattern) ? i.excludePattern.map((u) => u.pattern).flat() : i.excludePattern;
    n = n?.length === 1 ? n[0] : n;
    const r = this.handleIncludeExclude(i.includePattern, i.expandPatterns), s = this.handleIncludeExclude(n, i.expandPatterns), o = e.length > 1, a = (r.searchPaths && r.searchPaths.length ? r.searchPaths.map(
      (u) => this.getFolderQueryForSearchPath(u, i, s)
    ) : e.map(
      (u) => this.getFolderQueryForRoot(u, i, s, o)
    )).filter((u) => !!u), l = {
      _reason: i._reason,
      folderQueries: a,
      usingSearchPaths: !!(r.searchPaths && r.searchPaths.length),
      extraFileResources: i.extraFileResources,
      excludePattern: s.pattern,
      includePattern: r.pattern,
      onlyOpenEditors: i.onlyOpenEditors,
      maxResults: i.maxResults,
      onlyFileScheme: i.onlyFileScheme
    };
    if (i.onlyOpenEditors) {
      const u = Kt(this.editorGroupsService.groups.flatMap((g) => g.editors.map((_) => _.resource)));
      this.logService.trace("QueryBuilder#commonQuery - openEditor URIs", JSON.stringify(u));
      const d = u.filter((g) => kk(l, g.fsPath)), f = this.commonQueryFromFileList(d);
      return this.logService.trace("QueryBuilder#commonQuery - openEditor Query", JSON.stringify(f)), { ...l, ...f };
    }
    const c = i.extraFileResources && i.extraFileResources.filter((u) => kk(l, u.fsPath));
    return l.extraFileResources = c && c.length ? c : void 0, l;
  }
  commonQueryFromFileList(e) {
    const i = [], n = new fi(), r = {};
    let s = !1;
    return e.forEach((o) => {
      if (o.scheme === de.walkThrough)
        return;
      if (zR(o)) {
        const l = this.workspaceContextService.getWorkspaceFolder(o)?.uri ?? this.uriIdentityService.extUri.dirname(o);
        let c = n.get(l);
        c || (s = !0, c = { folder: l, includePattern: {} }, i.push(c), n.set(l, c));
        const u = zd(l.fsPath, o.fsPath);
        Fc(c.includePattern)[u.replace(/\\/g, "/")] = !0;
      } else
        o.fsPath && (s = !0, r[o.fsPath] = !0);
    }), {
      folderQueries: i,
      includePattern: r,
      usingSearchPaths: !0,
      excludePattern: s ? void 0 : { "**/*": !0 }
    };
  }
  isCaseSensitive(e, i) {
    if (i.isSmartCase) {
      if (e.isRegExp) {
        if (hS(e.pattern, !0))
          return !0;
      } else if (hS(e.pattern))
        return !0;
    }
    return !!e.isCaseSensitive;
  }
  isMultiline(e) {
    return e.isMultiline || e.isRegExp && n5(e.pattern) || e.pattern.indexOf(`
`) >= 0 ? !0 : !!e.isMultiline;
  }
  parseSearchPaths(e) {
    const i = (d) => Mp(d) || /^\.\.?([\/\\]|$)/.test(d), r = (Array.isArray(e) ? e : EM(e)).map((d) => {
      const f = this.pathService.resolvedUserHome;
      return f ? X3(d, f.scheme === de.file ? f.fsPath : f.path) : d;
    }), s = Q5(r, (d) => i(d) ? "searchPaths" : "exprSegments"), o = (s.exprSegments || []).map((d) => Iv(d, "/")).map((d) => Iv(d, "\\")).map((d) => (d[0] === "." && (d = "*" + d), SM(d))), a = {}, l = this.expandSearchPathPatterns(s.searchPaths || []);
    l && l.length && (a.searchPaths = l);
    const c = o.flat(), u = J1(...c);
    return u && (a.pattern = u), a;
  }
  getExcludesForFolder(e, i) {
    return i.disregardExcludeSettings ? void 0 : X6(e, !i.disregardSearchExcludeSettings);
  }
  expandSearchPathPatterns(e) {
    if (!e || !e.length)
      return [];
    const i = e.flatMap((r) => {
      let { pathPortion: s, globPortion: o } = xM(r);
      return o && (o = Y1(o)), this.expandOneSearchPath(s).flatMap((l) => this.resolveOneSearchPathPattern(l, o));
    }), n = /* @__PURE__ */ new Map();
    return i.forEach((r) => {
      const s = r.searchPath.toString(), o = n.get(s);
      o ? r.pattern && (o.pattern = o.pattern || {}, o.pattern[r.pattern] = !0) : n.set(s, {
        searchPath: r.searchPath,
        pattern: r.pattern ? J1(r.pattern) : void 0
      });
    }), Array.from(n.values());
  }
  expandOneSearchPath(e) {
    if (Mp(e)) {
      const i = this.workspaceContextService.getWorkspace().folders;
      return i[0] && i[0].uri.scheme !== de.file ? [{
        searchPath: i[0].uri.with({ path: e })
      }] : [{
        searchPath: x.file(Hc(e))
      }];
    }
    if (this.workspaceContextService.getWorkbenchState() === Vp.FOLDER) {
      const i = this.workspaceContextService.getWorkspace().folders[0].uri;
      if (e = bp(e), e.startsWith("../") || e === "..") {
        const r = dt.resolve(i.path, e);
        return [{
          searchPath: i.with({ path: r })
        }];
      }
      const n = Y1(e);
      return [{
        searchPath: i,
        pattern: n
      }];
    } else {
      if (e === "./" || e === ".\\")
        return [];
      {
        const i = e.replace(/^\.[\/\\]/, ""), r = this.workspaceContextService.getWorkspace().folders.map((s) => {
          const o = i.match(new RegExp(`^${Ja(s.name)}(?:/(.*)|$)`));
          return o ? {
            match: o,
            folder: s
          } : null;
        }).filter(Tn);
        if (r.length)
          return r.map((s) => {
            const o = s.match[1];
            return {
              searchPath: s.folder.uri,
              pattern: o && Y1(o)
            };
          });
        {
          const s = e.match(/\.[\/\\](.+)[\/\\]?/), o = s ? s[1] : e, a = h(13385, "Workspace folder does not exist: {0}", o);
          throw new Error(a);
        }
      }
    }
  }
  resolveOneSearchPathPattern(e, i) {
    const n = e.pattern && i ? `${e.pattern}/${i}` : e.pattern || i, r = [
      {
        searchPath: e.searchPath,
        pattern: n
      }
    ];
    return n && !n.endsWith("**") && r.push({
      searchPath: e.searchPath,
      pattern: n + "/**"
    }), r;
  }
  getFolderQueryForSearchPath(e, i, n) {
    const r = this.getFolderQueryForRoot($1(e.searchPath), i, n, !1);
    return r ? {
      ...r,
      includePattern: e.pattern
    } : null;
  }
  getFolderQueryForRoot(e, i, n, r) {
    let s;
    const o = x.isUri(e) ? e : e.uri;
    let a = i.excludePattern?.map((g) => {
      const _ = i.excludePattern && yM(g) ? g.uri : void 0;
      return !_ || !(x.isUri(e) && this.uriIdentityService.extUri.isEqual(e, _)) ? _ : void 0;
    });
    if (a?.length || (a = [void 0]), n.searchPaths) {
      const g = n.searchPaths.filter((_) => uc(_.searchPath, o))[0];
      if (g && !g.pattern)
        return null;
      g && (s = g.pattern);
    }
    const l = this.configurationService.getValue({ resource: o }), u = {
      ...this.getExcludesForFolder(l, i) || {},
      ...s || {}
    }, d = x.isUri(e) ? Fs(e) : e.name, f = a.map((g) => Object.keys(u).length > 0 ? {
      folder: g,
      pattern: u
    } : void 0).filter((g) => g);
    return {
      folder: o,
      folderName: r ? d : void 0,
      excludePattern: f,
      fileEncoding: l.files && l.files.encoding,
      disregardIgnoreFiles: typeof i.disregardIgnoreFiles == "boolean" ? i.disregardIgnoreFiles : !l.search?.useIgnoreFiles,
      disregardGlobalIgnoreFiles: typeof i.disregardGlobalIgnoreFiles == "boolean" ? i.disregardGlobalIgnoreFiles : !l.search?.useGlobalIgnoreFiles,
      disregardParentIgnoreFiles: typeof i.disregardParentIgnoreFiles == "boolean" ? i.disregardParentIgnoreFiles : !l.search?.useParentIgnoreFiles,
      ignoreSymlinks: typeof i.ignoreSymlinks == "boolean" ? i.ignoreSymlinks : !l.search?.followSymlinks
    };
  }
};
wI = W([
  M(0, c1),
  M(1, s5),
  M(2, wM),
  M(3, nt),
  M(4, bM),
  M(5, ST)
], wI);
function xM(t) {
  const e = t.match(/[\*\{\}\(\)\[\]\?]/);
  if (e) {
    const i = e.index, n = t.substr(0, i).match(/[/|\\][^/\\]*$/);
    if (n) {
      let r = t.substr(0, n.index);
      return r.match(/[/\\]/) || (r += "/"), {
        pathPortion: r,
        globPortion: t.substr((n.index || 0) + 1)
      };
    }
  }
  return {
    pathPortion: t
  };
}
function J1(...t) {
  return t.length ? t.reduce((e, i) => (e[i] = !0, e), /* @__PURE__ */ Object.create(null)) : void 0;
}
function EM(t) {
  return sw(t, ",").map((e) => e.trim()).filter((e) => !!e.length);
}
function SM(t) {
  return [
    `**/${t}/**`,
    `**/${t}`
  ].map((i) => i.replace(/\*\*\/\*\*/g, "**"));
}
function bp(t) {
  return t.replace(/\\/g, "/");
}
function Y1(t) {
  return bp(t).replace(/^\.\//, "").replace(/\/+$/g, "");
}
pe("searchService");
const DM = 7e3;
function kM(t, e) {
  const i = e.activationEvents;
  if (!i)
    return Promise.resolve(void 0);
  const n = [], r = [];
  for (const u of i)
    if (/^workspaceContains:/.test(u)) {
      const d = u.substr(18);
      d.indexOf("*") >= 0 || d.indexOf("?") >= 0 || t.forceUsingSearch ? r.push(d) : n.push(d);
    }
  if (n.length === 0 && r.length === 0)
    return Promise.resolve(void 0);
  const { promise: s, resolve: o } = QR(), a = (u) => o({ activationEvent: u }), l = Promise.all(n.map((u) => IM(t, u, a))).then(() => {
  }), c = CM(t, e.identifier, r, a);
  return Promise.all([l, c]).then(() => {
    o(void 0);
  }), s;
}
async function IM(t, e, i) {
  for (const n of t.folders)
    if (await t.exists(wi(x.revive(n), e))) {
      i(`workspaceContains:${e}`);
      return;
    }
}
async function CM(t, e, i, n) {
  if (i.length === 0)
    return Promise.resolve(void 0);
  const r = new Pt(), s = t.checkExists(t.folders, i, r.token), o = setTimeout(async () => {
    r.cancel(), t.logService.info(`Not activating extension '${e.value}': Timed out while searching for 'workspaceContains' pattern ${i.join(",")}`);
  }, DM);
  let a = !1;
  try {
    a = await s;
  } catch (l) {
    Yr(l) || Li(l);
  }
  r.dispose(), clearTimeout(o), a && n(`workspaceContains:${i.join(",")}`);
}
class o5 {
  constructor(e) {
    this._onDidChangePassword = new N(), this.onDidChangePassword = this._onDidChangePassword.event, this._proxy = e.getProxy(ee.MainThreadSecretState);
  }
  async $onDidChangePassword(e) {
    this._onDidChangePassword.fire(e);
  }
  get(e, i) {
    return this._proxy.$getPassword(e, i);
  }
  store(e, i, n) {
    return this._proxy.$setPassword(e, i, n);
  }
  delete(e, i) {
    return this._proxy.$deletePassword(e, i);
  }
  keys(e) {
    return this._proxy.$getKeys(e);
  }
}
const xE = pe("IExtHostSecretState");
class TM {
  #e;
  constructor(e, i) {
    this.disposables = new De(), this._extensionDescription = e, this._id = ht.toKey(e.identifier), this.#e = i, this.onDidChange = It.map(
      It.filter(this.#e.onDidChangePassword, (n) => n.extensionId === this._id),
      (n) => ({ key: n.key }),
      this.disposables
    );
  }
  dispose() {
    this.disposables.dispose();
  }
  get(e) {
    return this.#e.get(this._id, e);
  }
  store(e, i) {
    return this.#e.store(this._id, e, i);
  }
  delete(e) {
    return this.#e.delete(this._id, e);
  }
  keys() {
    return $(this._extensionDescription, "secretStorageKeys"), this.#e.keys(this._id) || [];
  }
}
let qy = class {
  constructor(e, i, n) {
    this.logService = n, this.bundleCache = /* @__PURE__ */ new Map(), this._proxy = i.getProxy(ee.MainThreadLocalization), this.currentLanguage = e.environment.appLanguage, this.isDefaultLanguage = this.currentLanguage === ho;
  }
  getMessage(e, i) {
    const { message: n, args: r, comment: s } = i;
    if (this.isDefaultLanguage)
      return cS(n, r ?? {});
    let o = n;
    s && s.length > 0 && (o += `/${Array.isArray(s) ? s.join("") : s}`);
    const a = this.bundleCache.get(e)?.contents[o];
    return a || this.logService.warn(`Using default string since no string found in i18n bundle that has the key: ${o}`), cS(a ?? n, r ?? {});
  }
  getBundle(e) {
    return this.bundleCache.get(e)?.contents;
  }
  getBundleUri(e) {
    return this.bundleCache.get(e)?.uri;
  }
  async initializeLocalizedMessages(e) {
    if (this.isDefaultLanguage || !e.l10n && !e.isBuiltin || this.bundleCache.has(e.identifier.value))
      return;
    let i;
    const n = await this.getBundleLocation(e);
    if (!n) {
      this.logService.error(`No bundle location found for extension ${e.identifier.value}`);
      return;
    }
    try {
      const r = await this._proxy.$fetchBundleContents(n), s = JSON.parse(r);
      i = e.isBuiltin ? s.contents?.bundle : s;
    } catch (r) {
      this.logService.error(`Failed to load translations for ${e.identifier.value} from ${n}: ${r.message}`);
      return;
    }
    i && this.bundleCache.set(e.identifier.value, {
      contents: i,
      uri: n
    });
  }
  async getBundleLocation(e) {
    if (e.isBuiltin) {
      const i = await this._proxy.$fetchBuiltInBundleUri(e.identifier.value, this.currentLanguage);
      return x.revive(i);
    }
    return e.l10n ? x.joinPath(e.extensionLocation, e.l10n, `bundle.l10n.${this.currentLanguage}.json`) : void 0;
  }
};
qy = W([
  M(0, pi),
  M(1, Ye),
  M(2, nt)
], qy);
const EE = pe("IExtHostLocalizationService"), SE = pe("IExtHostManagedSockets");
let jy = class {
  constructor(e) {
    this._remoteSocketIdCounter = 0, this._factory = null, this._managedRemoteSockets = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadManagedSockets);
  }
  setFactory(e, i) {
    for (const n of this._managedRemoteSockets.values())
      n.dispose();
    this._factory && this._proxy.$unregisterSocketFactory(this._factory.socketFactoryId), this._factory = new PM(e, i), this._proxy.$registerSocketFactory(this._factory.socketFactoryId);
  }
  async $openRemoteSocket(e) {
    if (!this._factory || this._factory.socketFactoryId !== e)
      throw new Error(`No socket factory with id ${e}`);
    const i = ++this._remoteSocketIdCounter, n = await this._factory.makeConnection(), r = new De();
    return this._managedRemoteSockets.set(i, new AM(i, n, r)), r.add(Ee(() => this._managedRemoteSockets.delete(i))), r.add(n.onDidEnd(() => {
      this._proxy.$onDidManagedSocketEnd(i), r.dispose();
    })), r.add(n.onDidClose((s) => {
      this._proxy.$onDidManagedSocketClose(i, s?.stack ?? s?.message), r.dispose();
    })), r.add(n.onDidReceiveMessage((s) => this._proxy.$onDidManagedSocketHaveData(i, ue.wrap(s)))), i;
  }
  $remoteSocketWrite(e, i) {
    this._managedRemoteSockets.get(e)?.actual.send(i.buffer);
  }
  $remoteSocketEnd(e) {
    const i = this._managedRemoteSockets.get(e);
    i && (i.actual.end(), i.dispose());
  }
  async $remoteSocketDrain(e) {
    await this._managedRemoteSockets.get(e)?.actual.drain?.();
  }
};
jy = W([
  M(0, Ye)
], jy);
class PM {
  constructor(e, i) {
    this.socketFactoryId = e, this.makeConnection = i;
  }
}
class AM extends ve {
  constructor(e, i, n) {
    super(), this.socketId = e, this.actual = i, this._register(n);
  }
}
var Gy;
const a5 = pe("IHostUtils");
let Qy = Gy = class extends ve {
  constructor(e, i, n, r, s, o, a, l, c, u, d, f, g) {
    super(), this._extHostManagedSockets = f, this._extHostLanguageModels = g, this._onDidChangeRemoteConnectionData = this._register(new N()), this.onDidChangeRemoteConnectionData = this._onDidChangeRemoteConnectionData.event, this._realPathCache = /* @__PURE__ */ new Map(), this._isTerminating = !1, this._hostUtils = i, this._extHostContext = n, this._initData = a, this._extHostWorkspace = r, this._extHostConfiguration = s, this._logService = o, this._extHostTunnelService = c, this._extHostTerminalService = u, this._extHostLocalizationService = d, this._mainThreadWorkspaceProxy = this._extHostContext.getProxy(ee.MainThreadWorkspace), this._mainThreadTelemetryProxy = this._extHostContext.getProxy(ee.MainThreadTelemetry), this._mainThreadExtensionsProxy = this._extHostContext.getProxy(ee.MainThreadExtensionService), this._almostReadyToRunExtensions = new Ur(), this._readyToStartExtensionHost = new Ur(), this._readyToRunExtensions = new Ur(), this._eagerExtensionsActivated = new Ur(), this._activationEventsReader = new LM(this._initData.extensions.activationEvents), this._globalRegistry = new Ua(this._activationEventsReader, this._initData.extensions.allExtensions);
    const _ = new ul(this._initData.extensions.myExtensions);
    this._myRegistry = new Ua(
      this._activationEventsReader,
      l5(this._globalRegistry, _)
    ), $o && (this._logService.info(`Creating extension host with the following global extensions: ${Nl(this._globalRegistry)}`), this._logService.info(`Creating extension host with the following local extensions: ${Nl(this._myRegistry)}`)), this._storage = new jP(this._extHostContext, this._logService), this._secretState = new o5(this._extHostContext), this._storagePath = l, this._instaService = this._store.add(e.createChild(new Px([mE, this._storage], [xE, this._secretState]))), this._activator = this._register(new yy(this._myRegistry, this._globalRegistry, {
      onExtensionActivationError: (w, v, S) => {
        this._mainThreadExtensionsProxy.$onExtensionActivationError(w, Oc(v), S);
      },
      actualActivateExtension: async (w, v) => {
        if (Ua.isHostExtension(w, this._myRegistry, this._globalRegistry))
          return await this._mainThreadExtensionsProxy.$activateExtension(w, v), new MN();
        const S = this._myRegistry.getExtensionDescription(w);
        return this._activateExtension(S, v);
      }
    }, this._logService)), this._extensionPathIndex = null, this._resolvers = /* @__PURE__ */ Object.create(null), this._started = !1, this._remoteConnectionData = this._initData.remote.connectionData;
  }
  getRemoteConnectionData() {
    return this._remoteConnectionData;
  }
  async initialize() {
    try {
      await this._beforeAlmostReadyToRunExtensions(), this._almostReadyToRunExtensions.open(), await this._extHostWorkspace.waitForInitializeCall(), tn("code/extHost/ready"), this._readyToStartExtensionHost.open(), this._initData.autoStart && this._startExtensionHost();
    } catch (e) {
      Li(e);
    }
  }
  async _deactivateAll() {
    this._storagePath.onWillDeactivateAll();
    let e = [];
    try {
      e = this._myRegistry.getAllExtensionDescriptions().map((s) => s.identifier).filter((s) => this.isActivated(s)).map((s) => this._deactivate(s));
    } catch {
    }
    await Promise.all(e);
  }
  terminate(e, i = 0) {
    if (this._isTerminating)
      return;
    this._isTerminating = !0, this._logService.info(`Extension host terminating: ${e}`), this._logService.flush(), this._extHostTerminalService.dispose(), this._activator.dispose(), Wd && fv((r) => {
      this._logService.error(r);
    }), this._extHostContext.dispose();
    const n = this._deactivateAll();
    Promise.race([qr(5e3), n]).finally(() => {
      this._hostUtils.pid ? this._logService.info(`Extension host with pid ${this._hostUtils.pid} exiting with code ${i}`) : this._logService.info(`Extension host exiting with code ${i}`), this._logService.flush(), this._logService.dispose(), this._hostUtils.exit(i);
    });
  }
  isActivated(e) {
    return this._readyToRunExtensions.isOpen() ? this._activator.isActivated(e) : !1;
  }
  async getExtension(e) {
    const i = await this._mainThreadExtensionsProxy.$getExtension(e);
    return i && {
      ...i,
      identifier: new ht(i.identifier.value),
      extensionLocation: x.revive(i.extensionLocation)
    };
  }
  _activateByEvent(e, i) {
    return this._activator.activateByEvent(e, i);
  }
  _activateById(e, i) {
    return this._activator.activateById(e, i);
  }
  activateByIdWithErrors(e, i) {
    return this._activateById(e, i).then(() => {
      const n = this._activator.getActivatedExtension(e);
      if (n.activationFailed)
        return Promise.reject(n.activationFailedError);
    });
  }
  getExtensionRegistry() {
    return this._readyToRunExtensions.wait().then((e) => this._myRegistry);
  }
  getExtensionExports(e) {
    if (this._readyToRunExtensions.isOpen())
      return this._activator.getActivatedExtension(e).exports;
    try {
      return this._activator.getActivatedExtension(e).exports;
    } catch {
      return null;
    }
  }
  async _realPathExtensionUri(e) {
    if (e.scheme === de.file && this._hostUtils.fsRealpath) {
      const i = e.fsPath;
      this._realPathCache.has(i) || this._realPathCache.set(i, this._hostUtils.fsRealpath(i));
      const n = await this._realPathCache.get(i);
      return x.file(n);
    }
    return e;
  }
  async getExtensionPathIndex() {
    return this._extensionPathIndex || (this._extensionPathIndex = this._createExtensionPathIndex(this._myRegistry.getAllExtensionDescriptions()).then((e) => new RM(e))), this._extensionPathIndex;
  }
  async _createExtensionPathIndex(e) {
    const i = $r.forUris((n) => BR.ignorePathCasing(n));
    return await Promise.all(e.map(async (n) => {
      if (this._getEntryPoint(n)) {
        const r = await this._realPathExtensionUri(n.extensionLocation);
        i.set(r, n);
      }
    })), i;
  }
  _deactivate(e) {
    let i = Promise.resolve(void 0);
    if (!this._readyToRunExtensions.isOpen() || !this._activator.isActivated(e))
      return i;
    const n = this._activator.getActivatedExtension(e);
    if (!n)
      return i;
    try {
      typeof n.module.deactivate == "function" && (i = Promise.resolve(n.module.deactivate()).then(void 0, (r) => (this._logService.error(r), Promise.resolve(void 0))));
    } catch (r) {
      this._logService.error(`An error occurred when deactivating the extension '${e.value}':`), this._logService.error(r);
    }
    try {
      n.disposable.dispose();
    } catch (r) {
      this._logService.error(`An error occurred when disposing the subscriptions for extension '${e.value}':`), this._logService.error(r);
    }
    return i;
  }
  async _activateExtension(e, i) {
    return this._initData.remote.isRemote ? this._mainThreadExtensionsProxy.$onWillActivateExtension(e.identifier) : await this._mainThreadExtensionsProxy.$onWillActivateExtension(e.identifier), this._doActivateExtension(e, i).then((n) => {
      const r = n.activationTimes;
      return this._mainThreadExtensionsProxy.$onDidActivateExtension(e.identifier, r.codeLoadingTime, r.activateCallTime, r.activateResolvedTime, i), this._logExtensionActivationTimes(e, i, "success", r), n;
    }, (n) => {
      throw this._logExtensionActivationTimes(e, i, "failure"), n;
    });
  }
  _logExtensionActivationTimes(e, i, n, r) {
    const s = yI(e, i);
    this._mainThreadTelemetryProxy.$publicLog2("extensionActivationTimes", {
      ...s,
      ...r || {},
      outcome: n
    });
  }
  _doActivateExtension(e, i) {
    const n = yI(e, i);
    this._mainThreadTelemetryProxy.$publicLog2("activatePlugin", n);
    const r = this._getEntryPoint(e);
    if (!r)
      return Promise.resolve(new NN(mu.NONE));
    this._logService.info(`ExtensionService#_doActivateExtension ${e.identifier.value}, startup: ${i.startup}, activationEvent: '${i.activationEvent}'${e.identifier.value !== i.extensionId.value ? `, root cause: ${i.extensionId.value}` : ""}`), this._logService.flush();
    const s = this._isESM(e), o = new De(), a = new Q1(i.startup);
    return Promise.all([
      s ? this._loadESMModule(e, wi(e.extensionLocation, r), a) : this._loadCommonJSModule(e, wi(e.extensionLocation, r), a),
      this._loadExtensionContext(e, o)
    ]).then((l) => (tn(`code/extHost/willActivateExtension/${e.identifier.value}`), Gy._callActivate(this._logService, e.identifier, l[0], l[1], o, a))).then((l) => (tn(`code/extHost/didActivateExtension/${e.identifier.value}`), l));
  }
  _loadExtensionContext(e, i) {
    const n = this._extHostLanguageModels.createLanguageModelAccessInformation(e), r = i.add(new ON(e, this._storage)), s = i.add(new GP(e.identifier.value, !1, this._storage)), o = i.add(new TM(e, this._secretState)), a = e.isUnderDevelopment ? this._initData.environment.extensionTestsLocationURI ? xc.Test : xc.Development : xc.Production, l = this._initData.remote.isRemote ? Aa.Workspace : Aa.UI;
    return this._logService.trace(`ExtensionService#loadExtensionContext ${e.identifier.value}`), Promise.all([
      r.whenReady,
      s.whenReady,
      this._storagePath.whenReady
    ]).then(() => {
      const c = this;
      let u, d;
      const f = lt(e, "ipc") ? this._initData.messagePorts?.get(ht.toKey(e.identifier)) : void 0;
      return Object.freeze({
        globalState: r,
        workspaceState: s,
        secrets: o,
        subscriptions: [],
        get languageModelAccessInformation() {
          return n;
        },
        get extensionUri() {
          return e.extensionLocation;
        },
        get extensionPath() {
          return e.extensionLocation.fsPath;
        },
        asAbsolutePath(g) {
          return Ev(e.extensionLocation.fsPath, g);
        },
        get storagePath() {
          return c._storagePath.workspaceValue(e)?.fsPath;
        },
        get globalStoragePath() {
          return c._storagePath.globalValue(e).fsPath;
        },
        get logPath() {
          return Ev(c._initData.logsLocation.fsPath, e.identifier.value);
        },
        get logUri() {
          return x.joinPath(c._initData.logsLocation, e.identifier.value);
        },
        get storageUri() {
          return c._storagePath.workspaceValue(e);
        },
        get globalStorageUri() {
          return c._storagePath.globalValue(e);
        },
        get extensionMode() {
          return a;
        },
        get extension() {
          return u === void 0 && (u = new Zu(
            c,
            e.identifier,
            e,
            l,
            !1
          )), u;
        },
        get extensionRuntime() {
          return $(e, "extensionRuntime"), c.extensionRuntime;
        },
        get environmentVariableCollection() {
          return c._extHostTerminalService.getEnvironmentVariableCollection(e);
        },
        get messagePassingProtocol() {
          if (!d) {
            if (!f)
              return;
            const g = It.buffer(It.fromDOMEventEmitter(f, "message", (_) => _.data));
            f.start(), d = {
              onDidReceiveMessage: g,
              postMessage: f.postMessage.bind(f)
            };
          }
          return d;
        }
      });
    });
  }
  static _callActivate(e, i, n, r, s, o) {
    return n = n || {
      activate: void 0,
      deactivate: void 0
    }, this._callActivateOptional(e, i, n, r, o).then((a) => new a1(
      !1,
      null,
      o.build(),
      n,
      a,
      Ee(() => {
        s.dispose(), Wn(r.subscriptions);
      })
    ));
  }
  static _callActivateOptional(e, i, n, r, s) {
    if (typeof n.activate == "function")
      try {
        s.activateCallStart(), e.trace(`ExtensionService#_callActivateOptional ${i.value}`);
        const o = n.activate.apply(globalThis, [r]);
        return s.activateCallStop(), s.activateResolveStart(), Promise.resolve(o).then((a) => (s.activateResolveStop(), a));
      } catch (o) {
        return Promise.reject(o);
      }
    else
      return Promise.resolve(n);
  }
  _activateOneStartupFinished(e, i) {
    this._activateById(e.identifier, {
      startup: !1,
      extensionId: e.identifier,
      activationEvent: i
    }).then(void 0, (n) => {
      this._logService.error(n);
    });
  }
  _activateAllStartupFinishedDeferred(e, i = 0) {
    const r = Date.now();
    _4(() => {
      for (let s = i; s < e.length; s += 1) {
        const o = e[s];
        for (const a of o.activationEvents ?? [])
          if (a === "onStartupFinished")
            if (Date.now() - r > 50) {
              this._activateAllStartupFinishedDeferred(e, s);
              break;
            } else
              this._activateOneStartupFinished(o, a);
      }
    });
  }
  _activateAllStartupFinished() {
    this._mainThreadExtensionsProxy.$setPerformanceMarks(FA()), this._extHostConfiguration.getConfigProvider().then((e) => {
      const i = e.getConfiguration("extensions.experimental").get("deferredStartupFinishedActivation"), n = this._myRegistry.getAllExtensionDescriptions();
      if (i)
        this._activateAllStartupFinishedDeferred(n);
      else
        for (const r of n)
          if (r.activationEvents)
            for (const s of r.activationEvents)
              s === "onStartupFinished" && this._activateOneStartupFinished(r, s);
    });
  }
  _handleEagerExtensions() {
    const e = this._activateByEvent("*", !0).then(void 0, (o) => {
      this._logService.error(o);
    });
    this._register(this._extHostWorkspace.onDidChangeWorkspace((o) => this._handleWorkspaceContainsEagerExtensions(o.added)));
    const i = this._extHostWorkspace.workspace ? this._extHostWorkspace.workspace.folders : [], n = this._handleWorkspaceContainsEagerExtensions(i), r = this._handleRemoteResolverEagerExtensions(), s = Promise.all([r, e, n]).then(() => {
    });
    return Promise.race([s, qr(1e4)]).then(() => {
      this._activateAllStartupFinished();
    }), s;
  }
  _handleWorkspaceContainsEagerExtensions(e) {
    return e.length === 0 ? Promise.resolve(void 0) : Promise.all(this._myRegistry.getAllExtensionDescriptions().map((i) => this._handleWorkspaceContainsEagerExtension(e, i))).then(() => {
    });
  }
  async _handleWorkspaceContainsEagerExtension(e, i) {
    if (this.isActivated(i.identifier))
      return;
    const n = !this._initData.remote.isRemote && !!this._initData.remote.authority, r = {
      logService: this._logService,
      folders: e.map((o) => o.uri),
      forceUsingSearch: n || !this._hostUtils.fsExists,
      exists: (o) => this._hostUtils.fsExists(o.fsPath),
      checkExists: (o, a, l) => this._mainThreadWorkspaceProxy.$checkExists(o, a, l)
    }, s = await kM(r, i);
    if (s)
      return this._activateById(i.identifier, { startup: !0, extensionId: i.identifier, activationEvent: s.activationEvent }).then(void 0, (o) => this._logService.error(o));
  }
  async _handleRemoteResolverEagerExtensions() {
    if (this._initData.remote.authority)
      return this._activateByEvent(`onResolveRemoteAuthority:${this._initData.remote.authority}`, !1);
  }
  async $extensionTestsExecute() {
    await this._eagerExtensionsActivated.wait();
    try {
      return await this._doHandleExtensionTests();
    } catch (e) {
      throw console.error(e), e;
    }
  }
  async _doHandleExtensionTests() {
    const { extensionDevelopmentLocationURI: e, extensionTestsLocationURI: i } = this._initData.environment;
    if (!e || !i)
      throw new Error(h(2623, "Cannot load test runner."));
    const n = (await this.getExtensionPathIndex()).findSubstr(i), s = await (this._isESM(n, i.path) ? this._loadESMModule(null, i, new Q1(!1)) : this._loadCommonJSModule(null, i, new Q1(!1)));
    if (!s || typeof s.run != "function")
      throw new Error(h(
        2624,
        "Path {0} does not point to a valid extension test runner.",
        i.toString()
      ));
    return new Promise((o, a) => {
      const l = (d, f) => {
        d ? ($o && this._logService.error("Test runner called back with error", d), a(d)) : ($o && (f ? this._logService.info(`Test runner called back with ${f} failures.`) : this._logService.info("Test runner called back with successful outcome.")), o(typeof f == "number" && f > 0 ? 1 : 0));
      }, c = Xn(i), u = s.run(c, l);
      u && u.then && u.then(() => {
        $o && this._logService.info("Test runner finished successfully."), o(0);
      }).catch((d) => {
        $o && this._logService.error("Test runner finished with error", d), a(d instanceof Error && d.stack ? d.stack : String(d));
      });
    });
  }
  _startExtensionHost() {
    if (this._started)
      throw new Error("Extension host is already started!");
    return this._started = !0, this._readyToStartExtensionHost.wait().then(() => this._readyToRunExtensions.open()).then(() => Promise.race([this._activator.waitForActivatingExtensions(), qr(1e3)])).then(() => this._handleEagerExtensions()).then(() => {
      this._eagerExtensionsActivated.open(), this._logService.info("Eager extensions activated");
    });
  }
  registerRemoteAuthorityResolver(e, i) {
    return this._resolvers[e] = i, Ee(() => {
      delete this._resolvers[e];
    });
  }
  async getRemoteExecServer(e) {
    const { resolver: i } = await this._activateAndGetResolver(e);
    return i?.resolveExecServer?.(e, { resolveAttempt: 0 });
  }
  async _activateAndGetResolver(e) {
    const i = e.indexOf("+");
    if (i === -1)
      throw new Lr(
        "Not an authority that can be resolved!",
        Cs.InvalidAuthority
      );
    const n = e.substr(0, i);
    return await this._almostReadyToRunExtensions.wait(), await this._activateByEvent(`onResolveRemoteAuthority:${n}`, !1), { authorityPrefix: n, resolver: this._resolvers[n] };
  }
  async $resolveAuthority(e, i) {
    const n = Ms.create(!1), r = () => `[resolveAuthority(${JD(e)},${i})][${n.elapsed()}ms] `, s = (E) => this._logService.info(`${r()}${E}`), o = (E) => this._logService.warn(`${r()}${E}`), a = (E, A = void 0) => this._logService.error(`${r()}${E}`, A), l = (E) => {
      if (E instanceof Lr)
        return {
          type: "error",
          error: {
            code: E._code,
            message: E._message,
            detail: E._detail
          }
        };
      throw E;
    }, c = async (E) => {
      s(`activating resolver for ${E}...`);
      const { resolver: A, authorityPrefix: j } = await this._activateAndGetResolver(E);
      if (!A)
        throw a(`no resolver for ${j}`), new Lr(
          `No remote extension installed to resolve ${j}.`,
          Cs.NoResolverFound
        );
      return { resolver: A, authorityPrefix: j, remoteAuthority: E };
    }, u = e.split(/@|%40/g).reverse();
    s(`activating remote resolvers ${u.join(" -> ")}`);
    let d;
    try {
      d = await Promise.all(u.map(c)).catch(async (E) => {
        if (!(E instanceof Lr) || E._code !== Cs.InvalidAuthority)
          throw E;
        return o(`resolving nested authorities failed: ${E.message}`), [await c(e)];
      });
    } catch (E) {
      return l(E);
    }
    const f = new s8();
    f.cancelAndSet(() => s("waiting..."), 1e3);
    let g, _;
    for (const [E, { authorityPrefix: A, resolver: j, remoteAuthority: V }] of d.entries())
      try {
        if (E === d.length - 1)
          s("invoking final resolve()..."), tn(`code/extHost/willResolveAuthority/${A}`), g = await j.resolve(V, { resolveAttempt: i, execServer: _ }), tn(`code/extHost/didResolveAuthorityOK/${A}`), s("setting tunnel factory..."), this._register(await this._extHostTunnelService.setTunnelFactory(j, fp.isManagedResolvedAuthority(g) ? g : void 0));
        else {
          if (s(`invoking resolveExecServer() for ${V}`), tn(`code/extHost/willResolveExecServer/${A}`), _ = await j.resolveExecServer?.(V, { resolveAttempt: i, execServer: _ }), !_)
            throw new Lr(
              `Exec server was not available for ${V}`,
              Cs.NoResolverFound
            );
          tn(`code/extHost/didResolveExecServerOK/${A}`);
        }
      } catch (le) {
        return tn(`code/extHost/didResolveAuthorityError/${A}`), a("returned an error", le), f.dispose(), l(le);
      }
    f.dispose();
    const w = {
      environmentTunnels: g.environmentTunnels,
      features: g.tunnelFeatures ? {
        elevation: g.tunnelFeatures.elevation,
        privacyOptions: g.tunnelFeatures.privacyOptions,
        protocol: g.tunnelFeatures.protocol === void 0 ? !0 : g.tunnelFeatures.protocol
      } : void 0
    }, v = {
      extensionHostEnv: g.extensionHostEnv,
      isTrusted: g.isTrusted,
      authenticationSession: g.authenticationSessionForInitializingExtensions ? { id: g.authenticationSessionForInitializingExtensions.id, providerId: g.authenticationSessionForInitializingExtensions.providerId } : void 0
    };
    s(`returned ${fp.isManagedResolvedAuthority(g) ? "managed authority" : `${g.host}:${g.port}`}`);
    let S;
    if (fp.isManagedResolvedAuthority(g)) {
      const E = i;
      this._extHostManagedSockets.setFactory(E, g.makeConnection), S = {
        authority: e,
        connectTo: new V9(E),
        connectionToken: g.connectionToken
      };
    } else
      S = {
        authority: e,
        connectTo: new z9(g.host, g.port),
        connectionToken: g.connectionToken
      };
    return {
      type: "ok",
      value: {
        authority: S,
        options: v,
        tunnelInformation: w
      }
    };
  }
  async $getCanonicalURI(e, i) {
    this._logService.info(`$getCanonicalURI invoked for authority (${JD(e)})`);
    const { resolver: n } = await this._activateAndGetResolver(e);
    if (!n)
      return null;
    const r = x.revive(i);
    if (typeof n.getCanonicalURI > "u")
      return r;
    const s = await Ai(() => n.getCanonicalURI(r));
    return s || r;
  }
  async $startExtensionHost(e) {
    e.toAdd.forEach((o) => o.extensionLocation = x.revive(o.extensionLocation));
    const { globalRegistry: i, myExtensions: n } = bI(this._activationEventsReader, this._globalRegistry, this._myRegistry, e), r = await this._createExtensionPathIndex(n);
    return (await this.getExtensionPathIndex()).setSearchTree(r), this._globalRegistry.set(i.getAllExtensionDescriptions()), this._myRegistry.set(n), $o && (this._logService.info(`$startExtensionHost: global extensions: ${Nl(this._globalRegistry)}`), this._logService.info(`$startExtensionHost: local extensions: ${Nl(this._myRegistry)}`)), this._startExtensionHost();
  }
  $activateByEvent(e, i) {
    return i === Zv.Immediate ? this._almostReadyToRunExtensions.wait().then((n) => this._activateByEvent(e, !1)) : this._readyToRunExtensions.wait().then((n) => this._activateByEvent(e, !1));
  }
  async $activate(e, i) {
    return await this._readyToRunExtensions.wait(), this._myRegistry.getExtensionDescription(e) ? (await this._activateById(e, i), !0) : !1;
  }
  async $deltaExtensions(e) {
    e.toAdd.forEach((o) => o.extensionLocation = x.revive(o.extensionLocation));
    const { globalRegistry: i, myExtensions: n } = bI(this._activationEventsReader, this._globalRegistry, this._myRegistry, e), r = await this._createExtensionPathIndex(n);
    return (await this.getExtensionPathIndex()).setSearchTree(r), this._globalRegistry.set(i.getAllExtensionDescriptions()), this._myRegistry.set(n), $o && (this._logService.info(`$deltaExtensions: global extensions: ${Nl(this._globalRegistry)}`), this._logService.info(`$deltaExtensions: local extensions: ${Nl(this._myRegistry)}`)), Promise.resolve(void 0);
  }
  async $test_latency(e) {
    return e;
  }
  async $test_up(e) {
    return e.byteLength;
  }
  async $test_down(e) {
    const i = ue.alloc(e), n = Math.random() % 256;
    for (let r = 0; r < e; r++)
      i.writeUInt8(n, r);
    return i;
  }
  async $updateRemoteConnectionData(e) {
    this._remoteConnectionData = e, this._onDidChangeRemoteConnectionData.fire();
  }
  _isESM(e, i) {
    return i ??= e ? this._getEntryPoint(e) : i, i?.endsWith(".mjs") || e?.type === "module" && !i?.endsWith(".cjs");
  }
};
Qy = Gy = W([
  M(0, uf),
  M(1, a5),
  M(2, Ye),
  M(3, Us),
  M(4, $s),
  M(5, nt),
  M(6, pi),
  M(7, _E),
  M(8, vE),
  M(9, Eu),
  M(10, EE),
  M(11, SE),
  M(12, yE)
], Qy);
function bI(t, e, i, n) {
  t.addActivationEvents(n.addActivationEvents);
  const r = new Ua(t, e.getAllExtensionDescriptions());
  r.deltaExtensions(n.toAdd, n.toRemove);
  const s = new ul(i.getAllExtensionDescriptions().map((a) => a.identifier));
  for (const a of n.myToRemove)
    s.delete(a);
  for (const a of n.myToAdd)
    s.add(a);
  const o = l5(r, s);
  return { globalRegistry: r, myExtensions: o };
}
function yI(t, e) {
  return {
    id: t.identifier.value,
    name: t.name,
    extensionVersion: t.version,
    publisherDisplayName: t.publisher,
    activationEvents: t.activationEvents ? t.activationEvents.join(",") : null,
    isBuiltin: t.isBuiltin,
    reason: e.activationEvent,
    reasonId: e.extensionId.value
  };
}
function Nl(t) {
  return t.getAllExtensionDescriptions().map((e) => e.identifier.value).join(",");
}
const Mo = pe("IExtHostExtensionService");
class Zu {
  #e;
  #t;
  #i;
  constructor(e, i, n, r, s) {
    this.#e = e, this.#t = i, this.#i = n.identifier, this.id = n.identifier.value, this.extensionUri = n.extensionLocation, this.extensionPath = Hc(Xn(n.extensionLocation)), this.packageJSON = n, this.extensionKind = r, this.isFromDifferentExtensionHost = s;
  }
  get isActive() {
    return this.#e.isActivated(this.#i);
  }
  get exports() {
    if (!(this.packageJSON.api === "none" || this.isFromDifferentExtensionHost))
      return this.#e.getExtensionExports(this.#i);
  }
  async activate() {
    if (this.isFromDifferentExtensionHost)
      throw new Error("Cannot activate foreign extension");
    return await this.#e.activateByIdWithErrors(this.#i, { startup: !1, extensionId: this.#t, activationEvent: "api" }), this.exports;
  }
}
function l5(t, e) {
  return t.getAllExtensionDescriptions().filter((i) => e.has(i.identifier));
}
class RM {
  constructor(e) {
    this._searchTree = e;
  }
  setSearchTree(e) {
    this._searchTree = e;
  }
  findSubstr(e) {
    return this._searchTree.findSubstr(e);
  }
  forEach(e) {
    return this._searchTree.forEach(e);
  }
}
class LM {
  constructor(e) {
    this._map = new Io(), this.addActivationEvents(e);
  }
  readActivationEvents(e) {
    return this._map.get(e.identifier) ?? [];
  }
  addActivationEvents(e) {
    for (const i of Object.keys(e))
      this._map.set(i, e[i]);
  }
}
const vf = pe("IExtHostApiDeprecationService");
let Ky = class {
  constructor(e, i) {
    this._extHostLogService = i, this._reportedUsages = /* @__PURE__ */ new Set(), this._telemetryShape = e.getProxy(ee.MainThreadTelemetry);
  }
  report(e, i, n) {
    const r = this.getUsageKey(e, i);
    this._reportedUsages.has(r) || (this._reportedUsages.add(r), i.isUnderDevelopment && this._extHostLogService.warn(`[Deprecation Warning] '${e}' is deprecated. ${n}`), this._telemetryShape.$publicLog2("extHostDeprecatedApiUsage", {
      extensionId: i.identifier.value,
      apiId: e
    }));
  }
  getUsageKey(e, i) {
    return `${e}-${i.identifier.value}`;
  }
};
Ky = W([
  M(0, Ye),
  M(1, nt)
], Ky);
var Re;
(function(t) {
  t[t.Off = 0] = "Off", t[t.Trace = 1] = "Trace", t[t.Debug = 2] = "Debug", t[t.Info = 3] = "Info", t[t.Warning = 4] = "Warning", t[t.Error = 5] = "Error";
})(Re || (Re = {}));
const NM = Re.Info;
function Jy(t, e) {
  return t !== Re.Off && t <= e;
}
function MM(t, e, i) {
  switch (e) {
    case Re.Trace:
      t.trace(i);
      break;
    case Re.Debug:
      t.debug(i);
      break;
    case Re.Info:
      t.info(i);
      break;
    case Re.Warning:
      t.warn(i);
      break;
    case Re.Error:
      t.error(i);
      break;
    case Re.Off:
      break;
    default:
      throw new Error(`Invalid log level ${e}`);
  }
}
function Ml(t, e = !1) {
  let i = "";
  for (let n = 0; n < t.length; n++) {
    let r = t[n];
    if (r instanceof Error && (r = xu(r, e)), typeof r == "object")
      try {
        r = JSON.stringify(r);
      } catch {
      }
    i += (n > 0 ? " " : "") + r;
  }
  return i;
}
class c5 extends ve {
  constructor() {
    super(...arguments), this.level = NM, this._onDidChangeLogLevel = this._register(new N()), this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
  }
  setLevel(e) {
    this.level !== e && (this.level = e, this._onDidChangeLogLevel.fire(this.level));
  }
  getLevel() {
    return this.level;
  }
  checkLogLevel(e) {
    return Jy(this.level, e);
  }
  canLog(e) {
    return this._store.isDisposed ? !1 : this.checkLogLevel(e);
  }
}
class u5 extends c5 {
  constructor(e) {
    super(), this.logAlways = e;
  }
  checkLogLevel(e) {
    return this.logAlways || super.checkLogLevel(e);
  }
  trace(e, ...i) {
    this.canLog(Re.Trace) && this.log(Re.Trace, Ml([e, ...i], !0));
  }
  debug(e, ...i) {
    this.canLog(Re.Debug) && this.log(Re.Debug, Ml([e, ...i]));
  }
  info(e, ...i) {
    this.canLog(Re.Info) && this.log(Re.Info, Ml([e, ...i]));
  }
  warn(e, ...i) {
    this.canLog(Re.Warning) && this.log(Re.Warning, Ml([e, ...i]));
  }
  error(e, ...i) {
    if (this.canLog(Re.Error))
      if (e instanceof Error) {
        const n = Array.prototype.slice.call(arguments);
        n[0] = e.stack, this.log(Re.Error, Ml(n));
      } else
        this.log(Re.Error, Ml([e, ...i]));
  }
  flush() {
  }
}
class OM extends c5 {
  constructor(e) {
    super(), this.loggers = e, e.length && this.setLevel(e[0].getLevel());
  }
  setLevel(e) {
    for (const i of this.loggers)
      i.setLevel(e);
    super.setLevel(e);
  }
  trace(e, ...i) {
    for (const n of this.loggers)
      n.trace(e, ...i);
  }
  debug(e, ...i) {
    for (const n of this.loggers)
      n.debug(e, ...i);
  }
  info(e, ...i) {
    for (const n of this.loggers)
      n.info(e, ...i);
  }
  warn(e, ...i) {
    for (const n of this.loggers)
      n.warn(e, ...i);
  }
  error(e, ...i) {
    for (const n of this.loggers)
      n.error(e, ...i);
  }
  flush() {
    for (const e of this.loggers)
      e.flush();
  }
  dispose() {
    for (const e of this.loggers)
      e.dispose();
    super.dispose();
  }
}
class FM extends ve {
  constructor(e, i, n) {
    if (super(), this.logLevel = e, this.logsHome = i, this._loggers = new fi(), this._onDidChangeLoggers = this._register(new N()), this.onDidChangeLoggers = this._onDidChangeLoggers.event, this._onDidChangeLogLevel = this._register(new N()), this.onDidChangeLogLevel = this._onDidChangeLogLevel.event, this._onDidChangeVisibility = this._register(new N()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, n)
      for (const r of n)
        this._loggers.set(r.resource, { logger: void 0, info: r });
  }
  getLoggerEntry(e) {
    return it(e) ? [...this._loggers.values()].find((i) => i.info.id === e) : this._loggers.get(e);
  }
  getLogger(e) {
    return this.getLoggerEntry(e)?.logger;
  }
  createLogger(e, i) {
    const n = this.toResource(e), r = it(e) ? e : i?.id ?? Yd(n.toString()).toString(16);
    let s = this._loggers.get(n)?.logger;
    const o = i?.logLevel === "always" ? Re.Trace : i?.logLevel;
    s || (s = this.doCreateLogger(n, o ?? this.getLogLevel(n) ?? this.logLevel, { ...i, id: r }));
    const a = {
      logger: s,
      info: {
        resource: n,
        id: r,
        logLevel: o,
        name: i?.name,
        hidden: i?.hidden,
        group: i?.group,
        extensionId: i?.extensionId,
        when: i?.when
      }
    };
    return this.registerLogger(a.info), this._loggers.set(n, a), s;
  }
  toResource(e) {
    return it(e) ? wi(this.logsHome, `${e}.log`) : e;
  }
  setLogLevel(e, i) {
    if (x.isUri(e)) {
      const n = e, r = i, s = this._loggers.get(n);
      s && r !== s.info.logLevel && (s.info.logLevel = r === this.logLevel ? void 0 : r, s.logger?.setLevel(r), this._loggers.set(s.info.resource, s), this._onDidChangeLogLevel.fire([n, r]));
    } else {
      this.logLevel = e;
      for (const [n, r] of this._loggers.entries())
        this._loggers.get(n)?.info.logLevel === void 0 && r.logger?.setLevel(this.logLevel);
      this._onDidChangeLogLevel.fire(this.logLevel);
    }
  }
  setVisibility(e, i) {
    const n = this.getLoggerEntry(e);
    n && i !== !n.info.hidden && (n.info.hidden = !i, this._loggers.set(n.info.resource, n), this._onDidChangeVisibility.fire([n.info.resource, i]));
  }
  getLogLevel(e) {
    let i;
    return e && (i = this._loggers.get(e)?.info.logLevel), i ?? this.logLevel;
  }
  registerLogger(e) {
    const i = this._loggers.get(e.resource);
    i ? i.info.hidden !== e.hidden && this.setVisibility(e.resource, !e.hidden) : (this._loggers.set(e.resource, { info: e, logger: void 0 }), this._onDidChangeLoggers.fire({ added: [e], removed: [] }));
  }
  deregisterLogger(e) {
    const i = this.toResource(e), n = this._loggers.get(i);
    n && (n.logger && n.logger.dispose(), this._loggers.delete(i), this._onDidChangeLoggers.fire({ added: [], removed: [n.info] }));
  }
  *getRegisteredLoggers() {
    for (const e of this._loggers.values())
      yield e.info;
  }
  getRegisteredLogger(e) {
    return this._loggers.get(e)?.info;
  }
  dispose() {
    this._loggers.forEach((e) => e.logger?.dispose()), this._loggers.clear(), super.dispose();
  }
}
function UM(t) {
  switch (t) {
    case Re.Trace:
      return "trace";
    case Re.Debug:
      return "debug";
    case Re.Info:
      return "info";
    case Re.Warning:
      return "warn";
    case Re.Error:
      return "error";
    case Re.Off:
      return "off";
  }
}
function $M(t) {
  switch (t) {
    case "trace":
      return Re.Trace;
    case "debug":
      return Re.Debug;
    case "info":
      return Re.Info;
    case "warn":
      return Re.Warning;
    case "error":
      return Re.Error;
    case "critical":
      return Re.Error;
    case "off":
      return Re.Off;
  }
}
new T("logLevel", UM(Re.Info));
let Qm = class extends FM {
  constructor(e, i) {
    super(i.logLevel, i.logsLocation, i.loggers.map((n) => Fi(n))), this._proxy = e.getProxy(ee.MainThreadLogger);
  }
  $setLogLevel(e, i) {
    i ? this.setLogLevel(x.revive(i), e) : this.setLogLevel(e);
  }
  setVisibility(e, i) {
    super.setVisibility(e, i), this._proxy.$setVisibility(e, i);
  }
  doCreateLogger(e, i, n) {
    return new HM(this._proxy, e, i, n);
  }
};
Qm = W([
  M(0, Ye),
  M(1, pi)
], Qm);
class HM extends u5 {
  constructor(e, i, n, r) {
    super(r?.logLevel === "always"), this.proxy = e, this.file = i, this.isLoggerCreated = !1, this.buffer = [], this.setLevel(n), this.proxy.$createLogger(i, r).then(() => {
      this.doLog(this.buffer), this.isLoggerCreated = !0;
    });
  }
  log(e, i) {
    const n = [[e, i]];
    this.isLoggerCreated ? this.doLog(n) : this.buffer.push(...n);
  }
  doLog(e) {
    this.proxy.$log(this.file, e);
  }
  flush() {
    this.proxy.$flush(this.file);
  }
}
class BM extends ve {
  constructor(e, i = []) {
    super(), this.logger = new OM([e, ...i]), this._register(e.onDidChangeLogLevel((n) => this.setLevel(n)));
  }
  get onDidChangeLogLevel() {
    return this.logger.onDidChangeLogLevel;
  }
  setLevel(e) {
    this.logger.setLevel(e);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(e, ...i) {
    this.logger.trace(e, ...i);
  }
  debug(e, ...i) {
    this.logger.debug(e, ...i);
  }
  info(e, ...i) {
    this.logger.info(e, ...i);
  }
  warn(e, ...i) {
    this.logger.warn(e, ...i);
  }
  error(e, ...i) {
    this.logger.error(e, ...i);
  }
  flush() {
    this.logger.flush();
  }
}
let Yy = class extends BM {
  constructor(e, i, n) {
    const r = n.remote.isRemote ? "remoteexthost" : e ? "workerexthost" : "exthost", s = n.remote.isRemote ? h(2628, "Extension Host (Remote)") : e ? h(2629, "Extension Host (Worker)") : h(2630, "Extension Host");
    super(i.createLogger(r, { name: s }));
  }
};
Yy = W([
  M(1, Lo),
  M(2, pi)
], Yy);
class xI {
  static async installEarlyHandler(e) {
    Error.stackTraceLimit = 100;
    const i = e.get(nt), r = e.get(Ye).getProxy(ee.MainThreadErrors);
    fv((s) => {
      i.error(s);
      const o = Oc(s);
      r.$onUnexpectedError(o);
    });
  }
  static async installFullHandler(e) {
    const i = e.get(nt), n = e.get(Ye), r = e.get(Mo), s = e.get(u1), o = e.get(vf), a = n.getProxy(ee.MainThreadExtensionService), l = n.getProxy(ee.MainThreadErrors), c = await r.getExtensionRegistry(), u = await r.getExtensionPathIndex(), d = /* @__PURE__ */ new WeakMap();
    function f(w, v) {
      if (d.has(w))
        return d.get(w).stack;
      let S = "", E, A;
      for (const V of v)
        S += `
	at ${V.toString()}`, A = V.getFileName(), !E && A && (E = u.findSubstr(x.file(A)));
      const j = `${w.name || "Error"}: ${w.message || ""}${S}`;
      return d.set(w, { extensionIdentifier: E?.identifier, stack: j }), j;
    }
    const g = Symbol("prepareStackTrace wrapped");
    let _ = f;
    Object.defineProperty(Error, "prepareStackTrace", {
      configurable: !1,
      get() {
        return _;
      },
      set(w) {
        if (w === f || !w || w[g]) {
          _ = w || f;
          return;
        }
        _ = function(v, S) {
          return f(v, S), w.call(Error, v, S);
        }, Object.assign(_, { [g]: !0 });
      }
    }), fv((w) => {
      Pp.is(w) || i.error(w);
      const v = Oc(w);
      let S;
      if (w instanceof W4 ? S = w.extension : S = d.get(w)?.extensionIdentifier, !!S)
        if (Pp.is(w)) {
          const E = c.getExtensionDescription(S);
          E && o.report(w.name, E, `${w.message}
 FROM: ${w.stack}`);
        } else {
          a.$onExtensionRuntimeError(S, v);
          const E = s.onExtensionError(S, w);
          i.trace("forwarded error to extension?", E, S);
        }
    }), sf.addListener((w) => {
      l.$onUnexpectedError(w);
    });
  }
}
class DE {
  constructor(e, i, n, r, s) {
    this._hostUtils = n, this._rpcProtocol = new Nv(e, null, r), i = DE._transform(i, this._rpcProtocol);
    const o = new Px(..._8());
    o.set(pi, { _serviceBrand: void 0, ...i, messagePorts: s }), o.set(Ye, new b8(this._rpcProtocol)), o.set(B_, new y8(r)), o.set(a5, n), o.set(nt, new lr(Yy, [!0], !0)), o.set(Lo, new lr(Qm, [], !0));
    const a = new Bp(o, !0);
    Wd && a.invokeFunction(xI.installEarlyHandler), this._logService = a.invokeFunction((l) => l.get(nt)), tn("code/extHost/didCreateServices"), this._hostUtils.pid ? this._logService.info(`Extension host with pid ${this._hostUtils.pid} started`) : this._logService.info("Extension host started"), this._logService.trace("initData", i), this._extensionService = a.invokeFunction((l) => l.get(Mo)), this._extensionService.initialize(), Wd && a.invokeFunction(xI.installFullHandler);
  }
  async asBrowserUri(e) {
    const i = this._rpcProtocol.getProxy(ee.MainThreadExtensionService);
    return x.revive(await i.$asBrowserUri(e));
  }
  async getAllStaticBrowserUris() {
    return (await this._rpcProtocol.getProxy(ee.MainThreadExtensionService).$getAllStaticBrowserUris()).map(([i, n]) => [x.revive(i), x.revive(n)]);
  }
  terminate(e) {
    this._extensionService.terminate(e);
  }
  getExtHostExtensionService() {
    return this._extensionService;
  }
  static _transform(e, i) {
    e.extensions.allExtensions.forEach((r) => {
      r.extensionLocation = x.revive(i.transformIncomingURIs(r.extensionLocation));
    }), e.environment.appRoot = x.revive(i.transformIncomingURIs(e.environment.appRoot));
    const n = e.environment.extensionDevelopmentLocationURI;
    return n && (e.environment.extensionDevelopmentLocationURI = n.map((r) => x.revive(i.transformIncomingURIs(r)))), e.environment.extensionTestsLocationURI = x.revive(i.transformIncomingURIs(e.environment.extensionTestsLocationURI)), e.environment.globalStorageHome = x.revive(i.transformIncomingURIs(e.environment.globalStorageHome)), e.environment.workspaceStorageHome = x.revive(i.transformIncomingURIs(e.environment.workspaceStorageHome)), e.nlsBaseUrl = x.revive(i.transformIncomingURIs(e.nlsBaseUrl)), e.logsLocation = x.revive(i.transformIncomingURIs(e.logsLocation)), e.workspace = i.transformIncomingURIs(e.workspace), e;
  }
}
const WM = (function(e) {
  const i = (n) => {
    globalThis.removeEventListener("message", i);
    const r = n.data;
    Object.defineProperties(globalThis, {
      postMessage: {
        value(s, o) {
          r.postMessage(s, o);
        }
      },
      onmessage: {
        get() {
          return r.onmessage;
        },
        set(s) {
          r.onmessage = s;
        }
      }
    }), r.addEventListener("message", (s) => {
      globalThis.dispatchEvent(new MessageEvent(
        "message",
        { data: s.data, ports: s.ports ? [...s.ports] : void 0 }
      ));
    }), r.start(), globalThis.Worker = class {
      constructor() {
        throw new TypeError("Nested workers from within nested worker are NOT supported.");
      }
    }, importScripts(e);
  };
  globalThis.addEventListener("message", i);
}).toString();
class VM extends EventTarget {
  constructor(e, i, n) {
    super(), this.onmessage = null, this.onmessageerror = null, this.onerror = null;
    const r = `((${WM})('${i}'))`, s = new Blob([r], { type: "application/javascript" }), o = URL.createObjectURL(s), a = new MessageChannel(), l = o, c = {
      type: "_newWorker",
      id: l,
      port: a.port2,
      url: o,
      options: n
    };
    e(c, [a.port2]), this.postMessage = a.port1.postMessage.bind(a.port1), this.terminate = () => {
      e({
        type: "_terminateWorker",
        id: l
      }), URL.revokeObjectURL(o), a.port1.close(), a.port2.close();
    }, Object.defineProperties(this, {
      onmessage: {
        get() {
          return a.port1.onmessage;
        },
        set(u) {
          a.port1.onmessage = u;
        }
      },
      onmessageerror: {
        get() {
          return a.port1.onmessageerror;
        },
        set(u) {
          a.port1.onmessageerror = u;
        }
      }
    }), a.port1.addEventListener("messageerror", (u) => {
      const d = new MessageEvent("messageerror", { data: u.data });
      this.dispatchEvent(d);
    }), a.port1.addEventListener("message", (u) => {
      const d = new MessageEvent("message", { data: u.data });
      this.dispatchEvent(d);
    }), a.port1.start();
  }
}
new T("inOutput", !1);
new T("activeLogOutput", !1);
new T("activeLogOutput.isLog", !1);
new T("activeLogOutput.levelSettable", !1);
new T("activeLogOutput.level", "");
new T("activeLogOutput.levelIsDefault", !1);
new T("outputView.scrollLock", !1);
new T("activeOutputChannel", "");
new T("output.filter.trace", !0);
new T("output.filter.debug", !0);
new T("output.filter.info", !0);
new T("output.filter.warning", !0);
new T("output.filter.error", !0);
new T("outputFilterFocus", !1);
new T("output.filter.categories", "");
var Sd;
(function(t) {
  t[t.Append = 1] = "Append", t[t.Replace = 2] = "Replace", t[t.Clear = 3] = "Clear";
})(Sd || (Sd = {}));
const zM = {
  OutputChannels: "workbench.contributions.outputChannels"
};
function qM(t) {
  return Array.isArray(t.source);
}
class jM extends ve {
  constructor() {
    super(...arguments), this.channels = /* @__PURE__ */ new Map(), this._onDidRegisterChannel = this._register(new N()), this.onDidRegisterChannel = this._onDidRegisterChannel.event, this._onDidRemoveChannel = this._register(new N()), this.onDidRemoveChannel = this._onDidRemoveChannel.event, this._onDidUpdateChannelFiles = this._register(new N()), this.onDidUpdateChannelSources = this._onDidUpdateChannelFiles.event;
  }
  registerChannel(e) {
    this.channels.has(e.id) || (this.channels.set(e.id, e), this._onDidRegisterChannel.fire(e.id));
  }
  getChannels() {
    const e = [];
    return this.channels.forEach((i) => e.push(i)), e;
  }
  getChannel(e) {
    return this.channels.get(e);
  }
  updateChannelSources(e, i) {
    const n = this.channels.get(e);
    n && qM(n) && (n.source = i, this._onDidUpdateChannelFiles.fire(n));
  }
  removeChannel(e) {
    const i = this.channels.get(e);
    i && (this.channels.delete(e), this._onDidRemoveChannel.fire(i));
  }
}
ai.add(zM.OutputChannels, new jM());
class d5 extends u5 {
  constructor(e, i, n, r, s) {
    super(), this.id = e, this.name = i, this.logger = n, this.proxy = r, this.extension = s, this.offset = 0, this.visible = !1, this.setLevel(n.getLevel()), this._register(n.onDidChangeLogLevel((o) => this.setLevel(o))), this._register(Ee(() => this.proxy.$dispose(this.id)));
  }
  get logLevel() {
    return this.getLevel();
  }
  appendLine(e) {
    this.append(e + `
`);
  }
  append(e) {
    this.info(e);
  }
  clear() {
    const e = this.offset;
    this.logger.flush(), this.proxy.$update(this.id, Sd.Clear, e);
  }
  replace(e) {
    const i = this.offset;
    this.info(e), this.proxy.$update(this.id, Sd.Replace, i), this.visible && this.logger.flush();
  }
  show(e, i) {
    this.logger.flush(), this.proxy.$reveal(this.id, !!(typeof e == "boolean" ? e : i));
  }
  hide() {
    this.proxy.$close(this.id);
  }
  log(e, i) {
    this.offset += ue.fromString(i).byteLength, MM(this.logger, e, i), this.visible && (this.logger.flush(), this.proxy.$update(this.id, Sd.Append));
  }
}
class GM extends d5 {
  appendLine(e) {
    this.append(e);
  }
}
let Xy = class {
  constructor(e, i, n, r, s, o) {
    this.initData = i, this.extHostFileSystem = n, this.extHostFileSystemInfo = r, this.loggerService = s, this.logService = o, this.extensionLogDirectoryPromise = /* @__PURE__ */ new Map(), this.namePool = 1, this.channels = /* @__PURE__ */ new Map(), this.visibleChannelId = null, this.proxy = e.getProxy(ee.MainThreadOutputService), this.outputsLocation = this.extHostFileSystemInfo.extUri.joinPath(i.logsLocation, `output_logging_${fM(/* @__PURE__ */ new Date()).replace(/-|:|\.\d+Z$/g, "")}`);
  }
  $setVisibleChannel(e) {
    this.visibleChannelId = e;
    for (const [i, n] of this.channels)
      n.visible = i === this.visibleChannelId;
  }
  createOutputChannel(e, i, n) {
    if (e = e.trim(), !e)
      throw new Error("illegal argument `name`. must not be falsy");
    const r = typeof i == "object" && i.log, s = it(i) ? i : void 0;
    if (it(s) && !s.trim())
      throw new Error("illegal argument `languageId`. must not be empty");
    let o;
    const a = this.initData.environment.extensionLogLevel?.find(([u]) => ht.equals(n.identifier, u))?.[1];
    a && (o = $M(a));
    const l = new De(), c = r ? this.doCreateLogOutputChannel(e, o, n, l) : this.doCreateOutputChannel(e, s, n, l);
    return c.then((u) => {
      this.channels.set(u.id, u), u.visible = u.id === this.visibleChannelId, l.add(Ee(() => this.channels.delete(u.id)));
    }), r ? this.createExtHostLogOutputChannel(e, o ?? this.logService.getLevel(), c, l) : this.createExtHostOutputChannel(e, c, l);
  }
  async doCreateOutputChannel(e, i, n, r) {
    this.outputDirectoryPromise || (this.outputDirectoryPromise = this.extHostFileSystem.value.createDirectory(this.outputsLocation).then(() => this.outputsLocation));
    const s = await this.outputDirectoryPromise, o = this.extHostFileSystemInfo.extUri.joinPath(s, `${this.namePool++}-${e.replace(/[\\/:\*\?"<>\|]/g, "")}.log`), a = r.add(this.loggerService.createLogger(o, { logLevel: "always", donotRotate: !0, donotUseFormatters: !0, hidden: !0 })), l = await this.proxy.$register(e, o, i, n.identifier.value);
    return r.add(Ee(() => this.loggerService.deregisterLogger(o))), new d5(l, e, a, this.proxy, n);
  }
  async doCreateLogOutputChannel(e, i, n, r) {
    const s = await this.createExtensionLogDirectory(n), o = e.replace(/[\\/:\*\?"<>\|]/g, ""), a = this.extHostFileSystemInfo.extUri.joinPath(s, `${o}.log`), l = `${n.identifier.value}.${o}`, c = r.add(this.loggerService.createLogger(a, { id: l, name: e, logLevel: i, extensionId: n.identifier.value }));
    return r.add(Ee(() => this.loggerService.deregisterLogger(a))), new GM(l, e, c, this.proxy, n);
  }
  createExtensionLogDirectory(e) {
    let i = this.extensionLogDirectoryPromise.get(e.identifier.value);
    if (!i) {
      const n = this.extHostFileSystemInfo.extUri.joinPath(this.initData.logsLocation, e.identifier.value);
      this.extensionLogDirectoryPromise.set(e.identifier.value, i = (async () => {
        try {
          await this.extHostFileSystem.value.createDirectory(n);
        } catch (r) {
          if (Wp(r) !== Me.FileExists)
            throw r;
        }
        return n;
      })());
    }
    return i;
  }
  createExtHostOutputChannel(e, i, n) {
    const r = () => {
      if (n.isDisposed)
        throw new Error("Channel has been closed");
    };
    return i.then((s) => n.add(s)), {
      get name() {
        return e;
      },
      append(s) {
        r(), i.then((o) => o.append(s));
      },
      appendLine(s) {
        r(), i.then((o) => o.appendLine(s));
      },
      clear() {
        r(), i.then((s) => s.clear());
      },
      replace(s) {
        r(), i.then((o) => o.replace(s));
      },
      show(s, o) {
        r(), i.then((a) => a.show(s, o));
      },
      hide() {
        r(), i.then((s) => s.hide());
      },
      dispose() {
        n.dispose();
      }
    };
  }
  createExtHostLogOutputChannel(e, i, n, r) {
    const s = () => {
      if (r.isDisposed)
        throw new Error("Channel has been closed");
    }, o = r.add(new N());
    function a(l) {
      i = l, o.fire(l);
    }
    return n.then((l) => {
      l.logLevel !== i && a(l.logLevel), r.add(l.onDidChangeLogLevel((c) => a(c)));
    }), {
      ...this.createExtHostOutputChannel(e, n, r),
      get logLevel() {
        return i;
      },
      onDidChangeLogLevel: o.event,
      trace(l, ...c) {
        s(), n.then((u) => u.trace(l, ...c));
      },
      debug(l, ...c) {
        s(), n.then((u) => u.debug(l, ...c));
      },
      info(l, ...c) {
        s(), n.then((u) => u.info(l, ...c));
      },
      warn(l, ...c) {
        s(), n.then((u) => u.warn(l, ...c));
      },
      error(l, ...c) {
        s(), n.then((u) => u.error(l, ...c));
      }
    };
  }
};
Xy = W([
  M(0, Ye),
  M(1, pi),
  M(2, l1),
  M(3, wu),
  M(4, Lo),
  M(5, nt)
], Xy);
const h5 = pe("IExtHostOutputService");
var ed, Eo;
let Zy = (Eo = class {
  constructor(e, i) {
    this._logService = i, this._provider = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadDecorations);
  }
  registerFileDecorationProvider(e, i) {
    const n = ed._handlePool++;
    this._provider.set(n, { provider: e, extensionDescription: i }), this._proxy.$registerDecorationProvider(n, i.identifier.value);
    const r = e.onDidChangeFileDecorations && e.onDidChangeFileDecorations((s) => {
      if (!s) {
        this._proxy.$onDidChange(n, null);
        return;
      }
      const o = qn(s);
      if (o.length <= ed._maxEventSize) {
        this._proxy.$onDidChange(n, o);
        return;
      }
      this._logService.warn("[Decorations] CAPPING events from decorations provider", i.identifier.value, o.length);
      const a = o.map((u) => ({ uri: u, rank: _R(u.path, "/") })), l = q5(a, (u, d) => u.rank - d.rank || Ya(u.uri.path, d.uri.path)), c = [];
      e: for (const u of l) {
        let d;
        for (const f of u) {
          const g = cc(f.uri.path);
          if (d !== g && (d = g, c.push(f.uri) >= ed._maxEventSize))
            break e;
        }
      }
      this._proxy.$onDidChange(n, c);
    });
    return new Ve(() => {
      r?.dispose(), this._proxy.$unregisterDecorationProvider(n), this._provider.delete(n);
    });
  }
  async $provideDecorations(e, i, n) {
    if (!this._provider.has(e))
      return /* @__PURE__ */ Object.create(null);
    const r = /* @__PURE__ */ Object.create(null), { provider: s, extensionDescription: o } = this._provider.get(e);
    return await Promise.all(i.map(async (a) => {
      try {
        const { uri: l, id: c } = a, u = await Promise.resolve(s.provideFileDecoration(x.revive(l), n));
        if (!u)
          return;
        try {
          qw.validate(u), u.badge && typeof u.badge != "string" && $(o, "codiconDecoration"), r[c] = [u.propagate, u.tooltip, u.badge, u.color];
        } catch (d) {
          this._logService.warn(`INVALID decoration from extension '${o.identifier.value}': ${d}`);
        }
      } catch (l) {
        this._logService.error(l);
      }
    })), r;
  }
}, ed = Eo, Eo._handlePool = 0, Eo._maxEventSize = 250, Eo);
Zy = ed = W([
  M(0, Ye),
  M(1, nt)
], Zy);
const f5 = pe("IExtHostDecorations");
class QM {
  constructor(e) {
    this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
  }
  getCount() {
    return this.values.length;
  }
  insertValues(e, i) {
    e = Dl(e);
    const n = this.values, r = this.prefixSum, s = i.length;
    return s === 0 ? !1 : (this.values = new Uint32Array(n.length + s), this.values.set(n.subarray(0, e), 0), this.values.set(n.subarray(e), e + s), this.values.set(i, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  setValue(e, i) {
    return e = Dl(e), i = Dl(i), this.values[e] === i ? !1 : (this.values[e] = i, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), !0);
  }
  removeValues(e, i) {
    e = Dl(e), i = Dl(i);
    const n = this.values, r = this.prefixSum;
    if (e >= n.length)
      return !1;
    const s = n.length - e;
    return i >= s && (i = s), i === 0 ? !1 : (this.values = new Uint32Array(n.length - i), this.values.set(n.subarray(0, e), 0), this.values.set(n.subarray(e + i), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  getTotalSum() {
    return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1);
  }
  getPrefixSum(e) {
    return e < 0 ? 0 : (e = Dl(e), this._getPrefixSum(e));
  }
  _getPrefixSum(e) {
    if (e <= this.prefixSumValidIndex[0])
      return this.prefixSum[e];
    let i = this.prefixSumValidIndex[0] + 1;
    i === 0 && (this.prefixSum[0] = this.values[0], i++), e >= this.values.length && (e = this.values.length - 1);
    for (let n = i; n <= e; n++)
      this.prefixSum[n] = this.prefixSum[n - 1] + this.values[n];
    return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
  }
  getIndexOf(e) {
    e = Math.floor(e), this.getTotalSum();
    let i = 0, n = this.values.length - 1, r = 0, s = 0, o = 0;
    for (; i <= n; )
      if (r = i + (n - i) / 2 | 0, s = this.prefixSum[r], o = s - this.values[r], e < o)
        n = r - 1;
      else if (e >= s)
        i = r + 1;
      else
        break;
    return new KM(r, e - o);
  }
}
class KM {
  constructor(e, i) {
    this.index = e, this.remainder = i, this._prefixSumIndexOfResultBrand = void 0, this.index = e, this.remainder = i;
  }
}
class JM {
  constructor(e, i, n, r) {
    this._uri = e, this._lines = i, this._eol = n, this._versionId = r, this._lineStarts = null, this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
  }
  onEvents(e) {
    e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
    const i = e.changes;
    for (const n of i)
      this._acceptDeleteRange(n.range), this._acceptInsertText(new Pn(n.range.startLineNumber, n.range.startColumn), n.text);
    this._versionId = e.versionId, this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const e = this._eol.length, i = this._lines.length, n = new Uint32Array(i);
      for (let r = 0; r < i; r++)
        n[r] = this._lines[r].length + e;
      this._lineStarts = new QM(n);
    }
  }
  _setLineText(e, i) {
    this._lines[e] = i, this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length);
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
      return;
    }
    this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, i) {
    if (i.length === 0)
      return;
    const n = C4(i);
    if (n.length === 1) {
      this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + n[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
      return;
    }
    n[n.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + n[0]);
    const r = new Uint32Array(n.length - 1);
    for (let s = 1; s < n.length; s++)
      this._lines.splice(e.lineNumber + s - 1, 0, n[s]), r[s - 1] = n[s].length + this._eol.length;
    this._lineStarts && this._lineStarts.insertValues(e.lineNumber, r);
  }
}
const e0 = /* @__PURE__ */ new Map();
function YM(t, e) {
  e ? e0.set(t, e) : e0.delete(t);
}
function XM(t) {
  return e0.get(t);
}
class ZM extends JM {
  constructor(e, i, n, r, s, o, a, l) {
    super(i, n, r, s), this._proxy = e, this._languageId = o, this._isDirty = a, this._encoding = l, this._isDisposed = !1;
  }
  dispose() {
    Wi(!this._isDisposed), this._isDisposed = !0, this._isDirty = !1;
  }
  equalLines(e) {
    return An(this._lines, e);
  }
  get document() {
    if (!this._document) {
      const e = this;
      this._document = {
        get uri() {
          return e._uri;
        },
        get fileName() {
          return e._uri.fsPath;
        },
        get isUntitled() {
          return e._uri.scheme === de.untitled;
        },
        get languageId() {
          return e._languageId;
        },
        get version() {
          return e._versionId;
        },
        get isClosed() {
          return e._isDisposed;
        },
        get isDirty() {
          return e._isDirty;
        },
        get encoding() {
          return e._encoding;
        },
        save() {
          return e._save();
        },
        getText(i) {
          return i ? e._getTextInRange(i) : e.getText();
        },
        get eol() {
          return e._eol === `
` ? fr.LF : fr.CRLF;
        },
        get lineCount() {
          return e._lines.length;
        },
        lineAt(i) {
          return e._lineAt(i);
        },
        offsetAt(i) {
          return e._offsetAt(i);
        },
        positionAt(i) {
          return e._positionAt(i);
        },
        validateRange(i) {
          return e._validateRange(i);
        },
        validatePosition(i) {
          return e._validatePosition(i);
        },
        getWordRangeAtPosition(i, n) {
          return e._getWordRangeAtPosition(i, n);
        },
        [Symbol.for("debug.description")]() {
          return `TextDocument(${e._uri.toString()})`;
        }
      };
    }
    return Object.freeze(this._document);
  }
  _acceptLanguageId(e) {
    Wi(!this._isDisposed), this._languageId = e;
  }
  _acceptIsDirty(e) {
    Wi(!this._isDisposed), this._isDirty = e;
  }
  _acceptEncoding(e) {
    Wi(!this._isDisposed), this._encoding = e;
  }
  _save() {
    return this._isDisposed ? Promise.reject(new Error("Document has been closed")) : this._proxy.$trySaveDocument(this._uri);
  }
  _getTextInRange(e) {
    const i = this._validateRange(e);
    if (i.isEmpty)
      return "";
    if (i.isSingleLine)
      return this._lines[i.start.line].substring(i.start.character, i.end.character);
    const n = this._eol, r = i.start.line, s = i.end.line, o = [];
    o.push(this._lines[r].substring(i.start.character));
    for (let a = r + 1; a < s; a++)
      o.push(this._lines[a]);
    return o.push(this._lines[s].substring(0, i.end.character)), o.join(n);
  }
  _lineAt(e) {
    let i;
    if (e instanceof je ? i = e.line : typeof e == "number" && (i = e), typeof i != "number" || i < 0 || i >= this._lines.length || Math.floor(i) !== i)
      throw new Error("Illegal value for `line`");
    return new eO(i, this._lines[i], i === this._lines.length - 1);
  }
  _offsetAt(e) {
    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.line - 1) + e.character;
  }
  _positionAt(e) {
    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
    const i = this._lineStarts.getIndexOf(e), n = this._lines[i.index].length;
    return new je(i.index, Math.min(i.remainder, n));
  }
  _validateRange(e) {
    if (!(e instanceof Oe))
      throw new Error("Invalid argument");
    const i = this._validatePosition(e.start), n = this._validatePosition(e.end);
    return i === e.start && n === e.end ? e : new Oe(i.line, i.character, n.line, n.character);
  }
  _validatePosition(e) {
    if (!(e instanceof je))
      throw new Error("Invalid argument");
    if (this._lines.length === 0)
      return e.with(0, 0);
    let { line: i, character: n } = e, r = !1;
    if (i < 0)
      i = 0, n = 0, r = !0;
    else if (i >= this._lines.length)
      i = this._lines.length - 1, n = this._lines[i].length, r = !0;
    else {
      const s = this._lines[i].length;
      n < 0 ? (n = 0, r = !0) : n > s && (n = s, r = !0);
    }
    return r ? new je(i, n) : e;
  }
  _getWordRangeAtPosition(e, i) {
    const n = this._validatePosition(e);
    if (!i)
      i = XM(this._languageId);
    else if (I4(i))
      throw new Error(
        `[getWordRangeAtPosition]: ignoring custom regexp '${i.source}' because it matches the empty string.`
      );
    const r = vT(n.character + 1, mT(i), this._lines[n.line], 0);
    if (r)
      return new Oe(
        n.line,
        r.startColumn - 1,
        n.line,
        r.endColumn - 1
      );
  }
}
class eO {
  constructor(e, i, n) {
    this._line = e, this._text = i, this._isLastLine = n;
  }
  get lineNumber() {
    return this._line;
  }
  get text() {
    return this._text;
  }
  get range() {
    return new Oe(this._line, 0, this._line, this._text.length);
  }
  get rangeIncludingLineBreak() {
    return this._isLastLine ? this.range : new Oe(this._line, 0, this._line + 1, 0);
  }
  get firstNonWhitespaceCharacterIndex() {
    return /^(\s*)/.exec(this._text)[1].length;
  }
  get isEmptyOrWhitespace() {
    return this.firstNonWhitespaceCharacterIndex === this._text.length;
  }
}
class kE {
  constructor(e) {
    this._prefix = e, this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
}
const y_ = class y_ {
  constructor(e, i, n) {
    const r = y_._Keys.nextId();
    e.$registerTextEditorDecorationType(i.identifier, r, Pb.from(n)), this.value = Object.freeze({
      key: r,
      dispose() {
        e.$removeTextEditorDecorationType(r);
      }
    });
  }
};
y_._Keys = new kE("TextEditorDecorationType");
let t0 = y_;
class tO {
  constructor(e, i) {
    this._collectedEdits = [], this._setEndOfLine = void 0, this._finalized = !1, this._document = e, this._documentVersionId = e.version, this._undoStopBefore = i.undoStopBefore, this._undoStopAfter = i.undoStopAfter;
  }
  finalize() {
    return this._finalized = !0, {
      documentVersionId: this._documentVersionId,
      edits: this._collectedEdits,
      setEndOfLine: this._setEndOfLine,
      undoStopBefore: this._undoStopBefore,
      undoStopAfter: this._undoStopAfter
    };
  }
  _throwIfFinalized() {
    if (this._finalized)
      throw new Error("Edit is only valid while callback runs");
  }
  replace(e, i) {
    this._throwIfFinalized();
    let n = null;
    if (e instanceof je)
      n = new Oe(e, e);
    else if (e instanceof Oe)
      n = e;
    else
      throw new Error("Unrecognized location");
    this._pushEdit(n, i, !1);
  }
  insert(e, i) {
    this._throwIfFinalized(), this._pushEdit(new Oe(e, e), i, !0);
  }
  delete(e) {
    this._throwIfFinalized();
    let i = null;
    if (e instanceof Oe)
      i = e;
    else
      throw new Error("Unrecognized location");
    this._pushEdit(i, null, !0);
  }
  _pushEdit(e, i, n) {
    const r = this._document.validateRange(e);
    this._collectedEdits.push({
      range: r,
      text: i,
      forceMoveMarkers: n
    });
  }
  setEndOfLine(e) {
    if (this._throwIfFinalized(), e !== fr.LF && e !== fr.CRLF)
      throw ze("endOfLine");
    this._setEndOfLine = e;
  }
}
class iO {
  constructor(e, i, n, r) {
    this._proxy = e, this._id = i, this._accept(n), this._logService = r;
    const s = this;
    this.value = {
      get tabSize() {
        return s._tabSize;
      },
      set tabSize(o) {
        s._setTabSize(o);
      },
      get indentSize() {
        return s._indentSize;
      },
      set indentSize(o) {
        s._setIndentSize(o);
      },
      get insertSpaces() {
        return s._insertSpaces;
      },
      set insertSpaces(o) {
        s._setInsertSpaces(o);
      },
      get cursorStyle() {
        return s._cursorStyle;
      },
      set cursorStyle(o) {
        s._setCursorStyle(o);
      },
      get lineNumbers() {
        return s._lineNumbers;
      },
      set lineNumbers(o) {
        s._setLineNumbers(o);
      }
    };
  }
  _accept(e) {
    this._tabSize = e.tabSize, this._indentSize = e.indentSize, this._originalIndentSize = e.originalIndentSize, this._insertSpaces = e.insertSpaces, this._cursorStyle = e.cursorStyle, this._lineNumbers = Sc.to(e.lineNumbers);
  }
  _validateTabSize(e) {
    if (e === "auto")
      return "auto";
    if (typeof e == "number") {
      const i = Math.floor(e);
      return i > 0 ? i : null;
    }
    if (typeof e == "string") {
      const i = parseInt(e, 10);
      return isNaN(i) ? null : i > 0 ? i : null;
    }
    return null;
  }
  _setTabSize(e) {
    const i = this._validateTabSize(e);
    if (i !== null) {
      if (typeof i == "number") {
        if (this._tabSize === i)
          return;
        this._tabSize = i;
      }
      this._warnOnError("setTabSize", this._proxy.$trySetOptions(this._id, {
        tabSize: i
      }));
    }
  }
  _validateIndentSize(e) {
    if (e === "tabSize")
      return "tabSize";
    if (typeof e == "number") {
      const i = Math.floor(e);
      return i > 0 ? i : null;
    }
    if (typeof e == "string") {
      const i = parseInt(e, 10);
      return isNaN(i) ? null : i > 0 ? i : null;
    }
    return null;
  }
  _setIndentSize(e) {
    const i = this._validateIndentSize(e);
    if (i !== null) {
      if (typeof i == "number") {
        if (this._originalIndentSize === i)
          return;
        this._indentSize = i, this._originalIndentSize = i;
      }
      this._warnOnError("setIndentSize", this._proxy.$trySetOptions(this._id, {
        indentSize: i
      }));
    }
  }
  _validateInsertSpaces(e) {
    return e === "auto" ? "auto" : e === "false" ? !1 : !!e;
  }
  _setInsertSpaces(e) {
    const i = this._validateInsertSpaces(e);
    if (typeof i == "boolean") {
      if (this._insertSpaces === i)
        return;
      this._insertSpaces = i;
    }
    this._warnOnError("setInsertSpaces", this._proxy.$trySetOptions(this._id, {
      insertSpaces: i
    }));
  }
  _setCursorStyle(e) {
    this._cursorStyle !== e && (this._cursorStyle = e, this._warnOnError("setCursorStyle", this._proxy.$trySetOptions(this._id, {
      cursorStyle: e
    })));
  }
  _setLineNumbers(e) {
    this._lineNumbers !== e && (this._lineNumbers = e, this._warnOnError("setLineNumbers", this._proxy.$trySetOptions(this._id, {
      lineNumbers: Sc.from(e)
    })));
  }
  assign(e) {
    const i = {};
    let n = !1;
    if (typeof e.tabSize < "u") {
      const r = this._validateTabSize(e.tabSize);
      r === "auto" ? (n = !0, i.tabSize = r) : typeof r == "number" && this._tabSize !== r && (this._tabSize = r, n = !0, i.tabSize = r);
    }
    if (typeof e.indentSize < "u") {
      const r = this._validateIndentSize(e.indentSize);
      r === "tabSize" ? (n = !0, i.indentSize = r) : typeof r == "number" && this._originalIndentSize !== r && (this._indentSize = r, this._originalIndentSize = r, n = !0, i.indentSize = r);
    }
    if (typeof e.insertSpaces < "u") {
      const r = this._validateInsertSpaces(e.insertSpaces);
      r === "auto" ? (n = !0, i.insertSpaces = r) : this._insertSpaces !== r && (this._insertSpaces = r, n = !0, i.insertSpaces = r);
    }
    typeof e.cursorStyle < "u" && this._cursorStyle !== e.cursorStyle && (this._cursorStyle = e.cursorStyle, n = !0, i.cursorStyle = e.cursorStyle), typeof e.lineNumbers < "u" && this._lineNumbers !== e.lineNumbers && (this._lineNumbers = e.lineNumbers, n = !0, i.lineNumbers = Sc.from(e.lineNumbers)), n && this._warnOnError("setOptions", this._proxy.$trySetOptions(this._id, i));
  }
  _warnOnError(e, i) {
    i.catch((n) => {
      this._logService.warn(`ExtHostTextEditorOptions '${e}' failed:'`), this._logService.warn(n);
    });
  }
}
class nO {
  constructor(e, i, n, r, s, o, a, l) {
    this.id = e, this._proxy = i, this._logService = n, this._disposed = !1, this._hasDecorationsForKey = /* @__PURE__ */ new Set(), this._selections = s, this._options = new iO(this._proxy, this.id, o, n), this._visibleRanges = a, this._viewColumn = l;
    const c = this;
    this.value = Object.freeze({
      get document() {
        return r.value;
      },
      set document(u) {
        throw new la("document");
      },
      get selection() {
        return c._selections && c._selections[0];
      },
      set selection(u) {
        if (!(u instanceof Qr))
          throw ze("selection");
        c._selections = [u], c._trySetSelection();
      },
      get selections() {
        return c._selections;
      },
      set selections(u) {
        if (!Array.isArray(u) || u.some((d) => !(d instanceof Qr)))
          throw ze("selections");
        u.length === 0 && (u = [new Qr(0, 0, 0, 0)]), c._selections = u, c._trySetSelection();
      },
      get visibleRanges() {
        return c._visibleRanges;
      },
      set visibleRanges(u) {
        throw new la("visibleRanges");
      },
      get diffInformation() {
        return c._diffInformation;
      },
      get options() {
        return c._options.value;
      },
      set options(u) {
        c._disposed || c._options.assign(u);
      },
      get viewColumn() {
        return c._viewColumn;
      },
      set viewColumn(u) {
        throw new la("viewColumn");
      },
      edit(u, d = { undoStopBefore: !0, undoStopAfter: !0 }) {
        if (c._disposed)
          return Promise.reject(new Error("TextEditor#edit not possible on closed editors"));
        const f = new tO(r.value, d);
        return u(f), c._applyEdit(f);
      },
      insertSnippet(u, d, f = { undoStopBefore: !0, undoStopAfter: !0 }) {
        if (c._disposed)
          return Promise.reject(new Error("TextEditor#insertSnippet not possible on closed editors"));
        let g;
        if (!d || Array.isArray(d) && d.length === 0)
          g = c._selections.map((_) => z.from(_));
        else if (d instanceof je) {
          const { lineNumber: _, column: w } = at.from(d);
          g = [{ startLineNumber: _, startColumn: w, endLineNumber: _, endColumn: w }];
        } else if (d instanceof Oe)
          g = [z.from(d)];
        else {
          g = [];
          for (const _ of d)
            if (_ instanceof Oe)
              g.push(z.from(_));
            else {
              const { lineNumber: w, column: v } = at.from(_);
              g.push({ startLineNumber: w, startColumn: v, endLineNumber: w, endColumn: v });
            }
        }
        return f.keepWhitespace === void 0 && (f.keepWhitespace = !1), i.$tryInsertSnippet(e, r.value.version, u.value, g, f);
      },
      setDecorations(u, d) {
        const f = d.length === 0;
        f && !c._hasDecorationsForKey.has(u.key) || (f ? c._hasDecorationsForKey.delete(u.key) : c._hasDecorationsForKey.add(u.key), c._runOnProxy(() => {
          if (NP(d))
            return i.$trySetDecorations(e, u.key, j6(d));
          {
            const g = new Array(4 * d.length);
            for (let _ = 0, w = d.length; _ < w; _++) {
              const v = d[_];
              g[4 * _] = v.start.line + 1, g[4 * _ + 1] = v.start.character + 1, g[4 * _ + 2] = v.end.line + 1, g[4 * _ + 3] = v.end.character + 1;
            }
            return i.$trySetDecorationsFast(e, u.key, g);
          }
        }));
      },
      revealRange(u, d) {
        c._runOnProxy(() => i.$tryRevealRange(e, z.from(u), d || Rg.Default));
      },
      show(u) {
        i.$tryShowEditor(e, si.from(u));
      },
      hide() {
        i.$tryHideEditor(e);
      },
      [Symbol.for("debug.description")]() {
        return `TextEditor(${this.document.uri.toString()})`;
      }
    });
  }
  dispose() {
    Wi(!this._disposed), this._disposed = !0;
  }
  _acceptOptions(e) {
    Wi(!this._disposed), this._options._accept(e);
  }
  _acceptVisibleRanges(e) {
    Wi(!this._disposed), this._visibleRanges = e;
  }
  _acceptViewColumn(e) {
    Wi(!this._disposed), this._viewColumn = e;
  }
  _acceptSelections(e) {
    Wi(!this._disposed), this._selections = e;
  }
  _acceptDiffInformation(e) {
    Wi(!this._disposed), this._diffInformation = e;
  }
  async _trySetSelection() {
    const e = this._selections.map(vr.from);
    return await this._runOnProxy(() => this._proxy.$trySetSelections(this.id, e)), this.value;
  }
  _applyEdit(e) {
    const i = e.finalize();
    if (i.edits.length === 0 && !i.setEndOfLine)
      return Promise.resolve(!0);
    const n = i.edits.map((s) => s.range);
    n.sort((s, o) => s.end.line === o.end.line ? s.end.character === o.end.character ? s.start.line === o.start.line ? s.start.character - o.start.character : s.start.line - o.start.line : s.end.character - o.end.character : s.end.line - o.end.line);
    for (let s = 0, o = n.length - 1; s < o; s++) {
      const a = n[s].end;
      if (n[s + 1].start.isBefore(a))
        return Promise.reject(new Error("Overlapping ranges are not allowed!"));
    }
    const r = i.edits.map((s) => ({
      range: z.from(s.range),
      text: s.text,
      forceMoveMarkers: s.forceMoveMarkers
    }));
    return this._proxy.$tryApplyEdits(this.id, i.documentVersionId, r, {
      setEndOfLine: typeof i.setEndOfLine == "number" ? au.from(i.setEndOfLine) : void 0,
      undoStopBefore: i.undoStopBefore,
      undoStopAfter: i.undoStopAfter
    });
  }
  _runOnProxy(e) {
    return this._disposed ? (this._logService.warn("TextEditor is closed/disposed"), Promise.resolve(void 0)) : e().then(() => this, (i) => (i instanceof Error && i.name === "DISPOSED" || this._logService.warn(i), null));
  }
}
class rO {
  constructor(e) {
    this.value = e, this._count = 0;
  }
  ref() {
    this._count++;
  }
  unref() {
    return --this._count === 0;
  }
}
let i0 = class {
  constructor(e, i) {
    this._extHostRpc = e, this._logService = i, this._activeEditorId = null, this._editors = /* @__PURE__ */ new Map(), this._documents = new fi(), this._onDidAddDocuments = new N(), this._onDidRemoveDocuments = new N(), this._onDidChangeVisibleTextEditors = new N(), this._onDidChangeActiveTextEditor = new N(), this.onDidAddDocuments = this._onDidAddDocuments.event, this.onDidRemoveDocuments = this._onDidRemoveDocuments.event, this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event, this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
  }
  $acceptDocumentsAndEditorsDelta(e) {
    this.acceptDocumentsAndEditorsDelta(e);
  }
  acceptDocumentsAndEditorsDelta(e) {
    const i = [], n = [], r = [];
    if (e.removedDocuments)
      for (const s of e.removedDocuments) {
        const o = x.revive(s), a = this._documents.get(o);
        a?.unref() && (this._documents.delete(o), i.push(a.value));
      }
    if (e.addedDocuments)
      for (const s of e.addedDocuments) {
        const o = x.revive(s.uri);
        let a = this._documents.get(o);
        if (a && o.scheme !== de.vscodeNotebookCell && o.scheme !== de.vscodeInteractiveInput)
          throw new Error(`document '${o} already exists!'`);
        a || (a = new rO(new ZM(this._extHostRpc.getProxy(ee.MainThreadDocuments), o, s.lines, s.EOL, s.versionId, s.languageId, s.isDirty, s.encoding)), this._documents.set(o, a), n.push(a.value)), a.ref();
      }
    if (e.removedEditors)
      for (const s of e.removedEditors) {
        const o = this._editors.get(s);
        this._editors.delete(s), o && r.push(o);
      }
    if (e.addedEditors)
      for (const s of e.addedEditors) {
        const o = x.revive(s.documentUri);
        Wi(this._documents.has(o), `document '${o}' does not exist`), Wi(!this._editors.has(s.id), `editor '${s.id}' already exists!`);
        const a = this._documents.get(o).value, l = new nO(s.id, this._extHostRpc.getProxy(ee.MainThreadTextEditors), this._logService, new Vi(() => a.document), s.selections.map(vr.to), s.options, s.visibleRanges.map((c) => z.to(c)), typeof s.editorPosition == "number" ? si.to(s.editorPosition) : void 0);
        this._editors.set(s.id, l);
      }
    e.newActiveEditor !== void 0 && (Wi(e.newActiveEditor === null || this._editors.has(e.newActiveEditor), `active editor '${e.newActiveEditor}' does not exist`), this._activeEditorId = e.newActiveEditor), Wn(i), Wn(r), e.removedDocuments && this._onDidRemoveDocuments.fire(i), e.addedDocuments && this._onDidAddDocuments.fire(n), (e.removedEditors || e.addedEditors) && this._onDidChangeVisibleTextEditors.fire(this.allEditors().map((s) => s.value)), e.newActiveEditor !== void 0 && this._onDidChangeActiveTextEditor.fire(this.activeEditor());
  }
  getDocument(e) {
    return this._documents.get(e)?.value;
  }
  allDocuments() {
    return Oi.map(this._documents.values(), (e) => e.value);
  }
  getEditor(e) {
    return this._editors.get(e);
  }
  activeEditor(e) {
    if (!this._activeEditorId)
      return;
    const i = this._editors.get(this._activeEditorId);
    return e ? i : i?.value;
  }
  allEditors() {
    return [...this._editors.values()];
  }
};
i0 = W([
  M(0, Ye),
  M(1, nt)
], i0);
const Su = pe("IExtHostDocumentsAndEditors"), sO = {
  type: "object",
  additionalProperties: !1,
  properties: {
    type: {
      type: "string",
      description: h(
        10738,
        "The actual task type. Please note that types starting with a '$' are reserved for internal usage."
      )
    },
    required: {
      type: "array",
      items: {
        type: "string"
      }
    },
    properties: {
      type: "object",
      description: h(10739, "Additional properties of the task type"),
      additionalProperties: {
        $ref: "http://json-schema.org/draft-07/schema#"
      }
    },
    when: {
      type: "string",
      markdownDescription: h(
        10740,
        "Condition which must be true to enable this type of task. Consider using `shellExecutionSupported`, `processExecutionSupported`, and `customExecutionSupported` as appropriate for this task definition. See the [API documentation](https://code.visualstudio.com/api/extension-guides/task-provider#when-clause) for more information."
      ),
      default: ""
    }
  }
};
var n0;
(function(t) {
  function e(i, n, r) {
    if (!i)
      return;
    const s = it(i.type) ? i.type : void 0;
    if (!s || s.length === 0) {
      r.error(h(
        10741,
        "The task type configuration is missing the required 'taskType' property"
      ));
      return;
    }
    const o = [];
    if (Array.isArray(i.required))
      for (const a of i.required)
        it(a) && o.push(a);
    return {
      extensionId: n.value,
      taskType: s,
      required: o,
      properties: i.properties ? yt(i.properties) : {},
      when: i.when ? Gt.deserialize(i.when) : void 0
    };
  }
  t.from = e;
})(n0 || (n0 = {}));
const oO = PT.registerExtensionPoint({
  extensionPoint: "taskDefinitions",
  activationEventsGenerator: (t, e) => {
    for (const i of t)
      i.type && e.push(`onTaskType:${i.type}`);
  },
  jsonSchema: {
    description: h(10742, "Contributes task kinds"),
    type: "array",
    items: sO
  }
});
class aO {
  constructor() {
    this._onDefinitionsChanged = new N(), this.onDefinitionsChanged = this._onDefinitionsChanged.event, this.taskTypes = /* @__PURE__ */ Object.create(null), this.readyPromise = new Promise((e, i) => {
      oO.setHandler((n, r) => {
        this._schema = void 0;
        try {
          for (const s of r.removed) {
            const o = s.value;
            for (const a of o)
              this.taskTypes && a.type && this.taskTypes[a.type] && delete this.taskTypes[a.type];
          }
          for (const s of r.added) {
            const o = s.value;
            for (const a of o) {
              const l = n0.from(a, s.description.identifier, s.collector);
              l && (this.taskTypes[l.taskType] = l);
            }
          }
          (r.removed.length > 0 || r.added.length > 0) && this._onDefinitionsChanged.fire();
        } catch {
        }
        e(void 0);
      });
    });
  }
  onReady() {
    return this.readyPromise;
  }
  get(e) {
    return this.taskTypes[e];
  }
  all() {
    return Object.keys(this.taskTypes).map((e) => this.taskTypes[e]);
  }
  getJsonSchema() {
    if (this._schema === void 0) {
      const e = [];
      for (const i of this.all()) {
        const n = {
          type: "object",
          additionalProperties: !1
        };
        i.required.length > 0 && (n.required = i.required.slice(0)), i.properties !== void 0 ? n.properties = yt(i.properties) : n.properties = /* @__PURE__ */ Object.create(null), n.properties.type = {
          type: "string",
          enum: [i.taskType]
        }, e.push(n);
      }
      this._schema = { oneOf: e };
    }
    return this._schema;
  }
}
const lO = new aO(), cO = {
  IconContribution: "base.contributions.icons"
};
var EI;
(function(t) {
  function e(i, n) {
    let r = i.defaults;
    for (; oi.isThemeIcon(r); ) {
      const s = Du.getIcon(r.id);
      if (!s)
        return;
      r = s.defaults;
    }
    return r;
  }
  t.getDefinition = e;
})(EI || (EI = {}));
var SI;
(function(t) {
  function e(n) {
    return {
      weight: n.weight,
      style: n.style,
      src: n.src.map((r) => ({ format: r.format, location: r.location.toString() }))
    };
  }
  t.toJSONObject = e;
  function i(n) {
    const r = (s) => it(s) ? s : void 0;
    if (n && Array.isArray(n.src) && n.src.every((s) => it(s.format) && it(s.location)))
      return {
        weight: r(n.weight),
        style: r(n.style),
        src: n.src.map((s) => ({ format: s.format, location: x.parse(s.location) }))
      };
  }
  t.fromJSONObject = i;
})(SI || (SI = {}));
const uO = /^([\w_-]+)$/, dO = h(
  2325,
  "The font ID must only contain letters, numbers, underscores and dashes."
);
class hO extends ve {
  constructor() {
    super(), this._onDidChange = this._register(new N()), this.onDidChange = this._onDidChange.event, this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: h(
              2326,
              "The id of the font to use. If not set, the font that is defined first is used."
            ), pattern: uO.source, patternErrorMessage: dO },
            fontCharacter: { type: "string", description: h(2327, "The font character associated with the icon definition.") }
          },
          additionalProperties: !1,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    }, this.iconReferenceSchema = { type: "string", pattern: `^${oi.iconNameExpression}$`, enum: [], enumDescriptions: [] }, this.iconsById = {}, this.iconFontsById = {};
  }
  registerIcon(e, i, n, r) {
    const s = this.iconsById[e];
    if (s) {
      if (n && !s.description) {
        s.description = n, this.iconSchema.properties[e].markdownDescription = `${n} $(${e})`;
        const l = this.iconReferenceSchema.enum.indexOf(e);
        l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = n), this._onDidChange.fire();
      }
      return s;
    }
    const o = { id: e, description: n, defaults: i, deprecationMessage: r };
    this.iconsById[e] = o;
    const a = { $ref: "#/definitions/icons" };
    return r && (a.deprecationMessage = r), n && (a.markdownDescription = `${n}: $(${e})`), this.iconSchema.properties[e] = a, this.iconReferenceSchema.enum.push(e), this.iconReferenceSchema.enumDescriptions.push(n || ""), this._onDidChange.fire(), { id: e };
  }
  deregisterIcon(e) {
    delete this.iconsById[e], delete this.iconSchema.properties[e];
    const i = this.iconReferenceSchema.enum.indexOf(e);
    i !== -1 && (this.iconReferenceSchema.enum.splice(i, 1), this.iconReferenceSchema.enumDescriptions.splice(i, 1)), this._onDidChange.fire();
  }
  getIcons() {
    return Object.keys(this.iconsById).map((e) => this.iconsById[e]);
  }
  getIcon(e) {
    return this.iconsById[e];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  getIconReferenceSchema() {
    return this.iconReferenceSchema;
  }
  registerIconFont(e, i) {
    const n = this.iconFontsById[e];
    return n || (this.iconFontsById[e] = i, this._onDidChange.fire(), i);
  }
  deregisterIconFont(e) {
    delete this.iconFontsById[e];
  }
  getIconFont(e) {
    return this.iconFontsById[e];
  }
  toString() {
    const e = (s, o) => s.id.localeCompare(o.id), i = (s) => {
      for (; oi.isThemeIcon(s.defaults); )
        s = this.iconsById[s.defaults.id];
      return `codicon codicon-${s ? s.id : ""}`;
    }, n = [];
    n.push("| preview     | identifier                        | default codicon ID                | description"), n.push("| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |");
    const r = Object.keys(this.iconsById).map((s) => this.iconsById[s]);
    for (const s of r.filter((o) => !!o.description).sort(e))
      n.push(`|<i class="${i(s)}"></i>|${s.id}|${oi.isThemeIcon(s.defaults) ? s.defaults.id : s.id}|${s.description || ""}|`);
    n.push("| preview     | identifier                        "), n.push("| ----------- | --------------------------------- |");
    for (const s of r.filter((o) => !oi.isThemeIcon(o.defaults)).sort(e))
      n.push(`|<i class="${i(s)}"></i>|${s.id}|`);
    return n.join(`
`);
  }
}
const Du = new hO();
ai.add(cO.IconContribution, Du);
function wf(t, e, i, n) {
  return Du.registerIcon(t, e, i, n);
}
function fO() {
  const t = B8();
  for (const e in t) {
    const i = "\\" + t[e].toString(16);
    Du.registerIcon(e, { fontCharacter: i });
  }
}
fO();
const p5 = "vscode://schemas/icons", g5 = ai.as(K_.JSONContribution);
g5.registerSchema(p5, Du.getIconSchema());
const DI = new cl(() => g5.notifySchemaChanged(p5), 200);
Du.onDidChange(() => {
  DI.isScheduled() || DI.schedule();
});
wf("widget-close", ge.close, h(2328, "Icon for the close action in widgets."));
wf("goto-previous-location", ge.arrowUp, h(2329, "Icon for goto previous editor location."));
wf("goto-next-location", ge.arrowDown, h(2330, "Icon for goto next editor location."));
oi.modify(ge.sync, "spin");
oi.modify(ge.loading, "spin");
wf("rerun-task", ge.refresh, h(10531, "View icon of the rerun task."));
const pO = "settings";
new T("taskRunning", !1, h(10752, "Whether a task is currently running."));
new T("taskTerminalActive", !1, h(10753, "Whether the active terminal is a task terminal."));
$_(10754, "Tasks");
var Km;
(function(t) {
  t[t.Escape = 1] = "Escape", t[t.Strong = 2] = "Strong", t[t.Weak = 3] = "Weak";
})(Km || (Km = {}));
(function(t) {
  function e(i) {
    if (!i)
      return t.Strong;
    switch (i.toLowerCase()) {
      case "escape":
        return t.Escape;
      case "strong":
        return t.Strong;
      case "weak":
        return t.Weak;
      default:
        return t.Strong;
    }
  }
  t.from = e;
})(Km || (Km = {}));
var kI;
(function(t) {
  t.defaults = { cwd: "${workspaceFolder}" };
})(kI || (kI = {}));
var Yh;
(function(t) {
  t[t.Always = 1] = "Always", t[t.Silent = 2] = "Silent", t[t.Never = 3] = "Never";
})(Yh || (Yh = {}));
(function(t) {
  function e(i) {
    switch (i.toLowerCase()) {
      case "always":
        return t.Always;
      case "silent":
        return t.Silent;
      case "never":
        return t.Never;
      default:
        return t.Always;
    }
  }
  t.fromString = e;
})(Yh || (Yh = {}));
var Xh;
(function(t) {
  t[t.Never = 1] = "Never", t[t.OnProblem = 2] = "OnProblem", t[t.Always = 3] = "Always";
})(Xh || (Xh = {}));
(function(t) {
  function e(i) {
    switch (i.toLowerCase()) {
      case "always":
        return t.Always;
      case "never":
        return t.Never;
      case "onproblem":
        return t.OnProblem;
      default:
        return t.OnProblem;
    }
  }
  t.fromString = e;
})(Xh || (Xh = {}));
var Zh;
(function(t) {
  t[t.Shared = 1] = "Shared", t[t.Dedicated = 2] = "Dedicated", t[t.New = 3] = "New";
})(Zh || (Zh = {}));
(function(t) {
  function e(i) {
    switch (i.toLowerCase()) {
      case "shared":
        return t.Shared;
      case "dedicated":
        return t.Dedicated;
      case "new":
        return t.New;
      default:
        return t.Shared;
    }
  }
  t.fromString = e;
})(Zh || (Zh = {}));
var II;
(function(t) {
  t.defaults = {
    echo: !0,
    reveal: Yh.Always,
    revealProblems: Xh.Never,
    focus: !1,
    panel: Zh.Shared,
    showReuseMessage: !0,
    clear: !1
  };
})(II || (II = {}));
var Jm;
(function(t) {
  t[t.Shell = 1] = "Shell", t[t.Process = 2] = "Process", t[t.CustomExecution = 3] = "CustomExecution";
})(Jm || (Jm = {}));
(function(t) {
  function e(n) {
    switch (n.toLowerCase()) {
      case "shell":
        return t.Shell;
      case "process":
        return t.Process;
      case "customExecution":
        return t.CustomExecution;
      default:
        return t.Process;
    }
  }
  t.fromString = e;
  function i(n) {
    switch (n) {
      case t.Shell:
        return "shell";
      case t.Process:
        return "process";
      case t.CustomExecution:
        return "customExecution";
      default:
        return "process";
    }
  }
  t.toString = i;
})(Jm || (Jm = {}));
var CI;
(function(t) {
  function e(i) {
    return it(i) ? i : i.value;
  }
  t.value = e;
})(CI || (CI = {}));
var TI;
(function(t) {
  t.Clean = { _id: "clean", isDefault: !1 }, t.Build = { _id: "build", isDefault: !1 }, t.Rebuild = { _id: "rebuild", isDefault: !1 }, t.Test = { _id: "test", isDefault: !1 };
  function e(n) {
    return n === t.Clean._id || n === t.Build._id || n === t.Rebuild._id || n === t.Test._id;
  }
  t.is = e;
  function i(n) {
    if (n !== void 0)
      return it(n) ? e(n) ? { _id: n, isDefault: !1 } : void 0 : n;
  }
  t.from = i;
})(TI || (TI = {}));
var PI;
(function(t) {
  t[t.Global = 1] = "Global", t[t.Workspace = 2] = "Workspace", t[t.Folder = 3] = "Folder";
})(PI || (PI = {}));
var AI;
(function(t) {
  t.Workspace = "workspace", t.Extension = "extension", t.InMemory = "inMemory", t.WorkspaceFile = "workspaceFile", t.User = "user";
  function e(i) {
    switch (i) {
      case t.User:
        return ti.USER;
      case t.WorkspaceFile:
        return ti.WORKSPACE;
      default:
        return ti.WORKSPACE_FOLDER;
    }
  }
  t.toConfigurationTarget = e;
})(AI || (AI = {}));
var RI;
(function(t) {
  t.parallel = "parallel", t.sequence = "sequence";
})(RI || (RI = {}));
var r0;
(function(t) {
  t[t.default = 1] = "default", t[t.folderOpen = 2] = "folderOpen";
})(r0 || (r0 = {}));
var s0;
(function(t) {
  t.terminateNewest = "terminateNewest", t.terminateOldest = "terminateOldest", t.prompt = "prompt", t.warn = "warn", t.silent = "silent";
})(s0 || (s0 = {}));
var LI;
(function(t) {
  t.defaults = { reevaluateOnRerun: !0, runOn: r0.default, instanceLimit: 1, instancePolicy: s0.prompt };
})(LI || (LI = {}));
var Ym;
(function(t) {
  t[t.Process = 1] = "Process", t[t.Terminal = 2] = "Terminal";
})(Ym || (Ym = {}));
(function(t) {
  t._default = t.Terminal;
})(Ym || (Ym = {}));
var NI;
(function(t) {
  t[t.V0_1_0 = 1] = "V0_1_0", t[t.V2_0_0 = 2] = "V2_0_0";
})(NI || (NI = {}));
var Xm;
(function(t) {
  t.SingleRun = "singleRun", t.Background = "background";
})(Xm || (Xm = {}));
var to;
(function(t) {
  t.Changed = "changed", t.ProcessStarted = "processStarted", t.ProcessEnded = "processEnded", t.Terminated = "terminated", t.Start = "start", t.AcquiredInput = "acquiredInput", t.DependsOnStarted = "dependsOnStarted", t.Active = "active", t.Inactive = "inactive", t.End = "end", t.ProblemMatcherStarted = "problemMatcherStarted", t.ProblemMatcherEnded = "problemMatcherEnded", t.ProblemMatcherFoundErrors = "problemMatcherFoundErrors";
})(to || (to = {}));
var MI;
(function(t) {
  t[t.System = 0] = "System", t[t.User = 1] = "User", t[t.FolderOpen = 2] = "FolderOpen", t[t.ConfigurationChange = 3] = "ConfigurationChange", t[t.Reconnect = 4] = "Reconnect";
})(MI || (MI = {}));
var OI;
(function(t) {
  function e(c) {
    return {
      taskId: c._id,
      taskName: c.configurationProperties.name,
      runType: c.configurationProperties.isBackground ? Xm.Background : Xm.SingleRun,
      group: c.configurationProperties.group,
      __task: c
    };
  }
  function i(c, u, d) {
    return {
      ...e(c),
      kind: to.Start,
      terminalId: u,
      resolvedVariables: d
    };
  }
  t.start = i;
  function n(c, u, d) {
    return {
      ...e(c),
      kind: to.ProcessStarted,
      terminalId: u,
      processId: d
    };
  }
  t.processStarted = n;
  function r(c, u, d) {
    return {
      ...e(c),
      kind: to.ProcessEnded,
      terminalId: u,
      exitCode: d
    };
  }
  t.processEnded = r;
  function s(c, u, d) {
    return {
      ...e(c),
      kind: to.Terminated,
      exitReason: d,
      terminalId: u
    };
  }
  t.terminated = s;
  function o(c, u, d) {
    return {
      ...e(u),
      kind: c,
      terminalId: d
    };
  }
  t.general = o;
  function a(c, u, d) {
    return {
      ...e(c),
      kind: to.ProblemMatcherEnded,
      hasErrors: u
    };
  }
  t.problemMatcherEnded = a;
  function l() {
    return { kind: to.Changed };
  }
  t.changed = l;
})(OI || (OI = {}));
var Zm;
(function(t) {
  function e(n) {
    const r = Object.keys(n).sort();
    let s = "";
    for (const o of r) {
      let a = n[o];
      a instanceof Object ? a = e(a) : typeof a == "string" && (a = a.replace(/,/g, ",,")), s += o + "," + a + ",";
    }
    return s;
  }
  function i(n) {
    const s = { _key: e(n), type: n.taskType };
    return Object.assign(s, n), s;
  }
  t.create = i;
})(Zm || (Zm = {}));
var FI;
(function(t) {
  t.AutoDetect = "task.autoDetect", t.SaveBeforeRun = "task.saveBeforeRun", t.ShowDecorations = "task.showDecorations", t.ProblemMatchersNeverPrompt = "task.problemMatchers.neverPrompt", t.SlowProviderWarning = "task.slowProviderWarning", t.QuickOpenHistory = "task.quickOpen.history", t.QuickOpenDetail = "task.quickOpen.detail", t.QuickOpenSkip = "task.quickOpen.skip", t.QuickOpenShowAll = "task.quickOpen.showAll", t.AllowAutomaticTasks = "task.allowAutomaticTasks", t.Reconnection = "task.reconnection", t.VerboseLogging = "task.verboseLogging";
})(FI || (FI = {}));
var UI;
(function(t) {
  t.Tasks = "tasks", t.SuppressTaskName = "tasks.suppressTaskName", t.Windows = "tasks.windows", t.Osx = "tasks.osx", t.Linux = "tasks.linux", t.ShowOutput = "tasks.showOutput", t.IsShellCommand = "tasks.isShellCommand", t.ServiceTestSetting = "tasks.service.testSetting";
})(UI || (UI = {}));
var $I;
(function(t) {
  function e(i, n) {
    const r = lO.get(i.type);
    if (r === void 0) {
      const l = yt(i);
      return delete l._key, Zm.create(l);
    }
    const s = /* @__PURE__ */ Object.create(null);
    s.type = r.taskType;
    const o = /* @__PURE__ */ new Set();
    r.required.forEach((l) => o.add(l));
    const a = r.properties;
    for (const l of Object.keys(a)) {
      const c = i[l];
      if (c != null)
        s[l] = c;
      else if (o.has(l)) {
        const u = a[l];
        if (u.default !== void 0)
          s[l] = yt(u.default);
        else
          switch (u.type) {
            case "boolean":
              s[l] = !1;
              break;
            case "number":
            case "integer":
              s[l] = 0;
              break;
            case "string":
              s[l] = "";
              break;
            default:
              n.error(h(
                10755,
                "Error: the task identifier '{0}' is missing the required property '{1}'. The task identifier will be ignored.",
                JSON.stringify(i, void 0, 0),
                l
              ));
              return;
          }
      }
    }
    return Zm.create(s);
  }
  t.createTaskIdentifier = e;
})($I || ($I = {}));
var e_;
(function(t) {
  function e(n) {
    if (n != null)
      return n;
  }
  t.from = e;
  function i(n) {
    if (n != null)
      return n;
  }
  t.to = i;
})(e_ || (e_ = {}));
var t_;
(function(t) {
  function e(n) {
    if (n != null)
      return n;
  }
  t.from = e;
  function i(n) {
    if (n != null)
      return n;
  }
  t.to = i;
})(t_ || (t_ = {}));
var o0;
(function(t) {
  function e(n) {
    if (n != null)
      return n;
  }
  t.from = e;
  function i(n) {
    if (n != null)
      return n;
  }
  t.to = i;
})(o0 || (o0 = {}));
var Dd;
(function(t) {
  function e(r) {
    if (r) {
      const s = r;
      return s && !!s.process;
    } else
      return !1;
  }
  t.is = e;
  function i(r) {
    if (r == null)
      return;
    const s = {
      process: r.process,
      args: r.args
    };
    return r.options && (s.options = o0.from(r.options)), s;
  }
  t.from = i;
  function n(r) {
    if (r != null)
      return new Yc(r.process, r.args, r.options);
  }
  t.to = n;
})(Dd || (Dd = {}));
var a0;
(function(t) {
  function e(n) {
    if (n != null)
      return n;
  }
  t.from = e;
  function i(n) {
    if (n != null)
      return n;
  }
  t.to = i;
})(a0 || (a0 = {}));
var kd;
(function(t) {
  function e(r) {
    if (r) {
      const s = r;
      return s && (!!s.commandLine || !!s.command);
    } else
      return !1;
  }
  t.is = e;
  function i(r) {
    if (r == null)
      return;
    const s = {};
    return r.commandLine !== void 0 ? s.commandLine = r.commandLine : (s.command = r.command, s.args = r.args), r.options && (s.options = a0.from(r.options)), s;
  }
  t.from = i;
  function n(r) {
    if (!(r == null || r.command === void 0 && r.commandLine === void 0))
      return r.commandLine ? new nl(r.commandLine, r.options) : new nl(r.command, r.args ? r.args : [], r.options);
  }
  t.to = n;
})(kd || (kd = {}));
var Ns;
(function(t) {
  function e(r) {
    if (r) {
      const s = r;
      return s && s.customExecution === "customExecution";
    } else
      return !1;
  }
  t.is = e;
  function i(r) {
    return {
      customExecution: "customExecution"
    };
  }
  t.from = i;
  function n(r, s) {
    return s.get(r);
  }
  t.to = n;
})(Ns || (Ns = {}));
var HI;
(function(t) {
  function e(i, n) {
    let r;
    return i.scope !== void 0 && typeof i.scope != "number" ? r = i.scope.uri : i.scope !== void 0 && typeof i.scope == "number" && (i.scope === To.Workspace && n && n.workspaceFile ? r = n.workspaceFile : r = pO), {
      id: i._id,
      workspaceFolder: r
    };
  }
  t.from = e;
})(HI || (HI = {}));
var l0;
(function(t) {
  function e(i) {
    if (i != null)
      return { _id: i.id, isDefault: i.isDefault };
  }
  t.from = e;
})(l0 || (l0 = {}));
var mo;
(function(t) {
  function e(r, s) {
    if (r == null)
      return [];
    const o = [];
    for (const a of r) {
      const l = i(a, s);
      l && o.push(l);
    }
    return o;
  }
  t.fromMany = e;
  function i(r, s) {
    if (r == null)
      return;
    let o;
    r.execution instanceof Yc ? o = Dd.from(r.execution) : r.execution instanceof nl ? o = kd.from(r.execution) : r.execution && r.execution instanceof Yx && (o = Ns.from(r.execution));
    const a = e_.from(r.definition);
    let l;
    return r.scope ? typeof r.scope == "number" ? l = r.scope : l = r.scope.uri : l = To.Workspace, !a || !l ? void 0 : {
      _id: r._id,
      definition: a,
      name: r.name,
      source: {
        extensionId: s.identifier.value,
        label: r.source,
        scope: l
      },
      execution: o,
      isBackground: r.isBackground,
      group: l0.from(r.group),
      presentationOptions: t_.from(r.presentationOptions),
      problemMatchers: qn(r.problemMatchers),
      hasDefinedMatchers: r.hasDefinedMatchers,
      runOptions: r.runOptions ? r.runOptions : { reevaluateOnRerun: !0 },
      detail: r.detail
    };
  }
  t.from = i;
  async function n(r, s, o) {
    if (r == null)
      return;
    let a;
    Dd.is(r.execution) ? a = Dd.to(r.execution) : kd.is(r.execution) ? a = kd.to(r.execution) : Ns.is(r.execution) && (a = Ns.to(r._id, o));
    const l = e_.to(r.definition);
    let c;
    if (r.source && (r.source.scope !== void 0 ? typeof r.source.scope == "number" ? c = r.source.scope : c = await s.resolveWorkspaceFolder(x.revive(r.source.scope)) : c = To.Workspace), !l || !c)
      return;
    const u = new Og(l, c, r.name, r.source.label, a, r.problemMatchers);
    return r.isBackground !== void 0 && (u.isBackground = r.isBackground), r.group !== void 0 && (u.group = ph.from(r.group._id), u.group && r.group.isDefault && (u.group = new ph(u.group.id, u.group.label), r.group.isDefault === !0 && (u.group.isDefault = r.group.isDefault))), r.presentationOptions && (u.presentationOptions = t_.to(r.presentationOptions)), r._id && (u._id = r._id), r.detail && (u.detail = r.detail), u;
  }
  t.to = n;
})(mo || (mo = {}));
var c0;
(function(t) {
  function e(n) {
    return n;
  }
  t.from = e;
  function i(n) {
    if (n)
      return Object.assign(/* @__PURE__ */ Object.create(null), n);
  }
  t.to = i;
})(c0 || (c0 = {}));
class X1 {
  #e;
  constructor(e, i, n) {
    this._id = i, this._task = n, this.#e = e;
  }
  get task() {
    return this._task;
  }
  terminate() {
    this.#e.terminateTask(this);
  }
  fireDidStartProcess(e) {
  }
  fireDidEndProcess(e) {
  }
  get terminal() {
    return this._terminal;
  }
  set terminal(e) {
    this._terminal = e;
  }
}
let u0 = class {
  constructor(e, i, n, r, s, o, a, l) {
    this._onDidExecuteTask = new N(), this._onDidTerminateTask = new N(), this._onDidTaskProcessStarted = new N(), this._onDidTaskProcessEnded = new N(), this._onDidStartTaskProblemMatchers = new N(), this._onDidEndTaskProblemMatchers = new N(), this._proxy = e.getProxy(ee.MainThreadTask), this._workspaceProvider = n, this._editorService = r, this._configurationService = s, this._terminalService = o, this._handleCounter = 0, this._handlers = /* @__PURE__ */ new Map(), this._taskExecutions = /* @__PURE__ */ new Map(), this._taskExecutionPromises = /* @__PURE__ */ new Map(), this._providedCustomExecutions2 = /* @__PURE__ */ new Map(), this._notProvidedCustomExecutions = /* @__PURE__ */ new Set(), this._activeCustomExecutions2 = /* @__PURE__ */ new Map(), this._logService = a, this._deprecationService = l, this._proxy.$registerSupportedExecutions(!0);
  }
  registerTaskProvider(e, i, n) {
    if (!n)
      return new Ve(() => {
      });
    const r = this.nextHandle();
    return this._handlers.set(r, { type: i, provider: n, extension: e }), this._proxy.$registerTaskProvider(r, i), new Ve(() => {
      this._handlers.delete(r), this._proxy.$unregisterTaskProvider(r);
    });
  }
  registerTaskSystem(e, i) {
    this._proxy.$registerTaskSystem(e, i);
  }
  fetchTasks(e) {
    return this._proxy.$fetchTasks(c0.from(e)).then(async (i) => {
      const n = [];
      for (const r of i) {
        const s = await mo.to(r, this._workspaceProvider, this._providedCustomExecutions2);
        s && n.push(s);
      }
      return n;
    });
  }
  get taskExecutions() {
    const e = [];
    return this._taskExecutions.forEach((i) => e.push(i)), e;
  }
  terminateTask(e) {
    if (!(e instanceof X1))
      throw new Error("No valid task execution provided");
    return this._proxy.$terminateTask(e._id);
  }
  get onDidStartTask() {
    return this._onDidExecuteTask.event;
  }
  async $onDidStartTask(e, i, n) {
    const r = this._providedCustomExecutions2.get(e.id);
    r && (this._activeCustomExecutions2.set(e.id, r), this._terminalService.attachPtyToTerminal(i, await r.callback(n))), this._lastStartedTask = e.id;
    const s = await this.getTaskExecution(e), o = this._terminalService.getTerminalById(i)?.value;
    s && (s.terminal = o), this._onDidExecuteTask.fire({
      execution: s
    });
  }
  get onDidEndTask() {
    return this._onDidTerminateTask.event;
  }
  async $OnDidEndTask(e) {
    if (!this._taskExecutionPromises.has(e.id))
      return;
    const i = await this.getTaskExecution(e);
    this._taskExecutionPromises.delete(e.id), this._taskExecutions.delete(e.id), this.customExecutionComplete(e), this._onDidTerminateTask.fire({
      execution: i
    });
  }
  get onDidStartTaskProcess() {
    return this._onDidTaskProcessStarted.event;
  }
  async $onDidStartTaskProcess(e) {
    const i = await this.getTaskExecution(e.id);
    this._onDidTaskProcessStarted.fire({
      execution: i,
      processId: e.processId
    });
  }
  get onDidEndTaskProcess() {
    return this._onDidTaskProcessEnded.event;
  }
  async $onDidEndTaskProcess(e) {
    const i = await this.getTaskExecution(e.id);
    this._onDidTaskProcessEnded.fire({
      execution: i,
      exitCode: e.exitCode
    });
  }
  get onDidStartTaskProblemMatchers() {
    return this._onDidStartTaskProblemMatchers.event;
  }
  async $onDidStartTaskProblemMatchers(e) {
    let i;
    try {
      i = await this.getTaskExecution(e.execution.id);
    } catch {
      return;
    }
    this._onDidStartTaskProblemMatchers.fire({ execution: i });
  }
  get onDidEndTaskProblemMatchers() {
    return this._onDidEndTaskProblemMatchers.event;
  }
  async $onDidEndTaskProblemMatchers(e) {
    let i;
    try {
      i = await this.getTaskExecution(e.execution.id);
    } catch {
      return;
    }
    this._onDidEndTaskProblemMatchers.fire({ execution: i, hasErrors: e.hasErrors });
  }
  $provideTasks(e, i) {
    const n = this._handlers.get(e);
    if (!n)
      return Promise.reject(new Error("no handler found"));
    const r = [], s = Ai(() => n.provider.provideTasks(xt.None)).then((o) => this.provideTasksInternal(i, r, n, o));
    return new Promise((o) => {
      s.then((a) => {
        Promise.all(r).then(() => {
          o(a);
        });
      });
    });
  }
  async $resolveTask(e, i) {
    const n = this._handlers.get(e);
    if (!n)
      return Promise.reject(new Error("no handler found"));
    if (i.definition.type !== n.type)
      throw new Error(
        `Unexpected: Task of type [${i.definition.type}] cannot be resolved by provider of type [${n.type}].`
      );
    const r = await mo.to(i, this._workspaceProvider, this._providedCustomExecutions2);
    if (!r)
      throw new Error("Unexpected: Task cannot be resolved.");
    const s = await n.provider.resolveTask(r, xt.None);
    if (!s)
      return;
    this.checkDeprecation(s, n);
    const o = mo.from(s, n.extension);
    if (!o)
      throw new Error("Unexpected: Task cannot be resolved.");
    if (s.definition !== r.definition)
      throw new Error(
        "Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed."
      );
    return Ns.is(o.execution) && await this.addCustomExecution(o, s, !0), await this.resolveTaskInternal(o);
  }
  nextHandle() {
    return this._handleCounter++;
  }
  async addCustomExecution(e, i, n) {
    const r = await this._proxy.$createTaskId(e);
    !n && !this._providedCustomExecutions2.has(r) && (this._notProvidedCustomExecutions.add(r), this._activeCustomExecutions2.set(r, i.execution)), this._providedCustomExecutions2.set(r, i.execution);
  }
  async getTaskExecution(e, i) {
    if (typeof e == "string") {
      const s = this._taskExecutionPromises.get(e);
      if (!s)
        throw new Xr("Unexpected: The specified task is missing an execution");
      return s;
    }
    const n = this._taskExecutionPromises.get(e.id);
    if (n)
      return n;
    let r;
    return i ? r = Promise.resolve(new X1(this, e.id, i)) : r = mo.to(e.task, this._workspaceProvider, this._providedCustomExecutions2).then((s) => {
      if (!s)
        throw new Xr("Unexpected: Task does not exist.");
      return new X1(this, e.id, s);
    }), this._taskExecutionPromises.set(e.id, r), r.then((s) => (this._taskExecutions.set(e.id, s), s));
  }
  checkDeprecation(e, i) {
    e._deprecated && this._deprecationService.report("Task.constructor", i.extension, "Use the Task constructor that takes a `scope` instead.");
  }
  customExecutionComplete(e) {
    this._activeCustomExecutions2.get(e.id) && this._activeCustomExecutions2.delete(e.id), this._notProvidedCustomExecutions.has(e.id) && this._lastStartedTask !== e.id && (this._providedCustomExecutions2.delete(e.id), this._notProvidedCustomExecutions.delete(e.id));
    const n = this._notProvidedCustomExecutions.values();
    let r = n.next();
    for (; !r.done; )
      !this._activeCustomExecutions2.has(r.value) && this._lastStartedTask !== r.value && (this._providedCustomExecutions2.delete(r.value), this._notProvidedCustomExecutions.delete(r.value)), r = n.next();
  }
};
u0 = W([
  M(0, Ye),
  M(1, pi),
  M(2, Us),
  M(3, Su),
  M(4, $s),
  M(5, Eu),
  M(6, nt),
  M(7, vf)
], u0);
let d0 = class extends u0 {
  constructor(e, i, n, r, s, o, a, l) {
    super(e, i, n, r, s, o, a, l), this.registerTaskSystem(de.vscodeRemote, {
      scheme: de.vscodeRemote,
      authority: "",
      platform: VA(dr.Web)
    });
  }
  async executeTask(e, i) {
    if (!i.execution)
      throw new Error("Tasks to execute must include an execution");
    const n = mo.from(i, e);
    if (n === void 0)
      throw new Error("Task is not valid");
    if (Ns.is(n.execution))
      await this.addCustomExecution(n, i, !1);
    else
      throw new gv();
    const r = await this.getTaskExecution(await this._proxy.$getTaskExecution(n), i);
    return this._proxy.$executeTask(n).catch((s) => {
      throw new Error(s);
    }), r;
  }
  provideTasksInternal(e, i, n, r) {
    const s = [];
    if (r)
      for (const o of r) {
        if (this.checkDeprecation(o, n), !o.definition || !e[o.definition.type]) {
          const l = o.source ? o.source : "No task source";
          this._logService.warn(`The task [${l}, ${o.name}] uses an undefined task type. The task will be ignored in the future.`);
        }
        const a = mo.from(o, n.extension);
        a && Ns.is(a.execution) ? (s.push(a), i.push(this.addCustomExecution(a, o, !0))) : this._logService.warn("Only custom execution tasks supported.");
      }
    return {
      tasks: s,
      extension: n.extension
    };
  }
  async resolveTaskInternal(e) {
    if (Ns.is(e.execution))
      return e;
    this._logService.warn("Only custom execution tasks supported.");
  }
  async $resolveVariables(e, i) {
    return {
      process: void 0,
      variables: /* @__PURE__ */ Object.create(null)
    };
  }
  async $jsonTasksSupported() {
    return !1;
  }
  async $findExecutable(e, i, n) {
  }
};
d0 = W([
  M(0, Ye),
  M(1, pi),
  M(2, Us),
  M(3, Su),
  M(4, $s),
  M(5, Eu),
  M(6, nt),
  M(7, vf)
], d0);
const m5 = pe("IExtHostTask");
class gO {
  constructor() {
    this.pendingRequests = /* @__PURE__ */ new Map(), this.queue = [], this._onError = new N(), this._onExit = new N(), this.sequence = 1;
  }
  get onError() {
    return this._onError.event;
  }
  get onExit() {
    return this._onExit.event;
  }
  onMessage(e) {
    this.messageCallback && this._onError.fire(new Error("attempt to set more than one 'Message' callback")), this.messageCallback = e;
  }
  onEvent(e) {
    this.eventCallback && this._onError.fire(new Error("attempt to set more than one 'Event' callback")), this.eventCallback = e;
  }
  onRequest(e) {
    this.requestCallback && this._onError.fire(new Error("attempt to set more than one 'Request' callback")), this.requestCallback = e;
  }
  sendResponse(e) {
    e.seq > 0 ? this._onError.fire(new Error(`attempt to send more than one response for command ${e.command}`)) : this.internalSend("response", e);
  }
  sendRequest(e, i, n, r) {
    const s = {
      command: e
    };
    if (i && Object.keys(i).length > 0 && (s.arguments = i), this.internalSend("request", s), typeof r == "number") {
      const o = setTimeout(() => {
        clearTimeout(o);
        const a = this.pendingRequests.get(s.seq);
        if (a) {
          this.pendingRequests.delete(s.seq);
          const l = {
            type: "response",
            seq: 0,
            request_seq: s.seq,
            success: !1,
            command: e,
            message: h(6391, "Timeout after {0} ms for '{1}'", r, e)
          };
          a(l);
        }
      }, r);
    }
    return n && this.pendingRequests.set(s.seq, n), s.seq;
  }
  acceptMessage(e) {
    this.messageCallback ? this.messageCallback(e) : (this.queue.push(e), this.queue.length === 1 && this.processQueue());
  }
  needsTaskBoundaryBetween(e, i) {
    return e.type !== "event" || i.type !== "event";
  }
  async processQueue() {
    let e;
    for (; this.queue.length; ) {
      if ((!e || this.needsTaskBoundaryBetween(this.queue[0], e)) && await qr(0), e = this.queue.shift(), !e)
        return;
      switch (e.type) {
        case "event":
          this.eventCallback?.(e);
          break;
        case "request":
          this.requestCallback?.(e);
          break;
        case "response": {
          const i = e, n = this.pendingRequests.get(i.request_seq);
          n && (this.pendingRequests.delete(i.request_seq), n(i));
          break;
        }
      }
    }
  }
  internalSend(e, i) {
    i.type = e, i.seq = this.sequence++, this.sendMessage(i);
  }
  async cancelPendingRequests() {
    if (this.pendingRequests.size === 0)
      return Promise.resolve();
    const e = /* @__PURE__ */ new Map();
    this.pendingRequests.forEach((i, n) => e.set(n, i)), await qr(500), e.forEach((i, n) => {
      i({
        type: "response",
        seq: 0,
        request_seq: n,
        success: !1,
        command: "canceled",
        message: "canceled"
      }), this.pendingRequests.delete(n);
    });
  }
  getPendingRequestIds() {
    return Array.from(this.pendingRequests.keys());
  }
  dispose() {
    this.queue = [];
  }
}
function mO(t) {
  return t.type && (t.label || t.program || t.runtime);
}
const _O = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/;
function vO(t) {
  return !!(t && t.match(_O));
}
function wO(t) {
  if (typeof t.path == "string" && !(typeof t.sourceReference == "number" && t.sourceReference > 0)) {
    if (vO(t.path))
      return x.parse(t.path);
    if (Mp(t.path))
      return x.file(t.path);
  }
  return t.path;
}
function bO(t) {
  if (typeof t.path == "object") {
    const e = x.revive(t.path);
    if (e)
      return e.scheme === de.file ? e.fsPath : e.toString();
  }
  return t.path;
}
function yO(t, e) {
  const i = bO, n = yt(t);
  return _5(n, (r, s) => {
    r && s && (s.path = i(s));
  }), n;
}
function xO(t, e) {
  const i = wO, n = yt(t);
  return _5(n, (r, s) => {
    !r && s && (s.path = i(s));
  }), n;
}
function _5(t, e) {
  switch (t.type) {
    case "event": {
      const i = t;
      switch (i.event) {
        case "output":
          e(!1, i.body.source);
          break;
        case "loadedSource":
          e(!1, i.body.source);
          break;
        case "breakpoint":
          e(!1, i.body.breakpoint.source);
          break;
      }
      break;
    }
    case "request": {
      const i = t;
      switch (i.command) {
        case "setBreakpoints":
          e(!0, i.arguments.source);
          break;
        case "breakpointLocations":
          e(!0, i.arguments.source);
          break;
        case "source":
          e(!0, i.arguments.source);
          break;
        case "gotoTargets":
          e(!0, i.arguments.source);
          break;
        case "launchVSCode":
          i.arguments.args.forEach((n) => e(!1, n));
          break;
      }
      break;
    }
    case "response": {
      const i = t;
      if (i.success && i.body)
        switch (i.command) {
          case "stackTrace":
            i.body.stackFrames.forEach((n) => e(!1, n.source));
            break;
          case "loadedSources":
            i.body.sources.forEach((n) => e(!1, n));
            break;
          case "scopes":
            i.body.scopes.forEach((n) => e(!1, n.source));
            break;
          case "setFunctionBreakpoints":
            i.body.breakpoints.forEach((n) => e(!1, n.source));
            break;
          case "setBreakpoints":
            i.body.breakpoints.forEach((n) => e(!1, n.source));
            break;
          case "disassemble":
            i.body?.instructions.forEach((r) => e(!1, r.location));
            break;
          case "locations":
            e(!1, i.body?.source);
            break;
        }
      break;
    }
  }
}
const bf = pe("IExtHostEditorTabs");
class BI {
  constructor(e, i, n) {
    this._activeTabIdGetter = n, this._parentGroup = i, this.acceptDtoUpdate(e);
  }
  get apiObject() {
    if (!this._apiObject) {
      const e = this, i = {
        get isActive() {
          return e._dto.id === e._activeTabIdGetter();
        },
        get label() {
          return e._dto.label;
        },
        get input() {
          return e._input;
        },
        get isDirty() {
          return e._dto.isDirty;
        },
        get isPinned() {
          return e._dto.isPinned;
        },
        get isPreview() {
          return e._dto.isPreview;
        },
        get group() {
          return e._parentGroup.apiObject;
        }
      };
      this._apiObject = Object.freeze(i);
    }
    return this._apiObject;
  }
  get tabId() {
    return this._dto.id;
  }
  acceptDtoUpdate(e) {
    this._dto = e, this._input = this._initInput();
  }
  _initInput() {
    switch (this._dto.input.kind) {
      case xn.TextInput:
        return new eE(x.revive(this._dto.input.uri));
      case xn.TextDiffInput:
        return new im(x.revive(this._dto.input.original), x.revive(this._dto.input.modified));
      case xn.TextMergeInput:
        return new aP(
          x.revive(this._dto.input.base),
          x.revive(this._dto.input.input1),
          x.revive(this._dto.input.input2),
          x.revive(this._dto.input.result)
        );
      case xn.CustomEditorInput:
        return new tE(x.revive(this._dto.input.uri), this._dto.input.viewType);
      case xn.WebviewEditorInput:
        return new lP(this._dto.input.viewType);
      case xn.NotebookInput:
        return new iE(x.revive(this._dto.input.uri), this._dto.input.notebookType);
      case xn.NotebookDiffInput:
        return new nE(
          x.revive(this._dto.input.original),
          x.revive(this._dto.input.modified),
          this._dto.input.notebookType
        );
      case xn.TerminalEditorInput:
        return new cP();
      case xn.InteractiveEditorInput:
        return new uP(x.revive(this._dto.input.uri), x.revive(this._dto.input.inputBoxUri));
      case xn.ChatEditorInput:
        return new dP();
      case xn.MultiDiffEditorInput:
        return new hP(this._dto.input.diffEditors.map((e) => new im(x.revive(e.original), x.revive(e.modified))));
      default:
        return;
    }
  }
}
class EO {
  constructor(e, i) {
    this._tabs = [], this._activeTabId = "", this._dto = e, this._activeGroupIdGetter = i;
    for (const n of e.tabs)
      n.isActive && (this._activeTabId = n.id), this._tabs.push(new BI(n, this, () => this.activeTabId()));
  }
  get apiObject() {
    if (!this._apiObject) {
      const e = this, i = {
        get isActive() {
          return e._dto.groupId === e._activeGroupIdGetter();
        },
        get viewColumn() {
          return si.to(e._dto.viewColumn);
        },
        get activeTab() {
          return e._tabs.find((n) => n.tabId === e._activeTabId)?.apiObject;
        },
        get tabs() {
          return Object.freeze(e._tabs.map((n) => n.apiObject));
        }
      };
      this._apiObject = Object.freeze(i);
    }
    return this._apiObject;
  }
  get groupId() {
    return this._dto.groupId;
  }
  get tabs() {
    return this._tabs;
  }
  acceptGroupDtoUpdate(e) {
    this._dto = e;
  }
  acceptTabOperation(e) {
    if (e.kind === Ds.TAB_OPEN) {
      const n = new BI(e.tabDto, this, () => this.activeTabId());
      return this._tabs.splice(e.index, 0, n), e.tabDto.isActive && (this._activeTabId = n.tabId), n;
    } else if (e.kind === Ds.TAB_CLOSE) {
      const n = this._tabs.splice(e.index, 1)[0];
      if (!n)
        throw new Error(
          `Tab close updated received for index ${e.index} which does not exist`
        );
      return n.tabId === this._activeTabId && (this._activeTabId = ""), n;
    } else if (e.kind === Ds.TAB_MOVE) {
      if (e.oldIndex === void 0)
        throw new Error("Invalid old index on move IPC");
      const n = this._tabs.splice(e.oldIndex, 1)[0];
      if (!n)
        throw new Error(
          `Tab move updated received for index ${e.oldIndex} which does not exist`
        );
      return this._tabs.splice(e.index, 0, n), n;
    }
    const i = this._tabs.find((n) => n.tabId === e.tabDto.id);
    if (!i)
      throw new Error("INVALID tab");
    return e.tabDto.isActive ? this._activeTabId = e.tabDto.id : this._activeTabId === e.tabDto.id && !e.tabDto.isActive && (this._activeTabId = ""), i.acceptDtoUpdate(e.tabDto), i;
  }
  activeTabId() {
    return this._activeTabId;
  }
}
let h0 = class {
  constructor(e) {
    this._onDidChangeTabs = new N(), this._onDidChangeTabGroups = new N(), this._extHostTabGroups = [], this._proxy = e.getProxy(ee.MainThreadEditorTabs);
  }
  get tabGroups() {
    if (!this._apiObject) {
      const e = this, i = {
        onDidChangeTabGroups: e._onDidChangeTabGroups.event,
        onDidChangeTabs: e._onDidChangeTabs.event,
        get all() {
          return Object.freeze(e._extHostTabGroups.map((n) => n.apiObject));
        },
        get activeTabGroup() {
          const n = e._activeGroupId;
          return Fc(e._extHostTabGroups.find((s) => s.groupId === n)?.apiObject);
        },
        close: async (n, r) => {
          const s = Array.isArray(n) ? n : [n];
          return s.length ? SO(s[0]) ? this._closeGroups(s, r) : this._closeTabs(s, r) : !0;
        }
      };
      this._apiObject = Object.freeze(i);
    }
    return this._apiObject;
  }
  $acceptEditorTabModel(e) {
    const i = new Set(this._extHostTabGroups.map((c) => c.groupId)), n = new Set(e.map((c) => c.groupId)), r = K5(i, n), s = this._extHostTabGroups.filter((c) => r.removed.includes(c.groupId)).map((c) => c.apiObject), o = [], a = [];
    this._extHostTabGroups = e.map((c) => {
      const u = new EO(c, () => this._activeGroupId);
      return r.added.includes(u.groupId) ? o.push(u.apiObject) : a.push(u.apiObject), u;
    });
    const l = Fc(e.find((c) => c.isActive === !0)?.groupId);
    l !== void 0 && this._activeGroupId !== l && (this._activeGroupId = l), this._onDidChangeTabGroups.fire(Object.freeze({ opened: o, closed: s, changed: a }));
  }
  $acceptTabGroupUpdate(e) {
    const i = this._extHostTabGroups.find((n) => n.groupId === e.groupId);
    if (!i)
      throw new Error("Update Group IPC call received before group creation.");
    i.acceptGroupDtoUpdate(e), e.isActive && (this._activeGroupId = e.groupId), this._onDidChangeTabGroups.fire(Object.freeze({ changed: [i.apiObject], opened: [], closed: [] }));
  }
  $acceptTabOperation(e) {
    const i = this._extHostTabGroups.find((r) => r.groupId === e.groupId);
    if (!i)
      throw new Error("Update Tabs IPC call received before group creation.");
    const n = i.acceptTabOperation(e);
    switch (e.kind) {
      case Ds.TAB_OPEN:
        this._onDidChangeTabs.fire(Object.freeze({
          opened: [n.apiObject],
          closed: [],
          changed: []
        }));
        return;
      case Ds.TAB_CLOSE:
        this._onDidChangeTabs.fire(Object.freeze({
          opened: [],
          closed: [n.apiObject],
          changed: []
        }));
        return;
      case Ds.TAB_MOVE:
      case Ds.TAB_UPDATE:
        this._onDidChangeTabs.fire(Object.freeze({
          opened: [],
          closed: [],
          changed: [n.apiObject]
        }));
        return;
    }
  }
  _findExtHostTabFromApi(e) {
    for (const i of this._extHostTabGroups)
      for (const n of i.tabs)
        if (n.apiObject === e)
          return n;
  }
  _findExtHostTabGroupFromApi(e) {
    return this._extHostTabGroups.find((i) => i.apiObject === e);
  }
  async _closeTabs(e, i) {
    const n = [];
    for (const r of e) {
      const s = this._findExtHostTabFromApi(r);
      if (!s)
        throw new Error("Tab close: Invalid tab not found!");
      n.push(s.tabId);
    }
    return this._proxy.$closeTab(n, i);
  }
  async _closeGroups(e, i) {
    const n = [];
    for (const r of e) {
      const s = this._findExtHostTabGroupFromApi(r);
      if (!s)
        throw new Error("Group close: Invalid group not found!");
      n.push(s.groupId);
    }
    return this._proxy.$closeGroup(n, i);
  }
};
h0 = W([
  M(0, Ye)
], h0);
function SO(t) {
  return t.tabs !== void 0;
}
var WI;
(function(t) {
  t.ViewletId = "workbench.view.extension.test", t.ExplorerViewId = "workbench.view.testing", t.OutputPeekContributionId = "editor.contrib.testingOutputPeek", t.DecorationsContributionId = "editor.contrib.testingDecorations", t.CoverageDecorationsContributionId = "editor.contrib.coverageDecorations", t.CoverageViewId = "workbench.view.testCoverage", t.ResultsPanelId = "workbench.panel.testResults", t.ResultsViewId = "workbench.panel.testResults.view", t.MessageLanguageId = "vscodeInternalTestMessage";
})(WI || (WI = {}));
var VI;
(function(t) {
  t.List = "list", t.Tree = "true";
})(VI || (VI = {}));
var zI;
(function(t) {
  t.ByLocation = "location", t.ByStatus = "status", t.ByDuration = "duration";
})(zI || (zI = {}));
ii.Errored + "", h(11834, "Errored"), ii.Failed + "", h(11835, "Failed"), ii.Passed + "", h(11836, "Passed"), ii.Queued + "", h(11837, "Queued"), ii.Running + "", h(11838, "Running"), ii.Skipped + "", h(11839, "Skipped"), ii.Unset + "", h(11840, "Not yet run");
Pi.Debug + "", h(11842, "Debug"), Pi.Run + "", h(11843, "Run"), Pi.Coverage + "", h(11844, "Coverage");
var f0;
(function(t) {
  t.CancelTestRefreshAction = "testing.cancelTestRefresh", t.CancelTestRunAction = "testing.cancelRun", t.ClearTestResultsAction = "testing.clearTestResults", t.CollapseAllAction = "testing.collapseAll", t.ConfigureTestProfilesAction = "testing.configureProfile", t.ContinousRunUsingForTest = "testing.continuousRunUsingForTest", t.CoverageAtCursor = "testing.coverageAtCursor", t.CoverageByUri = "testing.coverage.uri", t.CoverageClear = "testing.coverage.close", t.CoverageCurrentFile = "testing.coverageCurrentFile", t.CoverageFilterToTest = "testing.coverageFilterToTest", t.CoverageFilterToTestInEditor = "testing.coverageFilterToTestInEditor", t.CoverageLastRun = "testing.coverageLastRun", t.CoverageSelectedAction = "testing.coverageSelected", t.CoverageToggleToolbar = "testing.coverageToggleToolbar", t.CoverageViewChangeSorting = "testing.coverageViewChangeSorting", t.DebugAction = "testing.debug", t.DebugAllAction = "testing.debugAll", t.DebugAtCursor = "testing.debugAtCursor", t.DebugByUri = "testing.debug.uri", t.DebugCurrentFile = "testing.debugCurrentFile", t.DebugFailedTests = "testing.debugFailTests", t.DebugFailedFromLastRun = "testing.debugFailedFromLastRun", t.DebugLastRun = "testing.debugLastRun", t.DebugSelectedAction = "testing.debugSelected", t.FilterAction = "workbench.actions.treeView.testExplorer.filter", t.GetExplorerSelection = "_testing.getExplorerSelection", t.GetSelectedProfiles = "testing.getSelectedProfiles", t.GoToTest = "testing.editFocusedTest", t.GoToRelatedTest = "testing.goToRelatedTest", t.PeekRelatedTest = "testing.peekRelatedTest", t.GoToRelatedCode = "testing.goToRelatedCode", t.PeekRelatedCode = "testing.peekRelatedCode", t.HideTestAction = "testing.hideTest", t.OpenCoverage = "testing.openCoverage", t.OpenOutputPeek = "testing.openOutputPeek", t.RefreshTestsAction = "testing.refreshTests", t.ReRunFailedTests = "testing.reRunFailTests", t.ReRunFailedFromLastRun = "testing.reRunFailedFromLastRun", t.ReRunLastRun = "testing.reRunLastRun", t.RunAction = "testing.run", t.RunAllAction = "testing.runAll", t.RunAllWithCoverageAction = "testing.coverageAll", t.RunAtCursor = "testing.runAtCursor", t.RunByUri = "testing.run.uri", t.RunCurrentFile = "testing.runCurrentFile", t.RunSelectedAction = "testing.runSelected", t.RunUsingProfileAction = "testing.runUsing", t.RunWithCoverageAction = "testing.coverage", t.SearchForTestExtension = "testing.searchForTestExtension", t.SelectDefaultTestProfiles = "testing.selectDefaultTestProfiles", t.ShowMostRecentOutputAction = "testing.showMostRecentOutput", t.StartContinousRun = "testing.startContinuousRun", t.StartContinousRunFromExtension = "testing.startContinuousRunFromExtension", t.StopContinousRunFromExtension = "testing.stopContinuousRunFromExtension", t.StopContinousRun = "testing.stopContinuousRun", t.TestingSortByDurationAction = "testing.sortByDuration", t.TestingSortByLocationAction = "testing.sortByLocation", t.TestingSortByStatusAction = "testing.sortByStatus", t.TestingViewAsListAction = "testing.viewAsList", t.TestingViewAsTreeAction = "testing.viewAsTree", t.ToggleContinousRunForTest = "testing.toggleContinuousRunForTest", t.ToggleInlineTestOutput = "testing.toggleInlineTestOutput", t.UnhideAllTestsAction = "testing.unhideAllTests", t.UnhideTestAction = "testing.unhideTest";
})(f0 || (f0 = {}));
let DO = 0;
const qI = /* @__PURE__ */ new WeakMap(), g1 = pe("IExtHostTesting");
let p0 = class extends ve {
  constructor(e, i, n, r) {
    super(), this.logService = i, this.commands = n, this.editors = r, this.resultsChangedEmitter = this._register(new N()), this.controllers = /* @__PURE__ */ new Map(), this.defaultProfilesChangedEmitter = this._register(new N()), this.followupProviders = /* @__PURE__ */ new Set(), this.testFollowups = /* @__PURE__ */ new Map(), this.onResultsChanged = this.resultsChangedEmitter.event, this.results = [], this.proxy = e.getProxy(ee.MainThreadTesting), this.observer = new AO(this.proxy), this.runTracker = new CO(this.proxy, i), n.registerArgumentProcessor({
      processArgument: (s) => {
        switch (s?.$mid) {
          case tt.TestItemContext: {
            const o = s, a = o.tests[o.tests.length - 1].item.extId;
            return this.controllers.get(Ne.root(a))?.collection.tree.get(a)?.actual ?? iI(s);
          }
          case tt.TestMessageMenuArgs: {
            const { test: o, message: a } = s, l = o.item.extId;
            return {
              test: this.controllers.get(Ne.root(l))?.collection.tree.get(l)?.actual ?? iI({ tests: [o] }),
              message: du.to(a)
            };
          }
          default:
            return s;
        }
      }
    }), n.registerCommand(!1, "testing.getExplorerSelection", async () => {
      const s = await n.executeCommand(f0.GetExplorerSelection), o = (a) => {
        const l = this.controllers.get(Ne.root(a));
        if (l)
          return Ne.isRoot(a) ? l.controller : l.collection.tree.get(a)?.actual;
      };
      return {
        include: s?.include.map(o).filter(Tn) || [],
        exclude: s?.exclude.map(o).filter(Tn) || []
      };
    });
  }
  createTestController(e, i, n, r) {
    if (this.controllers.has(i))
      throw new Error(`Attempt to insert a duplicate controller with ID "${i}"`);
    const s = new De(), o = s.add(new QN(i, n, this.editors));
    o.root.label = n;
    const a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Set(), c = this.proxy, u = () => {
      let g = 0;
      r && (g |= bd.Refresh);
      const _ = f.relatedCodeProvider;
      return _ && (_?.provideRelatedTests && (g |= bd.TestRelatedToCode), _?.provideRelatedCode && (g |= bd.CodeRelatedToTest)), g;
    }, d = {
      items: o.root.children,
      get label() {
        return n;
      },
      set label(g) {
        n = g, o.root.label = g, c.$updateController(i, { label: n });
      },
      get refreshHandler() {
        return r;
      },
      set refreshHandler(g) {
        r = g, c.$updateController(i, { capabilities: u() });
      },
      get id() {
        return i;
      },
      get relatedCodeProvider() {
        return f.relatedCodeProvider;
      },
      set relatedCodeProvider(g) {
        $(e, "testRelatedCode"), f.relatedCodeProvider = g, c.$updateController(i, { capabilities: u() });
      },
      createRunProfile: (g, _, w, v, S, E) => {
        let A = Yd(g);
        for (; a.has(A); )
          A++;
        return new w5(
          this.proxy,
          a,
          l,
          this.defaultProfilesChangedEmitter.event,
          i,
          A,
          g,
          _,
          w,
          v,
          S,
          E
        );
      },
      createTestItem(g, _, w) {
        return new _l(i, g, _, w);
      },
      createTestRun: (g, _, w = !0) => this.runTracker.createTestRun(e, i, o, g, _, w),
      invalidateTestResults: (g) => {
        if (g === void 0)
          this.proxy.$markTestRetired(void 0);
        else {
          const _ = g instanceof Array ? g : [g];
          this.proxy.$markTestRetired(_.map((w) => Ne.fromExtHostTestItem(w, i).toString()));
        }
      },
      set resolveHandler(g) {
        o.resolveHandler = g;
      },
      get resolveHandler() {
        return o.resolveHandler;
      },
      dispose: () => {
        s.dispose();
      }
    }, f = { controller: d, collection: o, profiles: a, extension: e, activeProfiles: l };
    return c.$registerTestController(i, n, u()), s.add(Ee(() => c.$unregisterTestController(i))), this.controllers.set(i, f), s.add(Ee(() => this.controllers.delete(i))), s.add(o.onDidGenerateDiff((g) => c.$publishDiff(i, g.map(wg.serialize)))), d;
  }
  createTestObserver() {
    return this.observer.checkout();
  }
  async runTests(e, i = xt.None) {
    const n = v5(e);
    if (!n)
      throw new Error("The request passed to `vscode.test.runTests` must include a profile");
    const r = this.controllers.get(n.controllerId);
    if (!r)
      throw new Error("Controller not found");
    await this.proxy.$runTests({
      preserveFocus: e.preserveFocus ?? !0,
      group: hu.from(n.kind),
      targets: [{
        testIds: e.include?.map((s) => Ne.fromExtHostTestItem(s, r.collection.root.id).toString()) ?? [r.collection.root.id],
        profileId: n.profileId,
        controllerId: n.controllerId
      }],
      exclude: e.exclude?.map((s) => s.id)
    }, i);
  }
  registerTestFollowupProvider(e) {
    return this.followupProviders.add(e), { dispose: () => {
      this.followupProviders.delete(e);
    } };
  }
  async $getTestsRelatedToCode(e, i, n) {
    const r = this.editors.getDocument(x.revive(e));
    if (!r)
      return [];
    const s = at.to(i), o = [];
    return await Promise.all([...this.controllers.values()].map(async (a) => {
      let l;
      try {
        l = await a.relatedCodeProvider?.provideRelatedTests?.(r.document, s, n);
      } catch (c) {
        n.isCancellationRequested || this.logService.warn(`Error thrown while providing related tests for ${a.controller.label}`, c);
      }
      if (l) {
        for (const c of l)
          o.push(Ne.fromExtHostTestItem(c, a.controller.id).toString());
        a.collection.flushDiff();
      }
    })), o;
  }
  async $getCodeRelatedToTest(e, i) {
    const n = this.controllers.get(Ne.root(e));
    if (!n)
      return [];
    const r = n.collection.tree.get(e);
    return r ? (await n.relatedCodeProvider?.provideRelatedCode?.(r.actual, i))?.map(an.from) ?? [] : [];
  }
  $syncTests() {
    for (const { collection: e } of this.controllers.values())
      e.flushDiff();
    return Promise.resolve();
  }
  async $getCoverageDetails(e, i, n) {
    return (await this.runTracker.getCoverageDetails(e, i, n))?.map(Hh.fromDetails);
  }
  async $disposeRun(e) {
    this.runTracker.disposeTestRun(e);
  }
  $configureRunProfile(e, i) {
    this.controllers.get(e)?.profiles.get(i)?.configureHandler?.();
  }
  $setDefaultRunProfiles(e) {
    const i = /* @__PURE__ */ new Map();
    for (const [n, r] of Object.entries(e)) {
      const s = this.controllers.get(n);
      if (!s)
        continue;
      const o = /* @__PURE__ */ new Map(), a = r.filter((c) => !s.activeProfiles.has(c)), l = [...s.activeProfiles].filter((c) => !r.includes(c));
      for (const c of a)
        o.set(c, !0), s.activeProfiles.add(c);
      for (const c of l)
        o.set(c, !1), s.activeProfiles.delete(c);
      o.size && i.set(n, o);
    }
    this.defaultProfilesChangedEmitter.fire(i);
  }
  async $refreshTests(e, i) {
    await this.controllers.get(e)?.controller.refreshHandler?.(i);
  }
  $publishTestResults(e) {
    this.results = Object.freeze(e.map((i) => {
      const n = Qb.to(i), r = i.tasks.findIndex((s) => s.hasCoverage);
      return r !== -1 && (n.getDetailedCoverage = (s, o = xt.None) => this.proxy.$getCoverageDetails(i.id, r, s, o).then((a) => a.map(Hh.to))), qI.set(n, i.id), n;
    }).concat(this.results).sort((i, n) => n.completedAt - i.completedAt).slice(0, 32)), this.resultsChangedEmitter.fire();
  }
  async $expandTest(e, i) {
    const n = this.controllers.get(Ne.fromString(e).controllerId)?.collection;
    n && (await n.expand(e, i < 0 ? 1 / 0 : i), n.flushDiff());
  }
  $acceptDiff(e) {
    this.observer.applyDiff(e.map((i) => wg.deserialize({ asCanonicalUri: (n) => n }, i)));
  }
  async $runControllerTests(e, i) {
    return Promise.all(e.map((n) => this.runControllerTestRequest(n, !1, i)));
  }
  async $startContinuousRun(e, i) {
    const n = new Pt(i), r = await Promise.all(e.map((s) => this.runControllerTestRequest(s, !0, n.token)));
    return !i.isCancellationRequested && !r.some((s) => s.error) && await new Promise((s) => i.onCancellationRequested(s)), n.dispose(!0), r;
  }
  async $provideTestFollowups(e, i) {
    const n = this.results.find((o) => qI.get(o) === e.resultId), r = n && RO(Ne.fromString(e.extId), n?.results);
    if (!r)
      return [];
    let s = [];
    return await Promise.all([...this.followupProviders].map(async (o) => {
      try {
        const a = await o.provideFollowup(n, r, e.taskIndex, e.messageIndex, i);
        a && (s = s.concat(a));
      } catch (a) {
        this.logService.error("Error thrown while providing followup for test message", a);
      }
    })), i.isCancellationRequested ? [] : s.map((o) => {
      const a = DO++;
      return this.testFollowups.set(a, o), { title: o.title, id: a };
    });
  }
  $disposeTestFollowups(e) {
    for (const i of e)
      this.testFollowups.delete(i);
  }
  $executeTestFollowup(e) {
    const i = this.testFollowups.get(e);
    return i ? this.commands.executeCommand(i.command, ...i.arguments || []) : Promise.resolve();
  }
  $cancelExtensionTestRun(e, i) {
    e === void 0 ? this.runTracker.cancelAllRuns() : this.runTracker.cancelRunById(e, i);
  }
  getMetadataForRun(e) {
    for (const i of this.runTracker.trackers) {
      const n = i.getTaskIdForRun(e);
      if (n)
        return { taskId: n, runId: i.id };
    }
  }
  async runControllerTestRequest(e, i, n) {
    const r = this.controllers.get(e.controllerId);
    if (!r)
      return {};
    const { collection: s, profiles: o, extension: a } = r, l = o.get(e.profileId);
    if (!l)
      return {};
    const c = e.testIds.map((g) => s.tree.get(g)).filter(Tn), u = e.excludeExtIds.map((g) => r.collection.tree.get(g)).filter(Tn).filter((g) => c.some((_) => _.fullId.compare(g.fullId) === nr.IsChild));
    if (!c.length)
      return {};
    const d = new em(c.some((g) => g.actual instanceof wE) ? void 0 : c.map((g) => g.actual), u.map((g) => g.actual), l, i), f = A9(e) && this.runTracker.prepareForMainThreadTestRun(a, d, ef.fromInternal(e, r.collection), l, n);
    try {
      return await l.runHandler(d, n), {};
    } catch (g) {
      return { error: String(g) };
    } finally {
      f && f.hasRunningTasks && !n.isCancellationRequested && await It.toPromise(f.onEnd);
    }
  }
};
p0 = W([
  M(0, Ye),
  M(1, nt),
  M(2, vl),
  M(3, Su)
], p0);
const kO = 1e4;
var io;
(function(t) {
  t[t.Running = 0] = "Running", t[t.Cancelling = 1] = "Cancelling", t[t.Ended = 2] = "Ended";
})(io || (io = {}));
class IO extends ve {
  get hasRunningTasks() {
    return this.running > 0;
  }
  get id() {
    return this.dto.id;
  }
  constructor(e, i, n, r, s, o) {
    super(), this.dto = e, this.proxy = i, this.logService = n, this.profile = r, this.extension = s, this.state = io.Running, this.running = 0, this.tasks = /* @__PURE__ */ new Map(), this.sharedTestIds = /* @__PURE__ */ new Set(), this.endEmitter = this._register(new N()), this.publishedCoverage = /* @__PURE__ */ new Map(), this.onEnd = this.endEmitter.event, this.cts = this._register(new Pt(o));
    const a = this._register(new cl(() => this.forciblyEndTasks(), kO));
    this._register(this.cts.token.onCancellationRequested(() => a.schedule()));
    const l = new N();
    this.onDidDispose = l.event, this._register(Ee(() => {
      l.fire(), l.dispose();
    }));
  }
  getTaskIdForRun(e) {
    for (const [i, { run: n }] of this.tasks)
      if (n === e)
        return i;
  }
  cancel(e) {
    e ? this.tasks.get(e)?.cts.cancel() : this.state === io.Running ? (this.cts.cancel(), this.state = io.Cancelling) : this.state === io.Cancelling && this.forciblyEndTasks();
  }
  async getCoverageDetails(e, i, n) {
    const [, r] = Ne.fromString(e).path, s = this.publishedCoverage.get(e);
    if (!s)
      return [];
    const { report: o, extIds: a } = s, l = this.tasks.get(r);
    if (!l)
      throw new Error("unreachable: run task was not found");
    let c;
    if (i && o instanceof tu) {
      const d = a.indexOf(i);
      if (d === -1)
        return [];
      c = o.includesTests[d];
    }
    return await (c ? this.profile?.loadDetailedCoverageForTest?.(l.run, o, c, n) : this.profile?.loadDetailedCoverage?.(l.run, o, n)) ?? [];
  }
  createRun(e) {
    const i = this.dto.id, n = this.dto.controllerId, r = on(), s = (u) => (d, ...f) => {
      if (a) {
        this.logService.warn(`Setting the state of test "${d.id}" is a no-op after the run ends.`);
        return;
      }
      this.ensureTestIsKnown(d), u(d, ...f);
    }, o = (u, d) => {
      const f = d instanceof Array ? d.map(du.from) : [du.from(d)];
      if (u.uri && u.range) {
        const g = { range: z.from(u.range), uri: u.uri };
        for (const _ of f)
          _.location = _.location || g;
      }
      this.proxy.$appendTestMessagesInRun(i, r, Ne.fromExtHostTestItem(u, n).toString(), f);
    };
    let a = !1;
    const l = this._register(new Pt(this.cts.token)), c = {
      isPersisted: this.dto.isPersisted,
      token: l.token,
      name: e,
      onDidDispose: this.onDidDispose,
      addCoverage: (u) => {
        if (a)
          return;
        const d = u instanceof tu ? u.includesTests : [];
        if (d.length)
          for (const _ of d)
            this.ensureTestIsKnown(_);
        const f = u.uri.toString(), g = new Ne([i, r, f]).toString();
        this.publishedCoverage.set(g, { report: u, extIds: d.map((_) => Ne.fromExtHostTestItem(_, n).toString()) }), this.proxy.$appendCoverage(i, r, Hh.fromFile(n, g, u));
      },
      enqueued: s((u) => {
        this.proxy.$updateTestStateInRun(i, r, Ne.fromExtHostTestItem(u, n).toString(), ii.Queued);
      }),
      skipped: s((u) => {
        this.proxy.$updateTestStateInRun(i, r, Ne.fromExtHostTestItem(u, n).toString(), ii.Skipped);
      }),
      started: s((u) => {
        this.proxy.$updateTestStateInRun(i, r, Ne.fromExtHostTestItem(u, n).toString(), ii.Running);
      }),
      errored: s((u, d, f) => {
        o(u, d), this.proxy.$updateTestStateInRun(i, r, Ne.fromExtHostTestItem(u, n).toString(), ii.Errored, f);
      }),
      failed: s((u, d, f) => {
        o(u, d), this.proxy.$updateTestStateInRun(i, r, Ne.fromExtHostTestItem(u, n).toString(), ii.Failed, f);
      }),
      passed: s((u, d) => {
        this.proxy.$updateTestStateInRun(i, r, Ne.fromExtHostTestItem(u, this.dto.controllerId).toString(), ii.Passed, d);
      }),
      appendOutput: (u, d, f) => {
        a || (f && this.ensureTestIsKnown(f), this.proxy.$appendOutputToRun(i, r, ue.fromString(u), d && an.from(d), f && Ne.fromExtHostTestItem(f, n).toString()));
      },
      end: () => {
        a || (a = !0, this.proxy.$finishedTestRunTask(i, r), --this.running || this.markEnded());
      }
    };
    return this.running++, this.tasks.set(r, { run: c, cts: l }), this.proxy.$startedTestRunTask(i, {
      id: r,
      ctrlId: this.dto.controllerId,
      name: e || this.extension.displayName || this.extension.identifier.value,
      running: !0
    }), c;
  }
  forciblyEndTasks() {
    for (const { run: e } of this.tasks.values())
      e.end();
  }
  markEnded() {
    this.state !== io.Ended && (this.state = io.Ended, this.endEmitter.fire());
  }
  ensureTestIsKnown(e) {
    if (!(e instanceof _l))
      throw new bg(e.id);
    if (this.sharedTestIds.has(Ne.fromExtHostTestItem(e, this.dto.controllerId).toString()))
      return;
    const i = [], n = this.dto.colllection.root;
    for (; ; ) {
      const r = Ao.from(e);
      if (i.unshift(r), this.sharedTestIds.has(r.extId) || (this.sharedTestIds.add(r.extId), e === n))
        break;
      e = e.parent || n;
    }
    this.proxy.$addTestsToRun(this.dto.controllerId, this.dto.id, i);
  }
  dispose() {
    this.markEnded(), super.dispose();
  }
}
class CO {
  get trackers() {
    return this.tracked.values();
  }
  constructor(e, i) {
    this.proxy = e, this.logService = i, this.tracked = /* @__PURE__ */ new Map(), this.trackedById = /* @__PURE__ */ new Map();
  }
  getCoverageDetails(e, i, n) {
    const r = Ne.root(e);
    return this.trackedById.get(r)?.getCoverageDetails(e, i, n) || [];
  }
  disposeTestRun(e) {
    this.trackedById.get(e)?.dispose(), this.trackedById.delete(e);
    for (const [i, { id: n }] of this.tracked)
      n === e && this.tracked.delete(i);
  }
  prepareForMainThreadTestRun(e, i, n, r, s) {
    return this.getTracker(i, n, r, e, s);
  }
  cancelRunById(e, i) {
    this.trackedById.get(e)?.cancel(i);
  }
  cancelAllRuns() {
    for (const e of this.tracked.values())
      e.cancel();
  }
  createTestRun(e, i, n, r, s, o) {
    const a = this.tracked.get(r);
    if (a)
      return a.createRun(s);
    const l = ef.fromPublic(i, n, r, o), c = v5(r);
    this.proxy.$startedExtensionTestRun({
      controllerId: i,
      continuous: !!r.continuous,
      profile: c && { group: hu.from(c.kind), id: c.profileId },
      exclude: r.exclude?.map((d) => Ne.fromExtHostTestItem(d, n.root.id).toString()) ?? [],
      id: l.id,
      include: r.include?.map((d) => Ne.fromExtHostTestItem(d, n.root.id).toString()) ?? [n.root.id],
      preserveFocus: r.preserveFocus ?? !0,
      persist: o
    });
    const u = this.getTracker(r, l, r.profile, e);
    return It.once(u.onEnd)(() => {
      this.proxy.$finishedExtensionTestRun(l.id);
    }), u.createRun(s);
  }
  getTracker(e, i, n, r, s) {
    const o = new IO(i, this.proxy, this.logService, n, r, s);
    return this.tracked.set(e, o), this.trackedById.set(o.id, o), o;
  }
}
const v5 = (t) => {
  if (t.profile) {
    if (!(t.profile instanceof w5))
      throw new Error(
        "TestRunRequest.profile is not an instance created from TestController.createRunProfile"
      );
    return t.profile;
  }
};
class ef {
  static fromPublic(e, i, n, r) {
    return new ef(e, on(), r, i);
  }
  static fromInternal(e, i) {
    return new ef(e.controllerId, e.runId, !0, i);
  }
  constructor(e, i, n, r) {
    this.controllerId = e, this.id = i, this.isPersisted = n, this.colllection = r;
  }
}
class TO {
  get isEmpty() {
    return this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0;
  }
  constructor(e) {
    this.emitter = e, this.added = /* @__PURE__ */ new Set(), this.updated = /* @__PURE__ */ new Set(), this.removed = /* @__PURE__ */ new Set(), this.alreadyRemoved = /* @__PURE__ */ new Set();
  }
  add(e) {
    this.added.add(e);
  }
  update(e) {
    Object.assign(e.revived, Ao.toPlain(e.item)), this.added.has(e) || this.updated.add(e);
  }
  remove(e) {
    if (this.added.has(e)) {
      this.added.delete(e);
      return;
    }
    this.updated.delete(e);
    const i = Ne.parentId(e.item.extId);
    if (i && this.alreadyRemoved.has(i.toString())) {
      this.alreadyRemoved.add(e.item.extId);
      return;
    }
    this.removed.add(e);
  }
  getChangeEvent() {
    const { added: e, updated: i, removed: n } = this;
    return {
      get added() {
        return [...e].map((r) => r.revived);
      },
      get updated() {
        return [...i].map((r) => r.revived);
      },
      get removed() {
        return [...n].map((r) => r.revived);
      }
    };
  }
  complete() {
    this.isEmpty || this.emitter.fire(this.getChangeEvent());
  }
}
class PO extends R9 {
  constructor() {
    super(...arguments), this.changeEmitter = new N(), this.onDidChangeTests = this.changeEmitter.event;
  }
  get rootTests() {
    return this.roots;
  }
  getMirroredTestDataById(e) {
    return this.items.get(e);
  }
  getMirroredTestDataByReference(e) {
    return this.items.get(e.id);
  }
  createItem(e, i) {
    return {
      ...e,
      revived: Ao.toPlain(e.item),
      depth: i ? i.depth + 1 : 0,
      children: /* @__PURE__ */ new Set()
    };
  }
  createChangeCollector() {
    return new TO(this.changeEmitter);
  }
}
class AO {
  constructor(e) {
    this.proxy = e;
  }
  checkout() {
    this.current || (this.current = this.createObserverData());
    const e = this.current;
    return e.observers++, {
      onDidChangeTest: e.tests.onDidChangeTests,
      get tests() {
        return [...e.tests.rootTests].map((i) => i.revived);
      },
      dispose: vx(() => {
        --e.observers === 0 && (this.proxy.$unsubscribeFromDiffs(), this.current = void 0);
      })
    };
  }
  getMirroredTestDataByReference(e) {
    return this.current?.tests.getMirroredTestDataByReference(e);
  }
  applyDiff(e) {
    this.current?.tests.apply(e);
  }
  createObserverData() {
    const e = new PO({ asCanonicalUri: (i) => i });
    return this.proxy.$subscribeToDiffs(), { observers: 0, tests: e };
  }
}
const Wu = (t, e, i, n) => {
  i ? Object.assign(i, n) : e.$updateTestRunConfig(t.controllerId, t.profileId, n);
};
class w5 extends nP {
  #e;
  #t;
  #i;
  #n;
  #s;
  get label() {
    return this._label;
  }
  set label(e) {
    e !== this._label && (this._label = e, Wu(this, this.#e, this.#n, { label: e }));
  }
  get supportsContinuousRun() {
    return this._supportsContinuousRun;
  }
  set supportsContinuousRun(e) {
    e !== this._supportsContinuousRun && (this._supportsContinuousRun = e, Wu(this, this.#e, this.#n, { supportsContinuousRun: e }));
  }
  get isDefault() {
    return this.#t.has(this.profileId);
  }
  set isDefault(e) {
    e !== this.isDefault && (e ? this.#t.add(this.profileId) : this.#t.delete(this.profileId), Wu(this, this.#e, this.#n, { isDefault: e }));
  }
  get tag() {
    return this._tag;
  }
  set tag(e) {
    e?.id !== this._tag?.id && (this._tag = e, Wu(this, this.#e, this.#n, {
      tag: e ? wr.namespace(this.controllerId, e.id) : null
    }));
  }
  get configureHandler() {
    return this._configureHandler;
  }
  set configureHandler(e) {
    e !== this._configureHandler && (this._configureHandler = e, Wu(this, this.#e, this.#n, { hasConfigurationHandler: !!e }));
  }
  get onDidChangeDefault() {
    return It.chain(this.#i, (e) => e.map((i) => i.get(this.controllerId)?.get(this.profileId)).filter(Tn));
  }
  constructor(e, i, n, r, s, o, a, l, c, u = !1, d = void 0, f = !1) {
    super(s, o, l), this._label = a, this.runHandler = c, this._tag = d, this._supportsContinuousRun = f, this.#e = e, this.#s = i, this.#t = n, this.#i = r, i.set(o, this);
    const g = hu.from(l);
    u && n.add(o), this.#n = {
      profileId: o,
      controllerId: s,
      tag: d ? wr.namespace(this.controllerId, d.id) : null,
      label: a,
      group: g,
      isDefault: u,
      hasConfigurationHandler: !1,
      supportsContinuousRun: f
    }, queueMicrotask(() => {
      this.#n && (this.#e.$publishTestRunProfile(this.#n), this.#n = void 0);
    });
  }
  dispose() {
    this.#s?.delete(this.profileId) && (this.#s = void 0, this.#e.$removeTestProfile(this.controllerId, this.profileId)), this.#n = void 0;
  }
}
function RO(t, e) {
  for (let i = 0; i < t.path.length; i++) {
    const n = e.find((r) => r.id === t.path[i]);
    if (!n)
      return;
    if (i === t.path.length - 1)
      return n;
    e = n.children;
  }
}
var wt;
(function(t) {
  t.Unknown = "unknown", t.Env = "env", t.Config = "config", t.Command = "command", t.Input = "input", t.ExtensionInstallFolder = "extensionInstallFolder", t.WorkspaceFolder = "workspaceFolder", t.Cwd = "cwd", t.WorkspaceFolderBasename = "workspaceFolderBasename", t.UserHome = "userHome", t.LineNumber = "lineNumber", t.ColumnNumber = "columnNumber", t.SelectedText = "selectedText", t.File = "file", t.FileWorkspaceFolder = "fileWorkspaceFolder", t.FileWorkspaceFolderBasename = "fileWorkspaceFolderBasename", t.RelativeFile = "relativeFile", t.RelativeFileDirname = "relativeFileDirname", t.FileDirname = "fileDirname", t.FileExtname = "fileExtname", t.FileBasename = "fileBasename", t.FileBasenameNoExtension = "fileBasenameNoExtension", t.FileDirnameBasename = "fileDirnameBasename", t.ExecPath = "execPath", t.ExecInstallFolder = "execInstallFolder", t.PathSeparator = "pathSeparator", t.PathSeparatorAlias = "/";
})(wt || (wt = {}));
const LO = Object.values(wt).filter((t) => typeof t == "string");
class Qi extends Xr {
  constructor(e, i) {
    super(i), this.variable = e;
  }
}
const Od = class Od {
  constructor(e) {
    this.locations = /* @__PURE__ */ new Map(), this.newReplacementNotifiers = /* @__PURE__ */ new Set(), typeof e == "string" ? (this.stringRoot = !0, this.root = { value: e }) : (this.stringRoot = !1, this.root = structuredClone(e));
  }
  static parse(e) {
    if (e instanceof Od)
      return e;
    const i = new Od(e);
    return i.applyPlatformSpecificKeys(), i.parseObject(i.root), i;
  }
  applyPlatformSpecificKeys() {
    const e = this.root, i = ji ? "windows" : Rn ? "osx" : So ? "linux" : void 0;
    i && e && typeof e == "object" && e.hasOwnProperty(i) && Object.keys(e[i]).forEach((n) => e[n] = e[i][n]), delete e.windows, delete e.osx, delete e.linux;
  }
  parseVariable(e, i) {
    if (e[i] !== "$" || e[i + 1] !== "{")
      return;
    let n = i + 2, r = 1;
    for (; n < e.length; ) {
      if (e[n] === "{")
        r++;
      else if (e[n] === "}" && (r--, r === 0))
        break;
      n++;
    }
    if (r !== 0)
      return;
    const s = e.slice(i, n + 1), o = e.substring(i + 2, n), a = o.indexOf(":");
    return a === -1 ? { replacement: { id: s, name: o, inner: o }, end: n } : {
      replacement: {
        id: s,
        inner: o,
        name: o.slice(0, a),
        arg: o.slice(a + 1)
      },
      end: n
    };
  }
  parseObject(e) {
    if (!(typeof e != "object" || e === null)) {
      if (Array.isArray(e)) {
        for (let i = 0; i < e.length; i++) {
          const n = e[i];
          typeof n == "string" ? this.parseString(e, i, n) : this.parseObject(n);
        }
        return;
      }
      for (const [i, n] of Object.entries(e))
        this.parseString(e, i, i, !0), typeof n == "string" ? this.parseString(e, i, n) : this.parseObject(n);
    }
  }
  parseString(e, i, n, r, s) {
    let o = 0;
    for (; o < n.length; ) {
      const a = n.indexOf("${", o);
      if (a === -1)
        break;
      const l = this.parseVariable(n, a);
      if (l) {
        if (o = l.end + 1, s?.includes(l.replacement.id))
          continue;
        const c = this.locations.get(l.replacement.id) || { locations: [], replacement: l.replacement }, u = { object: e, propertyName: i, replaceKeyName: r };
        c.locations.push(u), this.locations.set(l.replacement.id, c), c.resolved ? this._resolveAtLocation(l.replacement, u, c.resolved, s) : this.newReplacementNotifiers.forEach((d) => d(l.replacement));
      } else
        o = a + 2;
    }
  }
  *unresolved() {
    const e = /* @__PURE__ */ new Map(), i = (n) => {
      e.set(n.id, n);
    };
    for (const n of this.locations.values())
      n.resolved === void 0 && e.set(n.replacement.id, n.replacement);
    for (this.newReplacementNotifiers.add(i); ; ) {
      const n = Oi.first(e);
      if (!n)
        break;
      const [r, s] = n;
      yield s, e.delete(r);
    }
    this.newReplacementNotifiers.delete(i);
  }
  resolved() {
    return Oi.map(Oi.filter(this.locations.values(), (e) => !!e.resolved), (e) => [e.replacement, e.resolved]);
  }
  resolve(e, i) {
    typeof i != "object" && (i = { value: String(i) });
    const n = this.locations.get(e.id);
    if (n && (n.resolved = i, i.value !== void 0))
      for (const r of n.locations || Oi.empty())
        this._resolveAtLocation(e, r, i);
  }
  _resolveAtLocation(e, { replaceKeyName: i, propertyName: n, object: r }, s, o = []) {
    if (s.value !== void 0) {
      if (o.push(e.id), i && typeof n == "string") {
        const a = r[n], l = n.replaceAll(e.id, s.value);
        delete r[n], r[l] = a, this._renameKeyInLocations(r, n, l), this.parseString(r, l, s.value, !0, o);
      } else
        r[n] = r[n].replaceAll(e.id, s.value), this.parseString(r, n, s.value, !1, o);
      o.pop();
    }
  }
  _renameKeyInLocations(e, i, n) {
    for (const r of this.locations.values())
      for (const s of r.locations)
        s.object === e && s.propertyName === i && (s.propertyName = n);
  }
  toObject() {
    return this.stringRoot ? this.root.value : this.root;
  }
};
Od.VARIABLE_LHS = "${";
let i_ = Od;
class NO {
  constructor(e, i, n, r) {
    this._contributedVariables = /* @__PURE__ */ new Map(), this.resolvableVariables = new Set(LO), this._context = e, this._labelService = i, this._userHomePromise = n, r && (this._envVariablesPromise = r.then((s) => this.prepareEnv(s)));
  }
  prepareEnv(e) {
    if (ji) {
      const i = /* @__PURE__ */ Object.create(null);
      return Object.keys(e).forEach((n) => {
        i[n.toLowerCase()] = e[n];
      }), i;
    }
    return e;
  }
  async resolveWithEnvironment(e, i, n) {
    const r = i_.parse(n);
    for (const s of r.unresolved()) {
      const o = await this.evaluateSingleVariable(s, i?.uri, e);
      o !== void 0 && r.resolve(s, String(o));
    }
    return r.toObject();
  }
  async resolveAsync(e, i) {
    const n = i_.parse(i);
    for (const r of n.unresolved()) {
      const s = await this.evaluateSingleVariable(r, e?.uri);
      s !== void 0 && n.resolve(r, String(s));
    }
    return n.toObject();
  }
  resolveWithInteractionReplace(e, i) {
    throw new Error("resolveWithInteractionReplace not implemented.");
  }
  resolveWithInteraction(e, i) {
    throw new Error("resolveWithInteraction not implemented.");
  }
  contributeVariable(e, i) {
    if (this._contributedVariables.has(e))
      throw new Error("Variable " + e + " is contributed twice.");
    this.resolvableVariables.add(e), this._contributedVariables.set(e, i);
  }
  fsPath(e) {
    return this._labelService ? this._labelService.getUriLabel(e, { noPrefix: !0 }) : e.fsPath;
  }
  async evaluateSingleVariable(e, i, n, r) {
    const s = {
      env: n !== void 0 ? this.prepareEnv(n) : await this._envVariablesPromise,
      userHome: n !== void 0 ? void 0 : await this._userHomePromise
    }, { name: o, arg: a } = e, l = (d) => {
      const f = this._context.getFilePath();
      if (f)
        return Uu(f);
      throw new Qi(d, h(
        12946,
        "Variable {0} can not be resolved. Please open an editor.",
        e.id
      ));
    }, c = (d) => {
      const f = l(d);
      if (this._context.getWorkspaceFolderPathForFile) {
        const g = this._context.getWorkspaceFolderPathForFile();
        if (g)
          return Uu(g);
      }
      throw new Qi(d, h(
        12947,
        "Variable {0}: can not find workspace folder of '{1}'.",
        e.id,
        mn(f)
      ));
    }, u = (d) => {
      if (a) {
        const f = this._context.getFolderUri(a);
        if (f)
          return f;
        throw new Qi(d, h(
          12948,
          "Variable {0} can not be resolved. No such folder '{1}'.",
          d,
          a
        ));
      }
      if (i)
        return i;
      throw this._context.getWorkspaceFolderCount() > 1 ? new Qi(d, h(
        12949,
        "Variable {0} can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.",
        d
      )) : new Qi(d, h(
        12950,
        "Variable {0} can not be resolved. Please open a folder.",
        d
      ));
    };
    switch (o) {
      case "env":
        if (a) {
          if (s.env) {
            const d = s.env[ji ? a.toLowerCase() : a];
            if (it(d))
              return d;
          }
          return "";
        }
        throw new Qi(wt.Env, h(
          12951,
          "Variable {0} can not be resolved because no environment variable name is given.",
          e.id
        ));
      case "config":
        if (a) {
          const d = this._context.getConfigurationValue(i, a);
          if (ni(d))
            throw new Qi(wt.Config, h(
              12952,
              "Variable {0} can not be resolved because setting '{1}' not found.",
              e.id,
              a
            ));
          if (ri(d))
            throw new Qi(wt.Config, h(
              12953,
              "Variable {0} can not be resolved because '{1}' is a structured value.",
              e.id,
              a
            ));
          return d;
        }
        throw new Qi(wt.Config, h(
          12954,
          "Variable {0} can not be resolved because no settings name is given.",
          e.id
        ));
      case "command":
        return this.resolveFromMap(wt.Command, e.id, a, r, "command");
      case "input":
        return this.resolveFromMap(wt.Input, e.id, a, r, "input");
      case "extensionInstallFolder":
        if (a) {
          const d = await this._context.getExtension(a);
          if (!d)
            throw new Qi(wt.ExtensionInstallFolder, h(
              12955,
              "Variable {0} can not be resolved because the extension {1} is not installed.",
              e.id,
              a
            ));
          return this.fsPath(d.extensionLocation);
        }
        throw new Qi(wt.ExtensionInstallFolder, h(
          12956,
          "Variable {0} can not be resolved because no extension name is given.",
          e.id
        ));
      default:
        switch (o) {
          case "workspaceRoot":
          case "workspaceFolder": {
            const d = u(wt.WorkspaceFolder);
            return d ? Uu(this.fsPath(d)) : void 0;
          }
          case "cwd": {
            if (!i && !a)
              return $c();
            const d = u(wt.Cwd);
            return d ? Uu(this.fsPath(d)) : void 0;
          }
          case "workspaceRootFolderName":
          case "workspaceFolderBasename": {
            const d = u(wt.WorkspaceFolderBasename);
            return d ? Uu(mn(this.fsPath(d))) : void 0;
          }
          case "userHome":
            if (s.userHome)
              return s.userHome;
            throw new Qi(wt.UserHome, h(
              12957,
              "Variable {0} can not be resolved. UserHome path is not defined",
              e.id
            ));
          case "lineNumber": {
            const d = this._context.getLineNumber();
            if (d)
              return d;
            throw new Qi(wt.LineNumber, h(
              12958,
              "Variable {0} can not be resolved. Make sure to have a line selected in the active editor.",
              e.id
            ));
          }
          case "columnNumber": {
            const d = this._context.getColumnNumber();
            if (d)
              return d;
            throw new Error(h(
              12959,
              "Variable {0} can not be resolved. Make sure to have a column selected in the active editor.",
              e.id
            ));
          }
          case "selectedText": {
            const d = this._context.getSelectedText();
            if (d)
              return d;
            throw new Qi(wt.SelectedText, h(
              12960,
              "Variable {0} can not be resolved. Make sure to have some text selected in the active editor.",
              e.id
            ));
          }
          case "file":
            return l(wt.File);
          case "fileWorkspaceFolder":
            return c(wt.FileWorkspaceFolder);
          case "fileWorkspaceFolderBasename":
            return mn(c(wt.FileWorkspaceFolderBasename));
          case "relativeFile":
            return i || a ? zd(this.fsPath(u(wt.RelativeFile)), l(wt.RelativeFile)) : l(wt.RelativeFile);
          case "relativeFileDirname": {
            const d = cc(l(wt.RelativeFileDirname));
            if (i || a) {
              const f = zd(this.fsPath(u(wt.RelativeFileDirname)), d);
              return f.length === 0 ? "." : f;
            }
            return d;
          }
          case "fileDirname":
            return cc(l(wt.FileDirname));
          case "fileExtname":
            return Op(l(wt.FileExtname));
          case "fileBasename":
            return mn(l(wt.FileBasename));
          case "fileBasenameNoExtension": {
            const d = mn(l(wt.FileBasenameNoExtension));
            return d.slice(0, d.length - Op(d).length);
          }
          case "fileDirnameBasename":
            return mn(cc(l(wt.FileDirnameBasename)));
          case "execPath": {
            const d = this._context.getExecPath();
            return d || e.id;
          }
          case "execInstallFolder": {
            const d = this._context.getAppRoot();
            return d || e.id;
          }
          case "pathSeparator":
          case "/":
            return Vn;
          default:
            try {
              return this.resolveFromMap(wt.Unknown, e.id, a, r, void 0);
            } catch {
              return e.id;
            }
        }
    }
  }
  resolveFromMap(e, i, n, r, s) {
    if (n && r) {
      const o = s === void 0 ? r[n] : r[s + ":" + n];
      if (typeof o == "string")
        return o;
      throw new Qi(e, h(
        12961,
        "Variable {0} can not be resolved because the command has no value.",
        i
      ));
    }
    return i;
  }
}
const IE = pe("IExtHostVariableResolverProvider");
class MO extends NO {
  constructor(e, i, n, r, s, o, a) {
    function l() {
      if (n) {
        const c = n.activeEditor();
        if (c)
          return c.document.uri;
        const u = r.tabGroups.all.find((d) => d.isActive)?.activeTab;
        if (u !== void 0) {
          if (u.input instanceof im || u.input instanceof nE)
            return u.input.modified;
          if (u.input instanceof eE || u.input instanceof iE || u.input instanceof tE)
            return u.input.uri;
        }
      }
    }
    super({
      getFolderUri: (c) => {
        const u = o.folders.filter((d) => d.name === c);
        if (u && u.length > 0)
          return u[0].uri;
      },
      getWorkspaceFolderCount: () => o.folders.length,
      getConfigurationValue: (c, u) => s.getConfiguration(void 0, c).get(u),
      getAppRoot: () => $c(),
      getExecPath: () => Vd.VSCODE_EXEC_PATH,
      getFilePath: () => {
        const c = l();
        if (c)
          return Hc(c.fsPath);
      },
      getWorkspaceFolderPathForFile: () => {
        if (i) {
          const c = l();
          if (c) {
            const u = i.getWorkspaceFolder(c);
            if (u)
              return Hc(u.uri.fsPath);
          }
        }
      },
      getSelectedText: () => {
        if (n) {
          const c = n.activeEditor();
          if (c && !c.selection.isEmpty)
            return c.document.getText(c.selection);
        }
      },
      getLineNumber: () => {
        if (n) {
          const c = n.activeEditor();
          if (c)
            return String(c.selection.end.line + 1);
        }
      },
      getColumnNumber: () => {
        if (n) {
          const c = n.activeEditor();
          if (c)
            return String(c.selection.end.character + 1);
        }
      },
      getExtension: (c) => e.getExtension(c)
    }, void 0, a ? Promise.resolve(a) : void 0, Promise.resolve(Vd));
  }
}
let g0 = class extends ve {
  constructor(e, i, n, r, s) {
    super(), this.extensionService = e, this.workspaceService = i, this.editorService = n, this.configurationService = r, this.editorTabs = s, this._resolver = new Vi(async () => {
      const o = await this.configurationService.getConfigProvider(), l = { folders: await this.workspaceService.getWorkspaceFolders2() || [] };
      return this._register(this.workspaceService.onDidChangeWorkspace(async (c) => {
        l.folders = await this.workspaceService.getWorkspaceFolders2() || [];
      })), new MO(
        this.extensionService,
        this.workspaceService,
        this.editorService,
        this.editorTabs,
        o,
        l,
        this.homeDir()
      );
    });
  }
  getResolver() {
    return this._resolver.value;
  }
  homeDir() {
  }
};
g0 = W([
  M(0, Mo),
  M(1, Us),
  M(2, Su),
  M(3, $s),
  M(4, bf)
], g0);
const b5 = pe("IExtHostDebugService");
let m0 = class extends ve {
  get onDidStartDebugSession() {
    return this._onDidStartDebugSession.event;
  }
  get onDidTerminateDebugSession() {
    return this._onDidTerminateDebugSession.event;
  }
  get onDidChangeActiveDebugSession() {
    return this._onDidChangeActiveDebugSession.event;
  }
  get activeDebugSession() {
    return this._activeDebugSession?.api;
  }
  get onDidReceiveDebugSessionCustomEvent() {
    return this._onDidReceiveDebugSessionCustomEvent.event;
  }
  get activeDebugConsole() {
    return this._activeDebugConsole.value;
  }
  constructor(e, i, n, r, s, o, a, l) {
    super(), this._workspaceService = i, this._extensionService = n, this._configurationService = r, this._editorTabs = s, this._variableResolver = o, this._commands = a, this._testing = l, this._debugSessions = /* @__PURE__ */ new Map(), this._debugVisualizationTreeItemIdsCounter = 0, this._debugVisualizationProviders = /* @__PURE__ */ new Map(), this._debugVisualizationTrees = /* @__PURE__ */ new Map(), this._debugVisualizationTreeItemIds = /* @__PURE__ */ new WeakMap(), this._debugVisualizationElements = /* @__PURE__ */ new Map(), this._visualizers = /* @__PURE__ */ new Map(), this._visualizerIdCounter = 0, this._configProviderHandleCounter = 0, this._configProviders = [], this._adapterFactoryHandleCounter = 0, this._adapterFactories = [], this._trackerFactoryHandleCounter = 0, this._trackerFactories = [], this._debugAdapters = /* @__PURE__ */ new Map(), this._debugAdaptersTrackers = /* @__PURE__ */ new Map(), this._onDidStartDebugSession = this._register(new N()), this._onDidTerminateDebugSession = this._register(new N()), this._onDidChangeActiveDebugSession = this._register(new N()), this._onDidReceiveDebugSessionCustomEvent = this._register(new N()), this._debugServiceProxy = e.getProxy(ee.MainThreadDebugService), this._onDidChangeBreakpoints = this._register(new N()), this._onDidChangeActiveStackItem = this._register(new N()), this._activeDebugConsole = new FO(this._debugServiceProxy), this._breakpoints = /* @__PURE__ */ new Map(), this._extensionService.getExtensionRegistry().then((c) => {
      this._register(c.onDidChange((u) => {
        this.registerAllDebugTypes(c);
      })), this.registerAllDebugTypes(c);
    }), this._telemetryProxy = e.getProxy(ee.MainThreadTelemetry);
  }
  async $getVisualizerTreeItem(e, i) {
    const n = this.hydrateVisualizationContext(i);
    if (!n)
      return;
    const r = await this._debugVisualizationTrees.get(e)?.getTreeItem?.(n);
    return r ? this.convertVisualizerTreeItem(e, r) : void 0;
  }
  registerDebugVisualizationTree(e, i, n) {
    const r = ht.toKey(e.identifier), s = this.extensionVisKey(r, i);
    if (this._debugVisualizationProviders.has(s))
      throw new Error(`A debug visualization provider with id '${i}' is already registered`);
    return this._debugVisualizationTrees.set(s, n), this._debugServiceProxy.$registerDebugVisualizerTree(s, !!n.editItem), Ee(() => {
      this._debugServiceProxy.$unregisterDebugVisualizerTree(s), this._debugVisualizationTrees.delete(i);
    });
  }
  async $getVisualizerTreeItemChildren(e, i) {
    const n = this._debugVisualizationElements.get(i)?.item;
    return n ? (await this._debugVisualizationTrees.get(e)?.getChildren?.(n))?.map((s) => this.convertVisualizerTreeItem(e, s)) || [] : [];
  }
  async $editVisualizerTreeItem(e, i) {
    const n = this._debugVisualizationElements.get(e);
    if (!n)
      return;
    const r = await this._debugVisualizationTrees.get(n.provider)?.editItem?.(n.item, i);
    return this.convertVisualizerTreeItem(n.provider, r || n.item);
  }
  $disposeVisualizedTree(e) {
    const i = this._debugVisualizationElements.get(e);
    if (!i)
      return;
    const n = [i.children];
    for (const r of n)
      if (r)
        for (const s of r)
          n.push(this._debugVisualizationElements.get(s)?.children), this._debugVisualizationElements.delete(s);
  }
  convertVisualizerTreeItem(e, i) {
    let n = this._debugVisualizationTreeItemIds.get(i);
    return n || (n = this._debugVisualizationTreeItemIdsCounter++, this._debugVisualizationTreeItemIds.set(i, n), this._debugVisualizationElements.set(n, { provider: e, item: i })), uy.from(i, n);
  }
  asDebugSourceUri(e, i) {
    const n = e;
    if (typeof n.sourceReference == "number" && n.sourceReference > 0) {
      let r = `debug:${encodeURIComponent(n.path || "")}`, s = "?";
      return i && (r += `${s}session=${encodeURIComponent(i.id)}`, s = "&"), r += `${s}ref=${n.sourceReference}`, x.parse(r);
    } else {
      if (n.path)
        return x.file(n.path);
      throw new Error(
        "cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing."
      );
    }
  }
  registerAllDebugTypes(e) {
    const i = [];
    for (const n of e.getAllExtensionDescriptions())
      if (n.contributes) {
        const r = n.contributes.debuggers;
        if (r && r.length > 0)
          for (const s of r)
            mO(s) && i.push(s.type);
      }
    this._debugServiceProxy.$registerDebugTypes(i);
  }
  get activeStackItem() {
    return this._activeStackItem;
  }
  get onDidChangeActiveStackItem() {
    return this._onDidChangeActiveStackItem.event;
  }
  get onDidChangeBreakpoints() {
    return this._onDidChangeBreakpoints.event;
  }
  get breakpoints() {
    const e = [];
    return this._breakpoints.forEach((i) => e.push(i)), e;
  }
  async $resolveDebugVisualizer(e, i) {
    const n = this._visualizers.get(e);
    if (!n)
      throw new Error(`No debug visualizer found with id '${e}'`);
    let { v: r, provider: s, extensionId: o } = n;
    if (r.visualization || (r = await s.resolveDebugVisualization?.(r, i) || r, n.v = r), !r.visualization)
      throw new Error(
        `No visualization returned from resolveDebugVisualization in '${s}'`
      );
    return this.serializeVisualization(o, r.visualization);
  }
  async $executeDebugVisualizerCommand(e) {
    const i = this._visualizers.get(e);
    if (!i)
      throw new Error(`No debug visualizer found with id '${e}'`);
    const n = i.v.visualization;
    n && "command" in n && this._commands.executeCommand(n.command, ...n.arguments || []);
  }
  hydrateVisualizationContext(e) {
    const i = this._debugSessions.get(e.sessionId);
    return i && {
      session: i.api,
      variable: e.variable,
      containerId: e.containerId,
      frameId: e.frameId,
      threadId: e.threadId
    };
  }
  async $provideDebugVisualizers(e, i, n, r) {
    const s = this.hydrateVisualizationContext(n), o = this.extensionVisKey(e, i), a = this._debugVisualizationProviders.get(o);
    if (!s || !a)
      return [];
    const l = await a.provideDebugVisualization(s, r);
    return l ? l.map((c) => {
      const u = ++this._visualizerIdCounter;
      this._visualizers.set(u, { v: c, provider: a, extensionId: e });
      const d = c.iconPath ? this.getIconPathOrClass(c.iconPath) : void 0;
      return {
        id: u,
        name: c.name,
        iconClass: d?.iconClass,
        iconPath: d?.iconPath,
        visualization: this.serializeVisualization(e, c.visualization)
      };
    }) : [];
  }
  $disposeDebugVisualizers(e) {
    for (const i of e)
      this._visualizers.delete(i);
  }
  registerDebugVisualizationProvider(e, i, n) {
    if (!e.contributes?.debugVisualizers?.some((o) => o.id === i))
      throw new Error(
        `Extensions may only call registerDebugVisualizationProvider() for renderers they contribute (got ${i})`
      );
    const r = ht.toKey(e.identifier), s = this.extensionVisKey(r, i);
    if (this._debugVisualizationProviders.has(s))
      throw new Error(`A debug visualization provider with id '${i}' is already registered`);
    return this._debugVisualizationProviders.set(s, n), this._debugServiceProxy.$registerDebugVisualizer(r, i), Ee(() => {
      this._debugServiceProxy.$unregisterDebugVisualizer(r, i), this._debugVisualizationProviders.delete(i);
    });
  }
  addBreakpoints(e) {
    const i = e.filter((s) => {
      const o = s.id;
      return this._breakpoints.has(o) ? !1 : (this._breakpoints.set(o, s), !0);
    });
    this.fireBreakpointChanges(i, [], []);
    const n = [], r = /* @__PURE__ */ new Map();
    for (const s of i)
      if (s instanceof ma) {
        let o = r.get(s.location.uri.toString());
        o || (o = {
          type: "sourceMulti",
          uri: s.location.uri,
          lines: []
        }, r.set(s.location.uri.toString(), o), n.push(o)), o.lines.push({
          id: s.id,
          enabled: s.enabled,
          condition: s.condition,
          hitCondition: s.hitCondition,
          logMessage: s.logMessage,
          line: s.location.range.start.line,
          character: s.location.range.start.character,
          mode: s.mode
        });
      } else s instanceof _a && n.push({
        type: "function",
        id: s.id,
        enabled: s.enabled,
        hitCondition: s.hitCondition,
        logMessage: s.logMessage,
        condition: s.condition,
        functionName: s.functionName,
        mode: s.mode
      });
    return this._debugServiceProxy.$registerBreakpoints(n);
  }
  removeBreakpoints(e) {
    const i = e.filter((o) => this._breakpoints.delete(o.id));
    this.fireBreakpointChanges([], i, []);
    const n = i.filter((o) => o instanceof ma).map((o) => o.id), r = i.filter((o) => o instanceof _a).map((o) => o.id), s = i.filter((o) => o instanceof Hg).map((o) => o.id);
    return this._debugServiceProxy.$unregisterBreakpoints(n, r, s);
  }
  startDebugging(e, i, n) {
    const r = n.testRun && this._testing.getMetadataForRun(n.testRun);
    return this._debugServiceProxy.$startDebugging(e ? e.uri : void 0, i, {
      parentSessionID: n.parentSession ? n.parentSession.id : void 0,
      lifecycleManagedByParent: n.lifecycleManagedByParent,
      repl: n.consoleMode === Gg.MergeWithParent ? "mergeWithParent" : "separate",
      noDebug: n.noDebug,
      compact: n.compact,
      suppressSaveBeforeStart: n.suppressSaveBeforeStart,
      testRun: r && {
        runId: r.runId,
        taskId: r.taskId
      },
      suppressDebugStatusbar: n.suppressDebugStatusbar ?? n.debugUI?.simple,
      suppressDebugToolbar: n.suppressDebugToolbar ?? n.debugUI?.simple,
      suppressDebugView: n.suppressDebugView ?? n.debugUI?.simple
    });
  }
  stopDebugging(e) {
    return this._debugServiceProxy.$stopDebugging(e ? e.id : void 0);
  }
  registerDebugConfigurationProvider(e, i, n) {
    if (!i)
      return new Ve(() => {
      });
    const r = this._configProviderHandleCounter++;
    return this._configProviders.push({ type: e, handle: r, provider: i }), this._debugServiceProxy.$registerDebugConfigurationProvider(e, n, !!i.provideDebugConfigurations, !!i.resolveDebugConfiguration, !!i.resolveDebugConfigurationWithSubstitutedVariables, r), new Ve(() => {
      this._configProviders = this._configProviders.filter((s) => s.provider !== i), this._debugServiceProxy.$unregisterDebugConfigurationProvider(r);
    });
  }
  registerDebugAdapterDescriptorFactory(e, i, n) {
    if (!n)
      return new Ve(() => {
      });
    if (!this.definesDebugType(e, i))
      throw new Error(
        `a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${i}' debugger.`
      );
    if (this.getAdapterDescriptorFactoryByType(i))
      throw new Error("a DebugAdapterDescriptorFactory can only be registered once per a type.");
    const r = this._adapterFactoryHandleCounter++;
    return this._adapterFactories.push({ type: i, handle: r, factory: n }), this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(i, r), new Ve(() => {
      this._adapterFactories = this._adapterFactories.filter((s) => s.factory !== n), this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(r);
    });
  }
  registerDebugAdapterTrackerFactory(e, i) {
    if (!i)
      return new Ve(() => {
      });
    const n = this._trackerFactoryHandleCounter++;
    return this._trackerFactories.push({ type: e, handle: n, factory: i }), new Ve(() => {
      this._trackerFactories = this._trackerFactories.filter((r) => r.factory !== i);
    });
  }
  async $runInTerminal(e, i) {
    return Promise.resolve(void 0);
  }
  async $substituteVariables(e, i) {
    let n;
    const r = await this.getFolder(e);
    return r && (n = {
      uri: r.uri,
      name: r.name,
      index: r.index,
      toResource: () => {
        throw new Error("Not implemented");
      }
    }), (await this._variableResolver.getResolver()).resolveAsync(n, i);
  }
  createDebugAdapter(e, i) {
    if (e instanceof _h)
      return new $O(e.implementation);
  }
  createSignService() {
  }
  async $startDASession(e, i) {
    const n = this, r = await this.getSession(i);
    return this.getAdapterDescriptor(this.getAdapterDescriptorFactoryByType(r.type), r).then((s) => {
      if (!s)
        throw new Error(
          `Couldn't find a debug adapter descriptor for debug type '${r.type}' (extension might have failed to activate)`
        );
      const o = this.createDebugAdapter(s, r);
      if (!o)
        throw new Error(`Couldn't create a debug adapter for type '${r.type}'.`);
      const a = o;
      return this._debugAdapters.set(e, a), this.getDebugAdapterTrackers(r).then((l) => (l && this._debugAdaptersTrackers.set(e, l), a.onMessage(async (c) => {
        if (c.type === "request" && c.command === "handshake") {
          const u = c, d = {
            type: "response",
            seq: 0,
            command: u.command,
            request_seq: u.seq,
            success: !0
          };
          this._signService || (this._signService = this.createSignService());
          try {
            if (this._signService) {
              const f = await this._signService.sign(u.arguments.value);
              d.body = {
                signature: f
              }, a.sendResponse(d);
            } else
              throw new Error("no signer");
          } catch (f) {
            d.success = !1, d.message = f.message, a.sendResponse(d);
          }
        } else {
          l && l.onDidSendMessage && l.onDidSendMessage(c);
          try {
            c = xO(c, !0);
          } catch (u) {
            const d = c.type + "_" + (c.command ?? c.event ?? "");
            throw this._telemetryProxy.$publicLog2("debugProtocolMessageError", { type: d, from: r.type }), u;
          }
          n._debugServiceProxy.$acceptDAMessage(e, c);
        }
      }), a.onError((c) => {
        l && l.onError && l.onError(c), this._debugServiceProxy.$acceptDAError(e, c.name, c.message, c.stack);
      }), a.onExit((c) => {
        l && l.onExit && l.onExit(c ?? void 0, void 0), this._debugServiceProxy.$acceptDAExit(e, c ?? void 0, void 0);
      }), l && l.onWillStartSession && l.onWillStartSession(), a.startSession()));
    });
  }
  $sendDAMessage(e, i) {
    i = yO(i);
    const n = this._debugAdaptersTrackers.get(e);
    n && n.onWillReceiveMessage && n.onWillReceiveMessage(i), this._debugAdapters.get(e)?.sendMessage(i);
  }
  $stopDASession(e) {
    const i = this._debugAdaptersTrackers.get(e);
    this._debugAdaptersTrackers.delete(e), i && i.onWillStopSession && i.onWillStopSession();
    const n = this._debugAdapters.get(e);
    return this._debugAdapters.delete(e), n ? n.stopSession() : Promise.resolve(void 0);
  }
  $acceptBreakpointsDelta(e) {
    const i = [], n = [], r = [];
    if (e.added)
      for (const s of e.added) {
        const o = s.id;
        if (o && !this._breakpoints.has(o)) {
          let a;
          if (s.type === "function")
            a = new _a(
              s.functionName,
              s.enabled,
              s.condition,
              s.hitCondition,
              s.logMessage,
              s.mode
            );
          else if (s.type === "data")
            a = new Hg(
              s.label,
              s.dataId,
              s.canPersist,
              s.enabled,
              s.hitCondition,
              s.condition,
              s.logMessage,
              s.mode
            );
          else {
            const l = x.revive(s.uri);
            a = new ma(new Ln(l, new je(s.line, s.character)), s.enabled, s.condition, s.hitCondition, s.logMessage, s.mode);
          }
          n6(a, o), this._breakpoints.set(o, a), i.push(a);
        }
      }
    if (e.removed)
      for (const s of e.removed) {
        const o = this._breakpoints.get(s);
        o && (this._breakpoints.delete(s), n.push(o));
      }
    if (e.changed) {
      for (const s of e.changed)
        if (s.id) {
          const o = this._breakpoints.get(s.id);
          if (o) {
            if (o instanceof _a && s.type === "function") {
              const a = o;
              a.enabled = s.enabled, a.condition = s.condition, a.hitCondition = s.hitCondition, a.logMessage = s.logMessage, a.functionName = s.functionName;
            } else if (o instanceof ma && s.type === "source") {
              const a = o;
              a.enabled = s.enabled, a.condition = s.condition, a.hitCondition = s.hitCondition, a.logMessage = s.logMessage, a.location = new Ln(x.revive(s.uri), new je(s.line, s.character));
            }
            r.push(o);
          }
        }
    }
    this.fireBreakpointChanges(i, n, r);
  }
  async $acceptStackFrameFocus(e) {
    let i;
    if (e) {
      const n = await this.getSession(e.sessionId);
      e.kind === "thread" ? i = new XT(n.api, e.threadId) : i = new YT(n.api, e.threadId, e.frameId);
    }
    this._activeStackItem = i, this._onDidChangeActiveStackItem.fire(this._activeStackItem);
  }
  $provideDebugConfigurations(e, i, n) {
    return Ai(async () => {
      const r = this.getConfigProviderByHandle(e);
      if (!r)
        throw new Error("no DebugConfigurationProvider found");
      if (!r.provideDebugConfigurations)
        throw new Error("DebugConfigurationProvider has no method provideDebugConfigurations");
      const s = await this.getFolder(i);
      return r.provideDebugConfigurations(s, n);
    }).then((r) => {
      if (!r)
        throw new Error(
          "nothing returned from DebugConfigurationProvider.provideDebugConfigurations"
        );
      return r;
    });
  }
  $resolveDebugConfiguration(e, i, n, r) {
    return Ai(async () => {
      const s = this.getConfigProviderByHandle(e);
      if (!s)
        throw new Error("no DebugConfigurationProvider found");
      if (!s.resolveDebugConfiguration)
        throw new Error("DebugConfigurationProvider has no method resolveDebugConfiguration");
      const o = await this.getFolder(i);
      return s.resolveDebugConfiguration(o, n, r);
    });
  }
  $resolveDebugConfigurationWithSubstitutedVariables(e, i, n, r) {
    return Ai(async () => {
      const s = this.getConfigProviderByHandle(e);
      if (!s)
        throw new Error("no DebugConfigurationProvider found");
      if (!s.resolveDebugConfigurationWithSubstitutedVariables)
        throw new Error(
          "DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables"
        );
      const o = await this.getFolder(i);
      return s.resolveDebugConfigurationWithSubstitutedVariables(o, n, r);
    });
  }
  async $provideDebugAdapter(e, i) {
    const n = this.getAdapterDescriptorFactoryByHandle(e);
    if (!n)
      return Promise.reject(new Error("no adapter descriptor factory found for handle"));
    const r = await this.getSession(i);
    return this.getAdapterDescriptor(n, r).then((s) => {
      if (!s)
        throw new Error(
          `Couldn't find a debug adapter descriptor for debug type '${r.type}'`
        );
      return this.convertToDto(s);
    });
  }
  async $acceptDebugSessionStarted(e) {
    const i = await this.getSession(e);
    this._onDidStartDebugSession.fire(i.api);
  }
  async $acceptDebugSessionTerminated(e) {
    const i = await this.getSession(e);
    i && (this._onDidTerminateDebugSession.fire(i.api), this._debugSessions.delete(i.id));
  }
  async $acceptDebugSessionActiveChanged(e) {
    this._activeDebugSession = e ? await this.getSession(e) : void 0, this._onDidChangeActiveDebugSession.fire(this._activeDebugSession?.api);
  }
  async $acceptDebugSessionNameChanged(e, i) {
    (await this.getSession(e))?._acceptNameChanged(i);
  }
  async $acceptDebugSessionCustomEvent(e, i) {
    const r = {
      session: (await this.getSession(e)).api,
      event: i.event,
      body: i.body
    };
    this._onDidReceiveDebugSessionCustomEvent.fire(r);
  }
  convertToDto(e) {
    if (e instanceof Bg)
      return this.convertExecutableToDto(e);
    if (e instanceof mh)
      return this.convertServerToDto(e);
    if (e instanceof Wg)
      return this.convertPipeServerToDto(e);
    if (e instanceof _h)
      return this.convertImplementationToDto(e);
    throw new Error("convertToDto unexpected type");
  }
  convertExecutableToDto(e) {
    return {
      type: "executable",
      command: e.command,
      args: e.args,
      options: e.options
    };
  }
  convertServerToDto(e) {
    return {
      type: "server",
      port: e.port,
      host: e.host
    };
  }
  convertPipeServerToDto(e) {
    return {
      type: "pipeServer",
      path: e.path
    };
  }
  convertImplementationToDto(e) {
    return {
      type: "implementation"
    };
  }
  getAdapterDescriptorFactoryByType(e) {
    const i = this._adapterFactories.filter((n) => n.type === e);
    if (i.length > 0)
      return i[0].factory;
  }
  getAdapterDescriptorFactoryByHandle(e) {
    const i = this._adapterFactories.filter((n) => n.handle === e);
    if (i.length > 0)
      return i[0].factory;
  }
  getConfigProviderByHandle(e) {
    const i = this._configProviders.filter((n) => n.handle === e);
    if (i.length > 0)
      return i[0].provider;
  }
  definesDebugType(e, i) {
    if (e.contributes) {
      const n = e.contributes.debuggers;
      if (n && n.length > 0) {
        for (const r of n)
          if (r.label && r.type && r.type === i)
            return !0;
      }
    }
    return !1;
  }
  getDebugAdapterTrackers(e) {
    const n = e.configuration.type, r = this._trackerFactories.filter((s) => s.type === n || s.type === "*").map(
      (s) => Ai(() => s.factory.createDebugAdapterTracker(e.api)).then((o) => o, (o) => null)
    );
    return Promise.race([
      Promise.all(r).then((s) => {
        const o = Kt(s);
        if (o.length > 0)
          return new UO(o);
      }),
      new Promise((s) => setTimeout(() => s(void 0), 1e3))
    ]).catch((s) => {
    });
  }
  async getAdapterDescriptor(e, i) {
    const n = i.configuration.debugServer;
    if (typeof n == "number")
      return Promise.resolve(new mh(n));
    if (e) {
      const s = await this._extensionService.getExtensionRegistry();
      return Ai(() => e.createDebugAdapterDescriptor(i.api, this.daExecutableFromPackage(i, s))).then((o) => {
        if (o)
          return o;
      });
    }
    const r = await this._extensionService.getExtensionRegistry();
    return Promise.resolve(this.daExecutableFromPackage(i, r));
  }
  daExecutableFromPackage(e, i) {
  }
  fireBreakpointChanges(e, i, n) {
    (e.length > 0 || i.length > 0 || n.length > 0) && this._onDidChangeBreakpoints.fire(Object.freeze({
      added: e,
      removed: i,
      changed: n
    }));
  }
  async getSession(e) {
    if (e)
      if (typeof e == "string") {
        const i = this._debugSessions.get(e);
        if (i)
          return i;
      } else {
        let i = this._debugSessions.get(e.id);
        if (!i) {
          const n = await this.getFolder(e.folderUri), r = e.parent ? this._debugSessions.get(e.parent) : void 0;
          i = new OO(
            this._debugServiceProxy,
            e.id,
            e.type,
            e.name,
            n,
            e.configuration,
            r?.api
          ), this._debugSessions.set(i.id, i), this._debugServiceProxy.$sessionCached(i.id);
        }
        return i;
      }
    throw new Error("cannot find session");
  }
  getFolder(e) {
    if (e) {
      const i = x.revive(e);
      return this._workspaceService.resolveWorkspaceFolder(i);
    }
    return Promise.resolve(void 0);
  }
  extensionVisKey(e, i) {
    return `${e}\0${i}`;
  }
  serializeVisualization(e, i) {
    if (i) {
      if ("title" in i && "command" in i)
        return { type: cg.Command };
      if ("treeId" in i)
        return { type: cg.Tree, id: `${e}\0${i.treeId}` };
      throw new Error("Unsupported debug visualization type");
    }
  }
  getIconPathOrClass(e) {
    const i = this.getIconUris(e);
    let n, r;
    return "id" in i ? r = oi.asClassName(i) : n = i, {
      iconPath: n,
      iconClass: r
    };
  }
  getIconUris(e) {
    if (e instanceof qi)
      return { id: e.id };
    const i = typeof e == "object" && "dark" in e ? e.dark : e, n = typeof e == "object" && "light" in e ? e.light : e;
    return {
      dark: typeof i == "string" ? x.file(i) : i,
      light: typeof n == "string" ? x.file(n) : n
    };
  }
};
m0 = W([
  M(0, Ye),
  M(1, Us),
  M(2, Mo),
  M(3, $s),
  M(4, bf),
  M(5, IE),
  M(6, vl),
  M(7, g1)
], m0);
class OO {
  constructor(e, i, n, r, s, o, a) {
    this._debugServiceProxy = e, this._id = i, this._type = n, this._name = r, this._workspaceFolder = s, this._configuration = o, this._parentSession = a;
  }
  get api() {
    const e = this;
    return this.apiSession ??= Object.freeze({
      id: e._id,
      type: e._type,
      get name() {
        return e._name;
      },
      set name(i) {
        e._name = i, e._debugServiceProxy.$setDebugSessionName(e._id, i);
      },
      parentSession: e._parentSession,
      workspaceFolder: e._workspaceFolder,
      configuration: e._configuration,
      customRequest(i, n) {
        return e._debugServiceProxy.$customDebugAdapterRequest(e._id, i, n);
      },
      getDebugProtocolBreakpoint(i) {
        return e._debugServiceProxy.$getDebugProtocolBreakpoint(e._id, i.id);
      }
    });
  }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  _acceptNameChanged(e) {
    this._name = e;
  }
  get configuration() {
    return this._configuration;
  }
}
class FO {
  constructor(e) {
    this.value = Object.freeze({
      append(i) {
        e.$appendDebugConsole(i);
      },
      appendLine(i) {
        this.append(i + `
`);
      }
    });
  }
}
class UO {
  constructor(e) {
    this.trackers = e;
  }
  onWillStartSession() {
    this.trackers.forEach((e) => e.onWillStartSession ? e.onWillStartSession() : void 0);
  }
  onWillReceiveMessage(e) {
    this.trackers.forEach((i) => i.onWillReceiveMessage ? i.onWillReceiveMessage(e) : void 0);
  }
  onDidSendMessage(e) {
    this.trackers.forEach((i) => i.onDidSendMessage ? i.onDidSendMessage(e) : void 0);
  }
  onWillStopSession() {
    this.trackers.forEach((e) => e.onWillStopSession ? e.onWillStopSession() : void 0);
  }
  onError(e) {
    this.trackers.forEach((i) => i.onError ? i.onError(e) : void 0);
  }
  onExit(e, i) {
    this.trackers.forEach((n) => n.onExit ? n.onExit(e, i) : void 0);
  }
}
class $O extends gO {
  constructor(e) {
    super(), this.implementation = e, e.onDidSendMessage((i) => {
      this.acceptMessage(i);
    });
  }
  startSession() {
    return Promise.resolve(void 0);
  }
  sendMessage(e) {
    this.implementation.handleMessage(e);
  }
  stopSession() {
    return this.implementation.dispose(), Promise.resolve(void 0);
  }
}
let _0 = class extends m0 {
  constructor(e, i, n, r, s, o, a, l) {
    super(e, i, n, r, s, o, a, l);
  }
};
_0 = W([
  M(0, Ye),
  M(1, Us),
  M(2, Mo),
  M(3, $s),
  M(4, bf),
  M(5, IE),
  M(6, vl),
  M(7, g1)
], _0);
function HO(t) {
  return "uri" in t && "ranges" in t && "preview" in t;
}
function BO(t) {
  return t.folderOptions.map((e) => ({
    folder: e.folder,
    excludes: e.excludes.map((i) => typeof i == "string" ? i : i.pattern),
    includes: e.includes,
    useGlobalIgnoreFiles: e.useIgnoreFiles.global,
    useIgnoreFiles: e.useIgnoreFiles.local,
    useParentIgnoreFiles: e.useIgnoreFiles.parent,
    followSymlinks: e.followSymlinks,
    maxResults: t.maxResults,
    session: t.session
  }));
}
class y5 {
  constructor(e) {
    this.provider = e;
  }
  provideFileSearchResults(e, i, n) {
    return (async () => {
      const s = BO(i);
      return Promise.all(s.map((o) => this.provider.provideFileSearchResults({ pattern: e }, o, n)));
    })().then((s) => Kt(s).flat());
  }
}
function WO(t) {
  return t.folderOptions.map((e) => ({
    folder: e.folder,
    excludes: e.excludes.map((i) => typeof i == "string" ? i : i.pattern),
    includes: e.includes,
    useGlobalIgnoreFiles: e.useIgnoreFiles.global,
    useIgnoreFiles: e.useIgnoreFiles.local,
    useParentIgnoreFiles: e.useIgnoreFiles.parent,
    followSymlinks: e.followSymlinks,
    maxResults: t.maxResults,
    previewOptions: VO(t.previewOptions),
    maxFileSize: t.maxFileSize,
    encoding: e.encoding,
    afterContext: t.surroundingContext,
    beforeContext: t.surroundingContext
  }));
}
function VO(t) {
  return {
    matchLines: t?.matchLines ?? py.matchLines,
    charsPerLine: t?.charsPerLine ?? py.charsPerLine
  };
}
function zO(t) {
  if (HO(t)) {
    const e = qn(t.ranges).map((i, n) => {
      const s = qn(t.preview.matches)[n];
      return { sourceRange: i, previewRange: s };
    });
    return new go(t.uri, e, t.preview.text);
  } else
    return new hE(t.uri, t.text, t.lineNumber);
}
class qO {
  constructor(e) {
    this.provider = e;
  }
  provideTextSearchResults(e, i, n, r) {
    const s = (l) => {
      jO(l) && n.report(zO(l));
    };
    return (async () => Kt(await Promise.all(WO(i).map(
      (l) => this.provider.provideTextSearchResults(e, l, { report: (c) => s(c) }, r)
    ))).reduce((l, c) => ({ limitHit: l.limitHit || c.limitHit }), { limitHit: !1 }))().then((l) => ({
      limitHit: l.limitHit,
      message: Kt(qn(l.message))
    }));
  }
}
function jO(t) {
  if (GO(t)) {
    if (Array.isArray(t.ranges)) {
      if (!Array.isArray(t.preview.matches))
        return console.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same type."), !1;
      if (t.preview.matches.length !== t.ranges.length)
        return console.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same length."), !1;
    } else if (Array.isArray(t.preview.matches))
      return console.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same length."), !1;
  }
  return !0;
}
function GO(t) {
  return !!t.preview;
}
class x5 extends $r {
  constructor(e, i, n = () => !1) {
    const r = new q4(n, () => !1);
    super(r);
    const s = new fi();
    e.forEach((o, a) => {
      const l = o.folder.with({ query: "", fragment: "" });
      s.has(l) ? s.get(l).push({ fq: o, i: a }) : s.set(l, [{ fq: o, i: a }]);
    }), s.forEach((o, a) => {
      const l = /* @__PURE__ */ new Map();
      for (const c of o) {
        const u = i(c.fq, c.i);
        l.set(this.encodeKey(c.fq.folder), u);
      }
      super.set(a, l);
    });
  }
  findQueryFragmentAwareSubstr(e) {
    const i = super.findSubstr(e.with({ query: "", fragment: "" }));
    if (!i)
      return;
    const n = this.encodeKey(e);
    return i.get(n);
  }
  forEachFolderQueryInfo(e) {
    return this.forEach((i) => i.forEach((n) => e(n)));
  }
  encodeKey(e) {
    let i = "";
    return e.query && (i += e.query), e.fragment && (i += "#" + e.fragment), i;
  }
}
class QO {
  constructor(e, i, n) {
    this.config = e, this.provider = i, this.sessionLifecycle = n, this.isLimitHit = !1, this.resultCount = 0, this.isCanceled = !1, this.filePattern = e.filePattern, this.includePattern = e.includePattern && qc(e.includePattern), this.maxResults = e.maxResults || void 0, this.exists = e.exists, this.activeCancellationTokens = /* @__PURE__ */ new Set(), this.globalExcludePattern = e.excludePattern && qc(e.excludePattern);
  }
  cancel() {
    this.isCanceled = !0, this.activeCancellationTokens.forEach((e) => e.cancel()), this.activeCancellationTokens = /* @__PURE__ */ new Set();
  }
  search(e) {
    const i = this.config.folderQueries || [];
    return new Promise((n, r) => {
      const s = (o) => {
        this.resultCount++, e(o);
      };
      if (this.isCanceled)
        return n({ limitHit: this.isLimitHit });
      this.config.extraFileResources && this.config.extraFileResources.forEach((o) => {
        const a = o.toString(), l = mn(a);
        this.globalExcludePattern && this.globalExcludePattern(a, l) || this.matchFile(s, { base: o, basename: l });
      }), this.doSearch(i, s).then((o) => {
        n({
          limitHit: this.isLimitHit,
          stats: o || void 0
        });
      }, (o) => {
        r(new Error(xu(o)));
      });
    });
  }
  async doSearch(e, i) {
    const n = new Pt(), r = e.map((u) => this.getSearchOptionsForFolder(u)), s = this.provider instanceof y5 ? this.sessionLifecycle?.tokenSource.token : this.sessionLifecycle?.obj, o = {
      folderOptions: r,
      maxResults: this.config.maxResults ?? MP,
      session: s
    }, a = (u) => {
      const d = new $P(this.config, u), f = !d.hasSiblingExcludeClauses();
      return { queryTester: d, noSiblingsClauses: f, folder: u.folder, tree: this.initDirectoryTree() };
    }, l = new x5(e, a);
    let c;
    try {
      this.activeCancellationTokens.add(n), c = Ms.create();
      const u = await this.provider.provideFileSearchResults(this.config.filePattern || "", o, n.token), d = c.elapsed(), f = Ms.create();
      return this.isCanceled && !this.isLimitHit || (u && u.forEach((g) => {
        const _ = l.findQueryFragmentAwareSubstr(g), w = dt.relative(_.folder.path, g.path);
        if (_.noSiblingsClauses) {
          const v = mn(g.path);
          this.matchFile(i, { base: _.folder, relativePath: w, basename: v });
          return;
        }
        this.addDirectoryEntries(_.tree, _.folder, w, i);
      }), this.isCanceled && !this.isLimitHit) ? null : (l.forEachFolderQueryInfo((g) => {
        this.matchDirectoryTree(g.tree, g.queryTester, i);
      }), {
        providerTime: d,
        postProcessTime: f.elapsed()
      });
    } finally {
      n.dispose(), this.activeCancellationTokens.delete(n);
    }
  }
  getSearchOptionsForFolder(e) {
    const i = kc(this.config.includePattern, e.includePattern);
    let n = e.excludePattern?.map((s) => ({
      folder: s.folder,
      patterns: kc(this.config.excludePattern, s.pattern)
    }));
    n?.length || (n = [{
      folder: void 0,
      patterns: kc(this.config.excludePattern, void 0)
    }]);
    const r = BP(n);
    return {
      folder: e.folder,
      excludes: r,
      includes: i,
      useIgnoreFiles: {
        local: !e.disregardIgnoreFiles,
        parent: !e.disregardParentIgnoreFiles,
        global: !e.disregardGlobalIgnoreFiles
      },
      followSymlinks: !e.ignoreSymlinks
    };
  }
  initDirectoryTree() {
    const e = {
      rootEntries: [],
      pathToEntries: /* @__PURE__ */ Object.create(null)
    };
    return e.pathToEntries["."] = e.rootEntries, e;
  }
  addDirectoryEntries({ pathToEntries: e }, i, n, r) {
    if (n === this.filePattern) {
      const o = mn(this.filePattern);
      this.matchFile(r, { base: i, relativePath: this.filePattern, basename: o });
    }
    function s(o) {
      const a = mn(o), l = cc(o);
      let c = e[l];
      c || (c = e[l] = [], s(l)), c.push({
        base: i,
        relativePath: o,
        basename: a
      });
    }
    s(n);
  }
  matchDirectoryTree({ rootEntries: e, pathToEntries: i }, n, r) {
    const s = this, o = this.filePattern;
    function a(l) {
      const c = tN(() => l.map((u) => u.basename));
      for (let u = 0, d = l.length; u < d; u++) {
        const f = l[u], { relativePath: g, basename: _ } = f;
        if (n.matchesExcludesSync(g, _, o !== _ ? c : void 0))
          continue;
        const w = i[g];
        if (w)
          a(w);
        else {
          if (g === o)
            continue;
          s.matchFile(r, f);
        }
        if (s.isLimitHit)
          break;
      }
    }
    a(e);
  }
  matchFile(e, i) {
    (!this.includePattern || i.relativePath && this.includePattern(i.relativePath, i.basename)) && ((this.exists || this.maxResults && this.resultCount >= this.maxResults) && (this.isLimitHit = !0, this.cancel()), this.isLimitHit || e(i));
  }
}
class KO {
  constructor() {
    this._obj = new Object(), this.tokenSource = new Pt();
  }
  get obj() {
    if (this._obj)
      return this._obj;
    throw new Error("Session object has been dereferenced.");
  }
  cancel() {
    this.tokenSource.cancel(), this._obj = void 0;
  }
}
const x_ = class x_ {
  constructor() {
    this.sessions = /* @__PURE__ */ new Map();
  }
  fileSearch(e, i, n, r) {
    const s = this.getSessionTokenSource(e.cacheKey), o = new QO(e, i, s);
    let a = 0;
    const l = (c) => {
      a += c.length, n(c.map((u) => this.rawMatchToSearchItem(u)));
    };
    return this.doSearch(o, x_.BATCH_SIZE, l, r).then((c) => ({
      limitHit: c.limitHit,
      stats: c.stats ? {
        fromCache: !1,
        type: "fileSearchProvider",
        resultCount: a,
        detailStats: c.stats
      } : void 0,
      messages: []
    }));
  }
  clearCache(e) {
    this.sessions.get(e)?.cancel(), this.sessions.delete(e);
  }
  getSessionTokenSource(e) {
    if (e)
      return this.sessions.has(e) || this.sessions.set(e, new KO()), this.sessions.get(e);
  }
  rawMatchToSearchItem(e) {
    return e.relativePath ? {
      resource: wi(e.base, e.relativePath)
    } : {
      resource: e.base
    };
  }
  doSearch(e, i, n, r) {
    const s = r.onCancellationRequested(() => {
      e.cancel();
    }), o = (l) => {
      l && (a.push(l), i > 0 && a.length >= i && (n(a), a = []));
    };
    let a = [];
    return e.search(o).then((l) => (a.length && n(a), s.dispose(), l), (l) => (a.length && n(a), s.dispose(), Promise.reject(l)));
  }
};
x_.BATCH_SIZE = 512;
let v0 = x_;
class jI {
  constructor(e, i, n) {
    this.queryProviderPair = e, this.fileUtils = i, this.processType = n, this.collector = null, this.isLimitHit = !1, this.resultCount = 0;
  }
  get query() {
    return this.queryProviderPair.query;
  }
  search(e, i, n) {
    const r = this.query.folderQueries || [], s = new Pt(i);
    return new Promise((o, a) => {
      this.collector = new YO(e);
      let l = !1;
      const c = (u, d) => {
        if (!(u instanceof fy) && !l && !this.isLimitHit) {
          const f = this.resultSize(u);
          u instanceof go && typeof this.query.maxResults == "number" && this.resultCount + f > this.query.maxResults && (this.isLimitHit = !0, l = !0, s.cancel(), u = this.trimResultToSize(u, this.query.maxResults - this.resultCount));
          const g = this.resultSize(u);
          this.resultCount += g;
          const _ = u instanceof go;
          (g > 0 || !_) && this.collector.add(u, d);
        }
      };
      this.doSearch(r, c, s.token, n).then((u) => {
        s.dispose(), this.collector.flush(), o({
          limitHit: this.isLimitHit || u?.limitHit,
          messages: this.getMessagesFromResults(u),
          stats: {
            type: this.processType
          }
        });
      }, (u) => {
        s.dispose();
        const d = xu(u);
        a(new Error(d));
      });
    });
  }
  getMessagesFromResults(e) {
    return e?.message ? Array.isArray(e.message) ? e.message : [e.message] : [];
  }
  resultSize(e) {
    return e instanceof go ? Array.isArray(e.ranges) ? e.ranges.length : 1 : 0;
  }
  trimResultToSize(e, i) {
    return new go(e.uri, e.ranges.slice(0, i), e.previewText);
  }
  async doSearch(e, i, n, r) {
    const s = new x5(e, (d, f) => ({ queryTester: new $P(this.query, d), folder: d.folder, folderIdx: f }), () => !0), o = [], a = {
      report: (d) => {
        if (d instanceof fy)
          r?.(d);
        else {
          if (d.uri === void 0)
            throw Error("Text search result URI is undefined. Please check provider implementation.");
          const f = s.findQueryFragmentAwareSubstr(d.uri), g = f.folder.scheme === de.file ? eN(() => this.fileUtils.readdir(H_(d.uri))) : void 0, _ = O4(f.folder, d.uri);
          if (_) {
            const w = f.queryTester.includedInQuery(_, mn(_), g);
            Do(w) ? o.push(w.then((v) => {
              v && i(d, f.folderIdx);
            })) : w && i(d, f.folderIdx);
          }
        }
      }
    }, c = {
      folderOptions: e.map((d) => this.getSearchOptionsForFolder(d)),
      maxFileSize: this.query.maxFileSize,
      maxResults: this.query.maxResults ?? MP,
      previewOptions: this.query.previewOptions ?? py,
      surroundingContext: this.query.surroundingContext ?? 0
    };
    "usePCRE2" in this.query && (c.usePCRE2 = this.query.usePCRE2);
    let u;
    return this.queryProviderPair.query.type === Fa.aiText ? u = await this.queryProviderPair.provider.provideAITextSearchResults(this.queryProviderPair.query.contentPattern, c, a, n) : u = await this.queryProviderPair.provider.provideTextSearchResults(JO(this.queryProviderPair.query.contentPattern), c, a, n), o.length && await Promise.all(o), u;
  }
  getSearchOptionsForFolder(e) {
    const i = kc(this.query.includePattern, e.includePattern);
    let n = e.excludePattern?.map((o) => ({
      folder: o.folder,
      patterns: kc(this.query.excludePattern, o.pattern)
    }));
    (!n || n.length === 0) && (n = [{
      folder: void 0,
      patterns: kc(this.query.excludePattern, void 0)
    }]);
    const r = BP(n);
    return {
      folder: x.from(e.folder),
      excludes: r,
      includes: i,
      useIgnoreFiles: {
        local: !e.disregardIgnoreFiles,
        parent: !e.disregardParentIgnoreFiles,
        global: !e.disregardGlobalIgnoreFiles
      },
      followSymlinks: !e.ignoreSymlinks,
      encoding: (e.fileEncoding && this.fileUtils.toCanonicalName(e.fileEncoding)) ?? ""
    };
  }
}
function JO(t) {
  return {
    isCaseSensitive: t.isCaseSensitive || !1,
    isRegExp: t.isRegExp || !1,
    isWordMatch: t.isWordMatch || !1,
    isMultiline: t.isMultiline || !1,
    pattern: t.pattern
  };
}
class YO {
  constructor(e) {
    this._onResult = e, this._currentFolderIdx = -1, this._currentFileMatch = null, this._batchedCollector = new w0(512, (i) => this.sendItems(i));
  }
  add(e, i) {
    this._currentFileMatch && (this._currentFolderIdx !== i || !uc(this._currentUri, e.uri)) && (this.pushToCollector(), this._currentFileMatch = null), this._currentFileMatch || (this._currentFolderIdx = i, this._currentFileMatch = {
      resource: e.uri,
      results: []
    }), this._currentFileMatch.results.push(XO(e));
  }
  pushToCollector() {
    const e = this._currentFileMatch && this._currentFileMatch.results ? this._currentFileMatch.results.length : 0;
    this._batchedCollector.addItem(this._currentFileMatch, e);
  }
  flush() {
    this.pushToCollector(), this._batchedCollector.flush();
  }
  sendItems(e) {
    this._onResult(e);
  }
}
function XO(t) {
  return t instanceof go ? {
    previewText: t.previewText,
    rangeLocations: t.ranges.map((e) => ({
      preview: {
        startLineNumber: e.previewRange.start.line,
        startColumn: e.previewRange.start.character,
        endLineNumber: e.previewRange.end.line,
        endColumn: e.previewRange.end.character
      },
      source: {
        startLineNumber: e.sourceRange.start.line,
        startColumn: e.sourceRange.start.character,
        endLineNumber: e.sourceRange.end.line,
        endColumn: e.sourceRange.end.character
      }
    }))
  } : {
    text: t.text,
    lineNumber: t.lineNumber
  };
}
const oc = class oc {
  constructor(e, i) {
    this.maxBatchSize = e, this.cb = i, this.totalNumberCompleted = 0, this.batch = [], this.batchSize = 0;
  }
  addItem(e, i) {
    e && this.addItemToBatch(e, i);
  }
  addItems(e, i) {
    e && this.addItemsToBatch(e, i);
  }
  addItemToBatch(e, i) {
    this.batch.push(e), this.batchSize += i, this.onUpdate();
  }
  addItemsToBatch(e, i) {
    this.batch = this.batch.concat(e), this.batchSize += i, this.onUpdate();
  }
  onUpdate() {
    this.totalNumberCompleted < oc.START_BATCH_AFTER_COUNT ? this.flush() : this.batchSize >= this.maxBatchSize ? this.flush() : this.timeoutHandle || (this.timeoutHandle = setTimeout(() => {
      this.flush();
    }, oc.TIMEOUT));
  }
  flush() {
    this.batchSize && (this.totalNumberCompleted += this.batchSize, this.cb(this.batch), this.batch = [], this.batchSize = 0, this.timeoutHandle && (clearTimeout(this.timeoutHandle), this.timeoutHandle = void 0));
  }
};
oc.TIMEOUT = 4e3, oc.START_BATCH_AFTER_COUNT = 50;
let w0 = oc;
const E5 = pe("IExtHostSearch");
let b0 = class {
  constructor(e, i, n) {
    this.extHostRpc = e, this._uriTransformer = i, this._logService = n, this._proxy = this.extHostRpc.getProxy(ee.MainThreadSearch), this._handlePool = 0, this._textSearchProvider = /* @__PURE__ */ new Map(), this._textSearchUsedSchemes = /* @__PURE__ */ new Set(), this._aiTextSearchProvider = /* @__PURE__ */ new Map(), this._aiTextSearchUsedSchemes = /* @__PURE__ */ new Set(), this._fileSearchProvider = /* @__PURE__ */ new Map(), this._fileSearchUsedSchemes = /* @__PURE__ */ new Set(), this._fileSearchManager = new v0();
  }
  _transformScheme(e) {
    return this._uriTransformer.transformOutgoingScheme(e);
  }
  registerTextSearchProviderOld(e, i) {
    if (this._textSearchUsedSchemes.has(e))
      throw new Error(`a text search provider for the scheme '${e}' is already registered`);
    this._textSearchUsedSchemes.add(e);
    const n = this._handlePool++;
    return this._textSearchProvider.set(n, new qO(i)), this._proxy.$registerTextSearchProvider(n, this._transformScheme(e)), Ee(() => {
      this._textSearchUsedSchemes.delete(e), this._textSearchProvider.delete(n), this._proxy.$unregisterProvider(n);
    });
  }
  registerTextSearchProvider(e, i) {
    if (this._textSearchUsedSchemes.has(e))
      throw new Error(`a text search provider for the scheme '${e}' is already registered`);
    this._textSearchUsedSchemes.add(e);
    const n = this._handlePool++;
    return this._textSearchProvider.set(n, i), this._proxy.$registerTextSearchProvider(n, this._transformScheme(e)), Ee(() => {
      this._textSearchUsedSchemes.delete(e), this._textSearchProvider.delete(n), this._proxy.$unregisterProvider(n);
    });
  }
  registerAITextSearchProvider(e, i) {
    if (this._aiTextSearchUsedSchemes.has(e))
      throw new Error(
        `an AI text search provider for the scheme '${e}'is already registered`
      );
    this._aiTextSearchUsedSchemes.add(e);
    const n = this._handlePool++;
    return this._aiTextSearchProvider.set(n, i), this._proxy.$registerAITextSearchProvider(n, this._transformScheme(e)), Ee(() => {
      this._aiTextSearchUsedSchemes.delete(e), this._aiTextSearchProvider.delete(n), this._proxy.$unregisterProvider(n);
    });
  }
  registerFileSearchProviderOld(e, i) {
    if (this._fileSearchUsedSchemes.has(e))
      throw new Error(`a file search provider for the scheme '${e}' is already registered`);
    this._fileSearchUsedSchemes.add(e);
    const n = this._handlePool++;
    return this._fileSearchProvider.set(n, new y5(i)), this._proxy.$registerFileSearchProvider(n, this._transformScheme(e)), Ee(() => {
      this._fileSearchUsedSchemes.delete(e), this._fileSearchProvider.delete(n), this._proxy.$unregisterProvider(n);
    });
  }
  registerFileSearchProvider(e, i) {
    if (this._fileSearchUsedSchemes.has(e))
      throw new Error(`a file search provider for the scheme '${e}' is already registered`);
    this._fileSearchUsedSchemes.add(e);
    const n = this._handlePool++;
    return this._fileSearchProvider.set(n, i), this._proxy.$registerFileSearchProvider(n, this._transformScheme(e)), Ee(() => {
      this._fileSearchUsedSchemes.delete(e), this._fileSearchProvider.delete(n), this._proxy.$unregisterProvider(n);
    });
  }
  $provideFileSearchResults(e, i, n, r) {
    const s = Z1(n), o = this._fileSearchProvider.get(e);
    if (o)
      return this._fileSearchManager.fileSearch(s, o, (a) => {
        this._proxy.$handleFileMatch(e, i, a.map((l) => l.resource));
      }, r);
    throw new Error("unknown provider: " + e);
  }
  async doInternalFileSearchWithCustomCallback(e, i, n) {
    return { messages: [] };
  }
  $clearCache(e) {
    return this._fileSearchManager.clearCache(e), Promise.resolve(void 0);
  }
  $provideTextSearchResults(e, i, n, r) {
    const s = this._textSearchProvider.get(e);
    if (!s || !s.provideTextSearchResults)
      throw new Error(`Unknown Text Search Provider ${e}`);
    const o = Z1(n);
    return this.createTextSearchManager(o, s).search((l) => this._proxy.$handleTextMatch(e, i, l), r);
  }
  $provideAITextSearchResults(e, i, n, r) {
    const s = this._aiTextSearchProvider.get(e);
    if (!s || !s.provideAITextSearchResults)
      throw new Error(`Unknown AI Text Search Provider ${e}`);
    const o = Z1(n);
    return this.createAITextSearchManager(o, s).search((l) => this._proxy.$handleTextMatch(e, i, l), r, (l) => this._proxy.$handleKeywordResult(e, i, l));
  }
  $enableExtensionHostSearch() {
  }
  async $getAIName(e) {
    const i = this._aiTextSearchProvider.get(e);
    if (!(!i || !i.provideAITextSearchResults))
      return i.name ?? "AI";
  }
  createTextSearchManager(e, i) {
    return new jI({ query: e, provider: i }, {
      readdir: (n) => Promise.resolve([]),
      toCanonicalName: (n) => n
    }, "textSearchProvider");
  }
  createAITextSearchManager(e, i) {
    return new jI({ query: e, provider: i }, {
      readdir: (n) => Promise.resolve([]),
      toCanonicalName: (n) => n
    }, "aiTextSearchProvider");
  }
};
b0 = W([
  M(0, Ye),
  M(1, B_),
  M(2, nt)
], b0);
function Z1(t) {
  return {
    ...t,
    folderQueries: t.folderQueries && t.folderQueries.map(ZO),
    extraFileResources: t.extraFileResources && t.extraFileResources.map((e) => x.revive(e))
  };
}
function ZO(t) {
  return Fi(t);
}
const S5 = pe("IExtHostTerminalShellIntegration");
let y0 = class extends ve {
  constructor(e, i) {
    super(), this._extHostTerminalService = i, this._activeShellIntegrations = /* @__PURE__ */ new Map(), this._onDidChangeTerminalShellIntegration = new N(), this.onDidChangeTerminalShellIntegration = this._onDidChangeTerminalShellIntegration.event, this._onDidStartTerminalShellExecution = new N(), this.onDidStartTerminalShellExecution = this._onDidStartTerminalShellExecution.event, this._onDidEndTerminalShellExecution = new N(), this.onDidEndTerminalShellExecution = this._onDidEndTerminalShellExecution.event, this._proxy = e.getProxy(ee.MainThreadTerminalShellIntegration), this._register(Ee(() => {
      for (const [n, r] of this._activeShellIntegrations)
        r.dispose();
      this._activeShellIntegrations.clear();
    }));
  }
  $shellIntegrationChange(e) {
    const i = this._extHostTerminalService.getTerminalById(e);
    if (!i)
      return;
    const n = i.value;
    let r = this._activeShellIntegrations.get(e);
    r || (r = new eF(i.value, this._onDidStartTerminalShellExecution), this._activeShellIntegrations.set(e, r), r.store.add(i.onWillDispose(() => this._activeShellIntegrations.get(e)?.dispose())), r.store.add(r.onDidRequestShellExecution((s) => this._proxy.$executeCommand(e, s))), r.store.add(r.onDidRequestEndExecution((s) => this._onDidEndTerminalShellExecution.fire(s))), r.store.add(r.onDidRequestChangeShellIntegration((s) => this._onDidChangeTerminalShellIntegration.fire(s))), i.shellIntegration = r.value), this._onDidChangeTerminalShellIntegration.fire({
      terminal: n,
      shellIntegration: r.value
    });
  }
  $shellExecutionStart(e, i, n, r, s) {
    this._activeShellIntegrations.has(e) || this.$shellIntegrationChange(e);
    const o = {
      value: i,
      confidence: n,
      isTrusted: r
    };
    this._activeShellIntegrations.get(e)?.startShellExecution(o, this._convertCwdToUri(s));
  }
  $shellExecutionEnd(e, i, n, r, s) {
    const o = {
      value: i,
      confidence: n,
      isTrusted: r
    };
    this._activeShellIntegrations.get(e)?.endShellExecution(o, s);
  }
  $shellExecutionData(e, i) {
    this._activeShellIntegrations.get(e)?.emitData(i);
  }
  $shellEnvChange(e, i, n, r) {
    this._activeShellIntegrations.get(e)?.setEnv(i, n, r);
  }
  $cwdChange(e, i) {
    this._activeShellIntegrations.get(e)?.setCwd(this._convertCwdToUri(i));
  }
  $closeTerminal(e) {
    this._activeShellIntegrations.get(e)?.dispose(), this._activeShellIntegrations.delete(e);
  }
  _convertCwdToUri(e) {
    return e ? x.file(e) : void 0;
  }
};
y0 = W([
  M(0, Ye),
  M(1, Eu)
], y0);
class eF extends ve {
  get currentExecution() {
    return this._currentExecution;
  }
  constructor(e, i) {
    super(), this._terminal = e, this._onDidStartTerminalShellExecution = i, this._pendingExecutions = [], this.store = this._register(new De()), this._onDidRequestChangeShellIntegration = this._register(new N()), this.onDidRequestChangeShellIntegration = this._onDidRequestChangeShellIntegration.event, this._onDidRequestShellExecution = this._register(new N()), this.onDidRequestShellExecution = this._onDidRequestShellExecution.event, this._onDidRequestEndExecution = this._register(new N()), this.onDidRequestEndExecution = this._onDidRequestEndExecution.event, this._onDidRequestNewExecution = this._register(new N()), this.onDidRequestNewExecution = this._onDidRequestNewExecution.event;
    const n = this;
    this.value = {
      get cwd() {
        return n._cwd;
      },
      get env() {
        if (n._env)
          return Object.freeze({
            isTrusted: n._env.isTrusted,
            value: Object.freeze({ ...n._env.value })
          });
      },
      executeCommand(r, s) {
        let o = r;
        if (s)
          for (const c of s)
            !c.match(/["'`]/) && c.match(/\s/) ? o += ` "${c}"` : o += ` ${c}`;
        n._onDidRequestShellExecution.fire(o);
        const a = {
          value: o,
          confidence: fh.High,
          isTrusted: !0
        };
        return n.requestNewShellExecution(a, n._cwd).value;
      }
    };
  }
  requestNewShellExecution(e, i) {
    const n = new GI(e, i ?? this._cwd);
    return yp(e.value).length > 1 && (this._currentExecutionProperties = {
      isMultiLine: !0,
      unresolvedCommandLines: yp(e.value)
    }), this._pendingExecutions.push(n), this._onDidRequestNewExecution.fire(e.value), n;
  }
  startShellExecution(e, i) {
    if (this._pendingEndingExecution && (this._onDidRequestEndExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: this._pendingEndingExecution.value, exitCode: void 0 }), this._pendingEndingExecution = void 0), this._currentExecution) {
      if (this._currentExecutionProperties?.isMultiLine && this._currentExecutionProperties.unresolvedCommandLines) {
        const r = QI(this._currentExecutionProperties.unresolvedCommandLines, e);
        if (r) {
          this._currentExecutionProperties.unresolvedCommandLines = r.unresolvedCommandLines;
          return;
        }
      }
      this._currentExecution.endExecution(void 0), this._currentExecution.flush(), this._onDidRequestEndExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: this._currentExecution.value, exitCode: void 0 });
    }
    let n;
    if (e.confidence === fh.High)
      for (const [r, s] of this._pendingExecutions.entries())
        if (s.value.commandLine.value === e.value) {
          n = s, this._currentExecutionProperties = {
            isMultiLine: !1,
            unresolvedCommandLines: void 0
          }, n = s, this._pendingExecutions.splice(r, 1);
          break;
        } else {
          const o = QI(yp(s.value.commandLine.value), e);
          if (o) {
            this._currentExecutionProperties = {
              isMultiLine: !0,
              unresolvedCommandLines: o.unresolvedCommandLines
            }, n = s, this._pendingExecutions.splice(r, 1);
            break;
          }
        }
    else
      n = this._pendingExecutions.shift();
    n || (n = new GI(e, i ?? this._cwd)), this._currentExecution = n, this._onDidStartTerminalShellExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: this._currentExecution.value });
  }
  emitData(e) {
    this.currentExecution?.emitData(e);
  }
  endShellExecution(e, i) {
    if (!(this._currentExecutionProperties?.isMultiLine && this._currentExecutionProperties.unresolvedCommandLines && this._currentExecutionProperties.unresolvedCommandLines.length > 0) && this._currentExecution) {
      const n = this._currentExecutionProperties?.isMultiLine ? this._currentExecution.value.commandLine : e;
      this._currentExecution.endExecution(n);
      const r = this._currentExecution;
      this._pendingEndingExecution = r, this._currentExecution = void 0, r.flush().then(() => {
        this._pendingEndingExecution === r && (this._onDidRequestEndExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: r.value, exitCode: i }), this._pendingEndingExecution = void 0);
      });
    }
  }
  setEnv(e, i, n) {
    const r = {};
    for (let s = 0; s < e.length; s++)
      r[e[s]] = i[s];
    this._env = { value: r, isTrusted: n }, this._fireChangeEvent();
  }
  setCwd(e) {
    let i = !1;
    x.isUri(this._cwd) ? i = !x.isUri(e) || this._cwd.toString() !== e.toString() : this._cwd !== e && (i = !0), i && (this._cwd = e, this._fireChangeEvent());
  }
  _fireChangeEvent() {
    this._onDidRequestChangeShellIntegration.fire({ terminal: this._terminal, shellIntegration: this.value });
  }
}
class GI {
  constructor(e, i) {
    this._commandLine = e, this.cwd = i, this._isEnded = !1;
    const n = this;
    this.value = {
      get commandLine() {
        return n._commandLine;
      },
      get cwd() {
        return n.cwd;
      },
      read() {
        return n._createDataStream();
      }
    };
  }
  _createDataStream() {
    if (!this._dataStream) {
      if (this._isEnded)
        return Xa.EMPTY;
      this._dataStream = new tF();
    }
    return this._dataStream.createIterable();
  }
  emitData(e) {
    this._isEnded || this._dataStream?.emitData(e);
  }
  endExecution(e) {
    e && (this._commandLine = e), this._dataStream?.endExecution(), this._isEnded = !0;
  }
  async flush() {
    this._dataStream && (await this._dataStream.flush(), this._dataStream.dispose(), this._dataStream = void 0);
  }
}
class tF extends ve {
  constructor() {
    super(...arguments), this._iterables = [], this._emitters = [];
  }
  createIterable() {
    this._barrier || (this._barrier = new Ur());
    const e = this._barrier, i = new Xa(async (n) => {
      this._emitters.push(n), await e.wait();
    });
    return this._iterables.push(i), i;
  }
  emitData(e) {
    for (const i of this._emitters)
      i.emitOne(e);
  }
  endExecution() {
    this._barrier?.open();
  }
  async flush() {
    await Promise.all(this._iterables.map((e) => e.toPromise()));
  }
}
function yp(t) {
  return t.split(`
`).map((e) => e.trim()).filter((e) => e.length > 0);
}
function QI(t, e) {
  if (t.length === 0)
    return !1;
  const i = [...t], n = yp(e.value);
  if (i && i.length > 0) {
    for (; i.length > 0 && i[0] === n[0]; )
      i.shift(), n.shift();
    if (n.length === 0)
      return { unresolvedCommandLines: i };
  }
  return !1;
}
var no;
(function(t) {
  t[t.CR = 13] = "CR", t[t.LF = 10] = "LF", t[t.COLON = 58] = "COLON", t[t.SPACE = 32] = "SPACE";
})(no || (no = {}));
class ev {
  constructor(e) {
    this.dataBuffer = "", this.eventTypeBuffer = "", this.buffer = [], this.endedOnCR = !1, this.onEventHandler = e, this.decoder = new TextDecoder("utf-8");
  }
  getLastEventId() {
    return this.lastEventIdBuffer;
  }
  getReconnectionTime() {
    return this.reconnectionTime;
  }
  feed(e) {
    if (e.length === 0)
      return;
    let i = 0;
    for (this.endedOnCR && e[0] === no.LF && i++, this.endedOnCR = !1; i < e.length; ) {
      const n = e.indexOf(no.CR, i), r = e.indexOf(no.LF, i), s = n === -1 ? r : r === -1 ? n : Math.min(n, r);
      if (s === -1)
        break;
      let o = "";
      for (const a of this.buffer)
        o += this.decoder.decode(a, { stream: !0 });
      o += this.decoder.decode(e.subarray(i, s)), this.processLine(o), this.buffer.length = 0, i = s + (e[s] === no.CR && e[s + 1] === no.LF ? 2 : 1);
    }
    i < e.length ? this.buffer.push(e.subarray(i)) : this.endedOnCR = e[e.length - 1] === no.CR;
  }
  processLine(e) {
    if (!e.length) {
      this.dispatchEvent();
      return;
    }
    if (e.startsWith(":"))
      return;
    let i, n;
    const r = e.indexOf(":");
    r === -1 ? (i = e, n = "") : (i = e.substring(0, r), n = e.substring(r + 1), n.startsWith(" ") && (n = n.substring(1))), this.processField(i, n);
  }
  processField(e, i) {
    switch (e) {
      case "event":
        this.eventTypeBuffer = i;
        break;
      case "data":
        this.dataBuffer += i, this.dataBuffer += `
`;
        break;
      case "id":
        i.includes("\0") ? this.currentEventId = void 0 : this.currentEventId = this.lastEventIdBuffer = i;
        break;
      case "retry":
        /^\d+$/.test(i) && (this.reconnectionTime = parseInt(i, 10));
        break;
    }
  }
  dispatchEvent() {
    if (this.dataBuffer === "") {
      this.dataBuffer = "", this.eventTypeBuffer = "";
      return;
    }
    this.dataBuffer.endsWith(`
`) && (this.dataBuffer = this.dataBuffer.substring(0, this.dataBuffer.length - 1));
    const e = {
      type: this.eventTypeBuffer || "message",
      data: this.dataBuffer
    };
    this.currentEventId !== void 0 && (e.id = this.currentEventId), this.reconnectionTime !== void 0 && (e.retry = this.reconnectionTime), this.onEventHandler(e), this.reset();
  }
  reset() {
    this.dataBuffer = "", this.eventTypeBuffer = "", this.currentEventId = void 0;
  }
}
const x0 = pe("IExtHostMpcService");
let E0 = class extends ve {
  constructor(e, i, n) {
    super(), this._logService = i, this._extHostInitData = n, this._initialProviderPromises = /* @__PURE__ */ new Set(), this._sseEventSources = this._register(new Ap()), this._unresolvedMcpServers = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadMcp);
  }
  $startMcp(e, i) {
    this._startMcp(e, Nh.fromSerialized(i));
  }
  _startMcp(e, i) {
    if (i.type === sl.HTTP) {
      this._sseEventSources.set(e, new rF(e, i, this._proxy, this._logService));
      return;
    }
    throw new Error("not implemented");
  }
  $stopMcp(e) {
    this._sseEventSources.has(e) && (this._sseEventSources.deleteAndDispose(e), this._proxy.$onDidChangeState(e, { state: ys.Kind.Stopped }));
  }
  $sendMessage(e, i) {
    this._sseEventSources.get(e)?.send(i);
  }
  async $waitForInitialCollectionProviders() {
    await Promise.all(this._initialProviderPromises);
  }
  async $resolveMcpLaunch(e, i) {
    const n = this._unresolvedMcpServers.get(e);
    if (!n)
      return;
    const r = n.servers.find((o) => o.label === i);
    if (!r)
      return;
    if (!n.provider.resolveMcpServerDefinition)
      return Ed.from(r);
    const s = await n.provider.resolveMcpServerDefinition(r, xt.None);
    return s ? Ed.from(s) : void 0;
  }
  registerMcpConfigurationProvider(e, i, n) {
    const r = new De(), s = e.contributes?.mcpServerDefinitionProviders?.find((c) => c.id === i);
    if (!s)
      throw new Error(
        `MCP configuration providers must be registered in the contributes.mcpServerDefinitionProviders array within your package.json, but "${i}" was not`
      );
    const o = {
      id: z6(e.identifier, i),
      isTrustedByDefault: !0,
      label: s?.label ?? e.displayName ?? e.name,
      scope: jt.WORKSPACE,
      canResolveLaunch: typeof n.resolveMcpServerDefinition == "function",
      extensionId: e.identifier.value,
      configTarget: this._extHostInitData.remote.isRemote ? ti.USER_REMOTE : ti.USER
    }, a = async () => {
      const c = await n.provideMcpServerDefinitions(xt.None);
      this._unresolvedMcpServers.set(o.id, { servers: c ?? [], provider: n });
      const u = [];
      for (const d of c ?? []) {
        let f = ht.toKey(e.identifier) + "/" + d.label;
        if (u.some((g) => g.id === f)) {
          let g = 2;
          for (; u.some((_) => _.id === f + g); )
            g++;
          f = f + g;
        }
        u.push({
          id: f,
          label: d.label,
          cacheNonce: d.version || "$$NONE",
          launch: Ed.from(d)
        });
      }
      this._proxy.$upsertMcpCollection(o, u);
    };
    r.add(Ee(() => {
      this._unresolvedMcpServers.delete(o.id), this._proxy.$deleteMcpCollection(o.id);
    })), n.onDidChangeMcpServerDefinitions && r.add(n.onDidChangeMcpServerDefinitions(a)), n.onDidChangeServerDefinitions && r.add(n.onDidChangeServerDefinitions(a)), n.onDidChange && r.add(n.onDidChange(a));
    const l = new Promise((c) => {
      setTimeout(() => a().finally(() => {
        this._initialProviderPromises.delete(l), c();
      }), 0);
    });
    return this._initialProviderPromises.add(l), r;
  }
};
E0 = W([
  M(0, Ye),
  M(1, nt),
  M(2, pi)
], E0);
var hn;
(function(t) {
  t[t.Unknown = 0] = "Unknown", t[t.Http = 1] = "Http", t[t.SSE = 2] = "SSE";
})(hn || (hn = {}));
const iF = 5, nF = [301, 302, 303, 307, 308];
class rF extends ve {
  constructor(e, i, n, r) {
    super(), this._id = e, this._launch = i, this._proxy = n, this._logService = r, this._requestSequencer = new JR(), this._postEndpoint = new ko(), this._mode = { value: hn.Unknown }, this._cts = new Pt(), this._abortCtrl = new AbortController(), this._register(Ee(() => {
      this._abortCtrl.abort(), this._cts.dispose(!0);
    })), this._proxy.$onDidChangeState(this._id, { state: ys.Kind.Running });
  }
  async send(e) {
    try {
      this._mode.value === hn.Unknown ? await this._requestSequencer.queue(() => this._send(e)) : await this._send(e);
    } catch (i) {
      const n = `Error sending message to ${this._launch.uri}: ${String(i)}`;
      this._proxy.$onDidChangeState(this._id, { state: ys.Kind.Error, message: n });
    }
  }
  _send(e) {
    return this._mode.value === hn.SSE ? this._sendLegacySSE(this._mode.endpoint, e) : this._sendStreamableHttp(e, this._mode.value === hn.Http ? this._mode.sessionId : void 0);
  }
  async _sendStreamableHttp(e, i) {
    const n = new TextEncoder().encode(e), r = {
      ...Object.fromEntries(this._launch.headers),
      "Content-Type": "application/json",
      "Content-Length": String(n.length),
      Accept: "text/event-stream, application/json"
    };
    i && (r["Mcp-Session-Id"] = i), await this._addAuthHeader(r);
    const s = await this._fetchWithAuthRetry(this._launch.uri.toString(!0), {
      method: "POST",
      headers: r,
      body: n
    }, r), o = this._mode.value === hn.Unknown, a = s.headers.get("Mcp-Session-Id");
    if (a && (this._mode = { value: hn.Http, sessionId: a }), this._mode.value === hn.Unknown && s.status >= 400 && s.status < 500 && s.status !== 401 && s.status !== 403) {
      this._log(Re.Info, `${s.status} status sending message to ${this._launch.uri}, will attempt to fall back to legacy SSE`), this._sseFallbackWithMessage(e);
      return;
    }
    if (s.status >= 300) {
      const l = this._mode.value === hn.Http && !!this._mode.sessionId && (s.status === 400 || s.status === 404);
      this._proxy.$onDidChangeState(this._id, {
        state: ys.Kind.Error,
        message: `${s.status} status sending message to ${this._launch.uri}: ${await this._getErrText(s)}` + (l ? "; will retry with new session ID" : ""),
        shouldRetry: l
      });
      return;
    }
    this._mode.value === hn.Unknown && (this._mode = { value: hn.Http, sessionId: void 0 }), o && this._attachStreamableBackchannel(), await this._handleSuccessfulStreamableHttp(s, e);
  }
  async _sseFallbackWithMessage(e) {
    const i = await this._attachSSE();
    i && (this._mode = { value: hn.SSE, endpoint: i }, await this._sendLegacySSE(i, e));
  }
  async _populateAuthMetadata(e, i) {
    let n;
    if (i.headers.has("WWW-Authenticate")) {
      const u = i.headers.get("WWW-Authenticate"), { scheme: d, params: f } = oM(u);
      d === "Bearer" && f.resource_metadata && (n = f.resource_metadata);
    }
    let r, s, o;
    if (n) {
      const u = await this._getResourceMetadata(n);
      if (new URL(u.resource).toString() !== new URL(e).toString())
        throw new Error(
          `Protected Resource Metadata resource "${u.resource}" does not match MCP server resolved resource "${e}". The MCP server must follow OAuth spec https://datatracker.ietf.org/doc/html/rfc9728#PRConfigurationValidation`
        );
      r = u.authorization_servers?.[0], s = u.scopes_supported, o = u;
    }
    const a = new URL(i.url).origin;
    let l = {};
    r || (r = a, l = {
      ...Object.fromEntries(this._launch.headers)
    });
    try {
      const u = await this._getAuthorizationServerMetadata(r, l);
      this._authMetadata = {
        authorizationServer: x.parse(r),
        serverMetadata: u,
        resourceMetadata: o
      };
      return;
    } catch (u) {
      this._log(Re.Warning, `Error populating auth metadata: ${String(u)}`);
    }
    const c = sM(new URL(a));
    c.scopes_supported = s ?? c.scopes_supported ?? [], this._authMetadata = {
      authorizationServer: x.parse(r),
      serverMetadata: c,
      resourceMetadata: o
    };
  }
  async _getResourceMetadata(e) {
    const i = new URL(e), n = new URL(this._launch.uri.toString(!0));
    let r = {};
    i.origin === n.origin && (r = {
      ...Object.fromEntries(this._launch.headers)
    });
    const s = await this._fetch(e, {
      method: "GET",
      headers: {
        ...r,
        Accept: "application/json",
        "MCP-Protocol-Version": Kl.LATEST_PROTOCOL_VERSION
      }
    });
    if (s.status !== 200)
      throw new Error(
        `Failed to fetch resource metadata: ${s.status} ${await this._getErrText(s)}`
      );
    const o = await s.json();
    if (tM(o))
      return o;
    throw new Error(`Invalid resource metadata: ${JSON.stringify(o)}`);
  }
  async _getAuthorizationServerMetadata(e, i) {
    const n = new URL(e), r = n.pathname === "/" ? "" : n.pathname, s = new URL(ZN, e).toString() + r;
    let o = await this._fetch(s, {
      method: "GET",
      headers: {
        ...i,
        Accept: "application/json",
        "MCP-Protocol-Version": Kl.LATEST_PROTOCOL_VERSION
      }
    });
    if (o.status !== 200) {
      const l = new URL(oI, e).toString() + r;
      if (o = await this._fetch(l, {
        method: "GET",
        headers: {
          ...i,
          Accept: "application/json",
          "MCP-Protocol-Version": Kl.LATEST_PROTOCOL_VERSION
        }
      }), o.status !== 200 && (o = await this._fetch(x.joinPath(x.parse(e), oI).toString(!0), {
        method: "GET",
        headers: {
          ...i,
          Accept: "application/json",
          "MCP-Protocol-Version": Kl.LATEST_PROTOCOL_VERSION
        }
      }), o.status !== 200))
        throw new Error(
          `Failed to fetch authorization server metadata: ${o.status} ${await this._getErrText(o)}`
        );
    }
    const a = await o.json();
    if (iM(a))
      return a;
    throw new Error(`Invalid authorization server metadata: ${JSON.stringify(a)}`);
  }
  async _handleSuccessfulStreamableHttp(e, i) {
    if (e.status !== 202)
      switch (e.headers.get("Content-Type")?.toLowerCase()) {
        case "text/event-stream": {
          const n = new ev((r) => {
            if (r.type === "message")
              this._proxy.$onDidReceiveMessage(this._id, r.data);
            else if (r.type === "endpoint")
              throw this._log(Re.Warning, `Received SSE endpoint from a POST to ${this._launch.uri}, will fall back to legacy SSE`), this._sseFallbackWithMessage(i), new zn();
          });
          try {
            await this._doSSE(n, e);
          } catch (r) {
            this._log(Re.Warning, `Error reading SSE stream: ${String(r)}`);
          }
          break;
        }
        case "application/json":
          this._proxy.$onDidReceiveMessage(this._id, await e.text());
          break;
        default: {
          const n = await e.text();
          sF(n) ? this._proxy.$onDidReceiveMessage(this._id, n) : this._log(Re.Warning, `Unexpected ${e.status} response for request: ${n}`);
        }
      }
  }
  async _attachStreamableBackchannel() {
    let e;
    for (let i = 0; !this._store.isDisposed; i++) {
      await qr(Math.min(i * 1e3, 3e4), this._cts.token);
      let n;
      try {
        const s = {
          ...Object.fromEntries(this._launch.headers),
          Accept: "text/event-stream"
        };
        await this._addAuthHeader(s), this._mode.value === hn.Http && this._mode.sessionId !== void 0 && (s["Mcp-Session-Id"] = this._mode.sessionId), e && (s["Last-Event-ID"] = e), n = await this._fetchWithAuthRetry(this._launch.uri.toString(!0), {
          method: "GET",
          headers: s
        }, s);
      } catch {
        this._log(Re.Info, `Error connecting to ${this._launch.uri} for async notifications, will retry`);
        continue;
      }
      if (n.status >= 400) {
        this._log(Re.Debug, `${n.status} status connecting to ${this._launch.uri} for async notifications; they will be disabled: ${await this._getErrText(n)}`);
        return;
      }
      n.headers.get("content-type")?.toLowerCase().includes("text/event-stream") && (i = 0);
      const r = new ev((s) => {
        s.type === "message" && this._proxy.$onDidReceiveMessage(this._id, s.data), s.id && (e = s.id);
      });
      try {
        await this._doSSE(r, n);
      } catch (s) {
        this._log(Re.Info, `Error reading from async stream, we will reconnect: ${s}`);
      }
    }
  }
  async _attachSSE() {
    const e = new ko(), i = {
      ...Object.fromEntries(this._launch.headers),
      Accept: "text/event-stream"
    };
    await this._addAuthHeader(i);
    let n;
    try {
      if (n = await this._fetchWithAuthRetry(this._launch.uri.toString(!0), {
        method: "GET",
        headers: i
      }, i), n.status >= 300) {
        this._proxy.$onDidChangeState(this._id, { state: ys.Kind.Error, message: `${n.status} status connecting to ${this._launch.uri} as SSE: ${await this._getErrText(n)}` });
        return;
      }
    } catch (s) {
      this._proxy.$onDidChangeState(this._id, { state: ys.Kind.Error, message: `Error connecting to ${this._launch.uri} as SSE: ${s}` });
      return;
    }
    const r = new ev((s) => {
      s.type === "message" ? this._proxy.$onDidReceiveMessage(this._id, s.data) : s.type === "endpoint" && e.complete(new URL(s.data, this._launch.uri.toString(!0)).toString());
    });
    return this._register(Ee(() => e.cancel())), this._doSSE(r, n).catch((s) => {
      this._proxy.$onDidChangeState(this._id, { state: ys.Kind.Error, message: `Error reading SSE stream: ${String(s)}` });
    }), e.p;
  }
  async _sendLegacySSE(e, i) {
    const n = new TextEncoder().encode(i), r = {
      ...Object.fromEntries(this._launch.headers),
      "Content-Type": "application/json",
      "Content-Length": String(n.length)
    };
    await this._addAuthHeader(r);
    const s = await this._fetch(e, {
      method: "POST",
      headers: r,
      body: n
    });
    s.status >= 300 && this._log(Re.Warning, `${s.status} status sending message to ${this._postEndpoint}: ${await this._getErrText(s)}`);
  }
  async _doSSE(e, i) {
    if (!i.body)
      return;
    const n = i.body.getReader();
    let r;
    do {
      try {
        r = await Ix(n.read(), this._cts.token);
      } catch (s) {
        if (n.cancel(), this._store.isDisposed)
          return;
        throw s;
      }
      r.value && e.feed(r.value);
    } while (!r.done);
  }
  async _addAuthHeader(e) {
    if (this._authMetadata)
      try {
        const i = await this._proxy.$getTokenFromServerMetadata(this._id, this._authMetadata.authorizationServer, this._authMetadata.serverMetadata, this._authMetadata.resourceMetadata);
        i && (e.Authorization = `Bearer ${i}`);
      } catch (i) {
        this._log(Re.Warning, `Error getting token from server metadata: ${String(i)}`);
      }
    return e;
  }
  _log(e, i) {
    this._store.isDisposed || this._proxy.$onDidPublishLog(this._id, e, i);
  }
  async _getErrText(e) {
    try {
      return await e.text();
    } catch {
      return e.statusText;
    }
  }
  async _fetchWithAuthRetry(e, i, n) {
    const r = () => this._fetch(e, i);
    let s = await r();
    return s.status === 401 && (this._authMetadata || (await this._populateAuthMetadata(e, s), await this._addAuthHeader(n), n.Authorization && (i.headers = n, s = await r()))), s;
  }
  async _fetch(e, i) {
    if (Jy(this._logService.getLevel(), Re.Trace)) {
      const s = { ...i, headers: { ...i.headers } };
      s.body && (s.body = new TextDecoder().decode(s.body)), s.headers?.Authorization && (s.headers.Authorization = "***"), this._log(Re.Trace, `Fetching ${e} with options: ${JSON.stringify(s)}`);
    }
    let n = e, r;
    for (let s = 0; s < iF && (r = await fetch(n, {
      ...i,
      signal: this._abortCtrl.signal,
      redirect: "manual"
    }), !!nF.includes(r.status)); s++) {
      const o = r.headers.get("location");
      if (!o)
        break;
      const a = new URL(o, n).toString();
      this._log(Re.Trace, `Redirect (${r.status}) from ${n} to ${a}`), n = a, (r.status === 303 || (r.status === 301 || r.status === 302) && i.method === "POST") && (i.method = "GET", delete i.body);
    }
    if (Jy(this._logService.getLevel(), Re.Trace)) {
      const s = {};
      r.headers.forEach((o, a) => {
        s[a] = o;
      }), this._log(Re.Trace, `Fetched ${n}: ${JSON.stringify({
        status: r.status,
        headers: s
      })}`);
    }
    return r;
  }
}
function sF(t) {
  try {
    return JSON.parse(t), !0;
  } catch {
    return !1;
  }
}
const D5 = pe("IExtHostDataChannels");
class oF {
  constructor() {
    this._channels = /* @__PURE__ */ new Map();
  }
  createDataChannel(e, i) {
    $(e, "dataChannels");
    let n = this._channels.get(i);
    return n || (n = new aF(i), this._channels.set(i, n)), n;
  }
  $onDidReceiveData(e, i) {
    const n = this._channels.get(e);
    n && n._fireDidReceiveData(i);
  }
}
class aF extends ve {
  constructor(e) {
    super(), this.channelId = e, this._onDidReceiveData = new N(), this.onDidReceiveData = this._onDidReceiveData.event, this._register(this._onDidReceiveData);
  }
  _fireDidReceiveData(e) {
    this._onDidReceiveData.fire({ data: e });
  }
  toString() {
    return `DataChannel(${this.channelId})`;
  }
}
gt(EE, qy, ft.Delayed);
gt(Lo, Qm, ft.Delayed);
gt(vf, Ky, ft.Delayed);
gt(vl, Ry, ft.Eager);
gt(f1, $y, ft.Eager);
gt(yE, zy, ft.Eager);
gt($s, by, ft.Eager);
gt(l1, Ey, ft.Eager);
gt(g1, p0, ft.Eager);
gt(b5, _0, ft.Eager);
gt(f5, Zy, ft.Eager);
gt(Su, i0, ft.Eager);
gt(SE, jy, ft.Eager);
gt(wu, R8, ft.Eager);
gt(h5, Xy, ft.Delayed);
gt(E5, b0, ft.Eager);
gt(mE, jP, ft.Eager);
gt(m5, d0, ft.Eager);
gt(Eu, Ny, ft.Eager);
gt(S5, y0, ft.Eager);
gt(vE, Cy, ft.Eager);
gt(d1, Oy, ft.Eager);
gt(h1, Uy, ft.Eager);
gt(Us, _y, ft.Eager);
gt(xE, o5, ft.Eager);
gt(bf, h0, ft.Eager);
gt(IE, g0, ft.Eager);
gt(x0, E0, ft.Eager);
gt(D5, oF, ft.Eager);
function k5(t, e, i, n, r, s) {
  if (Array.isArray(t)) {
    let o = 0;
    for (const a of t) {
      const l = k5(a, e, i, n, r, s);
      if (l === 10)
        return l;
      l > o && (o = l);
    }
    return o;
  } else {
    if (typeof t == "string")
      return t === "*" ? 5 : t === i ? 10 : 0;
    if (t) {
      const { language: o, pattern: a, scheme: l, hasAccessToAllModels: c, notebookType: u } = t;
      u && r && (e = r);
      let d = 0;
      if (l)
        if (l === e.scheme)
          d = 10;
        else if (l === "*")
          d = 5;
        else
          return 0;
      if (o)
        if (o === i)
          d = 10;
        else if (o === "*")
          d = Math.max(d, 5);
        else
          return 0;
      if (u)
        if (u === s)
          d = 10;
        else if (u === "*" && s !== void 0)
          d = Math.max(d, 5);
        else
          return 0;
      if (a) {
        let f;
        if (typeof a == "string" ? f = a : f = { ...a, base: Hc(a.base) }, f === e.fsPath || wd(f, e.fsPath))
          d = 10;
        else
          return 0;
      }
      return d;
    } else
      return 0;
  }
}
function I5(t) {
  return typeof t == "string" ? !1 : Array.isArray(t) ? t.some(I5) : !!t.notebookType;
}
var S0;
(function(t) {
  t[t.None = 0] = "None", t[t.Indent = 1] = "Indent", t[t.IndentOutdent = 2] = "IndentOutdent", t[t.Outdent = 3] = "Outdent";
})(S0 || (S0 = {}));
var D0;
(function(t) {
  t[t.Complete = 100] = "Complete", t[t.Partial = 50] = "Partial", t[t.None = 0] = "None";
})(D0 || (D0 = {}));
class lF {
  constructor(e) {
    this._relatedInformationProviders = /* @__PURE__ */ new Map(), this._nextHandle = 0, this._proxy = e.getProxy(ee.MainThreadAiRelatedInformation);
  }
  async $provideAiRelatedInformation(e, i, n) {
    if (this._relatedInformationProviders.size === 0)
      throw new Error("No related information providers registered");
    const r = this._relatedInformationProviders.get(e);
    if (!r)
      throw new Error("related information provider not found");
    return await r.provideRelatedInformation(i, n) ?? [];
  }
  getRelatedInformation(e, i, n) {
    return this._proxy.$getAiRelatedInformation(i, n);
  }
  registerRelatedInformationProvider(e, i, n) {
    const r = this._nextHandle;
    return this._nextHandle++, this._relatedInformationProviders.set(r, n), this._proxy.$registerAiRelatedInformationProvider(r, i), new Ve(() => {
      this._proxy.$unregisterAiRelatedInformationProvider(r), this._relatedInformationProviders.delete(r);
    });
  }
}
var tf;
(function(t) {
  t[t.Full = 1] = "Full", t[t.Delta = 2] = "Delta";
})(tf || (tf = {}));
function C5(t) {
  for (let e = 0, i = t.length; e < i; e += 4) {
    const n = t[e + 0], r = t[e + 1], s = t[e + 2], o = t[e + 3];
    t[e + 0] = o, t[e + 1] = s, t[e + 2] = r, t[e + 3] = n;
  }
}
function cF(t) {
  const e = new Uint8Array(t.buffer, t.byteOffset, t.length * 4);
  return v4() || C5(e), ue.wrap(e);
}
function uF(t) {
  const e = t.buffer;
  if (v4() || C5(e), e.byteOffset % 4 === 0)
    return new Uint32Array(e.buffer, e.byteOffset, e.length / 4);
  {
    const i = new Uint8Array(e.byteLength);
    return i.set(e), new Uint32Array(i.buffer, i.byteOffset, i.length / 4);
  }
}
function k0(t) {
  const e = new Uint32Array(dF(t));
  let i = 0;
  if (e[i++] = t.id, t.type === "full")
    e[i++] = tf.Full, e[i++] = t.data.length, e.set(t.data, i), i += t.data.length;
  else {
    e[i++] = tf.Delta, e[i++] = t.deltas.length;
    for (const n of t.deltas)
      e[i++] = n.start, e[i++] = n.deleteCount, n.data ? (e[i++] = n.data.length, e.set(n.data, i), i += n.data.length) : e[i++] = 0;
  }
  return cF(e);
}
function dF(t) {
  let e = 0;
  if (e += 2, t.type === "full")
    e += 1 + t.data.length;
  else {
    e += 1, e += 3 * t.deltas.length;
    for (const i of t.deltas)
      i.data && (e += i.data.length);
  }
  return e;
}
function KI(t) {
  const e = uF(t);
  let i = 0;
  const n = e[i++];
  if (e[i++] === tf.Full) {
    const a = e[i++], l = e.subarray(i, i + a);
    return i += a, {
      id: n,
      type: "full",
      data: l
    };
  }
  const s = e[i++], o = [];
  for (let a = 0; a < s; a++) {
    const l = e[i++], c = e[i++], u = e[i++];
    let d;
    u > 0 && (d = e.subarray(i, i + u), i += u), o[a] = { start: l, deleteCount: c, data: d };
  }
  return {
    id: n,
    type: "delta",
    deltas: o
  };
}
const hF = [
  new Pe(
    "vscode.executeDocumentHighlights",
    "_executeDocumentHighlights",
    "Execute document highlight provider.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of DocumentHighlight-instances.",
      Jn(su.to)
    )
  ),
  new Pe(
    "vscode.executeDocumentSymbolProvider",
    "_executeDocumentSymbolProvider",
    "Execute document symbol provider.",
    [q.Uri],
    new Se(
      "A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.",
      (t, e) => {
        if (mx(t))
          return;
        class i extends sh {
          constructor() {
            super(...arguments), this.containerName = "";
          }
          static to(r) {
            const s = new i(
              r.name,
              jn.to(r.kind),
              r.containerName || "",
              new Ln(e[0], z.to(r.range))
            );
            return s.detail = r.detail, s.range = s.location.range, s.selectionRange = z.to(r.selectionRange), s.children = r.children ? r.children.map(i.to) : [], s;
          }
        }
        return t.map(i.to);
      }
    )
  ),
  new Pe(
    "vscode.executeFormatDocumentProvider",
    "_executeFormatDocumentProvider",
    "Execute document format provider.",
    [q.Uri, new q("options", "Formatting options", (t) => !0, (t) => t)],
    new Se(
      "A promise that resolves to an array of TextEdits.",
      Jn(hi.to)
    )
  ),
  new Pe(
    "vscode.executeFormatRangeProvider",
    "_executeFormatRangeProvider",
    "Execute range format provider.",
    [q.Uri, q.Range, new q("options", "Formatting options", (t) => !0, (t) => t)],
    new Se(
      "A promise that resolves to an array of TextEdits.",
      Jn(hi.to)
    )
  ),
  new Pe(
    "vscode.executeFormatOnTypeProvider",
    "_executeFormatOnTypeProvider",
    "Execute format on type provider.",
    [q.Uri, q.Position, new q("ch", "Trigger character", (t) => typeof t == "string", (t) => t), new q("options", "Formatting options", (t) => !0, (t) => t)],
    new Se(
      "A promise that resolves to an array of TextEdits.",
      Jn(hi.to)
    )
  ),
  new Pe(
    "vscode.executeDefinitionProvider",
    "_executeDefinitionProvider",
    "Execute all definition providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Location or LocationLink instances.",
      Qs
    )
  ),
  new Pe(
    "vscode.experimental.executeDefinitionProvider_recursive",
    "_executeDefinitionProvider_recursive",
    "Execute all definition providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Location or LocationLink instances.",
      Qs
    )
  ),
  new Pe(
    "vscode.executeTypeDefinitionProvider",
    "_executeTypeDefinitionProvider",
    "Execute all type definition providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Location or LocationLink instances.",
      Qs
    )
  ),
  new Pe(
    "vscode.experimental.executeTypeDefinitionProvider_recursive",
    "_executeTypeDefinitionProvider_recursive",
    "Execute all type definition providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Location or LocationLink instances.",
      Qs
    )
  ),
  new Pe(
    "vscode.executeDeclarationProvider",
    "_executeDeclarationProvider",
    "Execute all declaration providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Location or LocationLink instances.",
      Qs
    )
  ),
  new Pe(
    "vscode.experimental.executeDeclarationProvider_recursive",
    "_executeDeclarationProvider_recursive",
    "Execute all declaration providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Location or LocationLink instances.",
      Qs
    )
  ),
  new Pe(
    "vscode.executeImplementationProvider",
    "_executeImplementationProvider",
    "Execute all implementation providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Location or LocationLink instances.",
      Qs
    )
  ),
  new Pe(
    "vscode.experimental.executeImplementationProvider_recursive",
    "_executeImplementationProvider_recursive",
    "Execute all implementation providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Location or LocationLink instances.",
      Qs
    )
  ),
  new Pe(
    "vscode.executeReferenceProvider",
    "_executeReferenceProvider",
    "Execute all reference providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Location-instances.",
      Jn(an.to)
    )
  ),
  new Pe(
    "vscode.experimental.executeReferenceProvider",
    "_executeReferenceProvider_recursive",
    "Execute all reference providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Location-instances.",
      Jn(an.to)
    )
  ),
  new Pe(
    "vscode.executeHoverProvider",
    "_executeHoverProvider",
    "Execute all hover providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Hover-instances.",
      Jn(Fh.to)
    )
  ),
  new Pe(
    "vscode.experimental.executeHoverProvider_recursive",
    "_executeHoverProvider_recursive",
    "Execute all hover providers.",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of Hover-instances.",
      Jn(Fh.to)
    )
  ),
  new Pe(
    "vscode.executeSelectionRangeProvider",
    "_executeSelectionRangeProvider",
    "Execute selection range provider.",
    [q.Uri, new q(
      "position",
      "A position in a text document",
      (t) => Array.isArray(t) && t.every((e) => je.isPosition(e)),
      (t) => t.map(at.from)
    )],
    new Se("A promise that resolves to an array of ranges.", (t) => t.map((e) => {
      let i;
      for (const n of e.reverse())
        i = new ch(z.to(n), i);
      return i;
    }))
  ),
  new Pe(
    "vscode.executeWorkspaceSymbolProvider",
    "_executeWorkspaceSymbolProvider",
    "Execute all workspace symbol providers.",
    [q.String.with("query", "Search string")],
    new Se(
      "A promise that resolves to an array of SymbolInformation-instances.",
      (t) => t.map(ol.to)
    )
  ),
  new Pe(
    "vscode.prepareCallHierarchy",
    "_executePrepareCallHierarchy",
    "Prepare call hierarchy at a position inside a document",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of CallHierarchyItem-instances",
      (t) => t.map(al.to)
    )
  ),
  new Pe(
    "vscode.provideIncomingCalls",
    "_executeProvideIncomingCalls",
    "Compute incoming calls for an item",
    [q.CallHierarchyItem],
    new Se(
      "A promise that resolves to an array of CallHierarchyIncomingCall-instances",
      (t) => t.map(Rb.to)
    )
  ),
  new Pe(
    "vscode.provideOutgoingCalls",
    "_executeProvideOutgoingCalls",
    "Compute outgoing calls for an item",
    [q.CallHierarchyItem],
    new Se(
      "A promise that resolves to an array of CallHierarchyOutgoingCall-instances",
      (t) => t.map(Lb.to)
    )
  ),
  new Pe(
    "vscode.prepareRename",
    "_executePrepareRename",
    "Execute the prepareRename of rename provider.",
    [q.Uri, q.Position],
    new Se("A promise that resolves to a range and placeholder text.", (t) => {
      if (t)
        return {
          range: z.to(t.range),
          placeholder: t.text
        };
    })
  ),
  new Pe(
    "vscode.executeDocumentRenameProvider",
    "_executeDocumentRenameProvider",
    "Execute rename provider.",
    [q.Uri, q.Position, q.String.with("newName", "The new symbol name")],
    new Se("A promise that resolves to a WorkspaceEdit.", (t) => {
      if (t) {
        if (t.rejectReason)
          throw new Error(t.rejectReason);
        return yn.to(t);
      }
    })
  ),
  new Pe(
    "vscode.executeLinkProvider",
    "_executeLinkProvider",
    "Execute document link provider.",
    [q.Uri, q.Number.with("linkResolveCount", "Number of links that should be resolved, only when links are unresolved.").optional()],
    new Se(
      "A promise that resolves to an array of DocumentLink-instances.",
      (t) => t.map(La.to)
    )
  ),
  new Pe(
    "vscode.provideDocumentSemanticTokensLegend",
    "_provideDocumentSemanticTokensLegend",
    "Provide semantic tokens legend for a document",
    [q.Uri],
    new Se("A promise that resolves to SemanticTokensLegend.", (t) => {
      if (t)
        return new Vw(t.tokenTypes, t.tokenModifiers);
    })
  ),
  new Pe(
    "vscode.provideDocumentSemanticTokens",
    "_provideDocumentSemanticTokens",
    "Provide semantic tokens for a document",
    [q.Uri],
    new Se("A promise that resolves to SemanticTokens.", (t) => {
      if (!t)
        return;
      const e = KI(t);
      if (e.type === "full")
        return new eu(e.data, void 0);
    })
  ),
  new Pe(
    "vscode.provideDocumentRangeSemanticTokensLegend",
    "_provideDocumentRangeSemanticTokensLegend",
    "Provide semantic tokens legend for a document range",
    [q.Uri, q.Range.optional()],
    new Se("A promise that resolves to SemanticTokensLegend.", (t) => {
      if (t)
        return new Vw(t.tokenTypes, t.tokenModifiers);
    })
  ),
  new Pe(
    "vscode.provideDocumentRangeSemanticTokens",
    "_provideDocumentRangeSemanticTokens",
    "Provide semantic tokens for a document range",
    [q.Uri, q.Range],
    new Se("A promise that resolves to SemanticTokens.", (t) => {
      if (!t)
        return;
      const e = KI(t);
      if (e.type === "full")
        return new eu(e.data, void 0);
    })
  ),
  new Pe(
    "vscode.executeCompletionItemProvider",
    "_executeCompletionItemProvider",
    "Execute completion item provider.",
    [
      q.Uri,
      q.Position,
      q.String.with("triggerCharacter", "Trigger completion when the user types the character, like `,` or `(`").optional(),
      q.Number.with("itemResolveCount", "Number of completions to resolve (too large numbers slow down completions)").optional()
    ],
    new Se(
      "A promise that resolves to a CompletionList-instance.",
      (t, e, i) => {
        if (!t)
          return new Gc([]);
        const n = t.suggestions.map((r) => $b.to(r, i));
        return new Gc(n, t.incomplete);
      }
    )
  ),
  new Pe(
    "vscode.executeSignatureHelpProvider",
    "_executeSignatureHelpProvider",
    "Execute signature help provider.",
    [q.Uri, q.Position, q.String.with("triggerCharacter", "Trigger signature help when the user types the character, like `,` or `(`").optional()],
    new Se("A promise that resolves to SignatureHelp.", (t) => {
      if (t)
        return Uh.to(t);
    })
  ),
  new Pe(
    "vscode.executeCodeLensProvider",
    "_executeCodeLensProvider",
    "Execute code lens provider.",
    [q.Uri, q.Number.with("itemResolveCount", "Number of lenses that should be resolved and returned. Will only return resolved lenses, will impact performance)").optional()],
    new Se(
      "A promise that resolves to an array of CodeLens-instances.",
      (t, e, i) => Jn((n) => new Cg(z.to(n.range), n.command && i.fromInternal(n.command)))(t)
    )
  ),
  new Pe(
    "vscode.executeCodeActionProvider",
    "_executeCodeActionProvider",
    "Execute code action provider.",
    [
      q.Uri,
      new q(
        "rangeOrSelection",
        "Range in a text document. Some refactoring provider requires Selection object.",
        (t) => Oe.isRange(t),
        (t) => Qr.isSelection(t) ? vr.from(t) : z.from(t)
      ),
      q.String.with("kind", "Code action kind to return code actions for").optional(),
      q.Number.with("itemResolveCount", "Number of code actions to resolve (too large numbers slow down code actions)").optional()
    ],
    new Se(
      "A promise that resolves to an array of Command-instances.",
      (t, e, i) => Jn((n) => {
        if (n._isSynthetic) {
          if (!n.command)
            throw new Error("Synthetic code actions must have a command");
          return i.fromInternal(n.command);
        } else {
          const r = new lh(n.title, n.kind ? new At(n.kind) : void 0);
          return n.edit && (r.edit = yn.to(n.edit)), n.command && (r.command = i.fromInternal(n.command)), r.isPreferred = n.isPreferred, r;
        }
      })(t)
    )
  ),
  new Pe(
    "vscode.executeDocumentColorProvider",
    "_executeDocumentColorProvider",
    "Execute document color provider.",
    [q.Uri],
    new Se(
      "A promise that resolves to an array of ColorInformation objects.",
      (t) => t ? t.map(
        (e) => new Ng(z.to(e.range), ou.to(e.color))
      ) : []
    )
  ),
  new Pe(
    "vscode.executeColorPresentationProvider",
    "_executeColorPresentationProvider",
    "Execute color presentation provider.",
    [
      new q(
        "color",
        "The color to show and insert",
        (t) => t instanceof Jc,
        ou.from
      ),
      new q(
        "context",
        "Context object with uri and range",
        (t) => !0,
        (t) => ({ uri: t.uri, range: z.from(t.range) })
      )
    ],
    new Se(
      "A promise that resolves to an array of ColorPresentation objects.",
      (t) => t ? t.map(wm.to) : []
    )
  ),
  new Pe(
    "vscode.executeInlayHintProvider",
    "_executeInlayHintProvider",
    "Execute inlay hints provider",
    [q.Uri, q.Range],
    new Se(
      "A promise that resolves to an array of Inlay objects",
      (t, e, i) => t.map(Hb.to.bind(void 0, i))
    )
  ),
  new Pe(
    "vscode.executeFoldingRangeProvider",
    "_executeFoldingRangeProvider",
    "Execute folding range provider",
    [q.Uri],
    new Se(
      "A promise that resolves to an array of FoldingRange objects",
      (t, e) => {
        if (t)
          return t.map(xm.to);
      }
    )
  ),
  new Pe(
    "vscode.resolveNotebookContentProviders",
    "_resolveNotebookContentProvider",
    "Resolve Notebook Content Providers",
    [],
    new Se(
      "A promise that resolves to an array of NotebookContentProvider static info objects.",
      Jn((t) => ({
        viewType: t.viewType,
        displayName: t.displayName,
        options: {
          transientOutputs: t.options.transientOutputs,
          transientCellMetadata: t.options.transientCellMetadata,
          transientDocumentMetadata: t.options.transientDocumentMetadata
        },
        filenamePattern: t.filenamePattern.map((e) => Sm.to(e))
      }))
    )
  ),
  new Pe(
    "vscode.executeInlineValueProvider",
    "_executeInlineValueProvider",
    "Execute inline value provider",
    [
      q.Uri,
      q.Range,
      new q(
        "context",
        "An InlineValueContext",
        (t) => t && typeof t.frameId == "number" && t.stoppedLocation instanceof Oe,
        (t) => fm.from(t)
      )
    ],
    new Se("A promise that resolves to an array of InlineValue objects", (t) => t.map(hm.to))
  ),
  new Pe(
    "vscode.open",
    "_workbench.open",
    "Opens the provided resource in the editor. Can be a text or binary file, or an http(s) URL. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.",
    [
      new q(
        "uriOrString",
        "Uri-instance or string (only http/https)",
        (t) => x.isUri(t) || typeof t == "string" && MR(t, de.http, de.https),
        (t) => t
      ),
      new q(
        "columnOrOptions",
        "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
        (t) => t === void 0 || typeof t == "number" || typeof t == "object",
        (t) => t && (typeof t == "number" ? [si.from(t), void 0] : [si.from(t.viewColumn), xd.from(t)])
      ).optional(),
      q.String.with("label", "").optional()
    ],
    Se.Void
  ),
  new Pe(
    "vscode.openWith",
    "_workbench.openWith",
    "Opens the provided resource with a specific editor.",
    [
      q.Uri.with("resource", "Resource to open"),
      q.String.with("viewId", "Custom editor view id. This should be the viewType string for custom editors or the notebookType string for notebooks. Use 'default' to use VS Code's default text editor"),
      new q(
        "columnOrOptions",
        "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
        (t) => t === void 0 || typeof t == "number" || typeof t == "object",
        (t) => t && (typeof t == "number" ? [si.from(t), void 0] : [si.from(t.viewColumn), xd.from(t)])
      ).optional()
    ],
    Se.Void
  ),
  new Pe(
    "vscode.diff",
    "_workbench.diff",
    "Opens the provided resources in the diff editor to compare their contents.",
    [
      q.Uri.with("left", "Left-hand side resource of the diff editor"),
      q.Uri.with("right", "Right-hand side resource of the diff editor"),
      q.String.with("title", "Human readable title for the diff editor").optional(),
      new q(
        "columnOrOptions",
        "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
        (t) => t === void 0 || typeof t == "object",
        (t) => t && [si.from(t.viewColumn), xd.from(t)]
      ).optional()
    ],
    Se.Void
  ),
  new Pe(
    "vscode.changes",
    "_workbench.changes",
    "Opens a list of resources in the changes editor to compare their contents.",
    [
      q.String.with("title", "Human readable title for the changes editor"),
      new q("resourceList", "List of resources to compare", (t) => {
        for (const e of t) {
          if (e.length !== 3)
            return !1;
          const [i, n, r] = e;
          if (!x.isUri(i) || !x.isUri(n) && n !== void 0 && n !== null || !x.isUri(r) && r !== void 0 && r !== null)
            return !1;
        }
        return !0;
      }, (t) => t)
    ],
    Se.Void
  ),
  new Pe(
    "vscode.prepareTypeHierarchy",
    "_executePrepareTypeHierarchy",
    "Prepare type hierarchy at a position inside a document",
    [q.Uri, q.Position],
    new Se(
      "A promise that resolves to an array of TypeHierarchyItem-instances",
      (t) => t.map(Na.to)
    )
  ),
  new Pe(
    "vscode.provideSupertypes",
    "_executeProvideSupertypes",
    "Compute supertypes for an item",
    [q.TypeHierarchyItem],
    new Se(
      "A promise that resolves to an array of TypeHierarchyItem-instances",
      (t) => t.map(Na.to)
    )
  ),
  new Pe(
    "vscode.provideSubtypes",
    "_executeProvideSubtypes",
    "Compute subtypes for an item",
    [q.TypeHierarchyItem],
    new Se(
      "A promise that resolves to an array of TypeHierarchyItem-instances",
      (t) => t.map(Na.to)
    )
  ),
  new Pe(
    "vscode.revealTestInExplorer",
    "_revealTestInExplorer",
    "Reveals a test instance in the explorer",
    [q.TestItem],
    Se.Void
  ),
  new Pe(
    "vscode.startContinuousTestRun",
    "testing.startContinuousRunFromExtension",
    "Starts running the given tests with continuous run mode.",
    [q.TestProfile, q.Arr(q.TestItem)],
    Se.Void
  ),
  new Pe(
    "vscode.stopContinuousTestRun",
    "testing.stopContinuousRunFromExtension",
    "Stops running the given tests with continuous run mode.",
    [q.Arr(q.TestItem)],
    Se.Void
  ),
  new Pe(
    "vscode.experimental.editSession.continue",
    "_workbench.editSessions.actions.continueEditSession",
    "Continue the current edit session in a different workspace",
    [q.Uri.with("workspaceUri", "The target workspace to continue the current edit session in")],
    Se.Void
  ),
  new Pe(
    "setContext",
    "_setContext",
    "Set a custom context key value that can be used in when clauses.",
    [
      q.String.with("name", "The context key name"),
      new q("value", "The context key value", () => !0, (t) => t)
    ],
    Se.Void
  ),
  new Pe(
    "vscode.editorChat.start",
    "inlineChat.start",
    "Invoke a new editor chat session",
    [new q("Run arguments", "", (t) => !0, (t) => {
      if (t)
        return {
          initialRange: t.initialRange ? z.from(t.initialRange) : void 0,
          initialSelection: Qr.isSelection(t.initialSelection) ? vr.from(t.initialSelection) : void 0,
          message: t.message,
          attachments: t.attachments,
          autoSend: t.autoSend,
          position: t.position ? at.from(t.position) : void 0
        };
    })],
    Se.Void
  )
];
class fF {
  static register(e) {
    hF.forEach(e.registerApiCommand, e), this._registerValidateWhenClausesCommand(e);
  }
  static _registerValidateWhenClausesCommand(e) {
    e.registerCommand(!1, "_validateWhenClauses", jL);
  }
}
function Jn(t) {
  return (e) => {
    if (Array.isArray(e))
      return e.map(t);
  };
}
function Qs(t) {
  if (!Array.isArray(t))
    return;
  const e = [];
  for (const i of t)
    z7(i) ? e.push(Oh.to(i)) : e.push(an.to(i));
  return e;
}
let I0 = class {
  constructor(e, i) {
    this._proxy = e.getProxy(ee.MainThreadBulkEdits), this._versionInformationProvider = {
      getTextDocumentVersion: (n) => i.getDocument(n)?.version,
      getNotebookDocumentVersion: () => {
      }
    };
  }
  applyWorkspaceEdit(e, i, n) {
    const r = new zi(yn.from(e, this._versionInformationProvider));
    return this._proxy.$tryApplyWorkspaceEdit(r, void 0, n?.isRefactoring ?? !1);
  }
};
I0 = W([
  M(0, Ye)
], I0);
function pF(t) {
  return !!t && typeof t.sessionId == "string" && t.$mid === tt.ChatViewContext;
}
var JI;
(function(t) {
  t[t.Info = 0] = "Info", t[t.Warning = 1] = "Warning", t[t.Error = 2] = "Error";
})(JI || (JI = {}));
var YI;
(function(t) {
  t[t.Complete = 1] = "Complete", t[t.Partial = 2] = "Partial", t[t.Omitted = 3] = "Omitted";
})(YI || (YI = {}));
var XI;
(function(t) {
  t[t.NoReason = 0] = "NoReason", t[t.FilteredContentRetry = 1] = "FilteredContentRetry", t[t.CopyrightContentRetry = 2] = "CopyrightContentRetry";
})(XI || (XI = {}));
var n_;
(function(t) {
  t[t.Down = 0] = "Down", t[t.Up = 1] = "Up";
})(n_ || (n_ = {}));
var ZI;
(function(t) {
  t.IncorrectCode = "incorrectCode", t.DidNotFollowInstructions = "didNotFollowInstructions", t.IncompleteCode = "incompleteCode", t.MissingContext = "missingContext", t.PoorlyWrittenOrFormatted = "poorlyWrittenOrFormatted", t.RefusedAValidRequest = "refusedAValidRequest", t.OffensiveOrUnsafe = "offensiveOrUnsafe", t.Other = "other", t.WillReportIssue = "willReportIssue";
})(ZI || (ZI = {}));
var eC;
(function(t) {
  t[t.Action = 1] = "Action", t[t.Toolbar = 2] = "Toolbar";
})(eC || (eC = {}));
class C0 {
  constructor(e, i, n, r, s) {
    this._extension = e, this._request = i, this._proxy = n, this._commandsConverter = r, this._sessionDisposables = s, this._stopWatch = Ms.create(!1), this._isClosed = !1;
  }
  close() {
    this._isClosed = !0;
  }
  get timings() {
    return {
      firstProgress: this._firstProgress,
      totalElapsed: this._stopWatch.elapsed()
    };
  }
  get apiObject() {
    if (!this._apiObject) {
      let n = function(l) {
        if (e._isClosed) {
          const c = new Error("Response stream has been closed");
          throw Error.captureStackTrace(c, l), c;
        }
      }, o = function(l, c) {
        if (r.push(c !== void 0 ? [l, c] : l) === 1 && queueMicrotask(() => {
          e._proxy.$handleProgressChunk(e._request.requestId, r).finally(() => {
            s.forEach((d) => d()), s.length = 0;
          }), r.length = 0;
        }), c !== void 0)
          return new Promise((d) => {
            s.push(d);
          });
      };
      const e = this;
      this._stopWatch.reset();
      let i = 0;
      const r = [], s = [], a = (l, c) => {
        if (typeof this._firstProgress > "u" && (l.kind === "markdownContent" || l.kind === "markdownVuln" || l.kind === "prepareToolInvocation") && (this._firstProgress = this._stopWatch.elapsed()), c) {
          const u = i++, d = o(l, u), f = {
            report: (g) => {
              d.then(() => {
                bn.isMarkdownString(g.value) ? o(zh.from(g), u) : o(Oa.from(g), u);
              });
            }
          };
          Promise.all([d, c(f)]).then(([g, _]) => {
            o(ty.from(_), u);
          });
        } else
          o(l);
      };
      this._apiObject = Object.freeze({
        clearToPreviousToolInvocation(l) {
          return n(this.markdown), o({ kind: "clearToPreviousToolInvocation", reason: l }), this;
        },
        markdown(l) {
          n(this.markdown);
          const c = new X_(l), u = Bh.from(c);
          return a(u), this;
        },
        markdownWithVulnerabilities(l, c) {
          n(this.markdown), c && $(e._extension, "chatParticipantAdditions");
          const u = new Th(l, c), d = Pm.from(u);
          return a(d), this;
        },
        codeblockUri(l, c) {
          n(this.codeblockUri), $(e._extension, "chatParticipantAdditions");
          const u = new t1(l, c), d = Tm.from(u);
          return a(d), this;
        },
        filetree(l, c) {
          n(this.filetree);
          const u = new Z_(l, c), d = Wh.from(u);
          return a(d), this;
        },
        anchor(l, c) {
          const u = new Ph(l, c);
          return this.push(u);
        },
        button(l) {
          n(this.anchor);
          const c = new e1(l), u = jh.from(c, e._commandsConverter, e._sessionDisposables);
          return a(u), this;
        },
        progress(l, c) {
          n(this.progress);
          const u = new _p(l, c), d = c ? Rm.from(u) : Vh.from(u);
          return a(d, c), this;
        },
        warning(l) {
          n(this.progress), $(e._extension, "chatParticipantAdditions");
          const c = new Ah(l), u = zh.from(c);
          return a(u), this;
        },
        reference(l, c) {
          return this.reference2(l, c);
        },
        reference2(l, c, u) {
          if (n(this.reference), typeof l == "object" && "variableName" in l && $(e._extension, "chatParticipantAdditions"), typeof l == "object" && "variableName" in l && !l.value) {
            const d = e._request.variables.variables.find((f) => f.name === l.variableName);
            if (d) {
              let f;
              if (d.references?.length)
                f = d.references.map((g) => ({
                  kind: "reference",
                  reference: { variableName: l.variableName, value: g.reference }
                }));
              else {
                const g = new Ra(l, c, u);
                f = [Oa.from(g)];
              }
              return f.forEach((g) => a(g)), this;
            }
          } else {
            const d = new Ra(l, c, u), f = Oa.from(d);
            a(f);
          }
          return this;
        },
        codeCitation(l, c, u) {
          n(this.codeCitation), $(e._extension, "chatParticipantAdditions");
          const d = new rm(l, c, u), f = Om.from(d);
          a(f);
        },
        textEdit(l, c) {
          n(this.textEdit), $(e._extension, "chatParticipantAdditions");
          const u = new Rh(l, c);
          u.isDone = c === !0 ? !0 : void 0;
          const d = Lm.from(u);
          return a(d), this;
        },
        notebookEdit(l, c) {
          n(this.notebookEdit), $(e._extension, "chatParticipantAdditions");
          const u = new sm(l, c), d = Mm.from(u);
          return a(d), this;
        },
        confirmation(l, c, u, d) {
          n(this.confirmation), $(e._extension, "chatParticipantAdditions");
          const f = new nm(l, c, u, d), g = Am.from(f);
          return a(g), this;
        },
        prepareToolInvocation(l) {
          n(this.prepareToolInvocation), $(e._extension, "chatParticipantAdditions");
          const c = new Lh(l), u = qh.from(c);
          return a(u), this;
        },
        push(l) {
          if (n(this.push), (l instanceof Rh || l instanceof sm || l instanceof Th || l instanceof Ah || l instanceof nm || l instanceof rm || l instanceof i1 || l instanceof oE || l instanceof aE || l instanceof _p) && $(e._extension, "chatParticipantAdditions"), l instanceof Ra)
            this.reference2(l.value, l.iconPath, l.options);
          else if (l instanceof _p) {
            const c = l.task ? Rm.from(l) : Vh.from(l);
            a(c, l.task);
          } else if (l instanceof Ph) {
            const c = gu.from(l);
            if (l.resolve) {
              $(e._extension, "chatParticipantAdditions"), c.resolveId = on();
              const u = new Pt();
              l.resolve(u.token).then(() => {
                const d = gu.from(l);
                e._proxy.$handleAnchorResolve(e._request.requestId, c.resolveId, d);
              }).then(() => u.dispose(), () => u.dispose()), e._sessionDisposables.add(Ee(() => u.dispose(!0)));
            }
            a(c);
          } else if (l instanceof Lh) {
            $(e._extension, "chatParticipantAdditions");
            const c = qh.from(l);
            return a(c), this;
          } else {
            const c = Gh.from(l, e._commandsConverter, e._sessionDisposables);
            a(c);
          }
          return this;
        }
      });
    }
    return this._apiObject;
  }
}
const vs = class vs extends ve {
  constructor(e, i, n, r, s, o, a) {
    super(), this._logService = i, this._commands = n, this._documents = r, this._languageModels = s, this._diagnostics = o, this._tools = a, this._agents = /* @__PURE__ */ new Map(), this._participantDetectionProviders = /* @__PURE__ */ new Map(), this._relatedFilesProviders = /* @__PURE__ */ new Map(), this._sessionDisposables = this._register(new Ap()), this._completionDisposables = this._register(new Ap()), this._inFlightRequests = /* @__PURE__ */ new Set(), this._onDidChangeChatRequestTools = this._register(new N()), this.onDidChangeChatRequestTools = this._onDidChangeChatRequestTools.event, this._onDidDisposeChatSession = this._register(new N()), this.onDidDisposeChatSession = this._onDidDisposeChatSession.event, this._proxy = e.getProxy(ee.MainThreadChatAgents2), n.registerArgumentProcessor({
      processArgument: (l) => pF(l) ? null : l
    });
  }
  transferActiveChat(e) {
    this._proxy.$transferActiveChatSession(e);
  }
  createChatAgent(e, i, n) {
    const r = vs._idPool++, s = new tC(e, i, this._proxy, r, n);
    return this._agents.set(r, s), this._proxy.$registerAgent(r, e.identifier, i, {}, void 0), s.apiAgent;
  }
  createDynamicChatAgent(e, i, n, r) {
    const s = vs._idPool++, o = new tC(e, i, this._proxy, s, r);
    return this._agents.set(s, o), this._proxy.$registerAgent(s, e.identifier, i, { isSticky: !0 }, n), o.apiAgent;
  }
  registerChatParticipantDetectionProvider(e, i) {
    const n = vs._participantDetectionProviderIdPool++;
    return this._participantDetectionProviders.set(n, new gF(e, i)), this._proxy.$registerChatParticipantDetectionProvider(n), Ee(() => {
      this._participantDetectionProviders.delete(n), this._proxy.$unregisterChatParticipantDetectionProvider(n);
    });
  }
  registerRelatedFilesProvider(e, i, n) {
    const r = vs._relatedFilesProviderIdPool++;
    return this._relatedFilesProviders.set(r, new mF(e, i)), this._proxy.$registerRelatedFilesProvider(r, n), Ee(() => {
      this._relatedFilesProviders.delete(r), this._proxy.$unregisterRelatedFilesProvider(r);
    });
  }
  async $provideRelatedFiles(e, i, n) {
    const r = this._relatedFilesProviders.get(e);
    if (!r)
      return Promise.resolve([]);
    const s = iy.to(i);
    return await r.provider.provideRelatedFiles(s, n) ?? void 0;
  }
  async $detectChatParticipant(e, i, n, r, s) {
    const o = this._participantDetectionProviders.get(e);
    if (!o)
      return;
    const { request: a, location: l, history: c } = await this._createRequest(i, n, o.extension), u = await this.getModelForRequest(a, o.extension), d = Qh.to(a, l, u, this.getDiagnosticsWhenEnabled(o.extension), this.getToolsForRequest(o.extension, a), o.extension, this._logService);
    return o.provider.provideParticipantDetection(d, { history: c }, { participants: r.participants, location: Fm.to(r.location) }, s);
  }
  async _createRequest(e, i, n) {
    const r = Fi(e), s = await this.prepareHistoryTurns(n, r.agentId, i);
    let o;
    if (r.locationData?.type === nn.Editor) {
      const a = this._documents.getDocument(r.locationData.document);
      o = new pP(a, vr.to(r.locationData.selection), z.to(r.locationData.wholeRange));
    } else if (r.locationData?.type === nn.Notebook) {
      const a = this._documents.getDocument(r.locationData.sessionInputUri);
      o = new gP(a);
    }
    return { request: r, location: o, history: s };
  }
  async getModelForRequest(e, i) {
    let n;
    if (e.userSelectedModelId && (n = await this._languageModels.getLanguageModelByIdentifier(i, e.userSelectedModelId)), !n && (n = await this._languageModels.getDefaultLanguageModel(i), !n))
      throw new Error("Language model unavailable");
    return n;
  }
  async $setRequestPaused(e, i, n) {
    const r = this._agents.get(e);
    if (!r)
      return;
    const s = Oi.find(this._inFlightRequests, (o) => o.requestId === i);
    s && r.setChatRequestPauseState({ request: s.extRequest, isPaused: n });
  }
  async $setRequestTools(e, i) {
    const n = [...this._inFlightRequests].find((r) => r.requestId === e);
    if (n) {
      n.extRequest.tools.clear();
      for (const [r, s] of this.getToolsForRequest(n.extension, i))
        n.extRequest.tools.set(r, s);
      this._onDidChangeChatRequestTools.fire(n.extRequest);
    }
  }
  async $invokeAgent(e, i, n, r) {
    const s = this._agents.get(e);
    if (!s)
      throw new Error(
        `[CHAT](${e}) CANNOT invoke agent because the agent is not registered`
      );
    let o, a;
    try {
      const { request: l, location: c, history: u } = await this._createRequest(i, n, s.extension);
      let d = this._sessionDisposables.get(l.sessionId);
      d || (d = new De(), this._sessionDisposables.set(l.sessionId, d)), o = new C0(
        s.extension,
        l,
        this._proxy,
        this._commands.converter,
        d
      );
      const f = await this.getModelForRequest(l, s.extension), g = Qh.to(l, c, f, this.getDiagnosticsWhenEnabled(s.extension), this.getToolsForRequest(s.extension, l), s.extension, this._logService);
      a = { requestId: i.requestId, extRequest: g, extension: s.extension }, this._inFlightRequests.add(a);
      const _ = s.invoke(g, { history: u }, o.apiObject, r);
      return await _F(1e3, Promise.resolve(_).then((w) => {
        if (w?.metadata)
          try {
            JSON.stringify(w.metadata);
          } catch (S) {
            const E = `result.metadata MUST be JSON.stringify-able. Got error: ${S.message}`;
            return this._logService.error(`[${s.extension.identifier.value}] [@${s.id}] ${E}`, s.extension), { errorDetails: { message: E }, timings: o?.timings, nextQuestion: w.nextQuestion };
          }
        let v;
        return w?.errorDetails && (v = {
          ...w.errorDetails,
          responseIsIncomplete: !0
        }), (v?.responseIsRedacted || v?.isQuotaExceeded || v?.confirmationButtons) && $(s.extension, "chatParticipantPrivate"), { errorDetails: v, timings: o?.timings, metadata: w?.metadata, nextQuestion: w?.nextQuestion, details: w?.details };
      }), r);
    } catch (l) {
      this._logService.error(l, s.extension), l instanceof bi && l.cause && (l = l.cause);
      const c = l instanceof Error && l.name === "ChatQuotaExceeded";
      return { errorDetails: { message: xu(l), responseIsIncomplete: !0, isQuotaExceeded: c } };
    } finally {
      a && this._inFlightRequests.delete(a), o?.close();
    }
  }
  getDiagnosticsWhenEnabled(e) {
    return lt(e, "chatReferenceDiagnostic") ? this._diagnostics.getDiagnostics() : [];
  }
  getToolsForRequest(e, i) {
    if (!i.userSelectedTools)
      return /* @__PURE__ */ new Map();
    const n = /* @__PURE__ */ new Map();
    for (const r of this._tools.getTools(e))
      typeof i.userSelectedTools[r.name] == "boolean" && n.set(r.name, i.userSelectedTools[r.name]);
    return n;
  }
  async prepareHistoryTurns(e, i, n) {
    const r = [];
    for (const s of n.history) {
      const o = Dc.to(s.result), a = i === s.request.agentId ? o : { ...o, metadata: void 0 }, l = [], c = [];
      for (const g of s.request.variables.variables)
        if (g.kind === "tool")
          c.push(Kh.to(g));
        else if (g.kind === "toolset")
          c.push(...g.value.map(Kh.to));
        else {
          const _ = Um.to(g, this.getDiagnosticsWhenEnabled(e), this._logService);
          _ && l.push(_);
        }
      const u = lt(e, "chatParticipantPrivate") ? s.request.editedFileEvents : void 0, d = new om(s.request.message, s.request.command, l, s.request.agentId, c, u);
      r.push(d);
      const f = Kt(s.response.map((g) => Gh.toContent(g, this._commands.converter)));
      r.push(new fP(f, a, s.request.agentId, s.request.command));
    }
    return r;
  }
  $releaseSession(e) {
    this._sessionDisposables.deleteAndDispose(e), this._onDidDisposeChatSession.fire(e);
  }
  async $provideFollowups(e, i, n, r, s) {
    const o = this._agents.get(i);
    if (!o)
      return Promise.resolve([]);
    const a = Fi(e), l = await this.prepareHistoryTurns(o.extension, o.id, r), c = Dc.to(n);
    return (await o.provideFollowups(c, { history: l }, s)).filter((u) => {
      const d = !u.participant || Oi.some(this._agents.values(), (f) => f.id === u.participant && ht.equals(f.extension.identifier, o.extension.identifier));
      return d || this._logService.warn(`[@${o.id}] ChatFollowup refers to an unknown participant: ${u.participant}`), d;
    }).map((u) => Im.from(u, a));
  }
  $acceptFeedback(e, i, n) {
    const r = this._agents.get(e);
    if (!r)
      return;
    const s = Dc.to(i);
    let o;
    switch (n.direction) {
      case n_.Down:
        o = Ch.Unhelpful;
        break;
      case n_.Up:
        o = Ch.Helpful;
        break;
    }
    const a = {
      result: s,
      kind: o,
      unhelpfulReason: lt(r.extension, "chatParticipantAdditions") ? n.reason : void 0
    };
    r.acceptFeedback(Object.freeze(a));
  }
  $acceptAction(e, i, n) {
    const r = this._agents.get(e);
    if (!r || n.action.kind === "vote")
      return;
    const s = ry.to(i, n, this._commands.converter);
    s && r.acceptAction(Object.freeze(s));
  }
  async $invokeCompletionProvider(e, i, n) {
    const r = this._agents.get(e);
    if (!r)
      return [];
    let s = this._completionDisposables.get(e);
    return s ? s.clear() : (s = new De(), this._completionDisposables.set(e, s)), (await r.invokeCompletionProvider(i, n)).map(
      (a) => ny.from(a, this._commands.converter, s)
    );
  }
  async $provideChatTitle(e, i, n) {
    const r = this._agents.get(e);
    if (!r)
      return;
    const s = await this.prepareHistoryTurns(r.extension, r.id, { history: i });
    return await r.provideTitle({ history: s }, n);
  }
  async $provideChatSummary(e, i, n) {
    const r = this._agents.get(e);
    if (!r)
      return;
    const s = await this.prepareHistoryTurns(r.extension, r.id, { history: i });
    return await r.provideSummary({ history: s }, n);
  }
};
vs._idPool = 0, vs._participantDetectionProviderIdPool = 0, vs._relatedFilesProviderIdPool = 0;
let T0 = vs;
class gF {
  constructor(e, i) {
    this.extension = e, this.provider = i;
  }
}
class mF {
  constructor(e, i) {
    this.extension = e, this.provider = i;
  }
}
class tC {
  constructor(e, i, n, r, s) {
    this.extension = e, this.id = i, this._proxy = n, this._handle = r, this._requestHandler = s, this._onDidReceiveFeedback = new N(), this._onDidPerformAction = new N(), this._pauseStateEmitter = new N();
  }
  acceptFeedback(e) {
    this._onDidReceiveFeedback.fire(e);
  }
  acceptAction(e) {
    this._onDidPerformAction.fire(e);
  }
  setChatRequestPauseState(e) {
    this._pauseStateEmitter.fire(e);
  }
  async invokeCompletionProvider(e, i) {
    return this._agentVariableProvider ? await this._agentVariableProvider.provider.provideCompletionItems(e, i) ?? [] : [];
  }
  async provideFollowups(e, i, n) {
    if (!this._followupProvider)
      return [];
    const r = await this._followupProvider.provideFollowups(e, i, n);
    return r ? r.filter((s) => !(s && "commandId" in s)).filter((s) => !(s && "message" in s)) : [];
  }
  async provideTitle(e, i) {
    if (this._titleProvider)
      return await this._titleProvider.provideChatTitle(e, i) ?? void 0;
  }
  async provideSummary(e, i) {
    if (this._summarizer)
      return await this._summarizer.provideChatSummary(e, i) ?? void 0;
  }
  get apiAgent() {
    let e = !1, i = !1;
    const n = () => {
      e || i || (i = !0, queueMicrotask(() => {
        this._proxy.$updateAgent(this._handle, {
          icon: this._iconPath ? this._iconPath instanceof x ? this._iconPath : "light" in this._iconPath ? this._iconPath.light : void 0 : void 0,
          iconDark: this._iconPath && "dark" in this._iconPath ? this._iconPath.dark : void 0,
          themeIcon: this._iconPath instanceof qi ? this._iconPath : void 0,
          hasFollowups: this._followupProvider !== void 0,
          helpTextPrefix: !this._helpTextPrefix || typeof this._helpTextPrefix == "string" ? this._helpTextPrefix : Ae.from(this._helpTextPrefix),
          helpTextVariablesPrefix: !this._helpTextVariablesPrefix || typeof this._helpTextVariablesPrefix == "string" ? this._helpTextVariablesPrefix : Ae.from(this._helpTextVariablesPrefix),
          helpTextPostfix: !this._helpTextPostfix || typeof this._helpTextPostfix == "string" ? this._helpTextPostfix : Ae.from(this._helpTextPostfix),
          supportIssueReporting: this._supportIssueReporting,
          requester: this._requester,
          additionalWelcomeMessage: !this._additionalWelcomeMessage || typeof this._additionalWelcomeMessage == "string" ? this._additionalWelcomeMessage : Ae.from(this._additionalWelcomeMessage)
        }), i = !1;
      }));
    }, r = this;
    return {
      get id() {
        return r.id;
      },
      get iconPath() {
        return r._iconPath;
      },
      set iconPath(s) {
        r._iconPath = s, n();
      },
      get requestHandler() {
        return r._requestHandler;
      },
      set requestHandler(s) {
        i4(typeof s == "function", "Invalid request handler"), r._requestHandler = s;
      },
      get followupProvider() {
        return r._followupProvider;
      },
      set followupProvider(s) {
        r._followupProvider = s, n();
      },
      get helpTextPrefix() {
        return $(r.extension, "defaultChatParticipant"), r._helpTextPrefix;
      },
      set helpTextPrefix(s) {
        $(r.extension, "defaultChatParticipant"), r._helpTextPrefix = s, n();
      },
      get helpTextVariablesPrefix() {
        return $(r.extension, "defaultChatParticipant"), r._helpTextVariablesPrefix;
      },
      set helpTextVariablesPrefix(s) {
        $(r.extension, "defaultChatParticipant"), r._helpTextVariablesPrefix = s, n();
      },
      get helpTextPostfix() {
        return $(r.extension, "defaultChatParticipant"), r._helpTextPostfix;
      },
      set helpTextPostfix(s) {
        $(r.extension, "defaultChatParticipant"), r._helpTextPostfix = s, n();
      },
      get supportIssueReporting() {
        return $(r.extension, "chatParticipantPrivate"), r._supportIssueReporting;
      },
      set supportIssueReporting(s) {
        $(r.extension, "chatParticipantPrivate"), r._supportIssueReporting = s, n();
      },
      get onDidReceiveFeedback() {
        return r._onDidReceiveFeedback.event;
      },
      set participantVariableProvider(s) {
        if ($(r.extension, "chatParticipantAdditions"), r._agentVariableProvider = s, s) {
          if (!s.triggerCharacters.length)
            throw new Error("triggerCharacters are required");
          r._proxy.$registerAgentCompletionsProvider(r._handle, r.id, s.triggerCharacters);
        } else
          r._proxy.$unregisterAgentCompletionsProvider(r._handle, r.id);
      },
      get participantVariableProvider() {
        return $(r.extension, "chatParticipantAdditions"), r._agentVariableProvider;
      },
      set additionalWelcomeMessage(s) {
        $(r.extension, "defaultChatParticipant"), r._additionalWelcomeMessage = s, n();
      },
      get additionalWelcomeMessage() {
        return $(r.extension, "defaultChatParticipant"), r._additionalWelcomeMessage;
      },
      set titleProvider(s) {
        $(r.extension, "defaultChatParticipant"), r._titleProvider = s, n();
      },
      get titleProvider() {
        return $(r.extension, "defaultChatParticipant"), r._titleProvider;
      },
      set summarizer(s) {
        $(r.extension, "defaultChatParticipant"), r._summarizer = s;
      },
      get summarizer() {
        return $(r.extension, "defaultChatParticipant"), r._summarizer;
      },
      get onDidChangePauseState() {
        return $(r.extension, "chatParticipantAdditions"), r._pauseStateEmitter.event;
      },
      onDidPerformAction: lt(this.extension, "chatParticipantAdditions") ? this._onDidPerformAction.event : void 0,
      set requester(s) {
        r._requester = s, n();
      },
      get requester() {
        return r._requester;
      },
      dispose() {
        e = !0, r._followupProvider = void 0, r._onDidReceiveFeedback.dispose(), r._proxy.$unregisterAgent(r._handle);
      }
    };
  }
  invoke(e, i, n, r) {
    return this._requestHandler(e, i, n, r);
  }
}
function _F(t, e, i) {
  return new Promise((n, r) => {
    const s = i.onCancellationRequested(async () => {
      s.dispose(), await qr(t), n(void 0);
    });
    e.then(n, r).finally(() => s.dispose());
  });
}
class vF {
  constructor(e) {
    this._items = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadChatStatus);
  }
  createChatStatusItem(e, i) {
    const n = wF(e.identifier, i);
    if (this._items.has(n))
      throw new Error(`Chat status item '${i}' already exists`);
    const r = {
      id: n,
      title: "",
      description: "",
      detail: ""
    };
    let s = !1, o = !1;
    const a = () => {
      if (s)
        throw new Error("Chat status item is disposed");
      o && this._proxy.$setEntry(i, r);
    }, l = Object.freeze({
      id: i,
      get title() {
        return r.title;
      },
      set title(c) {
        r.title = c, a();
      },
      get description() {
        return r.description;
      },
      set description(c) {
        r.description = c, a();
      },
      get detail() {
        return r.detail;
      },
      set detail(c) {
        r.detail = c, a();
      },
      show: () => {
        o = !0, a();
      },
      hide: () => {
        o = !1, this._proxy.$disposeEntry(i);
      },
      dispose: () => {
        s = !0, this._proxy.$disposeEntry(i), this._items.delete(n);
      }
    });
    return this._items.set(n, l), l;
  }
}
function wF(t, e) {
  return `${ht.toKey(t)}.${e}`;
}
class bF {
  constructor(e) {
    const i = e.getProxy(ee.MainThreadClipboard);
    this.value = Object.freeze({
      readText() {
        return i.$readText();
      },
      writeText(n) {
        return i.$writeText(n);
      }
    });
  }
}
const T5 = "vscode-cdn.net", yF = `vscode-resource.${T5}`, P0 = `'self' https://*.${T5}`;
function Id(t, e) {
  return t.scheme === de.http || t.scheme === de.https ? t : (e && e.authority && e.isRemote && t.scheme === de.file && (t = x.from({
    scheme: de.vscodeRemote,
    authority: e.authority,
    path: t.path
  })), x.from({
    scheme: de.https,
    authority: `${t.scheme}+${xF(t.authority)}.${yF}`,
    path: t.path,
    fragment: t.fragment,
    query: t.query
  }));
}
function xF(t) {
  return t.replace(/./g, (e) => {
    const i = e.charCodeAt(0);
    return i >= L.a && i <= L.z || i >= L.A && i <= L.Z || i >= L.Digit0 && i <= L.Digit9 ? e : "-" + i.toString(16).padStart(4, "0");
  });
}
class EF {
  constructor(e, i, n) {
    this._proxy = e, this._editors = i, this._remoteInfo = n, this._handlePool = 0, this._disposables = new De(), this._insets = /* @__PURE__ */ new Map(), this._disposables.add(i.onDidChangeVisibleTextEditors(() => {
      const r = i.getVisibleTextEditors();
      for (const s of this._insets.values())
        r.indexOf(s.editor) < 0 && s.inset.dispose();
    }));
  }
  dispose() {
    this._insets.forEach((e) => e.inset.dispose()), this._disposables.dispose();
  }
  createWebviewEditorInset(e, i, n, r, s) {
    let o;
    for (const g of this._editors.getVisibleTextEditors(!0))
      if (g.value === e) {
        o = g;
        break;
      }
    if (!o)
      throw new Error("not a visible editor");
    const a = this, l = this._handlePool++, c = new N(), u = new N(), d = new class {
      constructor() {
        this._html = "", this._options = /* @__PURE__ */ Object.create(null);
      }
      asWebviewUri(g) {
        return Id(g, a._remoteInfo);
      }
      get cspSource() {
        return P0;
      }
      set options(g) {
        this._options = g, a._proxy.$setOptions(l, g);
      }
      get options() {
        return this._options;
      }
      set html(g) {
        this._html = g, a._proxy.$setHtml(l, g);
      }
      get html() {
        return this._html;
      }
      get onDidReceiveMessage() {
        return c.event;
      }
      postMessage(g) {
        return a._proxy.$postMessage(l, g);
      }
    }(), f = new class {
      constructor() {
        this.editor = e, this.line = i, this.height = n, this.webview = d, this.onDidDispose = u.event;
      }
      dispose() {
        a._insets.has(l) && (a._insets.delete(l), a._proxy.$disposeEditorInset(l), u.fire(), u.dispose(), c.dispose());
      }
    }();
    return this._proxy.$createEditorInset(l, o.id, o.value.document.uri, i + 1, n, r || {}, s.identifier, s.extensionLocation), this._insets.set(l, { editor: e, inset: f, onDidReceiveMessage: c }), f;
  }
  $onDidDispose(e) {
    const i = this._insets.get(e);
    i && i.inset.dispose();
  }
  $onDidReceiveMessage(e, i) {
    this._insets.get(e)?.onDidReceiveMessage.fire(i);
  }
}
const E_ = class E_ {
  constructor(e) {
    this.providers = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadCodeMapper);
  }
  async $mapCode(e, i, n) {
    const r = this.providers.get(e);
    if (!r)
      throw new Error(`Received request to map code for unknown provider handle ${e}`);
    const s = {
      textEdit: (l, c) => {
        c = qn(c), this._proxy.$handleProgress(i.requestId, {
          uri: l,
          edits: c.map(hi.from)
        });
      },
      notebookEdit: (l, c) => {
        c = qn(c), this._proxy.$handleProgress(i.requestId, {
          uri: l,
          edits: c.map(Nm.from)
        });
      }
    }, o = {
      location: i.location,
      chatRequestId: i.chatRequestId,
      chatRequestModel: i.chatRequestModel,
      chatSessionId: i.chatSessionId,
      codeBlocks: i.codeBlocks.map((l) => ({
        code: l.code,
        resource: x.revive(l.resource),
        markdownBeforeBlock: l.markdownBeforeBlock
      }))
    };
    return await r.provideMappedEdits(o, s, n) ?? null;
  }
  registerMappedEditsProvider(e, i) {
    const n = E_._providerHandlePool++;
    return this._proxy.$registerCodeMapperProvider(n, e.displayName ?? e.name), this.providers.set(n, i), {
      dispose: () => this._proxy.$unregisterCodeMapperProvider(n)
    };
  }
};
E_._providerHandlePool = 0;
let A0 = E_;
function SF(t, e, i) {
  const n = t.getProxy(ee.MainThreadComments), g = class g {
    constructor() {
      this._commentControllers = /* @__PURE__ */ new Map(), this._commentControllersByExtension = new Io(), e.registerArgumentProcessor({
        processArgument: (v) => {
          if (v && v.$mid === tt.CommentController) {
            const S = this._commentControllers.get(v.handle);
            return S ? S.value : v;
          } else if (v && v.$mid === tt.CommentThread) {
            const S = v, E = this._commentControllers.get(S.commentControlHandle);
            if (!E)
              return S;
            const A = E.getCommentThread(S.commentThreadHandle);
            return A ? A.value : S;
          } else if (v && (v.$mid === tt.CommentThreadReply || v.$mid === tt.CommentThreadInstance)) {
            const S = this._commentControllers.get(v.thread.commentControlHandle);
            if (!S)
              return v;
            const E = S.getCommentThread(v.thread.commentThreadHandle);
            return E ? v.$mid === tt.CommentThreadInstance ? E.value : {
              thread: E.value,
              text: v.text
            } : v;
          } else if (v && v.$mid === tt.CommentNode) {
            const S = this._commentControllers.get(v.thread.commentControlHandle);
            if (!S)
              return v;
            const E = S.getCommentThread(v.thread.commentThreadHandle);
            if (!E)
              return v;
            const A = v.commentUniqueId, j = E.getCommentByUniqueId(A);
            return j || v;
          } else if (v && v.$mid === tt.CommentThreadNode) {
            const S = this._commentControllers.get(v.thread.commentControlHandle);
            if (!S)
              return v;
            const E = S.getCommentThread(v.thread.commentThreadHandle);
            if (!E)
              return v;
            const A = v.text, j = v.commentUniqueId, V = E.getCommentByUniqueId(j);
            return V ? (typeof V.body == "string" ? V.body = A : V.body = new bn(A), V) : v;
          }
          return v;
        }
      });
    }
    createCommentController(v, S, E) {
      const A = g.handlePool++, j = new o(v, A, S, E);
      this._commentControllers.set(j.handle, j);
      const V = this._commentControllersByExtension.get(v.identifier) || [];
      return V.push(j), this._commentControllersByExtension.set(v.identifier, V), j.value;
    }
    async $createCommentThreadTemplate(v, S, E, A) {
      const j = this._commentControllers.get(v);
      j && j.$createCommentThreadTemplate(S, E, A);
    }
    async $setActiveComment(v, S) {
      const E = this._commentControllers.get(v);
      E && E.$setActiveComment(S ?? void 0);
    }
    async $updateCommentThreadTemplate(v, S, E) {
      const A = this._commentControllers.get(v);
      A && A.$updateCommentThreadTemplate(S, E);
    }
    $deleteCommentThread(v, S) {
      this._commentControllers.get(v)?.$deleteCommentThread(S);
    }
    async $updateCommentThread(v, S, E) {
      this._commentControllers.get(v)?.$updateCommentThread(S, E);
    }
    async $provideCommentingRanges(v, S, E) {
      const A = this._commentControllers.get(v);
      if (!A || !A.commentingRangeProvider)
        return Promise.resolve(void 0);
      const j = await i.ensureDocumentData(x.revive(S));
      return Ai(async () => {
        const V = await A.commentingRangeProvider?.provideCommentingRanges(j.document, E);
        let le;
        return Array.isArray(V) ? le = {
          ranges: V,
          fileComments: !1
        } : V ? le = {
          ranges: V.ranges || [],
          fileComments: V.enableFileComments || !1
        } : le = V ?? void 0, le;
      }).then((V) => {
        let le;
        return V && (le = {
          ranges: V.ranges.map((Q) => z.from(Q)),
          fileComments: V.fileComments
        }), le;
      });
    }
    $toggleReaction(v, S, E, A, j) {
      const V = this._commentControllers.get(v);
      return !V || !V.reactionHandler ? Promise.resolve(void 0) : Ai(() => {
        const le = V.getCommentThread(S);
        if (le) {
          const Q = le.getCommentByUniqueId(A.uniqueIdInThread);
          if (V !== void 0 && Q && V.reactionHandler)
            return V.reactionHandler(Q, c(j));
        }
        return Promise.resolve(void 0);
      });
    }
  };
  g.handlePool = 0;
  let r = g;
  const _ = class _ {
    set threadId(v) {
      this._id = v;
    }
    get threadId() {
      return this._id;
    }
    get id() {
      return this._id;
    }
    get resource() {
      return this._uri;
    }
    get uri() {
      return this._uri;
    }
    set range(v) {
      (v === void 0 != (this._range === void 0) || !v || !this._range || !v.isEqual(this._range)) && (this._range = v, this.modifications.range = v, this._onDidUpdateCommentThread.fire());
    }
    get range() {
      return this._range;
    }
    set canReply(v) {
      this._canReply !== v && (this._canReply = v, this.modifications.canReply = v, this._onDidUpdateCommentThread.fire());
    }
    get canReply() {
      return this._canReply;
    }
    get label() {
      return this._label;
    }
    set label(v) {
      this._label = v, this.modifications.label = v, this._onDidUpdateCommentThread.fire();
    }
    get contextValue() {
      return this._contextValue;
    }
    set contextValue(v) {
      this._contextValue = v, this.modifications.contextValue = v, this._onDidUpdateCommentThread.fire();
    }
    get comments() {
      return this._comments;
    }
    set comments(v) {
      this._comments = v, this.modifications.comments = v, this._onDidUpdateCommentThread.fire();
    }
    get collapsibleState() {
      return this._collapseState;
    }
    set collapsibleState(v) {
      this._collapseState !== v && (this._collapseState = v, this.modifications.collapsibleState = v, this._onDidUpdateCommentThread.fire());
    }
    get state() {
      return this._state;
    }
    set state(v) {
      this._state = v, typeof v == "object" ? ($(this.extensionDescription, "commentThreadApplicability"), this.modifications.state = v.resolved, this.modifications.applicability = v.applicability) : this.modifications.state = v, this._onDidUpdateCommentThread.fire();
    }
    get isDisposed() {
      return this._isDiposed;
    }
    constructor(v, S, E, A, j, V, le, Q, re) {
      this._commentControllerHandle = S, this._id = E, this._uri = A, this._range = j, this._comments = V, this.extensionDescription = le, this._isTemplate = Q, this.handle = _._handlePool++, this.commentHandle = 0, this.modifications = /* @__PURE__ */ Object.create(null), this._onDidUpdateCommentThread = new N(), this.onDidUpdateCommentThread = this._onDidUpdateCommentThread.event, this._canReply = !0, this._commentsMap = /* @__PURE__ */ new Map(), this._acceptInputDisposables = new Ss(), this._acceptInputDisposables.value = new De(), this._id === void 0 && (this._id = `${v}.${this.handle}`), n.$createCommentThread(S, this.handle, this._id, this._uri, z.from(this._range), this._comments.map(
        (ye) => a(this, ye, this._commentsMap, this.extensionDescription)
      ), le.identifier, this._isTemplate, re), this._localDisposables = [], this._isDiposed = !1, this._localDisposables.push(this.onDidUpdateCommentThread(() => {
        this.eventuallyUpdateCommentThread();
      })), this._localDisposables.push({
        dispose: () => {
          n.$deleteCommentThread(S, this.handle);
        }
      });
      const K = this;
      this.value = {
        get uri() {
          return K.uri;
        },
        get range() {
          return K.range;
        },
        set range(ye) {
          K.range = ye;
        },
        get comments() {
          return K.comments;
        },
        set comments(ye) {
          K.comments = ye;
        },
        get collapsibleState() {
          return K.collapsibleState;
        },
        set collapsibleState(ye) {
          K.collapsibleState = ye;
        },
        get canReply() {
          return K.canReply;
        },
        set canReply(ye) {
          K.canReply = ye;
        },
        get contextValue() {
          return K.contextValue;
        },
        set contextValue(ye) {
          K.contextValue = ye;
        },
        get label() {
          return K.label;
        },
        set label(ye) {
          K.label = ye;
        },
        get state() {
          return K.state;
        },
        set state(ye) {
          K.state = ye;
        },
        reveal: (ye, Fe) => K.reveal(ye, Fe),
        hide: () => K.hide(),
        dispose: () => {
          K.dispose();
        }
      };
    }
    updateIsTemplate() {
      this._isTemplate && (this._isTemplate = !1, this.modifications.isTemplate = !1);
    }
    eventuallyUpdateCommentThread() {
      if (this._isDiposed)
        return;
      this.updateIsTemplate(), this._acceptInputDisposables.value || (this._acceptInputDisposables.value = new De());
      const v = (E) => Object.prototype.hasOwnProperty.call(this.modifications, E), S = {};
      v("range") && (S.range = z.from(this._range)), v("label") && (S.label = this.label), v("contextValue") && (S.contextValue = this.contextValue ?? null), v("comments") && (S.comments = this._comments.map(
        (E) => a(this, E, this._commentsMap, this.extensionDescription)
      )), v("collapsibleState") && (S.collapseState = u(this._collapseState)), v("canReply") && (S.canReply = this.canReply), v("state") && (S.state = d(this._state)), v("applicability") && (S.applicability = f(this._state)), v("isTemplate") && (S.isTemplate = this._isTemplate), this.modifications = {}, n.$updateCommentThread(this._commentControllerHandle, this.handle, this._id, this._uri, S);
    }
    getCommentByUniqueId(v) {
      for (const S of this._commentsMap) {
        const E = S[0], A = S[1];
        if (v === A)
          return E;
      }
    }
    async reveal(v, S) {
      $(this.extensionDescription, "commentReveal");
      let E;
      v && v.body !== void 0 ? E = v : S = S ?? v;
      let A = E ? this._commentsMap.get(E) : void 0;
      A ??= this._commentsMap.get(this._comments[0]);
      let j = !0, V = !1;
      return S?.focus === Eh.Reply ? (V = !0, j = !1) : S?.focus === Eh.Comment && (j = !1), n.$revealCommentThread(this._commentControllerHandle, this.handle, A, { preserveFocus: j, focusReply: V });
    }
    async hide() {
      return n.$hideCommentThread(this._commentControllerHandle, this.handle);
    }
    dispose() {
      this._isDiposed = !0, this._acceptInputDisposables.dispose(), this._localDisposables.forEach((v) => v.dispose());
    }
  };
  _._handlePool = 0;
  let s = _;
  class o {
    get id() {
      return this._id;
    }
    get label() {
      return this._label;
    }
    get handle() {
      return this._handle;
    }
    get commentingRangeProvider() {
      return this._commentingRangeProvider;
    }
    set commentingRangeProvider(v) {
      this._commentingRangeProvider = v, v?.resourceHints && $(this._extension, "commentingRangeHint"), n.$updateCommentingRanges(this.handle, v?.resourceHints);
    }
    get reactionHandler() {
      return this._reactionHandler;
    }
    set reactionHandler(v) {
      this._reactionHandler = v, n.$updateCommentControllerFeatures(this.handle, { reactionHandler: !!v });
    }
    get options() {
      return this._options;
    }
    set options(v) {
      this._options = v, n.$updateCommentControllerFeatures(this.handle, { options: this._options });
    }
    get activeComment() {
      return $(this._extension, "activeComment"), this._activeComment;
    }
    get activeCommentThread() {
      return $(this._extension, "activeComment"), this._activeThread?.value;
    }
    constructor(v, S, E, A) {
      this._extension = v, this._handle = S, this._id = E, this._label = A, this._threads = /* @__PURE__ */ new Map(), n.$registerCommentController(this.handle, E, A, this._extension.identifier.value);
      const j = this;
      this.value = Object.freeze({
        id: j.id,
        label: j.label,
        get options() {
          return j.options;
        },
        set options(V) {
          j.options = V;
        },
        get commentingRangeProvider() {
          return j.commentingRangeProvider;
        },
        set commentingRangeProvider(V) {
          j.commentingRangeProvider = V;
        },
        get reactionHandler() {
          return j.reactionHandler;
        },
        set reactionHandler(V) {
          j.reactionHandler = V;
        },
        get activeCommentThread() {
          return j.activeCommentThread;
        },
        createCommentThread(V, le, Q) {
          return j.createCommentThread(V, le, Q).value;
        },
        dispose: () => {
          j.dispose();
        }
      }), this._localDisposables = [], this._localDisposables.push({
        dispose: () => {
          n.$unregisterCommentController(this.handle);
        }
      });
    }
    createCommentThread(v, S, E) {
      const A = new s(
        this.id,
        this.handle,
        void 0,
        v,
        S,
        E,
        this._extension,
        !1
      );
      return this._threads.set(A.handle, A), A;
    }
    $setActiveComment(v) {
      if (!v) {
        this._activeComment = void 0, this._activeThread = void 0;
        return;
      }
      const S = this._threads.get(v.commentThreadHandle);
      S && (this._activeComment = v.uniqueIdInThread ? S.getCommentByUniqueId(v.uniqueIdInThread) : void 0, this._activeThread = S);
    }
    $createCommentThreadTemplate(v, S, E) {
      const A = new s(
        this.id,
        this.handle,
        void 0,
        x.revive(v),
        z.to(S),
        [],
        this._extension,
        !0,
        E
      );
      return A.collapsibleState = Wl.Expanded, this._threads.set(A.handle, A), A;
    }
    $updateCommentThreadTemplate(v, S) {
      const E = this._threads.get(v);
      E && (E.range = z.to(S));
    }
    $updateCommentThread(v, S) {
      const E = this._threads.get(v);
      if (!E)
        return;
      ((j) => Object.prototype.hasOwnProperty.call(S, j))("collapseState") && (E.collapsibleState = u(S.collapseState));
    }
    $deleteCommentThread(v) {
      this._threads.get(v)?.dispose(), this._threads.delete(v);
    }
    getCommentThread(v) {
      return this._threads.get(v);
    }
    dispose() {
      this._threads.forEach((v) => {
        v.dispose();
      }), this._localDisposables.forEach((v) => v.dispose());
    }
  }
  function a(w, v, S, E) {
    let A = S.get(v);
    return A || (A = ++w.commentHandle, S.set(v, A)), v.state !== void 0 && $(E, "commentsDraftState"), v.reactions?.some((j) => j.reactors !== void 0) && $(E, "commentReactor"), {
      mode: v.mode,
      contextValue: v.contextValue,
      uniqueIdInThread: A,
      body: typeof v.body == "string" ? v.body : Ae.from(v.body),
      userName: v.author.name,
      userIconPath: v.author.iconPath,
      label: v.label,
      commentReactions: v.reactions ? v.reactions.map((j) => l(j)) : void 0,
      state: v.state,
      timestamp: v.timestamp?.toJSON()
    };
  }
  function l(w) {
    return {
      label: w.label,
      iconPath: w.iconPath ? s1(w.iconPath) : void 0,
      count: w.count,
      hasReacted: w.authorHasReacted,
      reactors: w.reactors && w.reactors.length > 0 && typeof w.reactors[0] != "string" ? w.reactors.map((v) => v.name) : w.reactors
    };
  }
  function c(w) {
    return {
      label: w.label || "",
      count: w.count || 0,
      iconPath: w.iconPath ? x.revive(w.iconPath) : "",
      authorHasReacted: w.hasReacted || !1,
      reactors: w.reactors?.map((v) => ({ name: v }))
    };
  }
  function u(w) {
    if (w !== void 0)
      switch (w) {
        case bh.Expanded:
          return Wl.Expanded;
        case bh.Collapsed:
          return Wl.Collapsed;
      }
    return Wl.Collapsed;
  }
  function d(w) {
    let v;
    if (typeof w == "object" ? v = w.resolved : v = w, v !== void 0)
      switch (v) {
        case yh.Unresolved:
          return hd.Unresolved;
        case yh.Resolved:
          return hd.Resolved;
      }
    return hd.Unresolved;
  }
  function f(w) {
    let v;
    if (typeof w == "object" && (v = w.applicability), v !== void 0)
      switch (v) {
        case xh.Current:
          return fd.Current;
        case xh.Outdated:
          return fd.Outdated;
      }
    return fd.Current;
  }
  return new r();
}
var Hf = { exports: {} }, iC;
function DF() {
  return iC || (iC = 1, function(t, e) {
    e = t.exports = Je;
    var i;
    typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? i = function() {
      var D = Array.prototype.slice.call(arguments, 0);
      D.unshift("SEMVER"), console.log.apply(console, D);
    } : i = function() {
    }, e.SEMVER_SPEC_VERSION = "2.0.0";
    var n = 256, r = Number.MAX_SAFE_INTEGER || 9007199254740991, s = 16, o = e.re = [], a = e.src = [], l = 0, c = l++;
    a[c] = "0|[1-9]\\d*";
    var u = l++;
    a[u] = "[0-9]+";
    var d = l++;
    a[d] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var f = l++;
    a[f] = "(" + a[c] + ")\\.(" + a[c] + ")\\.(" + a[c] + ")";
    var g = l++;
    a[g] = "(" + a[u] + ")\\.(" + a[u] + ")\\.(" + a[u] + ")";
    var _ = l++;
    a[_] = "(?:" + a[c] + "|" + a[d] + ")";
    var w = l++;
    a[w] = "(?:" + a[u] + "|" + a[d] + ")";
    var v = l++;
    a[v] = "(?:-(" + a[_] + "(?:\\." + a[_] + ")*))";
    var S = l++;
    a[S] = "(?:-?(" + a[w] + "(?:\\." + a[w] + ")*))";
    var E = l++;
    a[E] = "[0-9A-Za-z-]+";
    var A = l++;
    a[A] = "(?:\\+(" + a[E] + "(?:\\." + a[E] + ")*))";
    var j = l++, V = "v?" + a[f] + a[v] + "?" + a[A] + "?";
    a[j] = "^" + V + "$";
    var le = "[v=\\s]*" + a[g] + a[S] + "?" + a[A] + "?", Q = l++;
    a[Q] = "^" + le + "$";
    var re = l++;
    a[re] = "((?:<|>)?=?)";
    var K = l++;
    a[K] = a[u] + "|x|X|\\*";
    var ye = l++;
    a[ye] = a[c] + "|x|X|\\*";
    var Fe = l++;
    a[Fe] = "[v=\\s]*(" + a[ye] + ")(?:\\.(" + a[ye] + ")(?:\\.(" + a[ye] + ")(?:" + a[v] + ")?" + a[A] + "?)?)?";
    var Te = l++;
    a[Te] = "[v=\\s]*(" + a[K] + ")(?:\\.(" + a[K] + ")(?:\\.(" + a[K] + ")(?:" + a[S] + ")?" + a[A] + "?)?)?";
    var X = l++;
    a[X] = "^" + a[re] + "\\s*" + a[Fe] + "$";
    var Y = l++;
    a[Y] = "^" + a[re] + "\\s*" + a[Te] + "$";
    var Z = l++;
    a[Z] = "(?:^|[^\\d])(\\d{1," + s + "})(?:\\.(\\d{1," + s + "}))?(?:\\.(\\d{1," + s + "}))?(?:$|[^\\d])";
    var ie = l++;
    a[ie] = "(?:~>?)";
    var ce = l++;
    a[ce] = "(\\s*)" + a[ie] + "\\s+", o[ce] = new RegExp(a[ce], "g");
    var Le = "$1~", Be = l++;
    a[Be] = "^" + a[ie] + a[Fe] + "$";
    var qe = l++;
    a[qe] = "^" + a[ie] + a[Te] + "$";
    var St = l++;
    a[St] = "(?:\\^)";
    var Jt = l++;
    a[Jt] = "(\\s*)" + a[St] + "\\s+", o[Jt] = new RegExp(a[Jt], "g");
    var ct = "$1^", $t = l++;
    a[$t] = "^" + a[St] + a[Fe] + "$";
    var ln = l++;
    a[ln] = "^" + a[St] + a[Te] + "$";
    var gi = l++;
    a[gi] = "^" + a[re] + "\\s*(" + le + ")$|^$";
    var yr = l++;
    a[yr] = "^" + a[re] + "\\s*(" + V + ")$|^$";
    var Gn = l++;
    a[Gn] = "(\\s*)" + a[re] + "\\s*(" + le + "|" + a[Fe] + ")", o[Gn] = new RegExp(a[Gn], "g");
    var $i = "$1$2$3", ku = l++;
    a[ku] = "^\\s*(" + a[Fe] + ")\\s+-\\s+(" + a[Fe] + ")\\s*$";
    var yf = l++;
    a[yf] = "^\\s*(" + a[Te] + ")\\s+-\\s+(" + a[Te] + ")\\s*$";
    var Hs = l++;
    a[Hs] = "(<|>)?=?\\s*\\*";
    for (var Mn = 0; Mn < l; Mn++)
      i(Mn, a[Mn]), o[Mn] || (o[Mn] = new RegExp(a[Mn]));
    e.parse = We;
    function We(D, F) {
      if (D instanceof Je)
        return D;
      if (typeof D != "string" || D.length > n)
        return null;
      var H = F ? o[Q] : o[j];
      if (!H.test(D))
        return null;
      try {
        return new Je(D, F);
      } catch {
        return null;
      }
    }
    e.valid = _1;
    function _1(D, F) {
      var H = We(D, F);
      return H ? H.version : null;
    }
    e.clean = v1;
    function v1(D, F) {
      var H = We(D.trim().replace(/^[=v]+/, ""), F);
      return H ? H.version : null;
    }
    e.SemVer = Je;
    function Je(D, F) {
      if (D instanceof Je) {
        if (D.loose === F)
          return D;
        D = D.version;
      } else if (typeof D != "string")
        throw new TypeError("Invalid Version: " + D);
      if (D.length > n)
        throw new TypeError("version is longer than " + n + " characters");
      if (!(this instanceof Je))
        return new Je(D, F);
      i("SemVer", D, F), this.loose = F;
      var H = D.trim().match(F ? o[Q] : o[j]);
      if (!H)
        throw new TypeError("Invalid Version: " + D);
      if (this.raw = D, this.major = +H[1], this.minor = +H[2], this.patch = +H[3], this.major > r || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > r || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > r || this.patch < 0)
        throw new TypeError("Invalid patch version");
      H[4] ? this.prerelease = H[4].split(".").map(function(oe) {
        if (/^[0-9]+$/.test(oe)) {
          var J = +oe;
          if (J >= 0 && J < r)
            return J;
        }
        return oe;
      }) : this.prerelease = [], this.build = H[5] ? H[5].split(".") : [], this.format();
    }
    Je.prototype.format = function() {
      return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
    }, Je.prototype.toString = function() {
      return this.version;
    }, Je.prototype.compare = function(D) {
      return i("SemVer.compare", this.version, this.loose, D), D instanceof Je || (D = new Je(D, this.loose)), this.compareMain(D) || this.comparePre(D);
    }, Je.prototype.compareMain = function(D) {
      return D instanceof Je || (D = new Je(D, this.loose)), Bs(this.major, D.major) || Bs(this.minor, D.minor) || Bs(this.patch, D.patch);
    }, Je.prototype.comparePre = function(D) {
      if (D instanceof Je || (D = new Je(D, this.loose)), this.prerelease.length && !D.prerelease.length)
        return -1;
      if (!this.prerelease.length && D.prerelease.length)
        return 1;
      if (!this.prerelease.length && !D.prerelease.length)
        return 0;
      var F = 0;
      do {
        var H = this.prerelease[F], oe = D.prerelease[F];
        if (i("prerelease compare", F, H, oe), H === void 0 && oe === void 0)
          return 0;
        if (oe === void 0)
          return 1;
        if (H === void 0)
          return -1;
        if (H === oe)
          continue;
        return Bs(H, oe);
      } while (++F);
    }, Je.prototype.inc = function(D, F) {
      switch (D) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", F);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", F);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", F), this.inc("pre", F);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", F), this.inc("pre", F);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            for (var H = this.prerelease.length; --H >= 0; )
              typeof this.prerelease[H] == "number" && (this.prerelease[H]++, H = -2);
            H === -1 && this.prerelease.push(0);
          }
          F && (this.prerelease[0] === F ? isNaN(this.prerelease[1]) && (this.prerelease = [F, 0]) : this.prerelease = [F, 0]);
          break;
        default:
          throw new Error("invalid increment argument: " + D);
      }
      return this.format(), this.raw = this.version, this;
    }, e.inc = Oo;
    function Oo(D, F, H, oe) {
      typeof H == "string" && (oe = H, H = void 0);
      try {
        return new Je(D, H).inc(F, oe).version;
      } catch {
        return null;
      }
    }
    e.diff = xf;
    function xf(D, F) {
      if (Cu(D, F))
        return null;
      var H = We(D), oe = We(F);
      if (H.prerelease.length || oe.prerelease.length) {
        for (var J in H)
          if ((J === "major" || J === "minor" || J === "patch") && H[J] !== oe[J])
            return "pre" + J;
        return "prerelease";
      }
      for (var J in H)
        if ((J === "major" || J === "minor" || J === "patch") && H[J] !== oe[J])
          return J;
    }
    e.compareIdentifiers = Bs;
    var Ef = /^[0-9]+$/;
    function Bs(D, F) {
      var H = Ef.test(D), oe = Ef.test(F);
      return H && oe && (D = +D, F = +F), H && !oe ? -1 : oe && !H ? 1 : D < F ? -1 : D > F ? 1 : 0;
    }
    e.rcompareIdentifiers = w1;
    function w1(D, F) {
      return Bs(F, D);
    }
    e.major = b1;
    function b1(D, F) {
      return new Je(D, F).major;
    }
    e.minor = Sf;
    function Sf(D, F) {
      return new Je(D, F).minor;
    }
    e.patch = y1;
    function y1(D, F) {
      return new Je(D, F).patch;
    }
    e.compare = cn;
    function cn(D, F, H) {
      return new Je(D, H).compare(new Je(F, H));
    }
    e.compareLoose = Iu;
    function Iu(D, F) {
      return cn(D, F, !0);
    }
    e.rcompare = x1;
    function x1(D, F, H) {
      return cn(F, D, H);
    }
    e.sort = E1;
    function E1(D, F) {
      return D.sort(function(H, oe) {
        return e.compare(H, oe, F);
      });
    }
    e.rsort = Ws;
    function Ws(D, F) {
      return D.sort(function(H, oe) {
        return e.rcompare(H, oe, F);
      });
    }
    e.gt = wl;
    function wl(D, F, H) {
      return cn(D, F, H) > 0;
    }
    e.lt = bl;
    function bl(D, F, H) {
      return cn(D, F, H) < 0;
    }
    e.eq = Cu;
    function Cu(D, F, H) {
      return cn(D, F, H) === 0;
    }
    e.neq = Fo;
    function Fo(D, F, H) {
      return cn(D, F, H) !== 0;
    }
    e.gte = Qn;
    function Qn(D, F, H) {
      return cn(D, F, H) >= 0;
    }
    e.lte = yl;
    function yl(D, F, H) {
      return cn(D, F, H) <= 0;
    }
    e.cmp = xl;
    function xl(D, F, H, oe) {
      var J;
      switch (F) {
        case "===":
          typeof D == "object" && (D = D.version), typeof H == "object" && (H = H.version), J = D === H;
          break;
        case "!==":
          typeof D == "object" && (D = D.version), typeof H == "object" && (H = H.version), J = D !== H;
          break;
        case "":
        case "=":
        case "==":
          J = Cu(D, H, oe);
          break;
        case "!=":
          J = Fo(D, H, oe);
          break;
        case ">":
          J = wl(D, H, oe);
          break;
        case ">=":
          J = Qn(D, H, oe);
          break;
        case "<":
          J = bl(D, H, oe);
          break;
        case "<=":
          J = yl(D, H, oe);
          break;
        default:
          throw new TypeError("Invalid operator: " + F);
      }
      return J;
    }
    e.Comparator = un;
    function un(D, F) {
      if (D instanceof un) {
        if (D.loose === F)
          return D;
        D = D.value;
      }
      if (!(this instanceof un))
        return new un(D, F);
      i("comparator", D, F), this.loose = F, this.parse(D), this.semver === Vs ? this.value = "" : this.value = this.operator + this.semver.version, i("comp", this);
    }
    var Vs = {};
    un.prototype.parse = function(D) {
      var F = this.loose ? o[gi] : o[yr], H = D.match(F);
      if (!H)
        throw new TypeError("Invalid comparator: " + D);
      this.operator = H[1], this.operator === "=" && (this.operator = ""), H[2] ? this.semver = new Je(H[2], this.loose) : this.semver = Vs;
    }, un.prototype.toString = function() {
      return this.value;
    }, un.prototype.test = function(D) {
      return i("Comparator.test", D, this.loose), this.semver === Vs ? !0 : (typeof D == "string" && (D = new Je(D, this.loose)), xl(D, this.operator, this.semver, this.loose));
    }, un.prototype.intersects = function(D, F) {
      if (!(D instanceof un))
        throw new TypeError("a Comparator is required");
      var H;
      if (this.operator === "")
        return H = new Ht(D.value, F), rt(this.value, H, F);
      if (D.operator === "")
        return H = new Ht(this.value, F), rt(D.semver, H, F);
      var oe = (this.operator === ">=" || this.operator === ">") && (D.operator === ">=" || D.operator === ">"), J = (this.operator === "<=" || this.operator === "<") && (D.operator === "<=" || D.operator === "<"), ke = this.semver.version === D.semver.version, He = (this.operator === ">=" || this.operator === "<=") && (D.operator === ">=" || D.operator === "<="), Qe = xl(this.semver, "<", D.semver, F) && (this.operator === ">=" || this.operator === ">") && (D.operator === "<=" || D.operator === "<"), st = xl(this.semver, ">", D.semver, F) && (this.operator === "<=" || this.operator === "<") && (D.operator === ">=" || D.operator === ">");
      return oe || J || ke && He || Qe || st;
    }, e.Range = Ht;
    function Ht(D, F) {
      if (D instanceof Ht)
        return D.loose === F ? D : new Ht(D.raw, F);
      if (D instanceof un)
        return new Ht(D.value, F);
      if (!(this instanceof Ht))
        return new Ht(D, F);
      if (this.loose = F, this.raw = D, this.set = D.split(/\s*\|\|\s*/).map(function(H) {
        return this.parseRange(H.trim());
      }, this).filter(function(H) {
        return H.length;
      }), !this.set.length)
        throw new TypeError("Invalid SemVer Range: " + D);
      this.format();
    }
    Ht.prototype.format = function() {
      return this.range = this.set.map(function(D) {
        return D.join(" ").trim();
      }).join("||").trim(), this.range;
    }, Ht.prototype.toString = function() {
      return this.range;
    }, Ht.prototype.parseRange = function(D) {
      var F = this.loose;
      D = D.trim(), i("range", D, F);
      var H = F ? o[yf] : o[ku];
      D = D.replace(H, Au), i("hyphen replace", D), D = D.replace(o[Gn], $i), i("comparator trim", D, o[Gn]), D = D.replace(o[ce], Le), D = D.replace(o[Jt], ct), D = D.split(/\s+/).join(" ");
      var oe = F ? o[gi] : o[yr], J = D.split(" ").map(function(ke) {
        return Tu(ke, F);
      }).join(" ").split(/\s+/);
      return this.loose && (J = J.filter(function(ke) {
        return !!ke.match(oe);
      })), J = J.map(function(ke) {
        return new un(ke, F);
      }), J;
    }, Ht.prototype.intersects = function(D, F) {
      if (!(D instanceof Ht))
        throw new TypeError("a Range is required");
      return this.set.some(function(H) {
        return H.every(function(oe) {
          return D.set.some(function(J) {
            return J.every(function(ke) {
              return oe.intersects(ke, F);
            });
          });
        });
      });
    }, e.toComparators = Uo;
    function Uo(D, F) {
      return new Ht(D, F).set.map(function(H) {
        return H.map(function(oe) {
          return oe.value;
        }).join(" ").trim().split(" ");
      });
    }
    function Tu(D, F) {
      return i("comp", D), D = Pu(D, F), i("caret", D), D = S1(D, F), i("tildes", D), D = k1(D, F), i("xrange", D), D = xr(D, F), i("stars", D), D;
    }
    function Ni(D) {
      return !D || D.toLowerCase() === "x" || D === "*";
    }
    function S1(D, F) {
      return D.trim().split(/\s+/).map(function(H) {
        return D1(H, F);
      }).join(" ");
    }
    function D1(D, F) {
      var H = F ? o[qe] : o[Be];
      return D.replace(H, function(oe, J, ke, He, Qe) {
        i("tilde", D, oe, J, ke, He, Qe);
        var st;
        return Ni(J) ? st = "" : Ni(ke) ? st = ">=" + J + ".0.0 <" + (+J + 1) + ".0.0" : Ni(He) ? st = ">=" + J + "." + ke + ".0 <" + J + "." + (+ke + 1) + ".0" : Qe ? (i("replaceTilde pr", Qe), Qe.charAt(0) !== "-" && (Qe = "-" + Qe), st = ">=" + J + "." + ke + "." + He + Qe + " <" + J + "." + (+ke + 1) + ".0") : st = ">=" + J + "." + ke + "." + He + " <" + J + "." + (+ke + 1) + ".0", i("tilde return", st), st;
      });
    }
    function Pu(D, F) {
      return D.trim().split(/\s+/).map(function(H) {
        return Df(H, F);
      }).join(" ");
    }
    function Df(D, F) {
      i("caret", D, F);
      var H = F ? o[ln] : o[$t];
      return D.replace(H, function(oe, J, ke, He, Qe) {
        i("caret", D, oe, J, ke, He, Qe);
        var st;
        return Ni(J) ? st = "" : Ni(ke) ? st = ">=" + J + ".0.0 <" + (+J + 1) + ".0.0" : Ni(He) ? J === "0" ? st = ">=" + J + "." + ke + ".0 <" + J + "." + (+ke + 1) + ".0" : st = ">=" + J + "." + ke + ".0 <" + (+J + 1) + ".0.0" : Qe ? (i("replaceCaret pr", Qe), Qe.charAt(0) !== "-" && (Qe = "-" + Qe), J === "0" ? ke === "0" ? st = ">=" + J + "." + ke + "." + He + Qe + " <" + J + "." + ke + "." + (+He + 1) : st = ">=" + J + "." + ke + "." + He + Qe + " <" + J + "." + (+ke + 1) + ".0" : st = ">=" + J + "." + ke + "." + He + Qe + " <" + (+J + 1) + ".0.0") : (i("no pr"), J === "0" ? ke === "0" ? st = ">=" + J + "." + ke + "." + He + " <" + J + "." + ke + "." + (+He + 1) : st = ">=" + J + "." + ke + "." + He + " <" + J + "." + (+ke + 1) + ".0" : st = ">=" + J + "." + ke + "." + He + " <" + (+J + 1) + ".0.0"), i("caret return", st), st;
      });
    }
    function k1(D, F) {
      return i("replaceXRanges", D, F), D.split(/\s+/).map(function(H) {
        return C(H, F);
      }).join(" ");
    }
    function C(D, F) {
      D = D.trim();
      var H = F ? o[Y] : o[X];
      return D.replace(H, function(oe, J, ke, He, Qe, st) {
        i("xRange", D, oe, J, ke, He, Qe, st);
        var On = Ni(ke), Fn = On || Ni(He), m = Fn || Ni(Qe), b = m;
        return J === "=" && b && (J = ""), On ? J === ">" || J === "<" ? oe = "<0.0.0" : oe = "*" : J && b ? (Fn && (He = 0), m && (Qe = 0), J === ">" ? (J = ">=", Fn ? (ke = +ke + 1, He = 0, Qe = 0) : m && (He = +He + 1, Qe = 0)) : J === "<=" && (J = "<", Fn ? ke = +ke + 1 : He = +He + 1), oe = J + ke + "." + He + "." + Qe) : Fn ? oe = ">=" + ke + ".0.0 <" + (+ke + 1) + ".0.0" : m && (oe = ">=" + ke + "." + He + ".0 <" + ke + "." + (+He + 1) + ".0"), i("xRange return", oe), oe;
      });
    }
    function xr(D, F) {
      return i("replaceStars", D, F), D.trim().replace(o[Hs], "");
    }
    function Au(D, F, H, oe, J, ke, He, Qe, st, On, Fn, m, b) {
      return Ni(H) ? F = "" : Ni(oe) ? F = ">=" + H + ".0.0" : Ni(J) ? F = ">=" + H + "." + oe + ".0" : F = ">=" + F, Ni(st) ? Qe = "" : Ni(On) ? Qe = "<" + (+st + 1) + ".0.0" : Ni(Fn) ? Qe = "<" + st + "." + (+On + 1) + ".0" : m ? Qe = "<=" + st + "." + On + "." + Fn + "-" + m : Qe = "<=" + Qe, (F + " " + Qe).trim();
    }
    Ht.prototype.test = function(D) {
      if (!D)
        return !1;
      typeof D == "string" && (D = new Je(D, this.loose));
      for (var F = 0; F < this.set.length; F++)
        if (fe(this.set[F], D))
          return !0;
      return !1;
    };
    function fe(D, F) {
      for (var H = 0; H < D.length; H++)
        if (!D[H].test(F))
          return !1;
      if (F.prerelease.length) {
        for (var H = 0; H < D.length; H++)
          if (i(D[H].semver), D[H].semver !== Vs && D[H].semver.prerelease.length > 0) {
            var oe = D[H].semver;
            if (oe.major === F.major && oe.minor === F.minor && oe.patch === F.patch)
              return !0;
          }
        return !1;
      }
      return !0;
    }
    e.satisfies = rt;
    function rt(D, F, H) {
      try {
        F = new Ht(F, H);
      } catch {
        return !1;
      }
      return F.test(D);
    }
    e.maxSatisfying = I1;
    function I1(D, F, H) {
      var oe = null, J = null;
      try {
        var ke = new Ht(F, H);
      } catch {
        return null;
      }
      return D.forEach(function(He) {
        ke.test(He) && (!oe || J.compare(He) === -1) && (oe = He, J = new Je(oe, H));
      }), oe;
    }
    e.minSatisfying = C1;
    function C1(D, F, H) {
      var oe = null, J = null;
      try {
        var ke = new Ht(F, H);
      } catch {
        return null;
      }
      return D.forEach(function(He) {
        ke.test(He) && (!oe || J.compare(He) === 1) && (oe = He, J = new Je(oe, H));
      }), oe;
    }
    e.validRange = T1;
    function T1(D, F) {
      try {
        return new Ht(D, F).range || "*";
      } catch {
        return null;
      }
    }
    e.ltr = P1;
    function P1(D, F, H) {
      return Ru(D, F, "<", H);
    }
    e.gtr = El;
    function El(D, F, H) {
      return Ru(D, F, ">", H);
    }
    e.outside = Ru;
    function Ru(D, F, H, oe) {
      D = new Je(D, oe), F = new Ht(F, oe);
      var J, ke, He, Qe, st;
      switch (H) {
        case ">":
          J = wl, ke = yl, He = bl, Qe = ">", st = ">=";
          break;
        case "<":
          J = bl, ke = Qn, He = wl, Qe = "<", st = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (rt(D, F, oe))
        return !1;
      for (var On = 0; On < F.set.length; ++On) {
        var Fn = F.set[On], m = null, b = null;
        if (Fn.forEach(function(I) {
          I.semver === Vs && (I = new un(">=0.0.0")), m = m || I, b = b || I, J(I.semver, m.semver, oe) ? m = I : He(I.semver, b.semver, oe) && (b = I);
        }), m.operator === Qe || m.operator === st || (!b.operator || b.operator === Qe) && ke(D, b.semver))
          return !1;
        if (b.operator === st && He(D, b.semver))
          return !1;
      }
      return !0;
    }
    e.prerelease = A1;
    function A1(D, F) {
      var H = We(D, F);
      return H && H.prerelease.length ? H.prerelease : null;
    }
    e.intersects = R1;
    function R1(D, F, H) {
      return D = new Ht(D, H), F = new Ht(F, H), D.intersects(F);
    }
    e.coerce = kf;
    function kf(D) {
      if (D instanceof Je)
        return D;
      if (typeof D != "string")
        return null;
      var F = D.match(o[Z]);
      return F == null ? null : We((F[1] || "0") + "." + (F[2] || "0") + "." + (F[3] || "0"));
    }
  }(Hf, Hf.exports)), Hf.exports;
}
DF();
const P5 = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/, kF = /^-(\d{4})(\d{2})(\d{2})$/;
function IF(t) {
  return t = t.trim(), t === "*" || P5.test(t);
}
function A5(t) {
  if (!IF(t))
    return null;
  if (t = t.trim(), t === "*")
    return {
      hasCaret: !1,
      hasGreaterEquals: !1,
      majorBase: 0,
      majorMustEqual: !1,
      minorBase: 0,
      minorMustEqual: !1,
      patchBase: 0,
      patchMustEqual: !1,
      preRelease: null
    };
  const e = t.match(P5);
  return e ? {
    hasCaret: e[1] === "^",
    hasGreaterEquals: e[1] === ">=",
    majorBase: e[2] === "x" ? 0 : parseInt(e[2], 10),
    majorMustEqual: e[2] !== "x",
    minorBase: e[4] === "x" ? 0 : parseInt(e[4], 10),
    minorMustEqual: e[4] !== "x",
    patchBase: e[6] === "x" ? 0 : parseInt(e[6], 10),
    patchMustEqual: e[6] !== "x",
    preRelease: e[8] || null
  } : null;
}
function R5(t) {
  if (!t)
    return null;
  const e = t.majorBase, i = t.majorMustEqual, n = t.minorBase;
  let r = t.minorMustEqual;
  const s = t.patchBase;
  let o = t.patchMustEqual;
  t.hasCaret && (e === 0 || (r = !1), o = !1);
  let a = 0;
  if (t.preRelease) {
    const l = kF.exec(t.preRelease);
    if (l) {
      const [, c, u, d] = l;
      a = Date.UTC(Number(c), Number(u) - 1, Number(d));
    }
  }
  return {
    majorBase: e,
    majorMustEqual: i,
    minorBase: n,
    minorMustEqual: r,
    patchBase: s,
    patchMustEqual: o,
    isMinimum: t.hasGreaterEquals,
    notBefore: a
  };
}
class CF {
  constructor() {
    this.buffers = [];
  }
  add(e) {
    let i = this.buffers.indexOf(e);
    return i < 0 && (i = this.buffers.length, this.buffers.push(e)), i;
  }
}
function TF(t, e) {
  if (e.serializeBuffersForPostMessage) {
    const i = new CF(), r = JSON.stringify(t, (o, a) => {
      if (a instanceof ArrayBuffer)
        return {
          $$vscode_array_buffer_reference$$: !0,
          index: i.add(a)
        };
      if (ArrayBuffer.isView(a)) {
        const l = PF(a);
        if (l)
          return {
            $$vscode_array_buffer_reference$$: !0,
            index: i.add(a.buffer),
            view: {
              type: l,
              byteLength: a.byteLength,
              byteOffset: a.byteOffset
            }
          };
      }
      return a;
    }), s = i.buffers.map((o) => {
      const a = new Uint8Array(o);
      return ue.wrap(a);
    });
    return { message: r, buffers: s };
  } else
    return { message: JSON.stringify(t), buffers: [] };
}
function PF(t) {
  switch (t.constructor.name) {
    case "Int8Array":
      return Vt.Int8Array;
    case "Uint8Array":
      return Vt.Uint8Array;
    case "Uint8ClampedArray":
      return Vt.Uint8ClampedArray;
    case "Int16Array":
      return Vt.Int16Array;
    case "Uint16Array":
      return Vt.Uint16Array;
    case "Int32Array":
      return Vt.Int32Array;
    case "Uint32Array":
      return Vt.Uint32Array;
    case "Float32Array":
      return Vt.Float32Array;
    case "Float64Array":
      return Vt.Float64Array;
    case "BigInt64Array":
      return Vt.BigInt64Array;
    case "BigUint64Array":
      return Vt.BigUint64Array;
  }
}
function AF(t, e) {
  const i = e.map((s) => {
    const o = new ArrayBuffer(s.byteLength);
    return new Uint8Array(o).set(s.buffer), o;
  }), n = e.length ? (s, o) => {
    if (o && typeof o == "object" && o.$$vscode_array_buffer_reference$$) {
      const a = o, { index: l } = a, c = i[l];
      if (a.view)
        switch (a.view.type) {
          case Vt.Int8Array:
            return new Int8Array(
              c,
              a.view.byteOffset,
              a.view.byteLength / Int8Array.BYTES_PER_ELEMENT
            );
          case Vt.Uint8Array:
            return new Uint8Array(
              c,
              a.view.byteOffset,
              a.view.byteLength / Uint8Array.BYTES_PER_ELEMENT
            );
          case Vt.Uint8ClampedArray:
            return new Uint8ClampedArray(
              c,
              a.view.byteOffset,
              a.view.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT
            );
          case Vt.Int16Array:
            return new Int16Array(
              c,
              a.view.byteOffset,
              a.view.byteLength / Int16Array.BYTES_PER_ELEMENT
            );
          case Vt.Uint16Array:
            return new Uint16Array(
              c,
              a.view.byteOffset,
              a.view.byteLength / Uint16Array.BYTES_PER_ELEMENT
            );
          case Vt.Int32Array:
            return new Int32Array(
              c,
              a.view.byteOffset,
              a.view.byteLength / Int32Array.BYTES_PER_ELEMENT
            );
          case Vt.Uint32Array:
            return new Uint32Array(
              c,
              a.view.byteOffset,
              a.view.byteLength / Uint32Array.BYTES_PER_ELEMENT
            );
          case Vt.Float32Array:
            return new Float32Array(
              c,
              a.view.byteOffset,
              a.view.byteLength / Float32Array.BYTES_PER_ELEMENT
            );
          case Vt.Float64Array:
            return new Float64Array(
              c,
              a.view.byteOffset,
              a.view.byteLength / Float64Array.BYTES_PER_ELEMENT
            );
          case Vt.BigInt64Array:
            return new BigInt64Array(
              c,
              a.view.byteOffset,
              a.view.byteLength / BigInt64Array.BYTES_PER_ELEMENT
            );
          case Vt.BigUint64Array:
            return new BigUint64Array(
              c,
              a.view.byteOffset,
              a.view.byteLength / BigUint64Array.BYTES_PER_ELEMENT
            );
          default:
            throw new Error("Unknown array buffer view type");
        }
      return c;
    }
    return o;
  } : void 0;
  return { message: JSON.parse(t, n), arrayBuffers: i };
}
class RF {
  #e;
  #t;
  #i;
  #n;
  #s;
  #r;
  #a;
  #o;
  #l;
  #c;
  #u;
  #h;
  constructor(e, i, n, r, s, o, a) {
    this.#a = "", this.#l = !1, this.#c = !1, this._onMessageEmitter = new N(), this.onDidReceiveMessage = this._onMessageEmitter.event, this.#d = new N(), this._onDidDispose = this.#d.event, this.#e = e, this.#t = i, this.#o = n, this.#n = r, this.#s = s, this.#r = o, this.#u = vu(o), this.#h = LF(o), this.#i = a;
  }
  #d;
  dispose() {
    this.#l = !0, this.#d.fire(), this.#d.dispose(), this._onMessageEmitter.dispose();
  }
  asWebviewUri(e) {
    return this.#c = !0, Id(e, this.#n);
  }
  get cspSource() {
    const e = this.#r.extensionLocation;
    if (e.scheme === de.https || e.scheme === de.http) {
      let i = e.toString();
      return i.endsWith("/") || (i += "/"), i + " " + P0;
    }
    return P0;
  }
  get html() {
    return this.assertNotDisposed(), this.#a;
  }
  set html(e) {
    this.assertNotDisposed(), this.#a !== e && (this.#a = e, this.#h && !this.#c && /(["'])vscode-resource:([^\s'"]+?)(["'])/i.test(e) && (this.#c = !0, this.#i.report("Webview vscode-resource: uris", this.#r, "Please migrate to use the 'webview.asWebviewUri' api instead: https://aka.ms/vscode-webview-use-aswebviewuri")), this.#t.$setHtml(this.#e, this.rewriteOldResourceUrlsIfNeeded(e)));
  }
  get options() {
    return this.assertNotDisposed(), this.#o;
  }
  set options(e) {
    this.assertNotDisposed(), sn(this.#o, e) || this.#t.$setOptions(this.#e, L5(this.#r, this.#s, e)), this.#o = e;
  }
  async postMessage(e) {
    if (this.#l)
      return !1;
    const i = TF(e, { serializeBuffersForPostMessage: this.#u });
    return this.#t.$postMessage(this.#e, i.message, ...i.buffers);
  }
  assertNotDisposed() {
    if (this.#l)
      throw new Error("Webview is disposed");
  }
  rewriteOldResourceUrlsIfNeeded(e) {
    if (!this.#h)
      return e;
    const i = this.#r.extensionLocation?.scheme === de.vscodeRemote, n = this.#r.extensionLocation.scheme === de.vscodeRemote ? this.#r.extensionLocation.authority : void 0;
    return e.replace(/(["'])(?:vscode-resource):(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (r, s, o, a, l, c) => {
      const u = x.from({
        scheme: a || "file",
        path: decodeURIComponent(l)
      }), d = Id(u, { isRemote: i, authority: n }).toString();
      return `${s}${d}${c}`;
    }).replace(/(["'])(?:vscode-webview-resource):(\/\/[^\s\/'"]+\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (r, s, o, a, l, c) => {
      const u = x.from({
        scheme: a || "file",
        path: decodeURIComponent(l)
      }), d = Id(u, { isRemote: i, authority: n }).toString();
      return `${s}${d}${c}`;
    });
  }
}
function vu(t) {
  try {
    const e = R5(A5(t.engines.vscode));
    return !!e && e.majorBase >= 1 && e.minorBase >= 57;
  } catch {
    return !1;
  }
}
function LF(t) {
  try {
    const e = R5(A5(t.engines.vscode));
    return e ? e.majorBase < 1 || e.majorBase === 1 && e.minorBase < 60 : !1;
  } catch {
    return !1;
  }
}
class NF extends ve {
  constructor(e, i, n, r, s) {
    super(), this.remoteInfo = i, this.workspace = n, this._logService = r, this._deprecationService = s, this._webviews = /* @__PURE__ */ new Map(), this._webviewProxy = e.getProxy(ee.MainThreadWebviews);
  }
  dispose() {
    super.dispose();
    for (const e of this._webviews.values())
      e.dispose();
    this._webviews.clear();
  }
  $onMessage(e, i, n) {
    const r = this.getWebview(e);
    if (r) {
      const { message: s } = AF(i, n.value);
      r._onMessageEmitter.fire(s);
    }
  }
  $onMissingCsp(e, i) {
    this._logService.warn(`${i} created a webview without a content security policy: https://aka.ms/vscode-webview-missing-csp`);
  }
  createNewWebview(e, i, n) {
    const r = new RF(
      e,
      this._webviewProxy,
      MF(i),
      this.remoteInfo,
      this.workspace,
      n,
      this._deprecationService
    );
    this._webviews.set(e, r);
    const s = r._onDidDispose(() => {
      s.dispose(), this.deleteWebview(e);
    });
    return r;
  }
  deleteWebview(e) {
    this._webviews.delete(e);
  }
  getWebview(e) {
    return this._webviews.get(e);
  }
}
function r_(t) {
  return { id: t.identifier, location: t.extensionLocation };
}
function L5(t, e, i) {
  return {
    enableCommandUris: i.enableCommandUris,
    enableScripts: i.enableScripts,
    enableForms: i.enableForms,
    portMapping: i.portMapping,
    localResourceRoots: i.localResourceRoots || OF(t, e)
  };
}
function MF(t) {
  return {
    enableCommandUris: t.enableCommandUris,
    enableScripts: t.enableScripts,
    enableForms: t.enableForms,
    portMapping: t.portMapping,
    localResourceRoots: t.localResourceRoots?.map((e) => x.from(e))
  };
}
function OF(t, e) {
  return [
    ...(e?.getWorkspaceFolders() || []).map((i) => i.uri),
    t.extensionLocation
  ];
}
const S_ = class S_ {
  constructor(e) {
    this.id = e, this._data = /* @__PURE__ */ new Map(), this._idPool = 1;
  }
  add(e) {
    const i = this._idPool++;
    return this._data.set(i, e), this.logDebugInfo(), i;
  }
  get(e, i) {
    return this._data.has(e) ? this._data.get(e)[i] : void 0;
  }
  delete(e) {
    this._data.delete(e), this.logDebugInfo();
  }
  logDebugInfo() {
    S_.enableDebugLogging && console.log(`${this.id} cache size - ${this._data.size}`);
  }
};
S_.enableDebugLogging = !1;
let Nn = S_;
class FF {
  constructor(e, i) {
    this.document = e, this._storagePath = i, this._backupCounter = 1, this._edits = new Nn("custom documents");
  }
  addEdit(e) {
    return this._edits.add([e]);
  }
  async undo(e, i) {
    await this.getEdit(e).undo(), i || this.disposeBackup();
  }
  async redo(e, i) {
    await this.getEdit(e).redo(), i || this.disposeBackup();
  }
  disposeEdits(e) {
    for (const i of e)
      this._edits.delete(i);
  }
  getNewBackupUri() {
    if (!this._storagePath)
      throw new Error("Backup requires a valid storage path");
    const e = VF(this.document.uri) + this._backupCounter++;
    return wi(this._storagePath, e);
  }
  updateBackup(e) {
    this._backup?.delete(), this._backup = e;
  }
  disposeBackup() {
    this._backup?.delete(), this._backup = void 0;
  }
  getEdit(e) {
    const i = this._edits.get(e, 0);
    if (!i)
      throw new Error("No edit found");
    return i;
  }
}
class UF {
  constructor() {
    this._documents = /* @__PURE__ */ new Map();
  }
  get(e, i) {
    return this._documents.get(this.key(e, i));
  }
  add(e, i, n) {
    const r = this.key(e, i.uri);
    if (this._documents.has(r))
      throw new Error(
        `Document already exists for viewType:${e} resource:${i.uri}`
      );
    const s = new FF(i, n);
    return this._documents.set(r, s), s;
  }
  delete(e, i) {
    const n = this.key(e, i.uri);
    this._documents.delete(n);
  }
  key(e, i) {
    return `${e}@@@${i}`;
  }
}
var _o;
(function(t) {
  t[t.Text = 0] = "Text", t[t.Custom = 1] = "Custom";
})(_o || (_o = {}));
class $F {
  constructor() {
    this._providers = /* @__PURE__ */ new Map();
  }
  addTextProvider(e, i, n) {
    return this.add(e, { type: _o.Text, extension: i, provider: n });
  }
  addCustomProvider(e, i, n) {
    return this.add(e, { type: _o.Custom, extension: i, provider: n });
  }
  get(e) {
    return this._providers.get(e);
  }
  add(e, i) {
    if (this._providers.has(e))
      throw new Error(`Provider for viewType:${e} already registered`);
    return this._providers.set(e, i), new Ve(() => this._providers.delete(e));
  }
}
class HF {
  constructor(e, i, n, r, s) {
    this._extHostDocuments = i, this._extensionStoragePaths = n, this._extHostWebview = r, this._extHostWebviewPanels = s, this._editorProviders = new $F(), this._documents = new UF(), this._proxy = e.getProxy(ee.MainThreadCustomEditors);
  }
  registerCustomEditorProvider(e, i, n, r) {
    const s = new De();
    return BF(n) ? (s.add(this._editorProviders.addTextProvider(i, e, n)), this._proxy.$registerTextEditorProvider(r_(e), i, r.webviewOptions || {}, {
      supportsMove: !!n.moveCustomTextEditor
    }, vu(e))) : (s.add(this._editorProviders.addCustomProvider(i, e, n)), Bf(n) && s.add(n.onDidChangeCustomDocument((o) => {
      const a = this.getCustomDocumentEntry(i, o.document.uri);
      if (WF(o)) {
        const l = a.addEdit(o);
        this._proxy.$onDidEdit(o.document.uri, i, l, o.label);
      } else
        this._proxy.$onContentChange(o.document.uri, i);
    })), this._proxy.$registerCustomEditorProvider(r_(e), i, r.webviewOptions || {}, !!r.supportsMultipleEditorsPerDocument, vu(e))), Ve.from(s, new Ve(() => {
      this._proxy.$unregisterEditorProvider(i);
    }));
  }
  async $createCustomDocument(e, i, n, r, s) {
    const o = this._editorProviders.get(i);
    if (!o)
      throw new Error(`No provider found for '${i}'`);
    if (o.type !== _o.Custom)
      throw new Error(`Invalid provide type for '${i}'`);
    const a = x.revive(e), l = await o.provider.openCustomDocument(a, { backupId: n, untitledDocumentData: r?.buffer }, s);
    let c;
    return Bf(o.provider) && this._extensionStoragePaths && (c = this._extensionStoragePaths.workspaceValue(o.extension) ?? this._extensionStoragePaths.globalValue(o.extension)), this._documents.add(i, l, c), { editable: Bf(o.provider) };
  }
  async $disposeCustomDocument(e, i) {
    const n = this._editorProviders.get(i);
    if (!n)
      throw new Error(`No provider found for '${i}'`);
    if (n.type !== _o.Custom)
      throw new Error(`Invalid provider type for '${i}'`);
    const r = x.revive(e), { document: s } = this.getCustomDocumentEntry(i, r);
    this._documents.delete(i, s), s.dispose();
  }
  async $resolveCustomEditor(e, i, n, r, s, o) {
    const a = this._editorProviders.get(n);
    if (!a)
      throw new Error(`No provider found for '${n}'`);
    const l = si.to(s), c = this._extHostWebview.createNewWebview(i, r.contentOptions, a.extension), u = this._extHostWebviewPanels.createNewWebviewPanel(i, n, r.title, l, r.options, c, r.active), d = x.revive(e);
    switch (a.type) {
      case _o.Custom: {
        const { document: f } = this.getCustomDocumentEntry(n, d);
        return a.provider.resolveCustomEditor(f, u, o);
      }
      case _o.Text: {
        const f = this._extHostDocuments.getDocument(d);
        return a.provider.resolveCustomTextEditor(f, u, o);
      }
      default:
        throw new Error("Unknown webview provider type");
    }
  }
  $disposeEdits(e, i, n) {
    this.getCustomDocumentEntry(i, e).disposeEdits(n);
  }
  async $onMoveCustomEditor(e, i, n) {
    const r = this._editorProviders.get(n);
    if (!r)
      throw new Error(`No provider found for '${n}'`);
    if (!r.provider.moveCustomTextEditor)
      throw new Error(`Provider does not implement move '${n}'`);
    const s = this._extHostWebviewPanels.getWebviewPanel(e);
    if (!s)
      throw new Error("No webview found");
    const o = x.revive(i), a = this._extHostDocuments.getDocument(o);
    await r.provider.moveCustomTextEditor(a, s, xt.None);
  }
  async $undo(e, i, n, r) {
    return this.getCustomDocumentEntry(i, e).undo(n, r);
  }
  async $redo(e, i, n, r) {
    return this.getCustomDocumentEntry(i, e).redo(n, r);
  }
  async $revert(e, i, n) {
    const r = this.getCustomDocumentEntry(i, e);
    await this.getCustomEditorProvider(i).revertCustomDocument(r.document, n), r.disposeBackup();
  }
  async $onSave(e, i, n) {
    const r = this.getCustomDocumentEntry(i, e);
    await this.getCustomEditorProvider(i).saveCustomDocument(r.document, n), r.disposeBackup();
  }
  async $onSaveAs(e, i, n, r) {
    const s = this.getCustomDocumentEntry(i, e);
    return this.getCustomEditorProvider(i).saveCustomDocumentAs(s.document, x.revive(n), r);
  }
  async $backup(e, i, n) {
    const r = this.getCustomDocumentEntry(i, e), o = await this.getCustomEditorProvider(i).backupCustomDocument(r.document, {
      destination: r.getNewBackupUri()
    }, n);
    return r.updateBackup(o), o.id;
  }
  getCustomDocumentEntry(e, i) {
    const n = this._documents.get(e, x.revive(i));
    if (!n)
      throw new Error("No custom document found");
    return n;
  }
  getCustomEditorProvider(e) {
    const n = this._editorProviders.get(e)?.provider;
    if (!n || !Bf(n))
      throw new Error("Custom document is not editable");
    return n;
  }
}
function Bf(t) {
  return !!t.onDidChangeCustomDocument;
}
function BF(t) {
  return typeof t.resolveCustomTextEditor == "function";
}
function WF(t) {
  return typeof t.undo == "function" && typeof t.redo == "function";
}
function VF(t) {
  const e = t.scheme === de.file || t.scheme === de.untitled ? t.fsPath : t.toString();
  return Yd(e) + "";
}
var Qo;
class s_ {
  #e;
  #t;
  #i;
  constructor(e, i, n, r, s, o, a, l) {
    this._name = e, this._owner = i, this._maxDiagnosticsTotal = n, this._maxDiagnosticsPerFile = r, this._modelVersionIdProvider = s, this._isDisposed = !1, this._maxDiagnosticsTotal = Math.max(r, n), this.#i = new fi((c) => o.getComparisonKey(c)), this.#e = a, this.#t = l;
  }
  dispose() {
    this._isDisposed || (this.#t.fire([...this.#i.keys()]), this.#e?.$clear(this._owner), this.#i.clear(), this._isDisposed = !0);
  }
  get name() {
    return this._checkDisposed(), this._name;
  }
  set(e, i) {
    if (!e) {
      this.clear();
      return;
    }
    this._checkDisposed();
    let n = [];
    if (x.isUri(e)) {
      if (!i) {
        this.delete(e);
        return;
      }
      this.#i.set(e, i.slice()), n = [e];
    } else if (Array.isArray(e)) {
      n = [];
      let o;
      e = [...e].sort(s_._compareIndexedTuplesByUri);
      for (const a of e) {
        const [l, c] = a;
        if ((!o || l.toString() !== o.toString()) && (o && this.#i.get(o).length === 0 && this.#i.delete(o), o = l, n.push(l), this.#i.set(l, [])), c)
          this.#i.get(l)?.push(...c);
        else {
          const u = this.#i.get(l);
          u && (u.length = 0);
        }
      }
    }
    if (this.#t.fire(n), !this.#e)
      return;
    const r = [];
    let s = 0;
    for (const o of n) {
      let a = [];
      const l = this.#i.get(o);
      if (l)
        if (l.length > this._maxDiagnosticsPerFile) {
          a = [];
          const c = [Ci.Error, Ci.Warning, Ci.Information, Ci.Hint];
          e: for (let u = 0; u < 4; u++)
            for (const d of l)
              if (d.severity === c[u] && a.push({ ...nu.from(d), modelVersionId: this._modelVersionIdProvider(o) }) === this._maxDiagnosticsPerFile)
                break e;
          a.push({
            severity: en.Info,
            message: h(
              2622,
              "Not showing {0} further errors and warnings.",
              l.length - this._maxDiagnosticsPerFile
            ),
            startLineNumber: a[a.length - 1].startLineNumber,
            startColumn: a[a.length - 1].startColumn,
            endLineNumber: a[a.length - 1].endLineNumber,
            endColumn: a[a.length - 1].endColumn
          });
        } else
          a = l.map(
            (c) => ({ ...nu.from(c), modelVersionId: this._modelVersionIdProvider(o) })
          );
      if (r.push([o, a]), s += a.length, s > this._maxDiagnosticsTotal)
        break;
    }
    this.#e.$changeMany(this._owner, r);
  }
  delete(e) {
    this._checkDisposed(), this.#t.fire([e]), this.#i.delete(e), this.#e?.$changeMany(this._owner, [[e, void 0]]);
  }
  clear() {
    this._checkDisposed(), this.#t.fire([...this.#i.keys()]), this.#i.clear(), this.#e?.$clear(this._owner);
  }
  forEach(e, i) {
    this._checkDisposed();
    for (const [n, r] of this)
      e.call(i, n, r, this);
  }
  *[Symbol.iterator]() {
    this._checkDisposed();
    for (const e of this.#i.keys())
      yield [e, this.get(e)];
  }
  get(e) {
    this._checkDisposed();
    const i = this.#i.get(e);
    return Array.isArray(i) ? Object.freeze(i.slice(0)) : [];
  }
  has(e) {
    return this._checkDisposed(), Array.isArray(this.#i.get(e));
  }
  _checkDisposed() {
    if (this._isDisposed)
      throw new Error("illegal state - object is disposed");
  }
  static _compareIndexedTuplesByUri(e, i) {
    return e[0].toString() < i[0].toString() ? -1 : e[0].toString() > i[0].toString() ? 1 : 0;
  }
}
var Fr;
let R0 = (Fr = class {
  static _mapper(e) {
    const i = new fi();
    for (const n of e)
      i.set(n, n);
    return { uris: Object.freeze(Array.from(i.values())) };
  }
  constructor(e, i, n, r) {
    this._logService = i, this._fileSystemInfoService = n, this._extHostDocumentsAndEditors = r, this._collections = /* @__PURE__ */ new Map(), this._onDidChangeDiagnostics = new RA({ merge: (s) => s.flat(), delay: 50 }), this.onDidChangeDiagnostics = It.map(this._onDidChangeDiagnostics.event, Qo._mapper), this._proxy = e.getProxy(ee.MainThreadDiagnostics);
  }
  createDiagnosticCollection(e, i) {
    const { _collections: n, _proxy: r, _onDidChangeDiagnostics: s, _logService: o, _fileSystemInfoService: a, _extHostDocumentsAndEditors: l } = this, c = new class {
      $changeMany(f, g) {
        r.$changeMany(f, g), o.trace("[DiagnosticCollection] change many (extension, owner, uris)", e.value, f, g.length === 0 ? "CLEARING" : g);
      }
      $clear(f) {
        r.$clear(f), o.trace("[DiagnosticCollection] remove all (extension, owner)", e.value, f);
      }
      dispose() {
        r.dispose();
      }
    }();
    let u;
    if (!i)
      i = "_generated_diagnostic_collection_name_#" + Qo._idPool++, u = i;
    else if (!n.has(i))
      u = i;
    else {
      this._logService.warn(`DiagnosticCollection with name '${i}' does already exist.`);
      do
        u = i + Qo._idPool++;
      while (n.has(u));
    }
    return new class extends s_ {
      constructor() {
        super(i, u, Qo._maxDiagnosticsTotal, Qo._maxDiagnosticsPerFile, (f) => l.getDocument(f)?.version, a.extUri, c, s), n.set(u, this);
      }
      dispose() {
        super.dispose(), n.delete(u);
      }
    }();
  }
  getDiagnostics(e) {
    if (e)
      return this._getDiagnostics(e);
    {
      const i = /* @__PURE__ */ new Map(), n = [];
      for (const r of this._collections.values())
        r.forEach((s, o) => {
          let a = i.get(s.toString());
          typeof a > "u" && (a = n.length, i.set(s.toString(), a), n.push([s, []])), n[a][1] = n[a][1].concat(...o);
        });
      return n;
    }
  }
  _getDiagnostics(e) {
    let i = [];
    for (const n of this._collections.values())
      n.has(e) && (i = i.concat(n.get(e)));
    return i;
  }
  $acceptMarkersChange(e) {
    if (!this._mirrorCollection) {
      const i = "_generated_mirror", n = new s_(
        i,
        i,
        Number.MAX_SAFE_INTEGER,
        Number.MAX_SAFE_INTEGER,
        (r) => {
        },
        this._fileSystemInfoService.extUri,
        void 0,
        this._onDidChangeDiagnostics
      );
      this._collections.set(i, n), this._mirrorCollection = n;
    }
    for (const [i, n] of e)
      this._mirrorCollection.set(x.revive(i), n.map(nu.to));
  }
}, Qo = Fr, Fr._idPool = 0, Fr._maxDiagnosticsPerFile = 1e3, Fr._maxDiagnosticsTotal = 1.1 * Fr._maxDiagnosticsPerFile, Fr);
R0 = Qo = W([
  M(1, nt),
  M(2, wu)
], R0);
class zF {
  constructor(e) {
    this._proxy = e.getProxy(ee.MainThreadDialogs);
  }
  showOpenDialog(e) {
    return this._proxy.$showOpenDialog(e).then((i) => i ? i.map((n) => x.revive(n)) : void 0);
  }
  showSaveDialog(e) {
    return this._proxy.$showSaveDialog(e).then((i) => i ? x.revive(i) : void 0);
  }
}
const D_ = class D_ {
  constructor(e, i, n) {
    this._documentsAndEditors = i, this._logService = n, this._documentContentProviders = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadDocumentContentProviders);
  }
  registerTextDocumentContentProvider(e, i) {
    if (Object.keys(de).indexOf(e) >= 0)
      throw new Error(`scheme '${e}' already registered`);
    const n = D_._handlePool++;
    this._documentContentProviders.set(n, i), this._proxy.$registerTextContentProvider(n, e);
    let r;
    if (typeof i.onDidChange == "function") {
      let s;
      r = i.onDidChange(async (o) => {
        if (o.scheme !== e) {
          this._logService.warn(`Provider for scheme '${e}' is firing event for schema '${o.scheme}' which will be IGNORED`);
          return;
        }
        if (!this._documentsAndEditors.getDocument(o))
          return;
        s && await s;
        const a = this.$provideTextDocumentContent(n, o).then(async (l) => {
          if (!l && typeof l != "string")
            return;
          const c = this._documentsAndEditors.getDocument(o);
          if (!c)
            return;
          const u = C4(l);
          if (!c.equalLines(u))
            return this._proxy.$onVirtualDocumentChange(o, l);
        }).catch(Li).finally(() => {
          s === a && (s = void 0);
        });
        s = a;
      });
    }
    return new Ve(() => {
      this._documentContentProviders.delete(n) && this._proxy.$unregisterTextContentProvider(n), r && (r.dispose(), r = void 0);
    });
  }
  $provideTextDocumentContent(e, i) {
    const n = this._documentContentProviders.get(e);
    return n ? Promise.resolve(n.provideTextDocumentContent(x.revive(i), xt.None)) : Promise.reject(new Error(`unsupported uri-scheme: ${i.scheme}`));
  }
};
D_._handlePool = 0;
let L0 = D_;
class qF {
  constructor(e, i, n, r = { timeout: 1500, errors: 3 }) {
    this._logService = e, this._documents = i, this._mainThreadBulkEdits = n, this._thresholds = r, this._callbacks = new Ro(), this._badListeners = /* @__PURE__ */ new WeakMap();
  }
  dispose() {
    this._callbacks.clear();
  }
  getOnWillSaveTextDocumentEvent(e) {
    return (i, n, r) => {
      const o = { dispose: this._callbacks.push([i, n, e]) };
      return Array.isArray(r) && r.push(o), o;
    };
  }
  async $participateInSave(e, i) {
    const n = x.revive(e);
    let r = !1;
    const s = setTimeout(() => r = !0, this._thresholds.timeout), o = [];
    try {
      for (const a of [...this._callbacks]) {
        if (r)
          break;
        const l = this._documents.getDocument(n), c = await this._deliverEventAsyncAndBlameBadListeners(a, { document: l, reason: bm.to(i) });
        o.push(c);
      }
    } finally {
      clearTimeout(s);
    }
    return o;
  }
  _deliverEventAsyncAndBlameBadListeners([e, i, n], r) {
    const s = this._badListeners.get(e);
    return typeof s == "number" && s > this._thresholds.errors ? Promise.resolve(!1) : this._deliverEventAsync(n, e, i, r).then(() => !0, (o) => {
      if (this._logService.error(`onWillSaveTextDocument-listener from extension '${n.identifier.value}' threw ERROR`), this._logService.error(o), !(o instanceof Error) || o.message !== "concurrent_edits") {
        const a = this._badListeners.get(e);
        this._badListeners.set(e, a ? a + 1 : 1), typeof a == "number" && a > this._thresholds.errors && this._logService.info(`onWillSaveTextDocument-listener from extension '${n.identifier.value}' will now be IGNORED because of timeouts and/or errors`);
      }
      return !1;
    });
  }
  _deliverEventAsync(e, i, n, r) {
    const s = [], o = Date.now(), { document: a, reason: l } = r, { version: c } = a, u = Object.freeze({
      document: a,
      reason: l,
      waitUntil(d) {
        if (Object.isFrozen(s))
          throw gx("waitUntil can not be called async");
        s.push(Promise.resolve(d));
      }
    });
    try {
      i.apply(n, [u]);
    } catch (d) {
      return Promise.reject(d);
    }
    return new Promise((d, f) => {
      const g = setTimeout(() => f(new Error("timeout")), this._thresholds.timeout);
      return Promise.all(s).then((_) => {
        this._logService.debug(`onWillSaveTextDocument-listener from extension '${e.identifier.value}' finished after ${Date.now() - o}ms`), clearTimeout(g), d(_);
      }).catch((_) => {
        clearTimeout(g), f(_);
      });
    }).then((d) => {
      const f = { edits: [] };
      for (const g of d)
        if (Array.isArray(g) && g.every((_) => _ instanceof Co))
          for (const { newText: _, newEol: w, range: v } of g)
            f.edits.push({
              resource: a.uri,
              versionId: void 0,
              textEdit: {
                range: v && z.from(v),
                text: _,
                eol: w && au.from(w)
              }
            });
      if (f.edits.length !== 0)
        return c === a.version ? this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new zi(f)) : Promise.reject(new Error("concurrent_edits"));
    });
  }
}
class jF {
  constructor(e, i) {
    this._onDidAddDocument = new N(), this._onDidRemoveDocument = new N(), this._onDidChangeDocument = new N(), this._onDidChangeDocumentWithReason = new N(), this._onDidSaveDocument = new N(), this.onDidAddDocument = this._onDidAddDocument.event, this.onDidRemoveDocument = this._onDidRemoveDocument.event, this.onDidChangeDocument = this._onDidChangeDocument.event, this.onDidChangeDocumentWithReason = this._onDidChangeDocumentWithReason.event, this.onDidSaveDocument = this._onDidSaveDocument.event, this._toDispose = new De(), this._documentLoader = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadDocuments), this._documentsAndEditors = i, this._documentsAndEditors.onDidRemoveDocuments((n) => {
      for (const r of n)
        this._onDidRemoveDocument.fire(r.document);
    }, void 0, this._toDispose), this._documentsAndEditors.onDidAddDocuments((n) => {
      for (const r of n)
        this._onDidAddDocument.fire(r.document);
    }, void 0, this._toDispose);
  }
  dispose() {
    this._toDispose.dispose();
  }
  getAllDocumentData() {
    return [...this._documentsAndEditors.allDocuments()];
  }
  getDocumentData(e) {
    if (!e)
      return;
    const i = this._documentsAndEditors.getDocument(e);
    if (i)
      return i;
  }
  getDocument(e) {
    const i = this.getDocumentData(e);
    if (!i?.document)
      throw new Error(`Unable to retrieve document from URI '${e}'`);
    return i.document;
  }
  ensureDocumentData(e, i) {
    const n = this._documentsAndEditors.getDocument(e);
    if (n && (!i?.encoding || n.document.encoding === i.encoding))
      return Promise.resolve(n);
    let r = this._documentLoader.get(e.toString());
    return r ? i?.encoding && (r = r.then((s) => s.document.encoding !== i.encoding ? this.ensureDocumentData(e, i) : s)) : (r = this._proxy.$tryOpenDocument(e, i).then((s) => {
      this._documentLoader.delete(e.toString());
      const o = x.revive(s);
      return Fc(this._documentsAndEditors.getDocument(o));
    }, (s) => (this._documentLoader.delete(e.toString()), Promise.reject(s))), this._documentLoader.set(e.toString(), r)), r;
  }
  createDocumentData(e) {
    return this._proxy.$tryCreateDocument(e).then((i) => x.revive(i));
  }
  $acceptModelLanguageChanged(e, i) {
    const n = x.revive(e), r = this._documentsAndEditors.getDocument(n);
    if (!r)
      throw new Error("unknown document");
    this._onDidRemoveDocument.fire(r.document), r._acceptLanguageId(i), this._onDidAddDocument.fire(r.document);
  }
  $acceptModelSaved(e) {
    const i = x.revive(e), n = this._documentsAndEditors.getDocument(i);
    if (!n)
      throw new Error("unknown document");
    this.$acceptDirtyStateChanged(e, !1), this._onDidSaveDocument.fire(n.document);
  }
  $acceptDirtyStateChanged(e, i) {
    const n = x.revive(e), r = this._documentsAndEditors.getDocument(n);
    if (!r)
      throw new Error("unknown document");
    r._acceptIsDirty(i), this._onDidChangeDocument.fire({
      document: r.document,
      contentChanges: [],
      reason: void 0
    }), this._onDidChangeDocumentWithReason.fire({
      document: r.document,
      contentChanges: [],
      reason: void 0,
      detailedReason: void 0
    });
  }
  $acceptEncodingChanged(e, i) {
    const n = x.revive(e), r = this._documentsAndEditors.getDocument(n);
    if (!r)
      throw new Error("unknown document");
    r._acceptEncoding(i), this._onDidChangeDocument.fire({
      document: r.document,
      contentChanges: [],
      reason: void 0
    }), this._onDidChangeDocumentWithReason.fire({
      document: r.document,
      contentChanges: [],
      reason: void 0,
      detailedReason: void 0
    });
  }
  $acceptModelChanged(e, i, n) {
    const r = x.revive(e), s = this._documentsAndEditors.getDocument(r);
    if (!s)
      throw new Error("unknown document");
    s._acceptIsDirty(n), s.onEvents(i);
    let o;
    i.isUndoing ? o = hh.Undo : i.isRedoing && (o = hh.Redo), this._onDidChangeDocument.fire(Ov({
      document: s.document,
      contentChanges: i.changes.map((a) => ({
        range: z.to(a.range),
        rangeOffset: a.rangeOffset,
        rangeLength: a.rangeLength,
        text: a.text
      })),
      reason: o
    })), this._onDidChangeDocumentWithReason.fire(Ov({
      document: s.document,
      contentChanges: i.changes.map((a) => ({
        range: z.to(a.range),
        rangeOffset: a.rangeOffset,
        rangeLength: a.rangeLength,
        text: a.text
      })),
      reason: o,
      detailedReason: i.detailedReason ? {
        source: i.detailedReason.source,
        metadata: i.detailedReason
      } : void 0
    }));
  }
  setWordDefinitionFor(e, i) {
    YM(e, i);
  }
}
class GF {
  constructor(e) {
    this._provider = /* @__PURE__ */ new Map(), this._onDidChange = new N(), this.onDidChange = this._onDidChange.event, this._allKnownModels = /* @__PURE__ */ new Set(), this._handlePool = 0, this._proxy = e.getProxy(ee.MainThreadEmbeddings);
  }
  registerEmbeddingsProvider(e, i, n) {
    if (this._allKnownModels.has(i))
      throw new Error("An embeddings provider for this model is already registered");
    const r = this._handlePool++;
    return this._proxy.$registerEmbeddingProvider(r, i), this._provider.set(r, { id: i, provider: n }), Ee(() => {
      this._allKnownModels.delete(i), this._proxy.$unregisterEmbeddingProvider(r), this._provider.delete(r);
    });
  }
  async computeEmbeddings(e, i, n) {
    n ??= xt.None;
    let r = !1;
    typeof i == "string" && (i = [i], r = !0);
    const s = await this._proxy.$computeEmbeddings(e, i, n);
    if (s.length !== i.length)
      throw new Error();
    if (r) {
      if (s.length !== 1)
        throw new Error();
      return s[0];
    }
    return s;
  }
  async $provideEmbeddings(e, i, n) {
    const r = this._provider.get(e);
    if (!r)
      return [];
    const s = await r.provider.provideEmbeddings(i, n);
    return s || [];
  }
  get embeddingsModels() {
    return Array.from(this._allKnownModels);
  }
  $acceptEmbeddingModels(e) {
    this._allKnownModels = new Set(e), this._onDidChange.fire();
  }
}
class QF {
  constructor(e) {
    this._AiEmbeddingVectorProviders = /* @__PURE__ */ new Map(), this._nextHandle = 0, this._proxy = e.getProxy(ee.MainThreadAiEmbeddingVector);
  }
  async $provideAiEmbeddingVector(e, i, n) {
    if (this._AiEmbeddingVectorProviders.size === 0)
      throw new Error("No embedding vector providers registered");
    const r = this._AiEmbeddingVectorProviders.get(e);
    if (!r)
      throw new Error("Embedding vector provider not found");
    const s = await r.provideEmbeddingVector(i, n);
    if (!s)
      throw new Error("Embedding vector provider returned undefined");
    return s;
  }
  registerEmbeddingVectorProvider(e, i, n) {
    const r = this._nextHandle;
    return this._nextHandle++, this._AiEmbeddingVectorProviders.set(r, n), this._proxy.$registerAiEmbeddingVectorProvider(i, r), new Ve(() => {
      this._proxy.$unregisterAiEmbeddingVectorProvider(r), this._AiEmbeddingVectorProviders.delete(r);
    });
  }
}
var be;
(function(t) {
  t[t.Invalid = 0] = "Invalid", t[t.Start = 1] = "Start", t[t.H = 2] = "H", t[t.HT = 3] = "HT", t[t.HTT = 4] = "HTT", t[t.HTTP = 5] = "HTTP", t[t.F = 6] = "F", t[t.FI = 7] = "FI", t[t.FIL = 8] = "FIL", t[t.BeforeColon = 9] = "BeforeColon", t[t.AfterColon = 10] = "AfterColon", t[t.AlmostThere = 11] = "AlmostThere", t[t.End = 12] = "End", t[t.Accept = 13] = "Accept", t[t.LastKnownState = 14] = "LastKnownState";
})(be || (be = {}));
class KF {
  constructor(e, i, n) {
    const r = new Uint8Array(e * i);
    for (let s = 0, o = e * i; s < o; s++)
      r[s] = n;
    this._data = r, this.rows = e, this.cols = i;
  }
  get(e, i) {
    return this._data[e * this.cols + i];
  }
  set(e, i, n) {
    this._data[e * this.cols + i] = n;
  }
}
class N5 {
  constructor(e) {
    let i = 0, n = be.Invalid;
    for (let s = 0, o = e.length; s < o; s++) {
      const [a, l, c] = e[s];
      l > i && (i = l), a > n && (n = a), c > n && (n = c);
    }
    i++, n++;
    const r = new KF(n, i, be.Invalid);
    for (let s = 0, o = e.length; s < o; s++) {
      const [a, l, c] = e[s];
      r.set(a, l, c);
    }
    this._states = r, this._maxCharCode = i;
  }
  nextState(e, i) {
    return i < 0 || i >= this._maxCharCode ? be.Invalid : this._states.get(e, i);
  }
}
let tv = null;
function JF() {
  return tv === null && (tv = new N5([
    [be.Start, L.h, be.H],
    [be.Start, L.H, be.H],
    [be.Start, L.f, be.F],
    [be.Start, L.F, be.F],
    [be.H, L.t, be.HT],
    [be.H, L.T, be.HT],
    [be.HT, L.t, be.HTT],
    [be.HT, L.T, be.HTT],
    [be.HTT, L.p, be.HTTP],
    [be.HTT, L.P, be.HTTP],
    [be.HTTP, L.s, be.BeforeColon],
    [be.HTTP, L.S, be.BeforeColon],
    [be.HTTP, L.Colon, be.AfterColon],
    [be.F, L.i, be.FI],
    [be.F, L.I, be.FI],
    [be.FI, L.l, be.FIL],
    [be.FI, L.L, be.FIL],
    [be.FIL, L.e, be.BeforeColon],
    [be.FIL, L.E, be.BeforeColon],
    [be.BeforeColon, L.Colon, be.AfterColon],
    [be.AfterColon, L.Slash, be.AlmostThere],
    [be.AlmostThere, L.Slash, be.End]
  ])), tv;
}
var Ft;
(function(t) {
  t[t.None = 0] = "None", t[t.ForceTermination = 1] = "ForceTermination", t[t.CannotEndIn = 2] = "CannotEndIn";
})(Ft || (Ft = {}));
let Vu = null;
function YF() {
  if (Vu === null) {
    Vu = new p1(Ft.None);
    const t = ` 	<>'"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…|`;
    for (let i = 0; i < t.length; i++)
      Vu.set(t.charCodeAt(i), Ft.ForceTermination);
    const e = ".,;:";
    for (let i = 0; i < e.length; i++)
      Vu.set(e.charCodeAt(i), Ft.CannotEndIn);
  }
  return Vu;
}
class o_ {
  static _createLink(e, i, n, r, s) {
    let o = s - 1;
    do {
      const a = i.charCodeAt(o);
      if (e.get(a) !== Ft.CannotEndIn)
        break;
      o--;
    } while (o > r);
    if (r > 0) {
      const a = i.charCodeAt(r - 1), l = i.charCodeAt(o);
      (a === L.OpenParen && l === L.CloseParen || a === L.OpenSquareBracket && l === L.CloseSquareBracket || a === L.OpenCurlyBrace && l === L.CloseCurlyBrace) && o--;
    }
    return {
      range: {
        startLineNumber: n,
        startColumn: r + 1,
        endLineNumber: n,
        endColumn: o + 2
      },
      url: i.substring(r, o + 1)
    };
  }
  static computeLinks(e, i = JF()) {
    const n = YF(), r = [];
    for (let s = 1, o = e.getLineCount(); s <= o; s++) {
      const a = e.getLineContent(s), l = a.length;
      let c = 0, u = 0, d = 0, f = be.Start, g = !1, _ = !1, w = !1, v = !1;
      for (; c < l; ) {
        let S = !1;
        const E = a.charCodeAt(c);
        if (f === be.Accept) {
          let A;
          switch (E) {
            case L.OpenParen:
              g = !0, A = Ft.None;
              break;
            case L.CloseParen:
              A = g ? Ft.None : Ft.ForceTermination;
              break;
            case L.OpenSquareBracket:
              w = !0, _ = !0, A = Ft.None;
              break;
            case L.CloseSquareBracket:
              w = !1, A = _ ? Ft.None : Ft.ForceTermination;
              break;
            case L.OpenCurlyBrace:
              v = !0, A = Ft.None;
              break;
            case L.CloseCurlyBrace:
              A = v ? Ft.None : Ft.ForceTermination;
              break;
            case L.SingleQuote:
            case L.DoubleQuote:
            case L.BackTick:
              d === E ? A = Ft.ForceTermination : d === L.SingleQuote || d === L.DoubleQuote || d === L.BackTick ? A = Ft.None : A = Ft.ForceTermination;
              break;
            case L.Asterisk:
              A = d === L.Asterisk ? Ft.ForceTermination : Ft.None;
              break;
            case L.Space:
              A = w ? Ft.None : Ft.ForceTermination;
              break;
            default:
              A = n.get(E);
          }
          A === Ft.ForceTermination && (r.push(o_._createLink(n, a, s, u, c)), S = !0);
        } else if (f === be.End) {
          let A;
          E === L.OpenSquareBracket ? (_ = !0, A = Ft.None) : A = n.get(E), A === Ft.ForceTermination ? S = !0 : f = be.Accept;
        } else
          f = i.nextState(f, E), f === be.Invalid && (S = !0);
        S && (f = be.Start, g = !1, _ = !1, v = !1, u = c + 1, d = E), c++;
      }
      f === be.Accept && r.push(o_._createLink(n, a, s, u, l));
    }
    return r;
  }
}
class XF {
  constructor() {
    this._schemes = [];
  }
  add(e) {
    this._stateMachine = void 0, this._schemes.push(e);
  }
  delete(e) {
    const i = this._schemes.indexOf(e);
    i >= 0 && (this._schemes.splice(i, 1), this._stateMachine = void 0);
  }
  _initStateMachine() {
    if (!this._stateMachine) {
      const e = this._schemes.sort(), i = [];
      let n, r, s = be.LastKnownState, o = be.LastKnownState;
      for (const a of e) {
        let l = n ? yR(n, a) : 0;
        for (l === 0 ? r = be.Start : r = o; l < a.length; l++)
          l + 1 === a.length ? (s = o, o = be.BeforeColon) : o += 1, i.push([r, a.toUpperCase().charCodeAt(l), o]), i.push([r, a.toLowerCase().charCodeAt(l), o]), r = o;
        n = a, o = s;
      }
      i.push([be.BeforeColon, L.Colon, be.AfterColon]), i.push([be.AfterColon, L.Slash, be.End]), this._stateMachine = new N5(i);
    }
  }
  provideDocumentLinks(e) {
    this._initStateMachine();
    const i = [], n = o_.computeLinks({
      getLineContent(r) {
        return e.lineAt(r - 1).text;
      },
      getLineCount() {
        return e.lineCount;
      }
    }, this._stateMachine);
    for (const r of n) {
      const s = La.to(r);
      s.target && i.push(s);
    }
    return i;
  }
}
class a_ {
  constructor(e, i) {
    this._extHostLanguageFeatures = i, this._linkProvider = new XF(), this._fsProvider = /* @__PURE__ */ new Map(), this._registeredSchemes = /* @__PURE__ */ new Set(), this._watches = /* @__PURE__ */ new Map(), this._handlePool = 0, this._proxy = e.getProxy(ee.MainThreadFileSystem);
  }
  dispose() {
    this._linkProviderRegistration?.dispose();
  }
  registerFileSystemProvider(e, i, n, r = {}) {
    if (a_._validateFileSystemProvider(n), this._registeredSchemes.has(i))
      throw new Error(`a provider for the scheme '${i}' is already registered`);
    this._linkProviderRegistration || (this._linkProviderRegistration = this._extHostLanguageFeatures.registerDocumentLinkProvider(e, "*", this._linkProvider));
    const s = this._handlePool++;
    this._linkProvider.add(i), this._registeredSchemes.add(i), this._fsProvider.set(s, n);
    let o = Rr.FileReadWrite;
    r.isCaseSensitive && (o += Rr.PathCaseSensitive), r.isReadonly && (o += Rr.Readonly), typeof n.copy == "function" && (o += Rr.FileFolderCopy), typeof n.open == "function" && typeof n.close == "function" && typeof n.read == "function" && typeof n.write == "function" && ($(e, "fsChunks"), o += Rr.FileOpenReadWriteClose);
    let a;
    r.isReadonly && dl(r.isReadonly) && r.isReadonly.value !== "" && (a = {
      value: r.isReadonly.value,
      isTrusted: r.isReadonly.isTrusted,
      supportThemeIcons: r.isReadonly.supportThemeIcons,
      supportHtml: r.isReadonly.supportHtml,
      baseUri: r.isReadonly.baseUri,
      uris: r.isReadonly.uris
    }), this._proxy.$registerFileSystemProvider(s, i, o, a).catch((c) => {
      console.error(`FAILED to register filesystem provider of ${e.identifier.value}-extension for the scheme ${i}`), console.error(c);
    });
    const l = n.onDidChangeFile((c) => {
      const u = [];
      for (const d of c) {
        const { uri: f, type: g } = d;
        if (f.scheme !== i)
          continue;
        let _;
        switch (g) {
          case bc.Changed:
            _ = od.UPDATED;
            break;
          case bc.Created:
            _ = od.ADDED;
            break;
          case bc.Deleted:
            _ = od.DELETED;
            break;
          default:
            throw new Error("Unknown FileChangeType");
        }
        u.push({ resource: f, type: _ });
      }
      this._proxy.$onFileSystemChange(s, u);
    });
    return Ee(() => {
      l.dispose(), this._linkProvider.delete(i), this._registeredSchemes.delete(i), this._fsProvider.delete(s), this._proxy.$unregisterProvider(s);
    });
  }
  static _validateFileSystemProvider(e) {
    if (!e)
      throw new Error("MISSING provider");
    if (typeof e.watch != "function")
      throw new Error("Provider does NOT implement watch");
    if (typeof e.stat != "function")
      throw new Error("Provider does NOT implement stat");
    if (typeof e.readDirectory != "function")
      throw new Error("Provider does NOT implement readDirectory");
    if (typeof e.createDirectory != "function")
      throw new Error("Provider does NOT implement createDirectory");
    if (typeof e.readFile != "function")
      throw new Error("Provider does NOT implement readFile");
    if (typeof e.writeFile != "function")
      throw new Error("Provider does NOT implement writeFile");
    if (typeof e.delete != "function")
      throw new Error("Provider does NOT implement delete");
    if (typeof e.rename != "function")
      throw new Error("Provider does NOT implement rename");
  }
  static _asIStat(e) {
    const { type: i, ctime: n, mtime: r, size: s, permissions: o } = e;
    return { type: i, ctime: n, mtime: r, size: s, permissions: o };
  }
  $stat(e, i) {
    return Promise.resolve(this._getFsProvider(e).stat(x.revive(i))).then((n) => a_._asIStat(n));
  }
  $readdir(e, i) {
    return Promise.resolve(this._getFsProvider(e).readDirectory(x.revive(i)));
  }
  $readFile(e, i) {
    return Promise.resolve(this._getFsProvider(e).readFile(x.revive(i))).then((n) => ue.wrap(n));
  }
  $writeFile(e, i, n, r) {
    return Promise.resolve(this._getFsProvider(e).writeFile(x.revive(i), n.buffer, r));
  }
  $delete(e, i, n) {
    return Promise.resolve(this._getFsProvider(e).delete(x.revive(i), n));
  }
  $rename(e, i, n, r) {
    return Promise.resolve(this._getFsProvider(e).rename(x.revive(i), x.revive(n), r));
  }
  $copy(e, i, n, r) {
    const s = this._getFsProvider(e);
    if (!s.copy)
      throw new Error('FileSystemProvider does not implement "copy"');
    return Promise.resolve(s.copy(x.revive(i), x.revive(n), r));
  }
  $mkdir(e, i) {
    return Promise.resolve(this._getFsProvider(e).createDirectory(x.revive(i)));
  }
  $watch(e, i, n, r) {
    const s = this._getFsProvider(e).watch(x.revive(n), r);
    this._watches.set(i, s);
  }
  $unwatch(e, i) {
    const n = this._watches.get(i);
    n && (n.dispose(), this._watches.delete(i));
  }
  $open(e, i, n) {
    const r = this._getFsProvider(e);
    if (!r.open)
      throw new Error('FileSystemProvider does not implement "open"');
    return Promise.resolve(r.open(x.revive(i), n));
  }
  $close(e, i) {
    const n = this._getFsProvider(e);
    if (!n.close)
      throw new Error('FileSystemProvider does not implement "close"');
    return Promise.resolve(n.close(i));
  }
  $read(e, i, n, r) {
    const s = this._getFsProvider(e);
    if (!s.read)
      throw new Error('FileSystemProvider does not implement "read"');
    const o = ue.alloc(r);
    return Promise.resolve(s.read(i, n, o.buffer, 0, r)).then((a) => o.slice(0, a));
  }
  $write(e, i, n, r) {
    const s = this._getFsProvider(e);
    if (!s.write)
      throw new Error('FileSystemProvider does not implement "write"');
    return Promise.resolve(s.write(i, n, r.buffer, 0, r.byteLength));
  }
  _getFsProvider(e) {
    const i = this._fsProvider.get(e);
    if (!i) {
      const n = new Error();
      throw n.name = "ENOPRO", n.message = "no provider", n;
    }
    return i;
  }
}
const k_ = class k_ extends ve {
  constructor(e, i, n, r) {
    super(), this.onFileChanges = e, this.onLogMessage = i, this.verboseLogging = n, this.options = r, this.watcherDisposables = this._register(new Ss()), this.requests = void 0, this.restartCounter = 0;
  }
  init() {
    const e = new De();
    this.watcherDisposables.value = e, this.watcher = this.createWatcher(e), this.watcher.setVerboseLogging(this.verboseLogging), e.add(this.watcher.onDidChangeFile((i) => this.onFileChanges(i))), e.add(this.watcher.onDidLogMessage((i) => this.onLogMessage(i))), e.add(this.watcher.onDidError((i) => this.onError(i.error, i.request)));
  }
  onError(e, i) {
    this.canRestart(e, i) ? this.restartCounter < k_.MAX_RESTARTS && this.requests ? (this.error(`restarting watcher after unexpected error: ${e}`), this.restart(this.requests)) : this.error(`gave up attempting to restart watcher after unexpected error: ${e}`) : this.error(e);
  }
  canRestart(e, i) {
    return !(!this.options.restartOnError || i || e.indexOf("No space left on device") !== -1 || e.indexOf("EMFILE") !== -1);
  }
  restart(e) {
    this.restartCounter++, this.init(), this.watch(e);
  }
  async watch(e) {
    this.requests = e, await this.watcher?.watch(e);
  }
  async setVerboseLogging(e) {
    this.verboseLogging = e, await this.watcher?.setVerboseLogging(e);
  }
  error(e) {
    this.onLogMessage({ type: "error", message: `[File Watcher (${this.options.type})] ${e}` });
  }
  trace(e) {
    this.onLogMessage({ type: "trace", message: `[File Watcher (${this.options.type})] ${e}` });
  }
  dispose() {
    return this.watcher = void 0, super.dispose();
  }
};
k_.MAX_RESTARTS = 5;
let nC = k_;
function ZF(t, e) {
  return typeof e == "string" && !e.startsWith(ha) && !Mp(e) ? { base: t, pattern: e } : e;
}
class eU {
  get ignoreCreateEvents() {
    return !!(this._config & 1);
  }
  get ignoreChangeEvents() {
    return !!(this._config & 2);
  }
  get ignoreDeleteEvents() {
    return !!(this._config & 4);
  }
  constructor(e, i, n, r, s, o, a) {
    this.session = Math.random(), this._onDidCreate = new N(), this._onDidChange = new N(), this._onDidDelete = new N(), this._config = 0, a.ignoreCreateEvents && (this._config += 1), a.ignoreChangeEvents && (this._config += 2), a.ignoreDeleteEvents && (this._config += 4);
    const l = qc(o), c = typeof o == "string", u = s((d) => {
      if (!(typeof d.session == "number" && d.session !== this.session)) {
        if (!a.ignoreCreateEvents)
          for (const f of d.created) {
            const g = x.revive(f);
            l(g.fsPath) && (!c || n.getWorkspaceFolder(g)) && this._onDidCreate.fire(g);
          }
        if (!a.ignoreChangeEvents)
          for (const f of d.changed) {
            const g = x.revive(f);
            l(g.fsPath) && (!c || n.getWorkspaceFolder(g)) && this._onDidChange.fire(g);
          }
        if (!a.ignoreDeleteEvents)
          for (const f of d.deleted) {
            const g = x.revive(f);
            l(g.fsPath) && (!c || n.getWorkspaceFolder(g)) && this._onDidDelete.fire(g);
          }
      }
    });
    this._disposable = Ve.from(this.ensureWatching(e, n, i, r, o, a, !1), this._onDidCreate, this._onDidChange, this._onDidDelete, u);
  }
  ensureWatching(e, i, n, r, s, o, a) {
    const l = Ve.from();
    if (typeof s == "string" || o.ignoreChangeEvents && o.ignoreCreateEvents && o.ignoreDeleteEvents)
      return l;
    const c = e.getProxy(ee.MainThreadFileSystemEventService);
    let u = !1;
    (s.pattern.includes(ha) || s.pattern.includes(rw)) && (u = !0);
    const d = [];
    let f, g;
    if (a)
      (o.ignoreChangeEvents || o.ignoreCreateEvents || o.ignoreDeleteEvents) && (g = Js.UPDATED | Js.ADDED | Js.DELETED, o.ignoreChangeEvents && (g &= ~Js.UPDATED), o.ignoreCreateEvents && (g &= ~Js.ADDED), o.ignoreDeleteEvents && (g &= ~Js.DELETED));
    else if (u && d.length === 0) {
      const _ = i.getWorkspaceFolder(x.revive(s.baseUri)), w = n.getConfiguration("files", _).get("watcherExclude");
      if (w)
        for (const v in w)
          v && w[v] === !0 && d.push(v);
    } else if (!u) {
      const _ = i.getWorkspaceFolder(x.revive(s.baseUri));
      if (_) {
        const w = n.getConfiguration("files", _).get("watcherExclude");
        if (w) {
          for (const v in w)
            if (v && w[v] === !0) {
              const S = `${Iv(v, "/")}/${ha}`;
              f || (f = []), f.push(ZF(_.uri.fsPath, S));
            }
        }
        if (!f || f.length === 0)
          return l;
      }
    }
    return c.$watch(r.identifier.value, this.session, s.baseUri, { recursive: u, excludes: d, includes: f, filter: g }, !!a), Ve.from({ dispose: () => c.$unwatch(this.session) });
  }
  dispose() {
    this._disposable.dispose();
  }
  get onDidCreate() {
    return this._onDidCreate.event;
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get onDidDelete() {
    return this._onDidDelete.event;
  }
}
class tU {
  get created() {
    return this._created.value;
  }
  get changed() {
    return this._changed.value;
  }
  get deleted() {
    return this._deleted.value;
  }
  constructor(e) {
    this._events = e, this._created = new Vi(() => this._events.created.map(x.revive)), this._changed = new Vi(() => this._events.changed.map(x.revive)), this._deleted = new Vi(() => this._events.deleted.map(x.revive)), this.session = this._events.session;
  }
}
class iU {
  constructor(e, i, n) {
    this._mainContext = e, this._logService = i, this._extHostDocumentsAndEditors = n, this._onFileSystemEvent = new N(), this._onDidRenameFile = new N(), this._onDidCreateFile = new N(), this._onDidDeleteFile = new N(), this._onWillRenameFile = new id(), this._onWillCreateFile = new id(), this._onWillDeleteFile = new id(), this.onDidRenameFile = this._onDidRenameFile.event, this.onDidCreateFile = this._onDidCreateFile.event, this.onDidDeleteFile = this._onDidDeleteFile.event;
  }
  createFileSystemWatcher(e, i, n, r, s) {
    return new eU(
      this._mainContext,
      i,
      e,
      n,
      this._onFileSystemEvent.event,
      vn.from(r),
      s
    );
  }
  $onFileEvent(e) {
    this._onFileSystemEvent.fire(new tU(e));
  }
  $onDidRunFileOperation(e, i) {
    switch (e) {
      case kr.MOVE:
        this._onDidRenameFile.fire(Object.freeze({ files: i.map((n) => ({ oldUri: x.revive(n.source), newUri: x.revive(n.target) })) }));
        break;
      case kr.DELETE:
        this._onDidDeleteFile.fire(Object.freeze({ files: i.map((n) => x.revive(n.target)) }));
        break;
      case kr.CREATE:
      case kr.COPY:
        this._onDidCreateFile.fire(Object.freeze({ files: i.map((n) => x.revive(n.target)) }));
        break;
    }
  }
  getOnWillRenameFileEvent(e) {
    return this._createWillExecuteEvent(e, this._onWillRenameFile);
  }
  getOnWillCreateFileEvent(e) {
    return this._createWillExecuteEvent(e, this._onWillCreateFile);
  }
  getOnWillDeleteFileEvent(e) {
    return this._createWillExecuteEvent(e, this._onWillDeleteFile);
  }
  _createWillExecuteEvent(e, i) {
    return (n, r, s) => {
      const o = function(l) {
        n.call(r, l);
      };
      return o.extension = e, i.event(o, void 0, s);
    };
  }
  async $onWillRunFileOperation(e, i, n, r) {
    switch (e) {
      case kr.MOVE:
        return await this._fireWillEvent(this._onWillRenameFile, { files: i.map((s) => ({ oldUri: x.revive(s.source), newUri: x.revive(s.target) })) }, n, r);
      case kr.DELETE:
        return await this._fireWillEvent(this._onWillDeleteFile, { files: i.map((s) => x.revive(s.target)) }, n, r);
      case kr.CREATE:
      case kr.COPY:
        return await this._fireWillEvent(this._onWillCreateFile, { files: i.map((s) => x.revive(s.target)) }, n, r);
    }
  }
  async _fireWillEvent(e, i, n, r) {
    const s = /* @__PURE__ */ new Set(), o = [];
    if (await e.fireAsync(i, r, async (l, c) => {
      const u = Date.now(), d = await Promise.resolve(l);
      d instanceof tl && (o.push([c.extension, d]), s.add(c.extension.displayName ?? c.extension.identifier.value)), Date.now() - u > n && this._logService.warn("SLOW file-participant", c.extension.identifier);
    }), r.isCancellationRequested || o.length === 0)
      return;
    const a = { edits: [] };
    for (const [, l] of o) {
      const { edits: c } = yn.from(l, {
        getTextDocumentVersion: (u) => this._extHostDocumentsAndEditors.getDocument(u)?.version,
        getNotebookDocumentVersion: () => {
        }
      });
      a.edits = a.edits.concat(c);
    }
    return { edit: a, extensionNames: Array.from(s) };
  }
}
class nU {
  constructor(e, i, n, r, s) {
    this._extHostNotebooks = i, this._textDocumentsAndEditors = n, this._commands = r;
    const o = new Pe(
      "interactive.open",
      "_interactive.open",
      "Open interactive window and return notebook editor and input URI",
      [
        new q("showOptions", "Show Options", (a) => !0, (a) => a),
        new q("resource", "Interactive resource Uri", (a) => !0, (a) => a),
        new q("controllerId", "Notebook controller Id", (a) => !0, (a) => a),
        new q("title", "Interactive editor title", (a) => !0, (a) => a)
      ],
      new Se("Notebook and input URI", (a) => {
        if (s.debug("[ExtHostInteractive] open iw with notebook editor id", a.notebookEditorId), a.notebookEditorId !== void 0) {
          const l = this._extHostNotebooks.getEditorById(a.notebookEditorId);
          return s.debug("[ExtHostInteractive] notebook editor found", l.id), { notebookUri: x.revive(a.notebookUri), inputUri: x.revive(a.inputUri), notebookEditor: l.apiEditor };
        }
        return s.debug("[ExtHostInteractive] notebook editor not found, uris for the interactive document", a.notebookUri, a.inputUri), { notebookUri: x.revive(a.notebookUri), inputUri: x.revive(a.inputUri) };
      })
    );
    this._commands.registerApiCommand(o);
  }
  $willAddInteractiveDocument(e, i, n, r) {
    this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
      addedDocuments: [{
        EOL: i,
        lines: [""],
        languageId: n,
        uri: e,
        isDirty: !1,
        versionId: 1,
        encoding: "utf8"
      }]
    });
  }
  $willRemoveInteractiveDocument(e, i) {
    this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
      removedDocuments: [e]
    });
  }
}
class rU {
  constructor(e) {
    this._handlePool = 0, this._proxy = e.getProxy(ee.MainThreadLabelService);
  }
  $registerResourceLabelFormatter(e) {
    const i = this._handlePool++;
    return this._proxy.$registerResourceLabelFormatter(i, e), Ee(() => {
      this._proxy.$unregisterResourceLabelFormatter(i);
    });
  }
}
var ro;
(function(t) {
  t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL";
})(ro || (ro = {}));
class En extends ut {
  constructor(e, i, n, r) {
    super(e, i, n, r), this.selectionStartLineNumber = e, this.selectionStartColumn = i, this.positionLineNumber = n, this.positionColumn = r;
  }
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  equalsSelection(e) {
    return En.selectionsEqual(this, e);
  }
  static selectionsEqual(e, i) {
    return e.selectionStartLineNumber === i.selectionStartLineNumber && e.selectionStartColumn === i.selectionStartColumn && e.positionLineNumber === i.positionLineNumber && e.positionColumn === i.positionColumn;
  }
  getDirection() {
    return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? ro.LTR : ro.RTL;
  }
  setEndPosition(e, i) {
    return this.getDirection() === ro.LTR ? new En(this.startLineNumber, this.startColumn, e, i) : new En(e, i, this.startLineNumber, this.startColumn);
  }
  getPosition() {
    return new Pn(this.positionLineNumber, this.positionColumn);
  }
  getSelectionStart() {
    return new Pn(this.selectionStartLineNumber, this.selectionStartColumn);
  }
  setStartPosition(e, i) {
    return this.getDirection() === ro.LTR ? new En(e, i, this.endLineNumber, this.endColumn) : new En(this.endLineNumber, this.endColumn, e, i);
  }
  static fromPositions(e, i = e) {
    return new En(e.lineNumber, e.column, i.lineNumber, i.column);
  }
  static fromRange(e, i) {
    return i === ro.LTR ? new En(
      e.startLineNumber,
      e.startColumn,
      e.endLineNumber,
      e.endColumn
    ) : new En(
      e.endLineNumber,
      e.endColumn,
      e.startLineNumber,
      e.startColumn
    );
  }
  static liftSelection(e) {
    return new En(
      e.selectionStartLineNumber,
      e.selectionStartColumn,
      e.positionLineNumber,
      e.positionColumn
    );
  }
  static selectionsArrEqual(e, i) {
    if (e && !i || !e && i)
      return !1;
    if (!e && !i)
      return !0;
    if (e.length !== i.length)
      return !1;
    for (let n = 0, r = e.length; n < r; n++)
      if (!this.selectionsEqual(e[n], i[n]))
        return !1;
    return !0;
  }
  static isISelection(e) {
    return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
  }
  static createWithDirection(e, i, n, r, s) {
    return s === ro.LTR ? new En(e, i, n, r) : new En(n, r, e, i);
  }
}
class l_ {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideDocumentSymbols(e, i) {
    const n = this._documents.getDocument(e), r = await this._provider.provideDocumentSymbols(n, i);
    if (!mx(r))
      return r[0] instanceof oh ? r.map(Ab.from) : l_._asDocumentSymbolTree(r);
  }
  static _asDocumentSymbolTree(e) {
    e = e.slice(0).sort((r, s) => {
      let o = r.location.range.start.compareTo(s.location.range.start);
      return o === 0 && (o = s.location.range.end.compareTo(r.location.range.end)), o;
    });
    const i = [], n = [];
    for (const r of e) {
      const s = {
        name: r.name || "!!MISSING: name!!",
        kind: jn.from(r.kind),
        tags: r.tags?.map(Os.from) || [],
        detail: "",
        containerName: r.containerName,
        range: z.from(r.location.range),
        selectionRange: z.from(r.location.range),
        children: []
      };
      for (; ; ) {
        if (n.length === 0) {
          n.push(s), i.push(s);
          break;
        }
        const o = n[n.length - 1];
        if (ut.containsRange(o.range, s.range) && !ut.equalsRange(o.range, s.range)) {
          o.children?.push(s), n.push(s);
          break;
        }
        n.pop();
      }
    }
    return i;
  }
}
class Wf {
  constructor(e, i, n, r, s, o) {
    this._documents = e, this._commands = i, this._provider = n, this._extension = r, this._extTelemetry = s, this._logService = o, this._cache = new Nn("CodeLens"), this._disposables = /* @__PURE__ */ new Map();
  }
  async provideCodeLenses(e, i) {
    const n = this._documents.getDocument(e), r = await this._provider.provideCodeLenses(n, i);
    if (!r || i.isCancellationRequested)
      return;
    const s = this._cache.add(r), o = new De();
    this._disposables.set(s, o);
    const a = {
      cacheId: s,
      lenses: []
    };
    for (let l = 0; l < r.length; l++) {
      if (!Oe.isRange(r[l].range)) {
        console.warn("INVALID code lens, range is not defined", this._extension.identifier.value);
        continue;
      }
      a.lenses.push({
        cacheId: [s, l],
        range: z.from(r[l].range),
        command: this._commands.toInternal(r[l].command, o)
      });
    }
    return a;
  }
  async resolveCodeLens(e, i) {
    const n = e.cacheId && this._cache.get(...e.cacheId);
    if (!n)
      return;
    let r;
    if (typeof this._provider.resolveCodeLens != "function" || n.isResolved ? r = n : r = await this._provider.resolveCodeLens(n, i), r || (r = n), i.isCancellationRequested)
      return;
    const s = e.cacheId && this._disposables.get(e.cacheId[0]);
    if (s) {
      if (!r.command) {
        const o = new Error(
          "INVALID code lens resolved, lacks command: " + this._extension.identifier.value
        );
        this._extTelemetry.onExtensionError(this._extension.identifier, o), this._logService.error(o);
        return;
      }
      return e.command = this._commands.toInternal(r.command, s), e;
    }
  }
  releaseCodeLenses(e) {
    this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e);
  }
}
function m1(t) {
  return Array.isArray(t) ? t.map(Oh.from) : t ? [Oh.from(t)] : [];
}
class rC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideDefinition(e, i, n) {
    const r = this._documents.getDocument(e), s = at.to(i), o = await this._provider.provideDefinition(r, s, n);
    return m1(o);
  }
}
class sC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideDeclaration(e, i, n) {
    const r = this._documents.getDocument(e), s = at.to(i), o = await this._provider.provideDeclaration(r, s, n);
    return m1(o);
  }
}
class oC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideImplementation(e, i, n) {
    const r = this._documents.getDocument(e), s = at.to(i), o = await this._provider.provideImplementation(r, s, n);
    return m1(o);
  }
}
class aC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideTypeDefinition(e, i, n) {
    const r = this._documents.getDocument(e), s = at.to(i), o = await this._provider.provideTypeDefinition(r, s, n);
    return m1(o);
  }
}
const I_ = class I_ {
  constructor(e, i) {
    this._documents = e, this._provider = i, this._hoverCounter = 0, this._hoverMap = /* @__PURE__ */ new Map();
  }
  async provideHover(e, i, n, r) {
    const s = this._documents.getDocument(e), o = at.to(i);
    let a;
    if (n && n.verbosityRequest) {
      const d = n.verbosityRequest.previousHover.id, f = this._hoverMap.get(d);
      if (!f)
        throw new Error(`Hover with id ${d} not found`);
      const g = { verbosityDelta: n.verbosityRequest.verbosityDelta, previousHover: f };
      a = await this._provider.provideHover(s, o, r, g);
    } else
      a = await this._provider.provideHover(s, o, r);
    if (!a || mx(a.contents))
      return;
    a.range || (a.range = s.getWordRangeAtPosition(o)), a.range || (a.range = new Oe(o, o));
    const l = Fh.from(a), c = this._hoverCounter;
    if (this._hoverMap.size === I_.HOVER_MAP_MAX_SIZE) {
      const d = Math.min(...this._hoverMap.keys());
      this._hoverMap.delete(d);
    }
    return this._hoverMap.set(c, a), this._hoverCounter += 1, {
      ...l,
      id: c
    };
  }
  releaseHover(e) {
    this._hoverMap.delete(e);
  }
};
I_.HOVER_MAP_MAX_SIZE = 10;
let Cd = I_;
class lC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideEvaluatableExpression(e, i, n) {
    const r = this._documents.getDocument(e), s = at.to(i), o = await this._provider.provideEvaluatableExpression(r, s, n);
    if (o)
      return Nb.from(o);
  }
}
class cC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideInlineValues(e, i, n, r) {
    const s = this._documents.getDocument(e), o = await this._provider.provideInlineValues(s, z.to(i), fm.to(n), r);
    if (Array.isArray(o))
      return o.map((a) => hm.from(a));
  }
}
class uC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideDocumentHighlights(e, i, n) {
    const r = this._documents.getDocument(e), s = at.to(i), o = await this._provider.provideDocumentHighlights(r, s, n);
    if (Array.isArray(o))
      return o.map(su.from);
  }
}
class dC {
  constructor(e, i, n) {
    this._documents = e, this._provider = i, this._logService = n;
  }
  async provideMultiDocumentHighlights(e, i, n, r) {
    const s = this._documents.getDocument(e), o = n.map((c) => {
      try {
        return this._documents.getDocument(c);
      } catch (u) {
        this._logService.error("Error: Unable to retrieve document from URI: " + c + ". Error message: " + u);
        return;
      }
    }).filter((c) => c !== void 0), a = at.to(i), l = await this._provider.provideMultiDocumentHighlights(s, a, o, r);
    if (Array.isArray(l))
      return l.map(Mb.from);
  }
}
class hC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideLinkedEditingRanges(e, i, n) {
    const r = this._documents.getDocument(e), s = at.to(i), o = await this._provider.provideLinkedEditingRanges(r, s, n);
    if (o && Array.isArray(o.ranges))
      return {
        ranges: Kt(o.ranges.map(z.from)),
        wordPattern: o.wordPattern
      };
  }
}
class fC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideReferences(e, i, n, r) {
    const s = this._documents.getDocument(e), o = at.to(i), a = await this._provider.provideReferences(s, o, n, r);
    if (Array.isArray(a))
      return a.map(an.from);
  }
}
const ac = class ac {
  constructor(e, i, n, r, s, o, a) {
    this._documents = e, this._commands = i, this._diagnostics = n, this._provider = r, this._logService = s, this._extension = o, this._apiDeprecation = a, this._cache = new Nn("CodeAction"), this._disposables = /* @__PURE__ */ new Map();
  }
  async provideCodeActions(e, i, n, r) {
    const s = this._documents.getDocument(e), o = En.isISelection(i) ? vr.to(i) : z.to(i), a = [];
    for (const g of this._diagnostics.getDiagnostics(e))
      if (o.intersection(g.range) && a.push(g) > ac._maxCodeActionsPerFile)
        break;
    const l = {
      diagnostics: a,
      only: n.only ? new At(n.only) : void 0,
      triggerKind: Kb.to(n.trigger)
    }, c = await this._provider.provideCodeActions(s, o, l, r);
    if (!of(c) || r.isCancellationRequested)
      return;
    const u = this._cache.add(c), d = new De();
    this._disposables.set(u, d);
    const f = [];
    for (let g = 0; g < c.length; g++) {
      const _ = c[g];
      if (_)
        if (ac._isCommand(_) && !(_ instanceof lh))
          this._apiDeprecation.report("CodeActionProvider.provideCodeActions - return commands", this._extension, "Return 'CodeAction' instances instead."), f.push({
            _isSynthetic: !0,
            title: _.title,
            command: this._commands.toInternal(_, d)
          });
        else {
          const w = _;
          l.only && (w.kind ? l.only.contains(w.kind) || this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${l.only.value}' requested but returned code action is of kind '${w.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`) : this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${l.only.value}' requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`));
          const v = w.ranges ?? [];
          f.push({
            cacheId: [u, g],
            title: w.title,
            command: w.command && this._commands.toInternal(w.command, d),
            diagnostics: w.diagnostics && w.diagnostics.map(nu.from),
            edit: w.edit && yn.from(w.edit, void 0),
            kind: w.kind && w.kind.value,
            isPreferred: w.isPreferred,
            isAI: lt(this._extension, "codeActionAI") ? w.isAI : !1,
            ranges: lt(this._extension, "codeActionRanges") ? Kt(v.map(z.from)) : void 0,
            disabled: w.disabled?.reason
          });
        }
    }
    return { cacheId: u, actions: f };
  }
  async resolveCodeAction(e, i) {
    const [n, r] = e, s = this._cache.get(n, r);
    if (!s || ac._isCommand(s))
      return {};
    if (!this._provider.resolveCodeAction)
      return {};
    const o = await this._provider.resolveCodeAction(s, i) ?? s;
    let a;
    o.edit && (a = yn.from(o.edit, void 0));
    let l;
    if (o.command) {
      const c = this._disposables.get(n);
      c && (l = this._commands.toInternal(o.command, c));
    }
    return { edit: a, command: l };
  }
  releaseCodeActions(e) {
    this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e);
  }
  static _isCommand(e) {
    return typeof e.command == "string" && typeof e.title == "string";
  }
};
ac._maxCodeActionsPerFile = 1e3;
let Jl = ac;
class zu {
  constructor(e, i, n, r, s) {
    this._proxy = e, this._documents = i, this._provider = n, this._handle = r, this._extension = s, this._editsCache = new Nn("DocumentPasteEdit.edits");
  }
  async prepareDocumentPaste(e, i, n, r) {
    if (!this._provider.prepareDocumentPaste)
      return;
    this._cachedPrepare = void 0;
    const s = this._documents.getDocument(e), o = i.map((d) => z.to(d)), a = fu.toDataTransfer(n, () => {
      throw new z5();
    });
    if (await this._provider.prepareDocumentPaste(s, o, a, r), r.isCancellationRequested)
      return;
    const l = Array.from(a).filter(([, d]) => !(d instanceof $g)), c = /* @__PURE__ */ new Map(), u = await Promise.all(Array.from(l, async ([d, f]) => {
      const g = on();
      return c.set(g, f), [d, await Ma.from(d, f, g)];
    }));
    return this._cachedPrepare = c, { items: u };
  }
  async providePasteEdits(e, i, n, r, s, o) {
    if (!this._provider.provideDocumentPasteEdits)
      return [];
    const a = this._documents.getDocument(i), l = n.map((g) => z.to(g)), c = r.items.map(([g, _]) => {
      const w = this._cachedPrepare?.get(_.id);
      return w ? [g, w] : [
        g,
        Ma.to(g, _, async (v) => (await this._proxy.$resolvePasteFileData(this._handle, e, v)).buffer)
      ];
    }), u = new Xc(c), d = await this._provider.provideDocumentPasteEdits(a, l, u, {
      only: s.only ? new es(s.only) : void 0,
      triggerKind: s.triggerKind
    }, o);
    if (!d || o.isCancellationRequested)
      return [];
    const f = this._editsCache.add(d);
    return d.map((g, _) => ({
      _cacheId: [f, _],
      title: g.title ?? h(
        2625,
        "Paste using '{0}' extension",
        this._extension.displayName || this._extension.name
      ),
      kind: g.kind,
      yieldTo: g.yieldTo?.map((w) => w.value),
      insertText: typeof g.insertText == "string" ? g.insertText : { snippet: g.insertText.value },
      additionalEdit: g.additionalEdit ? yn.from(g.additionalEdit, void 0) : void 0
    }));
  }
  async resolvePasteEdit(e, i) {
    const [n, r] = e, s = this._editsCache.get(n, r);
    if (!s || !this._provider.resolveDocumentPasteEdit)
      return {};
    const o = await this._provider.resolveDocumentPasteEdit(s, i) ?? s;
    return {
      insertText: o.insertText,
      additionalEdit: o.additionalEdit ? yn.from(o.additionalEdit, void 0) : void 0
    };
  }
  releasePasteEdits(e) {
    this._editsCache.delete(e);
  }
}
class pC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideDocumentFormattingEdits(e, i, n) {
    const r = this._documents.getDocument(e), s = await this._provider.provideDocumentFormattingEdits(r, i, n);
    if (Array.isArray(s))
      return s.map(hi.from);
  }
}
class iv {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideDocumentRangeFormattingEdits(e, i, n, r) {
    const s = this._documents.getDocument(e), o = z.to(i), a = await this._provider.provideDocumentRangeFormattingEdits(s, o, n, r);
    if (Array.isArray(a))
      return a.map(hi.from);
  }
  async provideDocumentRangesFormattingEdits(e, i, n, r) {
    i4(typeof this._provider.provideDocumentRangesFormattingEdits == "function", "INVALID invocation of `provideDocumentRangesFormattingEdits`");
    const s = this._documents.getDocument(e), o = i.map(z.to), a = await this._provider.provideDocumentRangesFormattingEdits(s, o, n, r);
    if (Array.isArray(a))
      return a.map(hi.from);
  }
}
class gC {
  constructor(e, i) {
    this._documents = e, this._provider = i, this.autoFormatTriggerCharacters = [];
  }
  async provideOnTypeFormattingEdits(e, i, n, r, s) {
    const o = this._documents.getDocument(e), a = at.to(i), l = await this._provider.provideOnTypeFormattingEdits(o, a, n, r, s);
    if (Array.isArray(l))
      return l.map(hi.from);
  }
}
class Vf {
  constructor(e, i) {
    this._provider = e, this._logService = i, this._cache = new Nn("WorkspaceSymbols");
  }
  async provideWorkspaceSymbols(e, i) {
    const n = await this._provider.provideWorkspaceSymbols(e, i);
    if (!of(n))
      return { symbols: [] };
    const r = this._cache.add(n), s = {
      cacheId: r,
      symbols: []
    };
    for (let o = 0; o < n.length; o++) {
      const a = n[o];
      if (!a || !a.name) {
        this._logService.warn("INVALID SymbolInformation", a);
        continue;
      }
      s.symbols.push({
        ...ol.from(a),
        cacheId: [r, o]
      });
    }
    return s;
  }
  async resolveWorkspaceSymbol(e, i) {
    if (typeof this._provider.resolveWorkspaceSymbol != "function" || !e.cacheId)
      return e;
    const n = this._cache.get(...e.cacheId);
    if (n) {
      const r = await this._provider.resolveWorkspaceSymbol(n, i);
      return r && Za(e, ol.from(r), !0);
    }
  }
  releaseWorkspaceSymbols(e) {
    this._cache.delete(e);
  }
}
class ya {
  static supportsResolving(e) {
    return typeof e.prepareRename == "function";
  }
  constructor(e, i, n) {
    this._documents = e, this._provider = i, this._logService = n;
  }
  async provideRenameEdits(e, i, n, r) {
    const s = this._documents.getDocument(e), o = at.to(i);
    try {
      const a = await this._provider.provideRenameEdits(s, o, n, r);
      return a ? yn.from(a) : void 0;
    } catch (a) {
      const l = ya._asMessage(a);
      return l ? { rejectReason: l, edits: void 0 } : Promise.reject(a);
    }
  }
  async resolveRenameLocation(e, i, n) {
    if (typeof this._provider.prepareRename != "function")
      return Promise.resolve(void 0);
    const r = this._documents.getDocument(e), s = at.to(i);
    try {
      const o = await this._provider.prepareRename(r, s, n);
      let a, l;
      if (Oe.isRange(o) ? (a = o, l = r.getText(o)) : ri(o) && (a = o.range, l = o.placeholder), !a || !l)
        return;
      if (a.start.line > s.line || a.end.line < s.line) {
        this._logService.warn("INVALID rename location: position line must be within range start/end lines");
        return;
      }
      return { range: z.from(a), text: l };
    } catch (o) {
      const a = ya._asMessage(o);
      return a ? { rejectReason: a, range: void 0, text: void 0 } : Promise.reject(o);
    }
  }
  static _asMessage(e) {
    return typeof e == "string" ? e : e instanceof Error && typeof e.message == "string" ? e.message : void 0;
  }
}
const Fd = class Fd {
  constructor(e, i, n) {
    this._documents = e, this._provider = i, this._logService = n;
  }
  async supportsAutomaticNewSymbolNamesTriggerKind() {
    return this._provider.supportsAutomaticTriggerKind;
  }
  async provideNewSymbolNames(e, i, n, r) {
    const s = this._documents.getDocument(e), o = z.to(i);
    try {
      const a = Fd.languageTriggerKindToVSCodeTriggerKind[n], l = await this._provider.provideNewSymbolNames(s, o, a, r);
      return l ? l.map(
        (c) => typeof c == "string" ? { newSymbolName: c } : { newSymbolName: c.newSymbolName, tags: c.tags }
      ) : void 0;
    } catch (a) {
      this._logService.error(Fd._asMessage(a) ?? JSON.stringify(a, null, "	"));
      return;
    }
  }
  static _asMessage(e) {
    return typeof e == "string" ? e : e instanceof Error && typeof e.message == "string" ? e.message : void 0;
  }
};
Fd.languageTriggerKindToVSCodeTriggerKind = {
  [ig.Invoke]: wh.Invoke,
  [ig.Automatic]: wh.Automatic
};
let Td = Fd;
class nv {
  constructor(e, i) {
    this.resultId = e, this.tokens = i;
  }
}
class gn {
  constructor(e, i) {
    this._documents = e, this._provider = i, this._nextResultId = 1, this._previousResults = /* @__PURE__ */ new Map();
  }
  async provideDocumentSemanticTokens(e, i, n) {
    const r = this._documents.getDocument(e), s = i !== 0 ? this._previousResults.get(i) : null;
    let o = typeof s?.resultId == "string" && typeof this._provider.provideDocumentSemanticTokensEdits == "function" ? await this._provider.provideDocumentSemanticTokensEdits(r, s.resultId, n) : await this._provider.provideDocumentSemanticTokens(r, n);
    return s && this._previousResults.delete(i), o ? (o = gn._fixProvidedSemanticTokens(o), this._send(gn._convertToEdits(s, o), o)) : null;
  }
  async releaseDocumentSemanticColoring(e) {
    this._previousResults.delete(e);
  }
  static _fixProvidedSemanticTokens(e) {
    return gn._isSemanticTokens(e) ? gn._isCorrectSemanticTokens(e) ? e : new eu(new Uint32Array(e.data), e.resultId) : gn._isSemanticTokensEdits(e) ? gn._isCorrectSemanticTokensEdits(e) ? e : new pp(e.edits.map((i) => new ZT(i.start, i.deleteCount, i.data ? new Uint32Array(i.data) : i.data)), e.resultId) : e;
  }
  static _isSemanticTokens(e) {
    return e && !!e.data;
  }
  static _isCorrectSemanticTokens(e) {
    return e.data instanceof Uint32Array;
  }
  static _isSemanticTokensEdits(e) {
    return e && Array.isArray(e.edits);
  }
  static _isCorrectSemanticTokensEdits(e) {
    for (const i of e.edits)
      if (!(i.data instanceof Uint32Array))
        return !1;
    return !0;
  }
  static _convertToEdits(e, i) {
    if (!gn._isSemanticTokens(i) || !e || !e.tokens)
      return i;
    const n = e.tokens, r = n.length, s = i.data, o = s.length;
    let a = 0;
    const l = Math.min(r, o);
    for (; a < l && n[a] === s[a]; )
      a++;
    if (a === r && a === o)
      return new pp([], i.resultId);
    let c = 0;
    const u = l - a;
    for (; c < u && n[r - c - 1] === s[o - c - 1]; )
      c++;
    return new pp([{
      start: a,
      deleteCount: r - a - c,
      data: s.subarray(a, o - c)
    }], i.resultId);
  }
  _send(e, i) {
    if (gn._isSemanticTokens(e)) {
      const n = this._nextResultId++;
      return this._previousResults.set(n, new nv(e.resultId, e.data)), k0({
        id: n,
        type: "full",
        data: e.data
      });
    }
    if (gn._isSemanticTokensEdits(e)) {
      const n = this._nextResultId++;
      return gn._isSemanticTokens(i) ? this._previousResults.set(n, new nv(i.resultId, i.data)) : this._previousResults.set(n, new nv(e.resultId)), k0({
        id: n,
        type: "delta",
        deltas: (e.edits || []).map(
          (r) => ({ start: r.start, deleteCount: r.deleteCount, data: r.data })
        )
      });
    }
    return null;
  }
}
class mC {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideDocumentRangeSemanticTokens(e, i, n) {
    const r = this._documents.getDocument(e), s = await this._provider.provideDocumentRangeSemanticTokens(r, z.to(i), n);
    return s ? this._send(s) : null;
  }
  _send(e) {
    return k0({
      id: 0,
      type: "full",
      data: e.data
    });
  }
}
class Xo {
  static supportsResolving(e) {
    return typeof e.resolveCompletionItem == "function";
  }
  constructor(e, i, n, r, s) {
    this._documents = e, this._commands = i, this._provider = n, this._apiDeprecation = r, this._extension = s, this._cache = new Nn("CompletionItem"), this._disposables = /* @__PURE__ */ new Map();
  }
  async provideCompletionItems(e, i, n, r) {
    const s = this._documents.getDocument(e), o = at.to(i), a = s.getWordRangeAtPosition(o) || new Oe(o, o), l = a.with({ end: o }), c = new Ms(), u = await this._provider.provideCompletionItems(s, o, r, Fb.to(n));
    if (!u || r.isCancellationRequested)
      return;
    const d = Array.isArray(u) ? new Gc(u) : u, f = Xo.supportsResolving(this._provider) ? this._cache.add(d.items) : this._cache.add([]), g = new De();
    this._disposables.set(f, g);
    const _ = [], w = {
      x: f,
      [Ul.completions]: _,
      [Ul.defaultRanges]: { replace: z.from(a), insert: z.from(l) },
      [Ul.isIncomplete]: d.isIncomplete || void 0,
      [Ul.duration]: c.elapsed()
    };
    for (let v = 0; v < d.items.length; v++) {
      const S = d.items[v], E = this._convertCompletionItem(S, [f, v], l, a);
      _.push(E);
    }
    return w;
  }
  async resolveCompletionItem(e, i) {
    if (typeof this._provider.resolveCompletionItem != "function")
      return;
    const n = this._cache.get(...e);
    if (!n)
      return;
    const r = this._convertCompletionItem(n, e), s = await this._provider.resolveCompletionItem(n, i);
    if (!s)
      return;
    const o = this._convertCompletionItem(s, e);
    return (r[Ue.insertText] !== o[Ue.insertText] || r[Ue.insertTextRules] !== o[Ue.insertTextRules]) && this._apiDeprecation.report("CompletionItem.insertText", this._extension, "extension MAY NOT change 'insertText' of a CompletionItem during resolve"), (r[Ue.commandIdent] !== o[Ue.commandIdent] || r[Ue.commandId] !== o[Ue.commandId] || !sn(r[Ue.commandArguments], o[Ue.commandArguments])) && this._apiDeprecation.report("CompletionItem.command", this._extension, "extension MAY NOT change 'command' of a CompletionItem during resolve"), {
      ...r,
      [Ue.documentation]: o[Ue.documentation],
      [Ue.detail]: o[Ue.detail],
      [Ue.additionalTextEdits]: o[Ue.additionalTextEdits],
      [Ue.insertText]: o[Ue.insertText],
      [Ue.insertTextRules]: o[Ue.insertTextRules],
      [Ue.commandIdent]: o[Ue.commandIdent],
      [Ue.commandId]: o[Ue.commandId],
      [Ue.commandArguments]: o[Ue.commandArguments]
    };
  }
  releaseCompletionItems(e) {
    this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e);
  }
  _convertCompletionItem(e, i, n, r) {
    const s = this._disposables.get(i[0]);
    if (!s)
      throw Error("DisposableStore is missing...");
    const o = this._commands.toInternal(e.command, s), a = {
      x: i,
      [Ue.label]: e.label,
      [Ue.kind]: e.kind !== void 0 ? gm.from(e.kind) : void 0,
      [Ue.kindModifier]: e.tags && e.tags.map(pm.from),
      [Ue.detail]: e.detail,
      [Ue.documentation]: typeof e.documentation > "u" ? void 0 : Ae.fromStrict(e.documentation),
      [Ue.sortText]: e.sortText !== e.label ? e.sortText : void 0,
      [Ue.filterText]: e.filterText !== e.label ? e.filterText : void 0,
      [Ue.preselect]: e.preselect || void 0,
      [Ue.insertTextRules]: e.keepWhitespace ? Ia.KeepWhitespace : Ia.None,
      [Ue.commitCharacters]: e.commitCharacters?.join(""),
      [Ue.additionalTextEdits]: e.additionalTextEdits && e.additionalTextEdits.map(hi.from),
      [Ue.commandIdent]: o?.$ident,
      [Ue.commandId]: o?.id,
      [Ue.commandArguments]: o?.$ident ? void 0 : o?.arguments
    };
    e.textEdit ? (this._apiDeprecation.report("CompletionItem.textEdit", this._extension, "Use 'CompletionItem.insertText' and 'CompletionItem.range' instead."), a[Ue.insertText] = e.textEdit.newText) : typeof e.insertText == "string" ? a[Ue.insertText] = e.insertText : e.insertText instanceof il && (a[Ue.insertText] = e.insertText.value, a[Ue.insertTextRules] |= Ia.InsertAsSnippet);
    let l;
    return e.textEdit ? l = e.textEdit.range : e.range && (l = e.range), Oe.isRange(l) ? a[Ue.range] = z.from(l) : l && (!n?.isEqual(l.inserting) || !r?.isEqual(l.replacing)) && (a[Ue.range] = {
      insert: z.from(l.inserting),
      replace: z.from(l.replacing)
    }), a;
  }
}
class Wo {
  constructor(e, i, n, r) {
    this._extension = e, this._documents = i, this._provider = n, this._commands = r, this._references = new sU(), this.languageTriggerKindToVSCodeTriggerKind = {
      [Xp.Automatic]: vh.Automatic,
      [Xp.Explicit]: vh.Invoke
    }, this._isAdditionsProposedApiEnabled = lt(this._extension, "inlineCompletionsAdditions");
  }
  get supportsHandleEvents() {
    return lt(this._extension, "inlineCompletionsAdditions") && (typeof this._provider.handleDidShowCompletionItem == "function" || typeof this._provider.handleDidPartiallyAcceptCompletionItem == "function" || typeof this._provider.handleDidRejectCompletionItem == "function" || typeof this._provider.handleEndOfLifetime == "function");
  }
  async provideInlineCompletions(e, i, n, r) {
    const s = this._documents.getDocument(e), o = at.to(i), a = await this._provider.provideInlineCompletionItems(s, o, {
      selectedCompletionInfo: n.selectedSuggestionInfo ? {
        range: z.to(n.selectedSuggestionInfo.range),
        text: n.selectedSuggestionInfo.text
      } : void 0,
      triggerKind: this.languageTriggerKindToVSCodeTriggerKind[n.triggerKind],
      requestUuid: n.requestUuid,
      requestIssuedDateTime: n.requestIssuedDateTime
    }, r);
    if (!a)
      return;
    const { resultItems: l, list: c } = Array.isArray(a) ? { resultItems: a, list: void 0 } : { resultItems: a.items, list: a }, u = this._isAdditionsProposedApiEnabled ? Array.isArray(a) ? [] : a.commands || [] : [], d = this._isAdditionsProposedApiEnabled && !Array.isArray(a) ? a.enableForwardStability : void 0;
    let f;
    return {
      pid: this._references.createReferenceId({
        dispose() {
          f?.dispose();
        },
        items: l,
        list: c
      }),
      items: l.map((_, w) => {
        let v;
        _.command && (f || (f = new De()), v = this._commands.toInternal(_.command, f));
        let S;
        _.action && (f || (f = new De()), S = this._commands.toInternal(_.action, f));
        const E = _.insertText;
        return {
          insertText: typeof E == "string" ? E : { snippet: E.value },
          filterText: _.filterText,
          range: _.range ? z.from(_.range) : void 0,
          showRange: this._isAdditionsProposedApiEnabled && _.showRange ? z.from(_.showRange) : void 0,
          command: v,
          action: S,
          idx: w,
          completeBracketPairs: this._isAdditionsProposedApiEnabled ? _.completeBracketPairs : !1,
          isInlineEdit: this._isAdditionsProposedApiEnabled ? _.isInlineEdit : !1,
          showInlineEditMenu: this._isAdditionsProposedApiEnabled ? _.showInlineEditMenu : !1,
          displayLocation: _.displayLocation && this._isAdditionsProposedApiEnabled ? {
            range: z.from(_.displayLocation.range),
            label: _.displayLocation.label
          } : void 0,
          warning: _.warning && this._isAdditionsProposedApiEnabled ? {
            message: Ae.from(_.warning.message),
            icon: _.warning.icon ? Wm.fromThemeIcon(_.warning.icon) : void 0
          } : void 0
        };
      }),
      commands: u.map((_) => (f || (f = new De()), Ub.from(_, this._commands, f))),
      suppressSuggestions: !1,
      enableForwardStability: d
    };
  }
  disposeCompletions(e, i) {
    const n = this._references.get(e);
    if (this._provider.handleListEndOfLifetime && this._isAdditionsProposedApiEnabled && n?.list) {
      let s = function(o) {
        switch (o.kind) {
          case "lostRace":
            return { kind: ws.LostRace };
          case "tokenCancellation":
            return { kind: ws.TokenCancellation };
          case "other":
            return { kind: ws.Other };
          case "empty":
            return { kind: ws.Empty };
          case "notTaken":
            return { kind: ws.NotTaken };
          default:
            return { kind: ws.Other };
        }
      };
      this._provider.handleListEndOfLifetime(n.list, s(i));
    }
    this._references.disposeReferenceId(e)?.dispose();
  }
  handleDidShowCompletionItem(e, i, n) {
    const r = this._references.get(e)?.items[i];
    r && this._provider.handleDidShowCompletionItem && this._isAdditionsProposedApiEnabled && this._provider.handleDidShowCompletionItem(r, n);
  }
  handlePartialAccept(e, i, n, r) {
    const s = this._references.get(e)?.items[i];
    s && this._provider.handleDidPartiallyAcceptCompletionItem && this._isAdditionsProposedApiEnabled && (this._provider.handleDidPartiallyAcceptCompletionItem(s, n), this._provider.handleDidPartiallyAcceptCompletionItem(s, ay.to(r)));
  }
  handleEndOfLifetime(e, i, n) {
    const r = this._references.get(e)?.items[i];
    if (r && this._provider.handleEndOfLifetime && this._isAdditionsProposedApiEnabled) {
      const s = cy.to(n, (o) => this._references.get(o.pid)?.items[o.idx]);
      this._provider.handleEndOfLifetime(r, s);
    }
  }
  handleRejection(e, i) {
    const n = this._references.get(e)?.items[i];
    n && this._provider.handleDidRejectCompletionItem && this._isAdditionsProposedApiEnabled && this._provider.handleDidRejectCompletionItem(n);
  }
}
class sU {
  constructor() {
    this._references = /* @__PURE__ */ new Map(), this._idPool = 1;
  }
  createReferenceId(e) {
    const i = this._idPool++;
    return this._references.set(i, e), i;
  }
  disposeReferenceId(e) {
    const i = this._references.get(e);
    return this._references.delete(e), i;
  }
  get(e) {
    return this._references.get(e);
  }
}
class rv {
  constructor(e, i) {
    this._documents = e, this._provider = i, this._cache = new Nn("SignatureHelp");
  }
  async provideSignatureHelp(e, i, n, r) {
    const s = this._documents.getDocument(e), o = at.to(i), a = this.reviveContext(n), l = await this._provider.provideSignatureHelp(s, o, r, a);
    if (l) {
      const c = this._cache.add([l]);
      return { ...Uh.from(l), id: c };
    }
  }
  reviveContext(e) {
    let i;
    if (e.activeSignatureHelp) {
      const n = Uh.to(e.activeSignatureHelp), r = this._cache.get(e.activeSignatureHelp.id, 0);
      r ? (i = r, i.activeSignature = n.activeSignature, i.activeParameter = n.activeParameter) : i = n;
    }
    return { ...e, activeSignatureHelp: i };
  }
  releaseSignatureHelp(e) {
    this._cache.delete(e);
  }
}
class zf {
  constructor(e, i, n, r, s) {
    this._documents = e, this._commands = i, this._provider = n, this._logService = r, this._extension = s, this._cache = new Nn("InlayHints"), this._disposables = /* @__PURE__ */ new Map();
  }
  async provideInlayHints(e, i, n) {
    const r = this._documents.getDocument(e), s = z.to(i), o = await this._provider.provideInlayHints(r, s, n);
    if (!Array.isArray(o) || o.length === 0) {
      this._logService.trace(`[InlayHints] NO inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(i)}`);
      return;
    }
    if (n.isCancellationRequested)
      return;
    const a = this._cache.add(o);
    this._disposables.set(a, new De());
    const l = { hints: [], cacheId: a };
    for (let c = 0; c < o.length; c++)
      this._isValidInlayHint(o[c], s) && l.hints.push(this._convertInlayHint(o[c], [a, c]));
    return this._logService.trace(`[InlayHints] ${l.hints.length} inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(i)}`), l;
  }
  async resolveInlayHint(e, i) {
    if (typeof this._provider.resolveInlayHint != "function")
      return;
    const n = this._cache.get(...e);
    if (!n)
      return;
    const r = await this._provider.resolveInlayHint(n, i);
    if (r && this._isValidInlayHint(r))
      return this._convertInlayHint(r, e);
  }
  releaseHints(e) {
    this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e);
  }
  _isValidInlayHint(e, i) {
    return e.label.length === 0 || Array.isArray(e.label) && e.label.every((n) => n.value.length === 0) ? (console.log("INVALID inlay hint, empty label", e), !1) : !(i && !i.contains(e.position));
  }
  _convertInlayHint(e, i) {
    const n = this._disposables.get(i[0]);
    if (!n)
      throw Error("DisposableStore is missing...");
    const r = {
      label: "",
      cacheId: i,
      tooltip: Ae.fromStrict(e.tooltip),
      position: at.from(e.position),
      textEdits: e.textEdits && e.textEdits.map(hi.from),
      kind: e.kind && vm.from(e.kind),
      paddingLeft: e.paddingLeft,
      paddingRight: e.paddingRight
    };
    if (typeof e.label == "string")
      r.label = e.label;
    else {
      const s = [];
      r.label = s;
      for (const o of e.label) {
        if (!o.value) {
          console.warn("INVALID inlay hint, empty label part", this._extension.identifier.value);
          continue;
        }
        const a = {
          label: o.value,
          tooltip: Ae.fromStrict(o.tooltip)
        };
        Ln.isLocation(o.location) && (a.location = an.from(o.location)), o.command && (a.command = this._commands.toInternal(o.command, n)), s.push(a);
      }
    }
    return r;
  }
}
class vo {
  constructor(e, i) {
    this._documents = e, this._provider = i, this._cache = new Nn("DocumentLink");
  }
  async provideLinks(e, i) {
    const n = this._documents.getDocument(e), r = await this._provider.provideDocumentLinks(n, i);
    if (!(!Array.isArray(r) || r.length === 0) && !i.isCancellationRequested) {
      if (typeof this._provider.resolveDocumentLink != "function")
        return { links: r.filter(vo._validateLink).map(La.from) };
      {
        const s = this._cache.add(r), o = { links: [], cacheId: s };
        for (let a = 0; a < r.length; a++) {
          if (!vo._validateLink(r[a]))
            continue;
          const l = La.from(r[a]);
          l.cacheId = [s, a], o.links.push(l);
        }
        return o;
      }
    }
  }
  static _validateLink(e) {
    return e.target && e.target.path.length > 5e4 ? (console.warn("DROPPING link because it is too long"), !1) : !0;
  }
  async resolveLink(e, i) {
    if (typeof this._provider.resolveDocumentLink != "function")
      return;
    const n = this._cache.get(...e);
    if (!n)
      return;
    const r = await this._provider.resolveDocumentLink(n, i);
    if (!(!r || !vo._validateLink(r)))
      return La.from(r);
  }
  releaseLinks(e) {
    this._cache.delete(e);
  }
}
class sv {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideColors(e, i) {
    const n = this._documents.getDocument(e), r = await this._provider.provideDocumentColors(n, i);
    return Array.isArray(r) ? r.map((o) => ({
      color: ou.from(o.color),
      range: z.from(o.range)
    })) : [];
  }
  async provideColorPresentations(e, i, n) {
    const r = this._documents.getDocument(e), s = z.to(i.range), o = ou.to(i.color), a = await this._provider.provideColorPresentations(o, { document: r, range: s }, n);
    if (Array.isArray(a))
      return a.map(wm.from);
  }
}
class _C {
  constructor(e, i) {
    this._documents = e, this._provider = i;
  }
  async provideFoldingRanges(e, i, n) {
    const r = this._documents.getDocument(e), s = await this._provider.provideFoldingRanges(r, i, n);
    if (Array.isArray(s))
      return s.map(xm.from);
  }
}
class vC {
  constructor(e, i, n) {
    this._documents = e, this._provider = i, this._logService = n;
  }
  async provideSelectionRanges(e, i, n) {
    const r = this._documents.getDocument(e), s = i.map(at.to), o = await this._provider.provideSelectionRanges(r, s, n);
    if (!of(o))
      return [];
    if (o.length !== s.length)
      return this._logService.warn("BAD selection ranges, provider must return ranges for each position"), [];
    const a = [];
    for (let l = 0; l < s.length; l++) {
      const c = [];
      a.push(c);
      let u = s[l], d = o[l];
      for (; ; ) {
        if (!d.range.contains(u))
          throw new Error("INVALID selection range, must contain the previous range");
        if (c.push(Wb.from(d)), !d.parent)
          break;
        u = d.range, d = d.parent;
      }
    }
    return a;
  }
}
class qu {
  constructor(e, i) {
    this._documents = e, this._provider = i, this._idPool = new kE(""), this._cache = /* @__PURE__ */ new Map();
  }
  async prepareSession(e, i, n) {
    const r = this._documents.getDocument(e), s = at.to(i), o = await this._provider.prepareCallHierarchy(r, s, n);
    if (!o)
      return;
    const a = this._idPool.nextId();
    return this._cache.set(a, /* @__PURE__ */ new Map()), Array.isArray(o) ? o.map((l) => this._cacheAndConvertItem(a, l)) : [this._cacheAndConvertItem(a, o)];
  }
  async provideCallsTo(e, i, n) {
    const r = this._itemFromCache(e, i);
    if (!r)
      throw new Error("missing call hierarchy item");
    const s = await this._provider.provideCallHierarchyIncomingCalls(r, n);
    if (s)
      return s.map((o) => ({
        from: this._cacheAndConvertItem(e, o.from),
        fromRanges: o.fromRanges.map((a) => z.from(a))
      }));
  }
  async provideCallsFrom(e, i, n) {
    const r = this._itemFromCache(e, i);
    if (!r)
      throw new Error("missing call hierarchy item");
    const s = await this._provider.provideCallHierarchyOutgoingCalls(r, n);
    if (s)
      return s.map((o) => ({
        to: this._cacheAndConvertItem(e, o.to),
        fromRanges: o.fromRanges.map((a) => z.from(a))
      }));
  }
  releaseSession(e) {
    this._cache.delete(e);
  }
  _cacheAndConvertItem(e, i) {
    const n = this._cache.get(e), r = al.from(i, e, n.size.toString(36));
    return n.set(r._itemId, i), r;
  }
  _itemFromCache(e, i) {
    return this._cache.get(e)?.get(i);
  }
}
class ju {
  constructor(e, i) {
    this._documents = e, this._provider = i, this._idPool = new kE(""), this._cache = /* @__PURE__ */ new Map();
  }
  async prepareSession(e, i, n) {
    const r = this._documents.getDocument(e), s = at.to(i), o = await this._provider.prepareTypeHierarchy(r, s, n);
    if (!o)
      return;
    const a = this._idPool.nextId();
    return this._cache.set(a, /* @__PURE__ */ new Map()), Array.isArray(o) ? o.map((l) => this._cacheAndConvertItem(a, l)) : [this._cacheAndConvertItem(a, o)];
  }
  async provideSupertypes(e, i, n) {
    const r = this._itemFromCache(e, i);
    if (!r)
      throw new Error("missing type hierarchy item");
    const s = await this._provider.provideTypeHierarchySupertypes(r, n);
    if (s)
      return s.map((o) => this._cacheAndConvertItem(e, o));
  }
  async provideSubtypes(e, i, n) {
    const r = this._itemFromCache(e, i);
    if (!r)
      throw new Error("missing type hierarchy item");
    const s = await this._provider.provideTypeHierarchySubtypes(r, n);
    if (s)
      return s.map((o) => this._cacheAndConvertItem(e, o));
  }
  releaseSession(e) {
    this._cache.delete(e);
  }
  _cacheAndConvertItem(e, i) {
    const n = this._cache.get(e), r = Na.from(i, e, n.size.toString(36));
    return n.set(r._itemId, i), r;
  }
  _itemFromCache(e, i) {
    return this._cache.get(e)?.get(i);
  }
}
class qf {
  constructor(e, i, n, r, s) {
    this._proxy = e, this._documents = i, this._provider = n, this._handle = r, this._extension = s, this._cache = new Nn("DocumentDropEdit");
  }
  async provideDocumentOnDropEdits(e, i, n, r, s) {
    const o = this._documents.getDocument(i), a = at.to(n), l = fu.toDataTransfer(r, async (f) => (await this._proxy.$resolveDocumentOnDropFileData(this._handle, e, f)).buffer), c = await this._provider.provideDocumentDropEdits(o, a, l, s);
    if (!c)
      return;
    const u = qn(c), d = this._cache.add(u);
    return u.map((f, g) => ({
      _cacheId: [d, g],
      title: f.title ?? h(
        2626,
        "Drop using '{0}' extension",
        this._extension.displayName || this._extension.name
      ),
      kind: f.kind?.value,
      yieldTo: f.yieldTo?.map((_) => _.value),
      insertText: typeof f.insertText == "string" ? f.insertText : { snippet: f.insertText.value },
      additionalEdit: f.additionalEdit ? yn.from(f.additionalEdit, void 0) : void 0
    }));
  }
  async resolveDropEdit(e, i) {
    const [n, r] = e, s = this._cache.get(n, r);
    if (!s || !this._provider.resolveDocumentDropEdit)
      return {};
    const o = await this._provider.resolveDocumentDropEdit(s, i) ?? s;
    return { additionalEdit: o.additionalEdit ? yn.from(o.additionalEdit, void 0) : void 0 };
  }
  releaseDropEdits(e) {
    this._cache.delete(e);
  }
}
class Gu {
  constructor(e, i) {
    this.adapter = e, this.extension = i;
  }
}
const Yt = class Yt {
  constructor(e, i, n, r, s, o, a, l) {
    this._uriTransformer = i, this._documents = n, this._commands = r, this._diagnostics = s, this._logService = o, this._apiDeprecation = a, this._extensionTelemetry = l, this._adapter = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadLanguageFeatures);
  }
  _transformDocumentSelector(e, i) {
    return iu.from(e, this._uriTransformer, i);
  }
  _createDisposable(e) {
    return new Ve(() => {
      this._adapter.delete(e), this._proxy.$unregister(e);
    });
  }
  _nextHandle() {
    return Yt._handlePool++;
  }
  async _withAdapter(e, i, n, r, s, o = !1) {
    const a = this._adapter.get(e);
    if (!a || !(a.adapter instanceof i))
      return r;
    const l = Date.now();
    o || this._logService.trace(`[${a.extension.identifier.value}] INVOKE provider '${n.toString().replace(/[\r\n]/g, "")}'`);
    const c = n(a.adapter, a.extension);
    return Promise.resolve(c).catch((u) => {
      Yr(u) || (this._logService.error(`[${a.extension.identifier.value}] provider FAILED`), this._logService.error(u), this._extensionTelemetry.onExtensionError(a.extension.identifier, u));
    }).finally(() => {
      o || this._logService.trace(`[${a.extension.identifier.value}] provider DONE after ${Date.now() - l}ms`);
    }), xt.isCancellationToken(s) ? Ix(c, s) : c;
  }
  _addNewAdapter(e, i) {
    const n = this._nextHandle();
    return this._adapter.set(n, new Gu(e, i)), n;
  }
  static _extLabel(e) {
    return e.displayName || e.name;
  }
  static _extId(e) {
    return e.identifier.value;
  }
  registerDocumentSymbolProvider(e, i, n, r) {
    const s = this._addNewAdapter(new l_(this._documents, n), e), o = r && r.label || Yt._extLabel(e);
    return this._proxy.$registerDocumentSymbolProvider(s, this._transformDocumentSelector(i, e), o), this._createDisposable(s);
  }
  $provideDocumentSymbols(e, i, n) {
    return this._withAdapter(e, l_, (r) => r.provideDocumentSymbols(x.revive(i), n), void 0, n);
  }
  registerCodeLensProvider(e, i, n) {
    const r = this._nextHandle(), s = typeof n.onDidChangeCodeLenses == "function" ? this._nextHandle() : void 0;
    this._adapter.set(r, new Gu(new Wf(
      this._documents,
      this._commands.converter,
      n,
      e,
      this._extensionTelemetry,
      this._logService
    ), e)), this._proxy.$registerCodeLensSupport(r, this._transformDocumentSelector(i, e), s);
    let o = this._createDisposable(r);
    if (s !== void 0) {
      const a = n.onDidChangeCodeLenses((l) => this._proxy.$emitCodeLensEvent(s));
      o = Ve.from(o, a);
    }
    return o;
  }
  $provideCodeLenses(e, i, n) {
    return this._withAdapter(e, Wf, (r) => r.provideCodeLenses(x.revive(i), n), void 0, n, i.scheme === "output");
  }
  $resolveCodeLens(e, i, n) {
    return this._withAdapter(e, Wf, (r) => r.resolveCodeLens(i, n), void 0, void 0, !0);
  }
  $releaseCodeLenses(e, i) {
    this._withAdapter(e, Wf, (n) => Promise.resolve(n.releaseCodeLenses(i)), void 0, void 0, !0);
  }
  registerDefinitionProvider(e, i, n) {
    const r = this._addNewAdapter(new rC(this._documents, n), e);
    return this._proxy.$registerDefinitionSupport(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $provideDefinition(e, i, n, r) {
    return this._withAdapter(e, rC, (s) => s.provideDefinition(x.revive(i), n, r), [], r);
  }
  registerDeclarationProvider(e, i, n) {
    const r = this._addNewAdapter(new sC(this._documents, n), e);
    return this._proxy.$registerDeclarationSupport(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $provideDeclaration(e, i, n, r) {
    return this._withAdapter(e, sC, (s) => s.provideDeclaration(x.revive(i), n, r), [], r);
  }
  registerImplementationProvider(e, i, n) {
    const r = this._addNewAdapter(new oC(this._documents, n), e);
    return this._proxy.$registerImplementationSupport(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $provideImplementation(e, i, n, r) {
    return this._withAdapter(e, oC, (s) => s.provideImplementation(x.revive(i), n, r), [], r);
  }
  registerTypeDefinitionProvider(e, i, n) {
    const r = this._addNewAdapter(new aC(this._documents, n), e);
    return this._proxy.$registerTypeDefinitionSupport(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $provideTypeDefinition(e, i, n, r) {
    return this._withAdapter(e, aC, (s) => s.provideTypeDefinition(x.revive(i), n, r), [], r);
  }
  registerHoverProvider(e, i, n, r) {
    const s = this._addNewAdapter(new Cd(this._documents, n), e);
    return this._proxy.$registerHoverProvider(s, this._transformDocumentSelector(i, e)), this._createDisposable(s);
  }
  $provideHover(e, i, n, r, s) {
    return this._withAdapter(e, Cd, (o) => o.provideHover(x.revive(i), n, r, s), void 0, s);
  }
  $releaseHover(e, i) {
    this._withAdapter(e, Cd, (n) => Promise.resolve(n.releaseHover(i)), void 0, void 0);
  }
  registerEvaluatableExpressionProvider(e, i, n, r) {
    const s = this._addNewAdapter(new lC(this._documents, n), e);
    return this._proxy.$registerEvaluatableExpressionProvider(s, this._transformDocumentSelector(i, e)), this._createDisposable(s);
  }
  $provideEvaluatableExpression(e, i, n, r) {
    return this._withAdapter(e, lC, (s) => s.provideEvaluatableExpression(x.revive(i), n, r), void 0, r);
  }
  registerInlineValuesProvider(e, i, n, r) {
    const s = typeof n.onDidChangeInlineValues == "function" ? this._nextHandle() : void 0, o = this._addNewAdapter(new cC(this._documents, n), e);
    this._proxy.$registerInlineValuesProvider(o, this._transformDocumentSelector(i, e), s);
    let a = this._createDisposable(o);
    if (s !== void 0) {
      const l = n.onDidChangeInlineValues((c) => this._proxy.$emitInlineValuesEvent(s));
      a = Ve.from(a, l);
    }
    return a;
  }
  $provideInlineValues(e, i, n, r, s) {
    return this._withAdapter(e, cC, (o) => o.provideInlineValues(x.revive(i), n, r, s), void 0, s);
  }
  registerDocumentHighlightProvider(e, i, n) {
    const r = this._addNewAdapter(new uC(this._documents, n), e);
    return this._proxy.$registerDocumentHighlightProvider(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  registerMultiDocumentHighlightProvider(e, i, n) {
    const r = this._addNewAdapter(new dC(this._documents, n, this._logService), e);
    return this._proxy.$registerMultiDocumentHighlightProvider(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $provideDocumentHighlights(e, i, n, r) {
    return this._withAdapter(e, uC, (s) => s.provideDocumentHighlights(x.revive(i), n, r), void 0, r);
  }
  $provideMultiDocumentHighlights(e, i, n, r, s) {
    return this._withAdapter(e, dC, (o) => o.provideMultiDocumentHighlights(x.revive(i), n, r.map((a) => x.revive(a)), s), void 0, s);
  }
  registerLinkedEditingRangeProvider(e, i, n) {
    const r = this._addNewAdapter(new hC(this._documents, n), e);
    return this._proxy.$registerLinkedEditingRangeProvider(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $provideLinkedEditingRanges(e, i, n, r) {
    return this._withAdapter(e, hC, async (s) => {
      const o = await s.provideLinkedEditingRanges(x.revive(i), n, r);
      if (o)
        return {
          ranges: o.ranges,
          wordPattern: o.wordPattern ? Yt._serializeRegExp(o.wordPattern) : void 0
        };
    }, void 0, r);
  }
  registerReferenceProvider(e, i, n) {
    const r = this._addNewAdapter(new fC(this._documents, n), e);
    return this._proxy.$registerReferenceSupport(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $provideReferences(e, i, n, r, s) {
    return this._withAdapter(e, fC, (o) => o.provideReferences(x.revive(i), n, r, s), void 0, s);
  }
  registerCodeActionProvider(e, i, n, r) {
    const s = new De(), o = this._addNewAdapter(new Jl(
      this._documents,
      this._commands.converter,
      this._diagnostics,
      n,
      this._logService,
      e,
      this._apiDeprecation
    ), e);
    return this._proxy.$registerCodeActionSupport(o, this._transformDocumentSelector(i, e), {
      providedKinds: r?.providedCodeActionKinds?.map((a) => a.value),
      documentation: r?.documentation?.map((a) => ({
        kind: a.kind.value,
        command: this._commands.converter.toInternal(a.command, s)
      }))
    }, Yt._extLabel(e), Yt._extId(e), !!n.resolveCodeAction), s.add(this._createDisposable(o)), s;
  }
  $provideCodeActions(e, i, n, r, s) {
    return this._withAdapter(e, Jl, (o) => o.provideCodeActions(x.revive(i), n, r, s), void 0, s);
  }
  $resolveCodeAction(e, i, n) {
    return this._withAdapter(e, Jl, (r) => r.resolveCodeAction(i, n), {}, void 0);
  }
  $releaseCodeActions(e, i) {
    this._withAdapter(e, Jl, (n) => Promise.resolve(n.releaseCodeActions(i)), void 0, void 0);
  }
  registerDocumentFormattingEditProvider(e, i, n) {
    const r = this._addNewAdapter(new pC(this._documents, n), e);
    return this._proxy.$registerDocumentFormattingSupport(r, this._transformDocumentSelector(i, e), e.identifier, e.displayName || e.name), this._createDisposable(r);
  }
  $provideDocumentFormattingEdits(e, i, n, r) {
    return this._withAdapter(e, pC, (s) => s.provideDocumentFormattingEdits(x.revive(i), n, r), void 0, r);
  }
  registerDocumentRangeFormattingEditProvider(e, i, n) {
    const r = typeof n.provideDocumentRangesFormattingEdits == "function", s = this._addNewAdapter(new iv(this._documents, n), e);
    return this._proxy.$registerRangeFormattingSupport(s, this._transformDocumentSelector(i, e), e.identifier, e.displayName || e.name, r), this._createDisposable(s);
  }
  $provideDocumentRangeFormattingEdits(e, i, n, r, s) {
    return this._withAdapter(e, iv, (o) => o.provideDocumentRangeFormattingEdits(x.revive(i), n, r, s), void 0, s);
  }
  $provideDocumentRangesFormattingEdits(e, i, n, r, s) {
    return this._withAdapter(e, iv, (o) => o.provideDocumentRangesFormattingEdits(x.revive(i), n, r, s), void 0, s);
  }
  registerOnTypeFormattingEditProvider(e, i, n, r) {
    const s = this._addNewAdapter(new gC(this._documents, n), e);
    return this._proxy.$registerOnTypeFormattingSupport(s, this._transformDocumentSelector(i, e), r, e.identifier), this._createDisposable(s);
  }
  $provideOnTypeFormattingEdits(e, i, n, r, s, o) {
    return this._withAdapter(e, gC, (a) => a.provideOnTypeFormattingEdits(x.revive(i), n, r, s, o), void 0, o);
  }
  registerWorkspaceSymbolProvider(e, i) {
    const n = this._addNewAdapter(new Vf(i, this._logService), e);
    return this._proxy.$registerNavigateTypeSupport(n, typeof i.resolveWorkspaceSymbol == "function"), this._createDisposable(n);
  }
  $provideWorkspaceSymbols(e, i, n) {
    return this._withAdapter(e, Vf, (r) => r.provideWorkspaceSymbols(i, n), { symbols: [] }, n);
  }
  $resolveWorkspaceSymbol(e, i, n) {
    return this._withAdapter(e, Vf, (r) => r.resolveWorkspaceSymbol(i, n), void 0, void 0);
  }
  $releaseWorkspaceSymbols(e, i) {
    this._withAdapter(e, Vf, (n) => n.releaseWorkspaceSymbols(i), void 0, void 0);
  }
  registerRenameProvider(e, i, n) {
    const r = this._addNewAdapter(new ya(this._documents, n, this._logService), e);
    return this._proxy.$registerRenameSupport(r, this._transformDocumentSelector(i, e), ya.supportsResolving(n)), this._createDisposable(r);
  }
  $provideRenameEdits(e, i, n, r, s) {
    return this._withAdapter(e, ya, (o) => o.provideRenameEdits(x.revive(i), n, r, s), void 0, s);
  }
  $resolveRenameLocation(e, i, n, r) {
    return this._withAdapter(e, ya, (s) => s.resolveRenameLocation(x.revive(i), n, r), void 0, r);
  }
  registerNewSymbolNamesProvider(e, i, n) {
    const r = this._addNewAdapter(new Td(this._documents, n, this._logService), e);
    return this._proxy.$registerNewSymbolNamesProvider(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $supportsAutomaticNewSymbolNamesTriggerKind(e) {
    return this._withAdapter(e, Td, (i) => i.supportsAutomaticNewSymbolNamesTriggerKind(), !1, void 0);
  }
  $provideNewSymbolNames(e, i, n, r, s) {
    return this._withAdapter(e, Td, (o) => o.provideNewSymbolNames(x.revive(i), n, r, s), void 0, s);
  }
  registerDocumentSemanticTokensProvider(e, i, n, r) {
    const s = this._addNewAdapter(new gn(this._documents, n), e), o = typeof n.onDidChangeSemanticTokens == "function" ? this._nextHandle() : void 0;
    this._proxy.$registerDocumentSemanticTokensProvider(s, this._transformDocumentSelector(i, e), r, o);
    let a = this._createDisposable(s);
    if (o) {
      const l = n.onDidChangeSemanticTokens((c) => this._proxy.$emitDocumentSemanticTokensEvent(o));
      a = Ve.from(a, l);
    }
    return a;
  }
  $provideDocumentSemanticTokens(e, i, n, r) {
    return this._withAdapter(e, gn, (s) => s.provideDocumentSemanticTokens(x.revive(i), n, r), null, r);
  }
  $releaseDocumentSemanticTokens(e, i) {
    this._withAdapter(e, gn, (n) => n.releaseDocumentSemanticColoring(i), void 0, void 0);
  }
  registerDocumentRangeSemanticTokensProvider(e, i, n, r) {
    const s = this._addNewAdapter(new mC(this._documents, n), e);
    return this._proxy.$registerDocumentRangeSemanticTokensProvider(s, this._transformDocumentSelector(i, e), r), this._createDisposable(s);
  }
  $provideDocumentRangeSemanticTokens(e, i, n, r) {
    return this._withAdapter(e, mC, (s) => s.provideDocumentRangeSemanticTokens(x.revive(i), n, r), null, r);
  }
  registerCompletionItemProvider(e, i, n, r) {
    const s = this._addNewAdapter(new Xo(
      this._documents,
      this._commands.converter,
      n,
      this._apiDeprecation,
      e
    ), e);
    return this._proxy.$registerCompletionsProvider(s, this._transformDocumentSelector(i, e), r, Xo.supportsResolving(n), e.identifier), this._createDisposable(s);
  }
  $provideCompletionItems(e, i, n, r, s) {
    return this._withAdapter(e, Xo, (o) => o.provideCompletionItems(x.revive(i), n, r, s), void 0, s);
  }
  $resolveCompletionItem(e, i, n) {
    return this._withAdapter(e, Xo, (r) => r.resolveCompletionItem(i, n), void 0, n);
  }
  $releaseCompletionItems(e, i) {
    this._withAdapter(e, Xo, (n) => n.releaseCompletionItems(i), void 0, void 0);
  }
  registerInlineCompletionsProvider(e, i, n, r) {
    const s = typeof n.onDidChange == "function" && lt(e, "inlineCompletionsAdditions") ? this._nextHandle() : void 0, o = new Wo(e, this._documents, n, this._commands.converter), a = this._addNewAdapter(o, e);
    let l = this._createDisposable(a);
    if (s !== void 0) {
      const c = n.onDidChange((u) => this._proxy.$emitInlineCompletionsChange(s));
      l = Ve.from(l, c);
    }
    return this._proxy.$registerInlineCompletionsSupport(a, this._transformDocumentSelector(i, e), o.supportsHandleEvents, ht.toKey(e.identifier.value), e.version, r?.groupId ? ht.toKey(r.groupId) : void 0, r?.yieldTo?.map((c) => ht.toKey(c)) || [], r?.displayName, r?.debounceDelayMs, s), l;
  }
  $provideInlineCompletions(e, i, n, r, s) {
    return this._withAdapter(e, Wo, (o) => o.provideInlineCompletions(x.revive(i), n, r, s), void 0, void 0);
  }
  $handleInlineCompletionDidShow(e, i, n, r) {
    this._withAdapter(e, Wo, async (s) => {
      s.handleDidShowCompletionItem(i, n, r);
    }, void 0, void 0);
  }
  $handleInlineCompletionPartialAccept(e, i, n, r, s) {
    this._withAdapter(e, Wo, async (o) => {
      o.handlePartialAccept(i, n, r, s);
    }, void 0, void 0);
  }
  $handleInlineCompletionEndOfLifetime(e, i, n, r) {
    this._withAdapter(e, Wo, async (s) => {
      s.handleEndOfLifetime(i, n, r);
    }, void 0, void 0);
  }
  $handleInlineCompletionRejection(e, i, n) {
    this._withAdapter(e, Wo, async (r) => {
      r.handleRejection(i, n);
    }, void 0, void 0);
  }
  $freeInlineCompletionsList(e, i, n) {
    this._withAdapter(e, Wo, async (r) => {
      r.disposeCompletions(i, n);
    }, void 0, void 0);
  }
  registerSignatureHelpProvider(e, i, n, r) {
    const s = Array.isArray(r) ? { triggerCharacters: r, retriggerCharacters: [] } : r, o = this._addNewAdapter(new rv(this._documents, n), e);
    return this._proxy.$registerSignatureHelpProvider(o, this._transformDocumentSelector(i, e), s), this._createDisposable(o);
  }
  $provideSignatureHelp(e, i, n, r, s) {
    return this._withAdapter(e, rv, (o) => o.provideSignatureHelp(x.revive(i), n, r, s), void 0, s);
  }
  $releaseSignatureHelp(e, i) {
    this._withAdapter(e, rv, (n) => n.releaseSignatureHelp(i), void 0, void 0);
  }
  registerInlayHintsProvider(e, i, n) {
    const r = typeof n.onDidChangeInlayHints == "function" ? this._nextHandle() : void 0, s = this._addNewAdapter(new zf(
      this._documents,
      this._commands.converter,
      n,
      this._logService,
      e
    ), e);
    this._proxy.$registerInlayHintsProvider(s, this._transformDocumentSelector(i, e), typeof n.resolveInlayHint == "function", r, Yt._extLabel(e));
    let o = this._createDisposable(s);
    if (r !== void 0) {
      const a = n.onDidChangeInlayHints((l) => this._proxy.$emitInlayHintsEvent(r));
      o = Ve.from(o, a);
    }
    return o;
  }
  $provideInlayHints(e, i, n, r) {
    return this._withAdapter(e, zf, (s) => s.provideInlayHints(x.revive(i), n, r), void 0, r);
  }
  $resolveInlayHint(e, i, n) {
    return this._withAdapter(e, zf, (r) => r.resolveInlayHint(i, n), void 0, n);
  }
  $releaseInlayHints(e, i) {
    this._withAdapter(e, zf, (n) => n.releaseHints(i), void 0, void 0);
  }
  registerDocumentLinkProvider(e, i, n) {
    const r = this._addNewAdapter(new vo(this._documents, n), e);
    return this._proxy.$registerDocumentLinkProvider(r, this._transformDocumentSelector(i, e), typeof n.resolveDocumentLink == "function"), this._createDisposable(r);
  }
  $provideDocumentLinks(e, i, n) {
    return this._withAdapter(e, vo, (r) => r.provideLinks(x.revive(i), n), void 0, n, i.scheme === "output");
  }
  $resolveDocumentLink(e, i, n) {
    return this._withAdapter(e, vo, (r) => r.resolveLink(i, n), void 0, void 0, !0);
  }
  $releaseDocumentLinks(e, i) {
    this._withAdapter(e, vo, (n) => n.releaseLinks(i), void 0, void 0, !0);
  }
  registerColorProvider(e, i, n) {
    const r = this._addNewAdapter(new sv(this._documents, n), e);
    return this._proxy.$registerDocumentColorProvider(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $provideDocumentColors(e, i, n) {
    return this._withAdapter(e, sv, (r) => r.provideColors(x.revive(i), n), [], n);
  }
  $provideColorPresentations(e, i, n, r) {
    return this._withAdapter(e, sv, (s) => s.provideColorPresentations(x.revive(i), n, r), void 0, r);
  }
  registerFoldingRangeProvider(e, i, n) {
    const r = this._nextHandle(), s = typeof n.onDidChangeFoldingRanges == "function" ? this._nextHandle() : void 0;
    this._adapter.set(r, new Gu(new _C(this._documents, n), e)), this._proxy.$registerFoldingRangeProvider(r, this._transformDocumentSelector(i, e), e.identifier, s);
    let o = this._createDisposable(r);
    if (s !== void 0) {
      const a = n.onDidChangeFoldingRanges(() => this._proxy.$emitFoldingRangeEvent(s));
      o = Ve.from(o, a);
    }
    return o;
  }
  $provideFoldingRanges(e, i, n, r) {
    return this._withAdapter(e, _C, (s) => s.provideFoldingRanges(x.revive(i), n, r), void 0, r);
  }
  registerSelectionRangeProvider(e, i, n) {
    const r = this._addNewAdapter(new vC(this._documents, n, this._logService), e);
    return this._proxy.$registerSelectionRangeProvider(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $provideSelectionRanges(e, i, n, r) {
    return this._withAdapter(e, vC, (s) => s.provideSelectionRanges(x.revive(i), n, r), [], r);
  }
  registerCallHierarchyProvider(e, i, n) {
    const r = this._addNewAdapter(new qu(this._documents, n), e);
    return this._proxy.$registerCallHierarchyProvider(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $prepareCallHierarchy(e, i, n, r) {
    return this._withAdapter(e, qu, (s) => Promise.resolve(s.prepareSession(x.revive(i), n, r)), void 0, r);
  }
  $provideCallHierarchyIncomingCalls(e, i, n, r) {
    return this._withAdapter(e, qu, (s) => s.provideCallsTo(i, n, r), void 0, r);
  }
  $provideCallHierarchyOutgoingCalls(e, i, n, r) {
    return this._withAdapter(e, qu, (s) => s.provideCallsFrom(i, n, r), void 0, r);
  }
  $releaseCallHierarchy(e, i) {
    this._withAdapter(e, qu, (n) => Promise.resolve(n.releaseSession(i)), void 0, void 0);
  }
  registerTypeHierarchyProvider(e, i, n) {
    const r = this._addNewAdapter(new ju(this._documents, n), e);
    return this._proxy.$registerTypeHierarchyProvider(r, this._transformDocumentSelector(i, e)), this._createDisposable(r);
  }
  $prepareTypeHierarchy(e, i, n, r) {
    return this._withAdapter(e, ju, (s) => Promise.resolve(s.prepareSession(x.revive(i), n, r)), void 0, r);
  }
  $provideTypeHierarchySupertypes(e, i, n, r) {
    return this._withAdapter(e, ju, (s) => s.provideSupertypes(i, n, r), void 0, r);
  }
  $provideTypeHierarchySubtypes(e, i, n, r) {
    return this._withAdapter(e, ju, (s) => s.provideSubtypes(i, n, r), void 0, r);
  }
  $releaseTypeHierarchy(e, i) {
    this._withAdapter(e, ju, (n) => Promise.resolve(n.releaseSession(i)), void 0, void 0);
  }
  registerDocumentOnDropEditProvider(e, i, n, r) {
    const s = this._nextHandle();
    return this._adapter.set(s, new Gu(new qf(this._proxy, this._documents, n, s, e), e)), this._proxy.$registerDocumentOnDropEditProvider(s, this._transformDocumentSelector(i, e), r ? {
      supportsResolve: !!n.resolveDocumentDropEdit,
      dropMimeTypes: r.dropMimeTypes,
      providedDropKinds: r.providedDropEditKinds?.map((o) => o.value)
    } : void 0), this._createDisposable(s);
  }
  $provideDocumentOnDropEdits(e, i, n, r, s, o) {
    return this._withAdapter(e, qf, (a) => Promise.resolve(a.provideDocumentOnDropEdits(i, x.revive(n), r, s, o)), void 0, void 0);
  }
  $resolveDropEdit(e, i, n) {
    return this._withAdapter(e, qf, (r) => r.resolveDropEdit(i, n), {}, void 0);
  }
  $releaseDocumentOnDropEdits(e, i) {
    this._withAdapter(e, qf, (n) => Promise.resolve(n.releaseDropEdits(i)), void 0, void 0);
  }
  registerDocumentPasteEditProvider(e, i, n, r) {
    const s = this._nextHandle();
    return this._adapter.set(s, new Gu(new zu(this._proxy, this._documents, n, s, e), e)), this._proxy.$registerPasteEditProvider(s, this._transformDocumentSelector(i, e), {
      supportsCopy: !!n.prepareDocumentPaste,
      supportsPaste: !!n.provideDocumentPasteEdits,
      supportsResolve: !!n.resolveDocumentPasteEdit,
      providedPasteEditKinds: r.providedPasteEditKinds?.map((o) => o.value),
      copyMimeTypes: r.copyMimeTypes,
      pasteMimeTypes: r.pasteMimeTypes
    }), this._createDisposable(s);
  }
  $prepareDocumentPaste(e, i, n, r, s) {
    return this._withAdapter(e, zu, (o) => o.prepareDocumentPaste(x.revive(i), n, r, s), void 0, s);
  }
  $providePasteEdits(e, i, n, r, s, o, a) {
    return this._withAdapter(e, zu, (l) => l.providePasteEdits(i, x.revive(n), r, s, o, a), void 0, a);
  }
  $resolvePasteEdit(e, i, n) {
    return this._withAdapter(e, zu, (r) => r.resolvePasteEdit(i, n), {}, void 0);
  }
  $releasePasteEdits(e, i) {
    this._withAdapter(e, zu, (n) => Promise.resolve(n.releasePasteEdits(i)), void 0, void 0);
  }
  static _serializeRegExp(e) {
    return {
      pattern: e.source,
      flags: e.flags
    };
  }
  static _serializeIndentationRule(e) {
    return {
      decreaseIndentPattern: Yt._serializeRegExp(e.decreaseIndentPattern),
      increaseIndentPattern: Yt._serializeRegExp(e.increaseIndentPattern),
      indentNextLinePattern: e.indentNextLinePattern ? Yt._serializeRegExp(e.indentNextLinePattern) : void 0,
      unIndentedLinePattern: e.unIndentedLinePattern ? Yt._serializeRegExp(e.unIndentedLinePattern) : void 0
    };
  }
  static _serializeOnEnterRule(e) {
    return {
      beforeText: Yt._serializeRegExp(e.beforeText),
      afterText: e.afterText ? Yt._serializeRegExp(e.afterText) : void 0,
      previousLineText: e.previousLineText ? Yt._serializeRegExp(e.previousLineText) : void 0,
      action: e.action
    };
  }
  static _serializeOnEnterRules(e) {
    return e.map(Yt._serializeOnEnterRule);
  }
  static _serializeAutoClosingPair(e) {
    return {
      open: e.open,
      close: e.close,
      notIn: e.notIn ? e.notIn.map((i) => Kc.toString(i)) : void 0
    };
  }
  static _serializeAutoClosingPairs(e) {
    return e.map(Yt._serializeAutoClosingPair);
  }
  setLanguageConfiguration(e, i, n) {
    const { wordPattern: r } = n;
    if (r && I4(r))
      throw new Error(
        `Invalid language configuration: wordPattern '${r}' is not allowed to match the empty string.`
      );
    r ? this._documents.setWordDefinitionFor(i, r) : this._documents.setWordDefinitionFor(i, void 0), n.__electricCharacterSupport && this._apiDeprecation.report("LanguageConfiguration.__electricCharacterSupport", e, "Do not use."), n.__characterPairSupport && this._apiDeprecation.report("LanguageConfiguration.__characterPairSupport", e, "Do not use.");
    const s = this._nextHandle(), o = {
      comments: n.comments,
      brackets: n.brackets,
      wordPattern: n.wordPattern ? Yt._serializeRegExp(n.wordPattern) : void 0,
      indentationRules: n.indentationRules ? Yt._serializeIndentationRule(n.indentationRules) : void 0,
      onEnterRules: n.onEnterRules ? Yt._serializeOnEnterRules(n.onEnterRules) : void 0,
      __electricCharacterSupport: n.__electricCharacterSupport,
      __characterPairSupport: n.__characterPairSupport,
      autoClosingPairs: n.autoClosingPairs ? Yt._serializeAutoClosingPairs(n.autoClosingPairs) : void 0
    };
    return this._proxy.$setLanguageConfiguration(s, i, o), this._createDisposable(s);
  }
  $setWordDefinitions(e) {
    for (const i of e)
      this._documents.setWordDefinitionFor(i.languageId, new RegExp(i.regexSource, i.regexFlags));
  }
};
Yt._handlePool = 0;
let N0 = Yt;
var nf;
(function(t) {
  t.Internal = { type: "internal", label: "Built-In" };
  function e(r) {
    switch (r.type) {
      case "extension":
        return `extension:${r.extensionId.value}`;
      case "mcp":
        return `mcp:${r.collectionId}:${r.definitionId}`;
      case "user":
        return `user:${r.file.toString()}`;
      case "internal":
        return "internal";
    }
  }
  t.toKey = e;
  function i(r, s) {
    return e(r) === e(s);
  }
  t.equals = i;
  function n(r) {
    return r.type === "internal" ? { ordinal: 1, label: h(5425, "Built-In") } : r.type === "mcp" ? { ordinal: 2, label: h(5426, "MCP Server: {0}", r.label) } : r.type === "user" ? { ordinal: 0, label: h(5427, "User Defined") } : { ordinal: 3, label: h(5428, "Extension: {0}", r.label) };
  }
  t.classify = n;
})(nf || (nf = {}));
function oU(t) {
  return typeof t == "object" && typeof t.sessionId == "string";
}
const aU = pe("notebookService"), lU = pe("codeMapperService"), cU = pe("IChatService"), wC = "vscode_editFile", M0 = "vscode_editFile_internal", bC = {
  id: M0,
  displayName: "",
  modelDescription: "",
  source: nf.Internal
};
let O0 = class {
  constructor(e, i, n) {
    this.chatService = e, this.codeMapperService = i, this.notebookService = n;
  }
  async invoke(e, i, n, r) {
    if (!e.context)
      throw new Error("toolInvocationToken is required for this tool");
    const s = e.parameters, o = x.revive(s.uri), a = aw.parse(o)?.notebook || o, l = this.chatService.getSession(e.context?.sessionId), c = l.getRequests().at(-1);
    l.acceptResponseProgress(c, {
      kind: "markdownContent",
      content: new Gd("\n````\n")
    }), l.acceptResponseProgress(c, {
      kind: "codeblockUri",
      uri: a,
      isEdit: !0
    }), l.acceptResponseProgress(c, {
      kind: "markdownContent",
      content: new Gd("\n````\n")
    }), this.notebookService.hasSupportedNotebooks(a) && this.notebookService.getNotebookTextModel(a) ? l.acceptResponseProgress(c, {
      kind: "notebookEdit",
      edits: [],
      uri: a
    }) : l.acceptResponseProgress(c, {
      kind: "textEdit",
      edits: [],
      uri: a
    });
    const u = l.editingSession;
    if (!u)
      throw new Error("This tool must be called from within an editing session");
    const d = await this.codeMapperService.mapCode({
      codeBlocks: [{ code: s.code, resource: a, markdownBeforeBlock: s.explanation }],
      location: "tool",
      chatRequestId: e.chatRequestId,
      chatRequestModel: e.modelId,
      chatSessionId: e.context.sessionId
    }, {
      textEdit: (g, _) => {
        l.acceptResponseProgress(c, { kind: "textEdit", uri: g, edits: _ });
      },
      notebookEdit(g, _) {
        l.acceptResponseProgress(c, { kind: "notebookEdit", uri: g, edits: _ });
      }
    }, r);
    if (this.notebookService.hasSupportedNotebooks(a) && this.notebookService.getNotebookTextModel(a) ? l.acceptResponseProgress(c, { kind: "notebookEdit", uri: a, edits: [], done: !0 }) : l.acceptResponseProgress(c, { kind: "textEdit", uri: a, edits: [], done: !0 }), d?.errorMessage)
      throw new Error(d.errorMessage);
    let f;
    return await new Promise((g) => {
      let _ = !1;
      f = CP((w) => {
        const S = u.entries.read(w)?.find((E) => E.modifiedURI.toString() === a.toString());
        S && (S.isCurrentlyBeingModifiedBy.read(w) ? _ = !0 : _ && g(!0));
      });
    }).finally(() => {
      f.dispose();
    }), {
      content: [{ kind: "text", value: "The file was edited successfully" }]
    };
  }
  async prepareToolInvocation(e, i) {
    return {
      presentation: "hidden"
    };
  }
};
O0 = W([
  M(0, cU),
  M(1, lU),
  M(2, aU)
], O0);
const uU = pe("ILanguageModelToolsService"), dU = pe("chatTodoListService"), hU = "chat.todoListTool.enabled", fU = "manage_todo_list", yC = {
  id: fU,
  toolReferenceName: "todos",
  when: Gt.equals(`config.${hU}`, !0),
  canBeReferencedInPrompt: !0,
  icon: oi.fromId(ge.checklist.id),
  displayName: "Update Todo List",
  userDescription: "Manage and track todo items for task planning",
  modelDescription: `Manage a structured todo list to track progress and plan tasks throughout your coding session. Use this tool VERY frequently to ensure task visibility and proper planning.

When to use this tool:
- Complex multi-step work requiring planning and tracking
- When user provides multiple tasks or requests (numbered/comma-separated)
- After receiving new instructions that require multiple steps
- BEFORE starting work on any todo (mark as in-progress)
- IMMEDIATELY after completing each todo (mark completed individually)
- When breaking down larger tasks into smaller actionable steps
- To give users visibility into your progress and planning

When NOT to use:
- Single, trivial tasks that can be completed in one step
- Purely conversational/informational requests
- When just reading files or performing simple searches

CRITICAL workflow:
1. Plan tasks by writing todo list with specific, actionable items
2. Mark ONE todo as in-progress before starting work
3. Complete the work for that specific todo
4. Mark that todo as completed IMMEDIATELY
5. Move to next todo and repeat

Todo states:
- not-started: Todo not yet begun
- in-progress: Currently working (limit ONE at a time)
- completed: Finished successfully

IMPORTANT: Mark todos completed as soon as they are done. Do not batch completions.`,
  source: nf.Internal,
  inputSchema: {
    type: "object",
    properties: {
      operation: {
        type: "string",
        enum: ["write", "read"],
        description: "write: Replace entire todo list with new content. read: Retrieve current todo list. ALWAYS provide complete list when writing - partial updates not supported."
      },
      todoList: {
        type: "array",
        description: "Complete array of all todo items (required for write operation, ignored for read). Must include ALL items - both existing and new.",
        items: {
          type: "object",
          properties: {
            id: {
              type: "number",
              description: "Unique identifier for the todo. Use sequential numbers starting from 1."
            },
            title: {
              type: "string",
              description: "Concise action-oriented todo label (3-7 words). Displayed in UI."
            },
            description: {
              type: "string",
              description: "Detailed context, requirements, or implementation notes. Include file paths, specific methods, or acceptance criteria."
            },
            status: {
              type: "string",
              enum: ["not-started", "in-progress", "completed"],
              description: "not-started: Not begun | in-progress: Currently working (max 1) | completed: Fully finished with no blockers"
            }
          },
          required: ["id", "title", "description", "status"]
        }
      }
    },
    required: ["operation"]
  }
};
let F0 = class extends ve {
  constructor(e, i) {
    super(), this.chatTodoListService = e, this.logService = i;
  }
  async invoke(e, i, n, r) {
    const s = e.context?.sessionId;
    if (s === void 0)
      throw new Error("A chat session ID is required for this tool");
    const o = e.parameters;
    this.logService.debug(`ManageTodoListTool: Invoking with options ${JSON.stringify(o)}`);
    try {
      const a = this.chatTodoListService.getChatTodoListStorage();
      switch (o.operation) {
        case "read":
          return {
            content: [{
              kind: "text",
              value: this.handleRead(a, s)
            }]
          };
        case "write": {
          const l = o.todoList.map((c) => ({
            id: c.id,
            title: c.title,
            description: c.description,
            status: c.status
          }));
          return a.setTodoList(s, l), {
            content: [{
              kind: "text",
              value: "Successfully wrote todo list"
            }]
          };
        }
        default:
          return {
            content: [{
              kind: "text",
              value: "Error: Unknown operation"
            }]
          };
      }
    } catch (a) {
      return {
        content: [{
          kind: "text",
          value: `Error: ${a instanceof Error ? a.message : "Unknown error"}`
        }]
      };
    }
  }
  async prepareToolInvocation(e, i) {
    if (!e.chatSessionId)
      throw new Error("chatSessionId undefined");
    const r = this.chatTodoListService.getChatTodoListStorage().getTodoList(e.chatSessionId), s = e.parameters;
    let o;
    switch (s.operation) {
      case "write": {
        s.todoList && (o = this.generatePastTenseMessage(r, s.todoList));
        break;
      }
      case "read": {
        o = "Read todo list";
        break;
      }
    }
    const l = (s.todoList ?? r).map((c) => ({
      id: c.id.toString(),
      title: c.title,
      description: c.description,
      status: c.status
    }));
    return {
      pastTenseMessage: new Gd(o ?? "Updated todo list"),
      toolSpecificData: {
        kind: "todoList",
        sessionId: e.chatSessionId,
        todoList: l
      }
    };
  }
  generatePastTenseMessage(e, i) {
    if (e.length === 0)
      return `Created ${i.length} todo${i.length === 1 ? "" : "s"}`;
    const n = new Map(e.map((a) => [a.id, a])), r = i.filter((a) => {
      const l = n.get(a.id);
      return l && l.status !== "in-progress" && a.status === "in-progress";
    });
    if (r.length > 0) {
      const a = r[0], l = i.length;
      return `Starting (${i.findIndex((u) => u.id === a.id) + 1}/${l}) *${a.title}*`;
    }
    const s = i.filter((a) => {
      const l = n.get(a.id);
      return l && l.status !== "completed" && a.status === "completed";
    });
    if (s.length > 0) {
      const a = s[0], l = i.length;
      return `Completed (${i.findIndex((u) => u.id === a.id) + 1}/${l}) *${a.title}*`;
    }
    const o = i.filter((a) => !n.has(a.id));
    return o.length > 0 ? `Added ${o.length} todo${o.length === 1 ? "" : "s"}` : "Updated todo list";
  }
  handleRead(e, i) {
    const n = e.getTodoList(i);
    return n.length === 0 ? "No todo list found." : `# Task List

${this.formatTodoListAsMarkdownTaskList(n)}`;
  }
  formatTodoListAsMarkdownTaskList(e) {
    return e.length === 0 ? "" : e.map((i) => {
      let n;
      switch (i.status) {
        case "completed":
          n = "[x]";
          break;
        case "in-progress":
          n = "[-]";
          break;
        case "not-started":
        default:
          n = "[ ]";
          break;
      }
      const r = [`- ${n} ${i.title}`];
      return i.description && i.description.trim() && r.push(`  - ${i.description.trim()}`), r.join(`
`);
    }).join(`
`);
  }
};
F0 = W([
  M(0, dU),
  M(1, nt)
], F0);
var Pc;
let xC = (Pc = class extends ve {
  constructor(e, i) {
    super();
    const n = i.createInstance(O0);
    this._register(e.registerToolData(bC)), this._register(e.registerToolImplementation(bC.id, n));
    const r = i.createInstance(F0);
    this._register(e.registerToolData(yC)), this._register(e.registerToolImplementation(yC.id, r));
  }
}, Pc.ID = "chat.builtinTools", Pc);
xC = W([
  M(0, uU),
  M(1, uf)
], xC);
const pU = "vscode_fetchWebPage_internal", M5 = pe("commandService"), CE = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._onDidRegisterCommand = new N(), this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(t, e) {
    if (!t)
      throw new Error("invalid command");
    if (typeof t == "string") {
      if (!e)
        throw new Error("invalid command");
      return this.registerCommand({ id: t, handler: e });
    }
    if (t.metadata && Array.isArray(t.metadata.args)) {
      const o = [];
      for (const l of t.metadata.args)
        o.push(l.constraint);
      const a = t.handler;
      t.handler = function(l, ...c) {
        return oA(c, o), a(l, ...c);
      };
    }
    const { id: i } = t;
    let n = this._commands.get(i);
    n || (n = new Ro(), this._commands.set(i, n));
    const r = n.unshift(t), s = Ee(() => {
      r(), this._commands.get(i)?.isEmpty() && this._commands.delete(i);
    });
    return this._onDidRegisterCommand.fire(i), s;
  }
  registerCommandAlias(t, e) {
    return CE.registerCommand(t, (i, ...n) => i.get(M5).executeCommand(e, ...n));
  }
  getCommand(t) {
    const e = this._commands.get(t);
    if (!(!e || e.isEmpty()))
      return Oi.first(e);
  }
  getCommands() {
    const t = /* @__PURE__ */ new Map();
    for (const e of this._commands.keys()) {
      const i = this.getCommand(e);
      i && t.set(e, i);
    }
    return t;
  }
}();
CE.registerCommand("noop", () => {
});
var k;
(function(t) {
  t[t.DependsOnKbLayout = -1] = "DependsOnKbLayout", t[t.Unknown = 0] = "Unknown", t[t.Backspace = 1] = "Backspace", t[t.Tab = 2] = "Tab", t[t.Enter = 3] = "Enter", t[t.Shift = 4] = "Shift", t[t.Ctrl = 5] = "Ctrl", t[t.Alt = 6] = "Alt", t[t.PauseBreak = 7] = "PauseBreak", t[t.CapsLock = 8] = "CapsLock", t[t.Escape = 9] = "Escape", t[t.Space = 10] = "Space", t[t.PageUp = 11] = "PageUp", t[t.PageDown = 12] = "PageDown", t[t.End = 13] = "End", t[t.Home = 14] = "Home", t[t.LeftArrow = 15] = "LeftArrow", t[t.UpArrow = 16] = "UpArrow", t[t.RightArrow = 17] = "RightArrow", t[t.DownArrow = 18] = "DownArrow", t[t.Insert = 19] = "Insert", t[t.Delete = 20] = "Delete", t[t.Digit0 = 21] = "Digit0", t[t.Digit1 = 22] = "Digit1", t[t.Digit2 = 23] = "Digit2", t[t.Digit3 = 24] = "Digit3", t[t.Digit4 = 25] = "Digit4", t[t.Digit5 = 26] = "Digit5", t[t.Digit6 = 27] = "Digit6", t[t.Digit7 = 28] = "Digit7", t[t.Digit8 = 29] = "Digit8", t[t.Digit9 = 30] = "Digit9", t[t.KeyA = 31] = "KeyA", t[t.KeyB = 32] = "KeyB", t[t.KeyC = 33] = "KeyC", t[t.KeyD = 34] = "KeyD", t[t.KeyE = 35] = "KeyE", t[t.KeyF = 36] = "KeyF", t[t.KeyG = 37] = "KeyG", t[t.KeyH = 38] = "KeyH", t[t.KeyI = 39] = "KeyI", t[t.KeyJ = 40] = "KeyJ", t[t.KeyK = 41] = "KeyK", t[t.KeyL = 42] = "KeyL", t[t.KeyM = 43] = "KeyM", t[t.KeyN = 44] = "KeyN", t[t.KeyO = 45] = "KeyO", t[t.KeyP = 46] = "KeyP", t[t.KeyQ = 47] = "KeyQ", t[t.KeyR = 48] = "KeyR", t[t.KeyS = 49] = "KeyS", t[t.KeyT = 50] = "KeyT", t[t.KeyU = 51] = "KeyU", t[t.KeyV = 52] = "KeyV", t[t.KeyW = 53] = "KeyW", t[t.KeyX = 54] = "KeyX", t[t.KeyY = 55] = "KeyY", t[t.KeyZ = 56] = "KeyZ", t[t.Meta = 57] = "Meta", t[t.ContextMenu = 58] = "ContextMenu", t[t.F1 = 59] = "F1", t[t.F2 = 60] = "F2", t[t.F3 = 61] = "F3", t[t.F4 = 62] = "F4", t[t.F5 = 63] = "F5", t[t.F6 = 64] = "F6", t[t.F7 = 65] = "F7", t[t.F8 = 66] = "F8", t[t.F9 = 67] = "F9", t[t.F10 = 68] = "F10", t[t.F11 = 69] = "F11", t[t.F12 = 70] = "F12", t[t.F13 = 71] = "F13", t[t.F14 = 72] = "F14", t[t.F15 = 73] = "F15", t[t.F16 = 74] = "F16", t[t.F17 = 75] = "F17", t[t.F18 = 76] = "F18", t[t.F19 = 77] = "F19", t[t.F20 = 78] = "F20", t[t.F21 = 79] = "F21", t[t.F22 = 80] = "F22", t[t.F23 = 81] = "F23", t[t.F24 = 82] = "F24", t[t.NumLock = 83] = "NumLock", t[t.ScrollLock = 84] = "ScrollLock", t[t.Semicolon = 85] = "Semicolon", t[t.Equal = 86] = "Equal", t[t.Comma = 87] = "Comma", t[t.Minus = 88] = "Minus", t[t.Period = 89] = "Period", t[t.Slash = 90] = "Slash", t[t.Backquote = 91] = "Backquote", t[t.BracketLeft = 92] = "BracketLeft", t[t.Backslash = 93] = "Backslash", t[t.BracketRight = 94] = "BracketRight", t[t.Quote = 95] = "Quote", t[t.OEM_8 = 96] = "OEM_8", t[t.IntlBackslash = 97] = "IntlBackslash", t[t.Numpad0 = 98] = "Numpad0", t[t.Numpad1 = 99] = "Numpad1", t[t.Numpad2 = 100] = "Numpad2", t[t.Numpad3 = 101] = "Numpad3", t[t.Numpad4 = 102] = "Numpad4", t[t.Numpad5 = 103] = "Numpad5", t[t.Numpad6 = 104] = "Numpad6", t[t.Numpad7 = 105] = "Numpad7", t[t.Numpad8 = 106] = "Numpad8", t[t.Numpad9 = 107] = "Numpad9", t[t.NumpadMultiply = 108] = "NumpadMultiply", t[t.NumpadAdd = 109] = "NumpadAdd", t[t.NUMPAD_SEPARATOR = 110] = "NUMPAD_SEPARATOR", t[t.NumpadSubtract = 111] = "NumpadSubtract", t[t.NumpadDecimal = 112] = "NumpadDecimal", t[t.NumpadDivide = 113] = "NumpadDivide", t[t.KEY_IN_COMPOSITION = 114] = "KEY_IN_COMPOSITION", t[t.ABNT_C1 = 115] = "ABNT_C1", t[t.ABNT_C2 = 116] = "ABNT_C2", t[t.AudioVolumeMute = 117] = "AudioVolumeMute", t[t.AudioVolumeUp = 118] = "AudioVolumeUp", t[t.AudioVolumeDown = 119] = "AudioVolumeDown", t[t.BrowserSearch = 120] = "BrowserSearch", t[t.BrowserHome = 121] = "BrowserHome", t[t.BrowserBack = 122] = "BrowserBack", t[t.BrowserForward = 123] = "BrowserForward", t[t.MediaTrackNext = 124] = "MediaTrackNext", t[t.MediaTrackPrevious = 125] = "MediaTrackPrevious", t[t.MediaStop = 126] = "MediaStop", t[t.MediaPlayPause = 127] = "MediaPlayPause", t[t.LaunchMediaPlayer = 128] = "LaunchMediaPlayer", t[t.LaunchMail = 129] = "LaunchMail", t[t.LaunchApp2 = 130] = "LaunchApp2", t[t.Clear = 131] = "Clear", t[t.MAX_VALUE = 132] = "MAX_VALUE";
})(k || (k = {}));
var P;
(function(t) {
  t[t.DependsOnKbLayout = -1] = "DependsOnKbLayout", t[t.None = 0] = "None", t[t.Hyper = 1] = "Hyper", t[t.Super = 2] = "Super", t[t.Fn = 3] = "Fn", t[t.FnLock = 4] = "FnLock", t[t.Suspend = 5] = "Suspend", t[t.Resume = 6] = "Resume", t[t.Turbo = 7] = "Turbo", t[t.Sleep = 8] = "Sleep", t[t.WakeUp = 9] = "WakeUp", t[t.KeyA = 10] = "KeyA", t[t.KeyB = 11] = "KeyB", t[t.KeyC = 12] = "KeyC", t[t.KeyD = 13] = "KeyD", t[t.KeyE = 14] = "KeyE", t[t.KeyF = 15] = "KeyF", t[t.KeyG = 16] = "KeyG", t[t.KeyH = 17] = "KeyH", t[t.KeyI = 18] = "KeyI", t[t.KeyJ = 19] = "KeyJ", t[t.KeyK = 20] = "KeyK", t[t.KeyL = 21] = "KeyL", t[t.KeyM = 22] = "KeyM", t[t.KeyN = 23] = "KeyN", t[t.KeyO = 24] = "KeyO", t[t.KeyP = 25] = "KeyP", t[t.KeyQ = 26] = "KeyQ", t[t.KeyR = 27] = "KeyR", t[t.KeyS = 28] = "KeyS", t[t.KeyT = 29] = "KeyT", t[t.KeyU = 30] = "KeyU", t[t.KeyV = 31] = "KeyV", t[t.KeyW = 32] = "KeyW", t[t.KeyX = 33] = "KeyX", t[t.KeyY = 34] = "KeyY", t[t.KeyZ = 35] = "KeyZ", t[t.Digit1 = 36] = "Digit1", t[t.Digit2 = 37] = "Digit2", t[t.Digit3 = 38] = "Digit3", t[t.Digit4 = 39] = "Digit4", t[t.Digit5 = 40] = "Digit5", t[t.Digit6 = 41] = "Digit6", t[t.Digit7 = 42] = "Digit7", t[t.Digit8 = 43] = "Digit8", t[t.Digit9 = 44] = "Digit9", t[t.Digit0 = 45] = "Digit0", t[t.Enter = 46] = "Enter", t[t.Escape = 47] = "Escape", t[t.Backspace = 48] = "Backspace", t[t.Tab = 49] = "Tab", t[t.Space = 50] = "Space", t[t.Minus = 51] = "Minus", t[t.Equal = 52] = "Equal", t[t.BracketLeft = 53] = "BracketLeft", t[t.BracketRight = 54] = "BracketRight", t[t.Backslash = 55] = "Backslash", t[t.IntlHash = 56] = "IntlHash", t[t.Semicolon = 57] = "Semicolon", t[t.Quote = 58] = "Quote", t[t.Backquote = 59] = "Backquote", t[t.Comma = 60] = "Comma", t[t.Period = 61] = "Period", t[t.Slash = 62] = "Slash", t[t.CapsLock = 63] = "CapsLock", t[t.F1 = 64] = "F1", t[t.F2 = 65] = "F2", t[t.F3 = 66] = "F3", t[t.F4 = 67] = "F4", t[t.F5 = 68] = "F5", t[t.F6 = 69] = "F6", t[t.F7 = 70] = "F7", t[t.F8 = 71] = "F8", t[t.F9 = 72] = "F9", t[t.F10 = 73] = "F10", t[t.F11 = 74] = "F11", t[t.F12 = 75] = "F12", t[t.PrintScreen = 76] = "PrintScreen", t[t.ScrollLock = 77] = "ScrollLock", t[t.Pause = 78] = "Pause", t[t.Insert = 79] = "Insert", t[t.Home = 80] = "Home", t[t.PageUp = 81] = "PageUp", t[t.Delete = 82] = "Delete", t[t.End = 83] = "End", t[t.PageDown = 84] = "PageDown", t[t.ArrowRight = 85] = "ArrowRight", t[t.ArrowLeft = 86] = "ArrowLeft", t[t.ArrowDown = 87] = "ArrowDown", t[t.ArrowUp = 88] = "ArrowUp", t[t.NumLock = 89] = "NumLock", t[t.NumpadDivide = 90] = "NumpadDivide", t[t.NumpadMultiply = 91] = "NumpadMultiply", t[t.NumpadSubtract = 92] = "NumpadSubtract", t[t.NumpadAdd = 93] = "NumpadAdd", t[t.NumpadEnter = 94] = "NumpadEnter", t[t.Numpad1 = 95] = "Numpad1", t[t.Numpad2 = 96] = "Numpad2", t[t.Numpad3 = 97] = "Numpad3", t[t.Numpad4 = 98] = "Numpad4", t[t.Numpad5 = 99] = "Numpad5", t[t.Numpad6 = 100] = "Numpad6", t[t.Numpad7 = 101] = "Numpad7", t[t.Numpad8 = 102] = "Numpad8", t[t.Numpad9 = 103] = "Numpad9", t[t.Numpad0 = 104] = "Numpad0", t[t.NumpadDecimal = 105] = "NumpadDecimal", t[t.IntlBackslash = 106] = "IntlBackslash", t[t.ContextMenu = 107] = "ContextMenu", t[t.Power = 108] = "Power", t[t.NumpadEqual = 109] = "NumpadEqual", t[t.F13 = 110] = "F13", t[t.F14 = 111] = "F14", t[t.F15 = 112] = "F15", t[t.F16 = 113] = "F16", t[t.F17 = 114] = "F17", t[t.F18 = 115] = "F18", t[t.F19 = 116] = "F19", t[t.F20 = 117] = "F20", t[t.F21 = 118] = "F21", t[t.F22 = 119] = "F22", t[t.F23 = 120] = "F23", t[t.F24 = 121] = "F24", t[t.Open = 122] = "Open", t[t.Help = 123] = "Help", t[t.Select = 124] = "Select", t[t.Again = 125] = "Again", t[t.Undo = 126] = "Undo", t[t.Cut = 127] = "Cut", t[t.Copy = 128] = "Copy", t[t.Paste = 129] = "Paste", t[t.Find = 130] = "Find", t[t.AudioVolumeMute = 131] = "AudioVolumeMute", t[t.AudioVolumeUp = 132] = "AudioVolumeUp", t[t.AudioVolumeDown = 133] = "AudioVolumeDown", t[t.NumpadComma = 134] = "NumpadComma", t[t.IntlRo = 135] = "IntlRo", t[t.KanaMode = 136] = "KanaMode", t[t.IntlYen = 137] = "IntlYen", t[t.Convert = 138] = "Convert", t[t.NonConvert = 139] = "NonConvert", t[t.Lang1 = 140] = "Lang1", t[t.Lang2 = 141] = "Lang2", t[t.Lang3 = 142] = "Lang3", t[t.Lang4 = 143] = "Lang4", t[t.Lang5 = 144] = "Lang5", t[t.Abort = 145] = "Abort", t[t.Props = 146] = "Props", t[t.NumpadParenLeft = 147] = "NumpadParenLeft", t[t.NumpadParenRight = 148] = "NumpadParenRight", t[t.NumpadBackspace = 149] = "NumpadBackspace", t[t.NumpadMemoryStore = 150] = "NumpadMemoryStore", t[t.NumpadMemoryRecall = 151] = "NumpadMemoryRecall", t[t.NumpadMemoryClear = 152] = "NumpadMemoryClear", t[t.NumpadMemoryAdd = 153] = "NumpadMemoryAdd", t[t.NumpadMemorySubtract = 154] = "NumpadMemorySubtract", t[t.NumpadClear = 155] = "NumpadClear", t[t.NumpadClearEntry = 156] = "NumpadClearEntry", t[t.ControlLeft = 157] = "ControlLeft", t[t.ShiftLeft = 158] = "ShiftLeft", t[t.AltLeft = 159] = "AltLeft", t[t.MetaLeft = 160] = "MetaLeft", t[t.ControlRight = 161] = "ControlRight", t[t.ShiftRight = 162] = "ShiftRight", t[t.AltRight = 163] = "AltRight", t[t.MetaRight = 164] = "MetaRight", t[t.BrightnessUp = 165] = "BrightnessUp", t[t.BrightnessDown = 166] = "BrightnessDown", t[t.MediaPlay = 167] = "MediaPlay", t[t.MediaRecord = 168] = "MediaRecord", t[t.MediaFastForward = 169] = "MediaFastForward", t[t.MediaRewind = 170] = "MediaRewind", t[t.MediaTrackNext = 171] = "MediaTrackNext", t[t.MediaTrackPrevious = 172] = "MediaTrackPrevious", t[t.MediaStop = 173] = "MediaStop", t[t.Eject = 174] = "Eject", t[t.MediaPlayPause = 175] = "MediaPlayPause", t[t.MediaSelect = 176] = "MediaSelect", t[t.LaunchMail = 177] = "LaunchMail", t[t.LaunchApp2 = 178] = "LaunchApp2", t[t.LaunchApp1 = 179] = "LaunchApp1", t[t.SelectTask = 180] = "SelectTask", t[t.LaunchScreenSaver = 181] = "LaunchScreenSaver", t[t.BrowserSearch = 182] = "BrowserSearch", t[t.BrowserHome = 183] = "BrowserHome", t[t.BrowserBack = 184] = "BrowserBack", t[t.BrowserForward = 185] = "BrowserForward", t[t.BrowserStop = 186] = "BrowserStop", t[t.BrowserRefresh = 187] = "BrowserRefresh", t[t.BrowserFavorites = 188] = "BrowserFavorites", t[t.ZoomToggle = 189] = "ZoomToggle", t[t.MailReply = 190] = "MailReply", t[t.MailForward = 191] = "MailForward", t[t.MailSend = 192] = "MailSend", t[t.MAX_VALUE = 193] = "MAX_VALUE";
})(P || (P = {}));
class TE {
  constructor() {
    this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(e, i) {
    this._keyCodeToStr[e] = i, this._strToKeyCode[i.toLowerCase()] = e;
  }
  keyCodeToStr(e) {
    return this._keyCodeToStr[e];
  }
  strToKeyCode(e) {
    return this._strToKeyCode[e.toLowerCase()] || k.Unknown;
  }
}
const xp = new TE(), U0 = new TE(), $0 = new TE(), gU = new Array(230), mU = /* @__PURE__ */ Object.create(null), _U = /* @__PURE__ */ Object.create(null), H0 = [];
for (let t = 0; t <= P.MAX_VALUE; t++)
  k.DependsOnKbLayout;
for (let t = 0; t <= k.MAX_VALUE; t++)
  H0[t] = P.DependsOnKbLayout;
(function() {
  const t = "", e = [
    [1, P.None, "None", k.Unknown, "unknown", 0, "VK_UNKNOWN", t, t],
    [1, P.Hyper, "Hyper", k.Unknown, t, 0, t, t, t],
    [1, P.Super, "Super", k.Unknown, t, 0, t, t, t],
    [1, P.Fn, "Fn", k.Unknown, t, 0, t, t, t],
    [1, P.FnLock, "FnLock", k.Unknown, t, 0, t, t, t],
    [1, P.Suspend, "Suspend", k.Unknown, t, 0, t, t, t],
    [1, P.Resume, "Resume", k.Unknown, t, 0, t, t, t],
    [1, P.Turbo, "Turbo", k.Unknown, t, 0, t, t, t],
    [1, P.Sleep, "Sleep", k.Unknown, t, 0, "VK_SLEEP", t, t],
    [1, P.WakeUp, "WakeUp", k.Unknown, t, 0, t, t, t],
    [0, P.KeyA, "KeyA", k.KeyA, "A", 65, "VK_A", t, t],
    [0, P.KeyB, "KeyB", k.KeyB, "B", 66, "VK_B", t, t],
    [0, P.KeyC, "KeyC", k.KeyC, "C", 67, "VK_C", t, t],
    [0, P.KeyD, "KeyD", k.KeyD, "D", 68, "VK_D", t, t],
    [0, P.KeyE, "KeyE", k.KeyE, "E", 69, "VK_E", t, t],
    [0, P.KeyF, "KeyF", k.KeyF, "F", 70, "VK_F", t, t],
    [0, P.KeyG, "KeyG", k.KeyG, "G", 71, "VK_G", t, t],
    [0, P.KeyH, "KeyH", k.KeyH, "H", 72, "VK_H", t, t],
    [0, P.KeyI, "KeyI", k.KeyI, "I", 73, "VK_I", t, t],
    [0, P.KeyJ, "KeyJ", k.KeyJ, "J", 74, "VK_J", t, t],
    [0, P.KeyK, "KeyK", k.KeyK, "K", 75, "VK_K", t, t],
    [0, P.KeyL, "KeyL", k.KeyL, "L", 76, "VK_L", t, t],
    [0, P.KeyM, "KeyM", k.KeyM, "M", 77, "VK_M", t, t],
    [0, P.KeyN, "KeyN", k.KeyN, "N", 78, "VK_N", t, t],
    [0, P.KeyO, "KeyO", k.KeyO, "O", 79, "VK_O", t, t],
    [0, P.KeyP, "KeyP", k.KeyP, "P", 80, "VK_P", t, t],
    [0, P.KeyQ, "KeyQ", k.KeyQ, "Q", 81, "VK_Q", t, t],
    [0, P.KeyR, "KeyR", k.KeyR, "R", 82, "VK_R", t, t],
    [0, P.KeyS, "KeyS", k.KeyS, "S", 83, "VK_S", t, t],
    [0, P.KeyT, "KeyT", k.KeyT, "T", 84, "VK_T", t, t],
    [0, P.KeyU, "KeyU", k.KeyU, "U", 85, "VK_U", t, t],
    [0, P.KeyV, "KeyV", k.KeyV, "V", 86, "VK_V", t, t],
    [0, P.KeyW, "KeyW", k.KeyW, "W", 87, "VK_W", t, t],
    [0, P.KeyX, "KeyX", k.KeyX, "X", 88, "VK_X", t, t],
    [0, P.KeyY, "KeyY", k.KeyY, "Y", 89, "VK_Y", t, t],
    [0, P.KeyZ, "KeyZ", k.KeyZ, "Z", 90, "VK_Z", t, t],
    [0, P.Digit1, "Digit1", k.Digit1, "1", 49, "VK_1", t, t],
    [0, P.Digit2, "Digit2", k.Digit2, "2", 50, "VK_2", t, t],
    [0, P.Digit3, "Digit3", k.Digit3, "3", 51, "VK_3", t, t],
    [0, P.Digit4, "Digit4", k.Digit4, "4", 52, "VK_4", t, t],
    [0, P.Digit5, "Digit5", k.Digit5, "5", 53, "VK_5", t, t],
    [0, P.Digit6, "Digit6", k.Digit6, "6", 54, "VK_6", t, t],
    [0, P.Digit7, "Digit7", k.Digit7, "7", 55, "VK_7", t, t],
    [0, P.Digit8, "Digit8", k.Digit8, "8", 56, "VK_8", t, t],
    [0, P.Digit9, "Digit9", k.Digit9, "9", 57, "VK_9", t, t],
    [0, P.Digit0, "Digit0", k.Digit0, "0", 48, "VK_0", t, t],
    [1, P.Enter, "Enter", k.Enter, "Enter", 13, "VK_RETURN", t, t],
    [1, P.Escape, "Escape", k.Escape, "Escape", 27, "VK_ESCAPE", t, t],
    [1, P.Backspace, "Backspace", k.Backspace, "Backspace", 8, "VK_BACK", t, t],
    [1, P.Tab, "Tab", k.Tab, "Tab", 9, "VK_TAB", t, t],
    [1, P.Space, "Space", k.Space, "Space", 32, "VK_SPACE", t, t],
    [0, P.Minus, "Minus", k.Minus, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
    [0, P.Equal, "Equal", k.Equal, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
    [0, P.BracketLeft, "BracketLeft", k.BracketLeft, "[", 219, "VK_OEM_4", "[", "OEM_4"],
    [0, P.BracketRight, "BracketRight", k.BracketRight, "]", 221, "VK_OEM_6", "]", "OEM_6"],
    [0, P.Backslash, "Backslash", k.Backslash, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
    [0, P.IntlHash, "IntlHash", k.Unknown, t, 0, t, t, t],
    [0, P.Semicolon, "Semicolon", k.Semicolon, ";", 186, "VK_OEM_1", ";", "OEM_1"],
    [0, P.Quote, "Quote", k.Quote, "'", 222, "VK_OEM_7", "'", "OEM_7"],
    [0, P.Backquote, "Backquote", k.Backquote, "`", 192, "VK_OEM_3", "`", "OEM_3"],
    [0, P.Comma, "Comma", k.Comma, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
    [0, P.Period, "Period", k.Period, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
    [0, P.Slash, "Slash", k.Slash, "/", 191, "VK_OEM_2", "/", "OEM_2"],
    [1, P.CapsLock, "CapsLock", k.CapsLock, "CapsLock", 20, "VK_CAPITAL", t, t],
    [1, P.F1, "F1", k.F1, "F1", 112, "VK_F1", t, t],
    [1, P.F2, "F2", k.F2, "F2", 113, "VK_F2", t, t],
    [1, P.F3, "F3", k.F3, "F3", 114, "VK_F3", t, t],
    [1, P.F4, "F4", k.F4, "F4", 115, "VK_F4", t, t],
    [1, P.F5, "F5", k.F5, "F5", 116, "VK_F5", t, t],
    [1, P.F6, "F6", k.F6, "F6", 117, "VK_F6", t, t],
    [1, P.F7, "F7", k.F7, "F7", 118, "VK_F7", t, t],
    [1, P.F8, "F8", k.F8, "F8", 119, "VK_F8", t, t],
    [1, P.F9, "F9", k.F9, "F9", 120, "VK_F9", t, t],
    [1, P.F10, "F10", k.F10, "F10", 121, "VK_F10", t, t],
    [1, P.F11, "F11", k.F11, "F11", 122, "VK_F11", t, t],
    [1, P.F12, "F12", k.F12, "F12", 123, "VK_F12", t, t],
    [1, P.PrintScreen, "PrintScreen", k.Unknown, t, 0, t, t, t],
    [1, P.ScrollLock, "ScrollLock", k.ScrollLock, "ScrollLock", 145, "VK_SCROLL", t, t],
    [1, P.Pause, "Pause", k.PauseBreak, "PauseBreak", 19, "VK_PAUSE", t, t],
    [1, P.Insert, "Insert", k.Insert, "Insert", 45, "VK_INSERT", t, t],
    [1, P.Home, "Home", k.Home, "Home", 36, "VK_HOME", t, t],
    [1, P.PageUp, "PageUp", k.PageUp, "PageUp", 33, "VK_PRIOR", t, t],
    [1, P.Delete, "Delete", k.Delete, "Delete", 46, "VK_DELETE", t, t],
    [1, P.End, "End", k.End, "End", 35, "VK_END", t, t],
    [1, P.PageDown, "PageDown", k.PageDown, "PageDown", 34, "VK_NEXT", t, t],
    [1, P.ArrowRight, "ArrowRight", k.RightArrow, "RightArrow", 39, "VK_RIGHT", "Right", t],
    [1, P.ArrowLeft, "ArrowLeft", k.LeftArrow, "LeftArrow", 37, "VK_LEFT", "Left", t],
    [1, P.ArrowDown, "ArrowDown", k.DownArrow, "DownArrow", 40, "VK_DOWN", "Down", t],
    [1, P.ArrowUp, "ArrowUp", k.UpArrow, "UpArrow", 38, "VK_UP", "Up", t],
    [1, P.NumLock, "NumLock", k.NumLock, "NumLock", 144, "VK_NUMLOCK", t, t],
    [1, P.NumpadDivide, "NumpadDivide", k.NumpadDivide, "NumPad_Divide", 111, "VK_DIVIDE", t, t],
    [1, P.NumpadMultiply, "NumpadMultiply", k.NumpadMultiply, "NumPad_Multiply", 106, "VK_MULTIPLY", t, t],
    [1, P.NumpadSubtract, "NumpadSubtract", k.NumpadSubtract, "NumPad_Subtract", 109, "VK_SUBTRACT", t, t],
    [1, P.NumpadAdd, "NumpadAdd", k.NumpadAdd, "NumPad_Add", 107, "VK_ADD", t, t],
    [1, P.NumpadEnter, "NumpadEnter", k.Enter, t, 0, t, t, t],
    [1, P.Numpad1, "Numpad1", k.Numpad1, "NumPad1", 97, "VK_NUMPAD1", t, t],
    [1, P.Numpad2, "Numpad2", k.Numpad2, "NumPad2", 98, "VK_NUMPAD2", t, t],
    [1, P.Numpad3, "Numpad3", k.Numpad3, "NumPad3", 99, "VK_NUMPAD3", t, t],
    [1, P.Numpad4, "Numpad4", k.Numpad4, "NumPad4", 100, "VK_NUMPAD4", t, t],
    [1, P.Numpad5, "Numpad5", k.Numpad5, "NumPad5", 101, "VK_NUMPAD5", t, t],
    [1, P.Numpad6, "Numpad6", k.Numpad6, "NumPad6", 102, "VK_NUMPAD6", t, t],
    [1, P.Numpad7, "Numpad7", k.Numpad7, "NumPad7", 103, "VK_NUMPAD7", t, t],
    [1, P.Numpad8, "Numpad8", k.Numpad8, "NumPad8", 104, "VK_NUMPAD8", t, t],
    [1, P.Numpad9, "Numpad9", k.Numpad9, "NumPad9", 105, "VK_NUMPAD9", t, t],
    [1, P.Numpad0, "Numpad0", k.Numpad0, "NumPad0", 96, "VK_NUMPAD0", t, t],
    [1, P.NumpadDecimal, "NumpadDecimal", k.NumpadDecimal, "NumPad_Decimal", 110, "VK_DECIMAL", t, t],
    [0, P.IntlBackslash, "IntlBackslash", k.IntlBackslash, "OEM_102", 226, "VK_OEM_102", t, t],
    [1, P.ContextMenu, "ContextMenu", k.ContextMenu, "ContextMenu", 93, t, t, t],
    [1, P.Power, "Power", k.Unknown, t, 0, t, t, t],
    [1, P.NumpadEqual, "NumpadEqual", k.Unknown, t, 0, t, t, t],
    [1, P.F13, "F13", k.F13, "F13", 124, "VK_F13", t, t],
    [1, P.F14, "F14", k.F14, "F14", 125, "VK_F14", t, t],
    [1, P.F15, "F15", k.F15, "F15", 126, "VK_F15", t, t],
    [1, P.F16, "F16", k.F16, "F16", 127, "VK_F16", t, t],
    [1, P.F17, "F17", k.F17, "F17", 128, "VK_F17", t, t],
    [1, P.F18, "F18", k.F18, "F18", 129, "VK_F18", t, t],
    [1, P.F19, "F19", k.F19, "F19", 130, "VK_F19", t, t],
    [1, P.F20, "F20", k.F20, "F20", 131, "VK_F20", t, t],
    [1, P.F21, "F21", k.F21, "F21", 132, "VK_F21", t, t],
    [1, P.F22, "F22", k.F22, "F22", 133, "VK_F22", t, t],
    [1, P.F23, "F23", k.F23, "F23", 134, "VK_F23", t, t],
    [1, P.F24, "F24", k.F24, "F24", 135, "VK_F24", t, t],
    [1, P.Open, "Open", k.Unknown, t, 0, t, t, t],
    [1, P.Help, "Help", k.Unknown, t, 0, t, t, t],
    [1, P.Select, "Select", k.Unknown, t, 0, t, t, t],
    [1, P.Again, "Again", k.Unknown, t, 0, t, t, t],
    [1, P.Undo, "Undo", k.Unknown, t, 0, t, t, t],
    [1, P.Cut, "Cut", k.Unknown, t, 0, t, t, t],
    [1, P.Copy, "Copy", k.Unknown, t, 0, t, t, t],
    [1, P.Paste, "Paste", k.Unknown, t, 0, t, t, t],
    [1, P.Find, "Find", k.Unknown, t, 0, t, t, t],
    [1, P.AudioVolumeMute, "AudioVolumeMute", k.AudioVolumeMute, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", t, t],
    [1, P.AudioVolumeUp, "AudioVolumeUp", k.AudioVolumeUp, "AudioVolumeUp", 175, "VK_VOLUME_UP", t, t],
    [1, P.AudioVolumeDown, "AudioVolumeDown", k.AudioVolumeDown, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", t, t],
    [1, P.NumpadComma, "NumpadComma", k.NUMPAD_SEPARATOR, "NumPad_Separator", 108, "VK_SEPARATOR", t, t],
    [0, P.IntlRo, "IntlRo", k.ABNT_C1, "ABNT_C1", 193, "VK_ABNT_C1", t, t],
    [1, P.KanaMode, "KanaMode", k.Unknown, t, 0, t, t, t],
    [0, P.IntlYen, "IntlYen", k.Unknown, t, 0, t, t, t],
    [1, P.Convert, "Convert", k.Unknown, t, 0, t, t, t],
    [1, P.NonConvert, "NonConvert", k.Unknown, t, 0, t, t, t],
    [1, P.Lang1, "Lang1", k.Unknown, t, 0, t, t, t],
    [1, P.Lang2, "Lang2", k.Unknown, t, 0, t, t, t],
    [1, P.Lang3, "Lang3", k.Unknown, t, 0, t, t, t],
    [1, P.Lang4, "Lang4", k.Unknown, t, 0, t, t, t],
    [1, P.Lang5, "Lang5", k.Unknown, t, 0, t, t, t],
    [1, P.Abort, "Abort", k.Unknown, t, 0, t, t, t],
    [1, P.Props, "Props", k.Unknown, t, 0, t, t, t],
    [1, P.NumpadParenLeft, "NumpadParenLeft", k.Unknown, t, 0, t, t, t],
    [1, P.NumpadParenRight, "NumpadParenRight", k.Unknown, t, 0, t, t, t],
    [1, P.NumpadBackspace, "NumpadBackspace", k.Unknown, t, 0, t, t, t],
    [1, P.NumpadMemoryStore, "NumpadMemoryStore", k.Unknown, t, 0, t, t, t],
    [1, P.NumpadMemoryRecall, "NumpadMemoryRecall", k.Unknown, t, 0, t, t, t],
    [1, P.NumpadMemoryClear, "NumpadMemoryClear", k.Unknown, t, 0, t, t, t],
    [1, P.NumpadMemoryAdd, "NumpadMemoryAdd", k.Unknown, t, 0, t, t, t],
    [1, P.NumpadMemorySubtract, "NumpadMemorySubtract", k.Unknown, t, 0, t, t, t],
    [1, P.NumpadClear, "NumpadClear", k.Clear, "Clear", 12, "VK_CLEAR", t, t],
    [1, P.NumpadClearEntry, "NumpadClearEntry", k.Unknown, t, 0, t, t, t],
    [1, P.None, t, k.Ctrl, "Ctrl", 17, "VK_CONTROL", t, t],
    [1, P.None, t, k.Shift, "Shift", 16, "VK_SHIFT", t, t],
    [1, P.None, t, k.Alt, "Alt", 18, "VK_MENU", t, t],
    [1, P.None, t, k.Meta, "Meta", 91, "VK_COMMAND", t, t],
    [1, P.ControlLeft, "ControlLeft", k.Ctrl, t, 0, "VK_LCONTROL", t, t],
    [1, P.ShiftLeft, "ShiftLeft", k.Shift, t, 0, "VK_LSHIFT", t, t],
    [1, P.AltLeft, "AltLeft", k.Alt, t, 0, "VK_LMENU", t, t],
    [1, P.MetaLeft, "MetaLeft", k.Meta, t, 0, "VK_LWIN", t, t],
    [1, P.ControlRight, "ControlRight", k.Ctrl, t, 0, "VK_RCONTROL", t, t],
    [1, P.ShiftRight, "ShiftRight", k.Shift, t, 0, "VK_RSHIFT", t, t],
    [1, P.AltRight, "AltRight", k.Alt, t, 0, "VK_RMENU", t, t],
    [1, P.MetaRight, "MetaRight", k.Meta, t, 0, "VK_RWIN", t, t],
    [1, P.BrightnessUp, "BrightnessUp", k.Unknown, t, 0, t, t, t],
    [1, P.BrightnessDown, "BrightnessDown", k.Unknown, t, 0, t, t, t],
    [1, P.MediaPlay, "MediaPlay", k.Unknown, t, 0, t, t, t],
    [1, P.MediaRecord, "MediaRecord", k.Unknown, t, 0, t, t, t],
    [1, P.MediaFastForward, "MediaFastForward", k.Unknown, t, 0, t, t, t],
    [1, P.MediaRewind, "MediaRewind", k.Unknown, t, 0, t, t, t],
    [1, P.MediaTrackNext, "MediaTrackNext", k.MediaTrackNext, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", t, t],
    [1, P.MediaTrackPrevious, "MediaTrackPrevious", k.MediaTrackPrevious, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", t, t],
    [1, P.MediaStop, "MediaStop", k.MediaStop, "MediaStop", 178, "VK_MEDIA_STOP", t, t],
    [1, P.Eject, "Eject", k.Unknown, t, 0, t, t, t],
    [1, P.MediaPlayPause, "MediaPlayPause", k.MediaPlayPause, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", t, t],
    [1, P.MediaSelect, "MediaSelect", k.LaunchMediaPlayer, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", t, t],
    [1, P.LaunchMail, "LaunchMail", k.LaunchMail, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", t, t],
    [1, P.LaunchApp2, "LaunchApp2", k.LaunchApp2, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", t, t],
    [1, P.LaunchApp1, "LaunchApp1", k.Unknown, t, 0, "VK_MEDIA_LAUNCH_APP1", t, t],
    [1, P.SelectTask, "SelectTask", k.Unknown, t, 0, t, t, t],
    [1, P.LaunchScreenSaver, "LaunchScreenSaver", k.Unknown, t, 0, t, t, t],
    [1, P.BrowserSearch, "BrowserSearch", k.BrowserSearch, "BrowserSearch", 170, "VK_BROWSER_SEARCH", t, t],
    [1, P.BrowserHome, "BrowserHome", k.BrowserHome, "BrowserHome", 172, "VK_BROWSER_HOME", t, t],
    [1, P.BrowserBack, "BrowserBack", k.BrowserBack, "BrowserBack", 166, "VK_BROWSER_BACK", t, t],
    [1, P.BrowserForward, "BrowserForward", k.BrowserForward, "BrowserForward", 167, "VK_BROWSER_FORWARD", t, t],
    [1, P.BrowserStop, "BrowserStop", k.Unknown, t, 0, "VK_BROWSER_STOP", t, t],
    [1, P.BrowserRefresh, "BrowserRefresh", k.Unknown, t, 0, "VK_BROWSER_REFRESH", t, t],
    [1, P.BrowserFavorites, "BrowserFavorites", k.Unknown, t, 0, "VK_BROWSER_FAVORITES", t, t],
    [1, P.ZoomToggle, "ZoomToggle", k.Unknown, t, 0, t, t, t],
    [1, P.MailReply, "MailReply", k.Unknown, t, 0, t, t, t],
    [1, P.MailForward, "MailForward", k.Unknown, t, 0, t, t, t],
    [1, P.MailSend, "MailSend", k.Unknown, t, 0, t, t, t],
    [1, P.None, t, k.KEY_IN_COMPOSITION, "KeyInComposition", 229, t, t, t],
    [1, P.None, t, k.ABNT_C2, "ABNT_C2", 194, "VK_ABNT_C2", t, t],
    [1, P.None, t, k.OEM_8, "OEM_8", 223, "VK_OEM_8", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_KANA", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_HANGUL", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_JUNJA", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_FINAL", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_HANJA", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_KANJI", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_CONVERT", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_NONCONVERT", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_ACCEPT", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_MODECHANGE", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_SELECT", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_PRINT", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_EXECUTE", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_SNAPSHOT", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_HELP", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_APPS", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_PROCESSKEY", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_PACKET", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_DBE_SBCSCHAR", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_DBE_DBCSCHAR", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_ATTN", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_CRSEL", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_EXSEL", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_EREOF", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_PLAY", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_ZOOM", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_NONAME", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_PA1", t, t],
    [1, P.None, t, k.Unknown, t, 0, "VK_OEM_CLEAR", t, t]
  ], i = [], n = [];
  for (const r of e) {
    const [s, o, a, l, c, u, d, f, g] = r;
    if (n[o] || (n[o] = !0, mU[a] = o, _U[a.toLowerCase()] = o, s && l !== k.Unknown && l !== k.Enter && l !== k.Ctrl && l !== k.Shift && l !== k.Alt && l !== k.Meta && (H0[l] = o)), !i[l]) {
      if (i[l] = !0, !c)
        throw new Error(
          `String representation missing for key code ${l} around scan code ${a}`
        );
      xp.define(l, c), U0.define(l, f || c), $0.define(l, g || f || c);
    }
    u && (gU[u] = l);
  }
  H0[k.Enter] = P.Enter;
})();
var EC;
(function(t) {
  function e(a) {
    return xp.keyCodeToStr(a);
  }
  t.toString = e;
  function i(a) {
    return xp.strToKeyCode(a);
  }
  t.fromString = i;
  function n(a) {
    return U0.keyCodeToStr(a);
  }
  t.toUserSettingsUS = n;
  function r(a) {
    return $0.keyCodeToStr(a);
  }
  t.toUserSettingsGeneral = r;
  function s(a) {
    return U0.strToKeyCode(a) || $0.strToKeyCode(a);
  }
  t.fromUserSettings = s;
  function o(a) {
    if (a >= k.Numpad0 && a <= k.NumpadDivide)
      return null;
    switch (a) {
      case k.UpArrow:
        return "Up";
      case k.DownArrow:
        return "Down";
      case k.LeftArrow:
        return "Left";
      case k.RightArrow:
        return "Right";
    }
    return xp.keyCodeToStr(a);
  }
  t.toElectronAccelerator = o;
})(EC || (EC = {}));
var SC;
(function(t) {
  t[t.CtrlCmd = 2048] = "CtrlCmd", t[t.Shift = 1024] = "Shift", t[t.Alt = 512] = "Alt", t[t.WinCtrl = 256] = "WinCtrl";
})(SC || (SC = {}));
var Zo;
(function(t) {
  t[t.CtrlCmd = 2048] = "CtrlCmd", t[t.Shift = 1024] = "Shift", t[t.Alt = 512] = "Alt", t[t.WinCtrl = 256] = "WinCtrl", t[t.KeyCode = 255] = "KeyCode";
})(Zo || (Zo = {}));
function DC(t, e) {
  if (typeof t == "number") {
    if (t === 0)
      return null;
    const i = (t & 65535) >>> 0, n = (t & 4294901760) >>> 16;
    return n !== 0 ? new Ep([
      jf(i, e),
      jf(n, e)
    ]) : new Ep([jf(i, e)]);
  } else {
    const i = [];
    for (let n = 0; n < t.length; n++)
      i.push(jf(t[n], e));
    return new Ep(i);
  }
}
function jf(t, e) {
  const i = !!(t & Zo.CtrlCmd), n = !!(t & Zo.WinCtrl), r = e === zr.Macintosh ? n : i, s = !!(t & Zo.Shift), o = !!(t & Zo.Alt), a = e === zr.Macintosh ? i : n, l = t & Zo.KeyCode;
  return new PE(r, s, o, a, l);
}
class PE {
  constructor(e, i, n, r, s) {
    this.ctrlKey = e, this.shiftKey = i, this.altKey = n, this.metaKey = r, this.keyCode = s;
  }
  equals(e) {
    return e instanceof PE && this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode;
  }
  getHashCode() {
    const e = this.ctrlKey ? "1" : "0", i = this.shiftKey ? "1" : "0", n = this.altKey ? "1" : "0", r = this.metaKey ? "1" : "0";
    return `K${e}${i}${n}${r}${this.keyCode}`;
  }
  isModifierKey() {
    return this.keyCode === k.Unknown || this.keyCode === k.Ctrl || this.keyCode === k.Meta || this.keyCode === k.Alt || this.keyCode === k.Shift;
  }
  toKeybinding() {
    return new Ep([this]);
  }
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === k.Ctrl || this.shiftKey && this.keyCode === k.Shift || this.altKey && this.keyCode === k.Alt || this.metaKey && this.keyCode === k.Meta;
  }
}
class Ep {
  constructor(e) {
    if (e.length === 0)
      throw ze("chords");
    this.chords = e;
  }
  getHashCode() {
    let e = "";
    for (let i = 0, n = this.chords.length; i < n; i++)
      i !== 0 && (e += ";"), e += this.chords[i].getHashCode();
    return e;
  }
  equals(e) {
    if (e === null || this.chords.length !== e.chords.length)
      return !1;
    for (let i = 0; i < this.chords.length; i++)
      if (!this.chords[i].equals(e.chords[i]))
        return !1;
    return !0;
  }
}
var kC;
(function(t) {
  t[t.EditorCore = 0] = "EditorCore", t[t.EditorContrib = 100] = "EditorContrib", t[t.WorkbenchContrib = 200] = "WorkbenchContrib", t[t.BuiltinExtension = 300] = "BuiltinExtension", t[t.ExternalExtension = 400] = "ExternalExtension";
})(kC || (kC = {}));
class AE {
  constructor() {
    this._coreKeybindings = new Ro(), this._extensionKeybindings = [], this._cachedMergedKeybindings = null;
  }
  static bindToCurrentPlatform(e) {
    if (Pf === zr.Windows) {
      if (e && e.win)
        return e.win;
    } else if (Pf === zr.Macintosh) {
      if (e && e.mac)
        return e.mac;
    } else if (e && e.linux)
      return e.linux;
    return e;
  }
  registerKeybindingRule(e) {
    const i = AE.bindToCurrentPlatform(e), n = new De();
    if (i && i.primary) {
      const r = DC(i.primary, Pf);
      r && n.add(this._registerDefaultKeybinding(r, e.id, e.args, e.weight, 0, e.when));
    }
    if (i && Array.isArray(i.secondary))
      for (let r = 0, s = i.secondary.length; r < s; r++) {
        const o = i.secondary[r], a = DC(o, Pf);
        a && n.add(this._registerDefaultKeybinding(a, e.id, e.args, e.weight, -r - 1, e.when));
      }
    return n;
  }
  setExtensionKeybindings(e) {
    const i = [];
    let n = 0;
    for (const r of e)
      r.keybinding && (i[n++] = {
        keybinding: r.keybinding,
        command: r.id,
        commandArgs: r.args,
        when: r.when,
        weight1: r.weight,
        weight2: 0,
        extensionId: r.extensionId || null,
        isBuiltinExtension: r.isBuiltinExtension || !1
      });
    this._extensionKeybindings = i, this._cachedMergedKeybindings = null;
  }
  registerCommandAndKeybindingRule(e) {
    return wx(this.registerKeybindingRule(e), CE.registerCommand(e));
  }
  _registerDefaultKeybinding(e, i, n, r, s, o) {
    const a = this._coreKeybindings.push({
      keybinding: e,
      command: i,
      commandArgs: n,
      when: o,
      weight1: r,
      weight2: s,
      extensionId: null,
      isBuiltinExtension: !1
    });
    return this._cachedMergedKeybindings = null, Ee(() => {
      a(), this._cachedMergedKeybindings = null;
    });
  }
  getDefaultKeybindings() {
    return this._cachedMergedKeybindings || (this._cachedMergedKeybindings = Array.from(this._coreKeybindings).concat(this._extensionKeybindings), this._cachedMergedKeybindings.sort(bU)), this._cachedMergedKeybindings.slice(0);
  }
}
const vU = new AE(), wU = {
  EditorModes: "platform.keybindingsRegistry"
};
ai.add(wU.EditorModes, vU);
function bU(t, e) {
  if (t.weight1 !== e.weight1)
    return t.weight1 - e.weight1;
  if (t.command && e.command) {
    if (t.command < e.command)
      return -1;
    if (t.command > e.command)
      return 1;
  }
  return t.weight2 - e.weight2;
}
var Sp;
function yU(t) {
  return t.command !== void 0;
}
const y = class y {
  static for(e) {
    return y._instances.get(e) ?? new y(e);
  }
  constructor(e) {
    if (y._instances.has(e))
      throw new TypeError(
        `MenuId with identifier '${e}' already exists. Use MenuId.for(ident) or a unique identifier`
      );
    y._instances.set(e, this), this.id = e;
  }
};
y._instances = /* @__PURE__ */ new Map(), y.CommandPalette = new y("CommandPalette"), y.DebugBreakpointsContext = new y("DebugBreakpointsContext"), y.DebugCallStackContext = new y("DebugCallStackContext"), y.DebugConsoleContext = new y("DebugConsoleContext"), y.DebugVariablesContext = new y("DebugVariablesContext"), y.NotebookVariablesContext = new y("NotebookVariablesContext"), y.DebugHoverContext = new y("DebugHoverContext"), y.DebugWatchContext = new y("DebugWatchContext"), y.DebugToolBar = new y("DebugToolBar"), y.DebugToolBarStop = new y("DebugToolBarStop"), y.DebugDisassemblyContext = new y("DebugDisassemblyContext"), y.DebugCallStackToolbar = new y("DebugCallStackToolbar"), y.DebugCreateConfiguration = new y("DebugCreateConfiguration"), y.EditorContext = new y("EditorContext"), y.SimpleEditorContext = new y("SimpleEditorContext"), y.EditorContent = new y("EditorContent"), y.EditorLineNumberContext = new y("EditorLineNumberContext"), y.EditorContextCopy = new y("EditorContextCopy"), y.EditorContextPeek = new y("EditorContextPeek"), y.EditorContextShare = new y("EditorContextShare"), y.EditorTitle = new y("EditorTitle"), y.CompactWindowEditorTitle = new y("CompactWindowEditorTitle"), y.EditorTitleRun = new y("EditorTitleRun"), y.EditorTitleContext = new y("EditorTitleContext"), y.EditorTitleContextShare = new y("EditorTitleContextShare"), y.EmptyEditorGroup = new y("EmptyEditorGroup"), y.EmptyEditorGroupContext = new y("EmptyEditorGroupContext"), y.EditorTabsBarContext = new y("EditorTabsBarContext"), y.EditorTabsBarShowTabsSubmenu = new y("EditorTabsBarShowTabsSubmenu"), y.EditorTabsBarShowTabsZenModeSubmenu = new y("EditorTabsBarShowTabsZenModeSubmenu"), y.EditorActionsPositionSubmenu = new y("EditorActionsPositionSubmenu"), y.EditorSplitMoveSubmenu = new y("EditorSplitMoveSubmenu"), y.ExplorerContext = new y("ExplorerContext"), y.ExplorerContextShare = new y("ExplorerContextShare"), y.ExtensionContext = new y("ExtensionContext"), y.ExtensionEditorContextMenu = new y("ExtensionEditorContextMenu"), y.GlobalActivity = new y("GlobalActivity"), y.CommandCenter = new y("CommandCenter"), y.CommandCenterCenter = new y("CommandCenterCenter"), y.LayoutControlMenuSubmenu = new y("LayoutControlMenuSubmenu"), y.LayoutControlMenu = new y("LayoutControlMenu"), y.MenubarMainMenu = new y("MenubarMainMenu"), y.MenubarAppearanceMenu = new y("MenubarAppearanceMenu"), y.MenubarDebugMenu = new y("MenubarDebugMenu"), y.MenubarEditMenu = new y("MenubarEditMenu"), y.MenubarCopy = new y("MenubarCopy"), y.MenubarFileMenu = new y("MenubarFileMenu"), y.MenubarGoMenu = new y("MenubarGoMenu"), y.MenubarHelpMenu = new y("MenubarHelpMenu"), y.MenubarLayoutMenu = new y("MenubarLayoutMenu"), y.MenubarNewBreakpointMenu = new y("MenubarNewBreakpointMenu"), y.PanelAlignmentMenu = new y("PanelAlignmentMenu"), y.PanelPositionMenu = new y("PanelPositionMenu"), y.ActivityBarPositionMenu = new y("ActivityBarPositionMenu"), y.MenubarPreferencesMenu = new y("MenubarPreferencesMenu"), y.MenubarRecentMenu = new y("MenubarRecentMenu"), y.MenubarSelectionMenu = new y("MenubarSelectionMenu"), y.MenubarShare = new y("MenubarShare"), y.MenubarSwitchEditorMenu = new y("MenubarSwitchEditorMenu"), y.MenubarSwitchGroupMenu = new y("MenubarSwitchGroupMenu"), y.MenubarTerminalMenu = new y("MenubarTerminalMenu"), y.MenubarTerminalSuggestStatusMenu = new y("MenubarTerminalSuggestStatusMenu"), y.MenubarViewMenu = new y("MenubarViewMenu"), y.MenubarHomeMenu = new y("MenubarHomeMenu"), y.OpenEditorsContext = new y("OpenEditorsContext"), y.OpenEditorsContextShare = new y("OpenEditorsContextShare"), y.ProblemsPanelContext = new y("ProblemsPanelContext"), y.SCMInputBox = new y("SCMInputBox"), y.SCMChangeContext = new y("SCMChangeContext"), y.SCMResourceContext = new y("SCMResourceContext"), y.SCMResourceContextShare = new y("SCMResourceContextShare"), y.SCMResourceFolderContext = new y("SCMResourceFolderContext"), y.SCMResourceGroupContext = new y("SCMResourceGroupContext"), y.SCMSourceControl = new y("SCMSourceControl"), y.SCMSourceControlInline = new y("SCMSourceControlInline"), y.SCMSourceControlTitle = new y("SCMSourceControlTitle"), y.SCMHistoryTitle = new y("SCMHistoryTitle"), y.SCMHistoryItemContext = new y("SCMHistoryItemContext"), y.SCMHistoryItemChangeContext = new y("SCMHistoryItemChangeContext"), y.SCMHistoryItemHover = new y("SCMHistoryItemHover"), y.SCMHistoryItemRefContext = new y("SCMHistoryItemRefContext"), y.SCMQuickDiffDecorations = new y("SCMQuickDiffDecorations"), y.SCMTitle = new y("SCMTitle"), y.SearchContext = new y("SearchContext"), y.SearchActionMenu = new y("SearchActionContext"), y.StatusBarWindowIndicatorMenu = new y("StatusBarWindowIndicatorMenu"), y.StatusBarRemoteIndicatorMenu = new y("StatusBarRemoteIndicatorMenu"), y.StickyScrollContext = new y("StickyScrollContext"), y.TestItem = new y("TestItem"), y.TestItemGutter = new y("TestItemGutter"), y.TestProfilesContext = new y("TestProfilesContext"), y.TestMessageContext = new y("TestMessageContext"), y.TestMessageContent = new y("TestMessageContent"), y.TestPeekElement = new y("TestPeekElement"), y.TestPeekTitle = new y("TestPeekTitle"), y.TestCallStack = new y("TestCallStack"), y.TestCoverageFilterItem = new y("TestCoverageFilterItem"), y.TouchBarContext = new y("TouchBarContext"), y.TitleBar = new y("TitleBar"), y.TitleBarContext = new y("TitleBarContext"), y.TitleBarTitleContext = new y("TitleBarTitleContext"), y.TunnelContext = new y("TunnelContext"), y.TunnelPrivacy = new y("TunnelPrivacy"), y.TunnelProtocol = new y("TunnelProtocol"), y.TunnelPortInline = new y("TunnelInline"), y.TunnelTitle = new y("TunnelTitle"), y.TunnelLocalAddressInline = new y("TunnelLocalAddressInline"), y.TunnelOriginInline = new y("TunnelOriginInline"), y.ViewItemContext = new y("ViewItemContext"), y.ViewContainerTitle = new y("ViewContainerTitle"), y.ViewContainerTitleContext = new y("ViewContainerTitleContext"), y.ViewTitle = new y("ViewTitle"), y.ViewTitleContext = new y("ViewTitleContext"), y.CommentEditorActions = new y("CommentEditorActions"), y.CommentThreadTitle = new y("CommentThreadTitle"), y.CommentThreadActions = new y("CommentThreadActions"), y.CommentThreadAdditionalActions = new y("CommentThreadAdditionalActions"), y.CommentThreadTitleContext = new y("CommentThreadTitleContext"), y.CommentThreadCommentContext = new y("CommentThreadCommentContext"), y.CommentTitle = new y("CommentTitle"), y.CommentActions = new y("CommentActions"), y.CommentsViewThreadActions = new y("CommentsViewThreadActions"), y.InteractiveToolbar = new y("InteractiveToolbar"), y.InteractiveCellTitle = new y("InteractiveCellTitle"), y.InteractiveCellDelete = new y("InteractiveCellDelete"), y.InteractiveCellExecute = new y("InteractiveCellExecute"), y.InteractiveInputExecute = new y("InteractiveInputExecute"), y.InteractiveInputConfig = new y("InteractiveInputConfig"), y.ReplInputExecute = new y("ReplInputExecute"), y.IssueReporter = new y("IssueReporter"), y.NotebookToolbar = new y("NotebookToolbar"), y.NotebookToolbarContext = new y("NotebookToolbarContext"), y.NotebookStickyScrollContext = new y("NotebookStickyScrollContext"), y.NotebookCellTitle = new y("NotebookCellTitle"), y.NotebookCellDelete = new y("NotebookCellDelete"), y.NotebookCellInsert = new y("NotebookCellInsert"), y.NotebookCellBetween = new y("NotebookCellBetween"), y.NotebookCellListTop = new y("NotebookCellTop"), y.NotebookCellExecute = new y("NotebookCellExecute"), y.NotebookCellExecuteGoTo = new y("NotebookCellExecuteGoTo"), y.NotebookCellExecutePrimary = new y("NotebookCellExecutePrimary"), y.NotebookDiffCellInputTitle = new y("NotebookDiffCellInputTitle"), y.NotebookDiffDocumentMetadata = new y("NotebookDiffDocumentMetadata"), y.NotebookDiffCellMetadataTitle = new y("NotebookDiffCellMetadataTitle"), y.NotebookDiffCellOutputsTitle = new y("NotebookDiffCellOutputsTitle"), y.NotebookOutputToolbar = new y("NotebookOutputToolbar"), y.NotebookOutlineFilter = new y("NotebookOutlineFilter"), y.NotebookOutlineActionMenu = new y("NotebookOutlineActionMenu"), y.NotebookEditorLayoutConfigure = new y("NotebookEditorLayoutConfigure"), y.NotebookKernelSource = new y("NotebookKernelSource"), y.BulkEditTitle = new y("BulkEditTitle"), y.BulkEditContext = new y("BulkEditContext"), y.TimelineItemContext = new y("TimelineItemContext"), y.TimelineTitle = new y("TimelineTitle"), y.TimelineTitleContext = new y("TimelineTitleContext"), y.TimelineFilterSubMenu = new y("TimelineFilterSubMenu"), y.AccountsContext = new y("AccountsContext"), y.SidebarTitle = new y("SidebarTitle"), y.PanelTitle = new y("PanelTitle"), y.AuxiliaryBarTitle = new y("AuxiliaryBarTitle"), y.TerminalInstanceContext = new y("TerminalInstanceContext"), y.TerminalEditorInstanceContext = new y("TerminalEditorInstanceContext"), y.TerminalNewDropdownContext = new y("TerminalNewDropdownContext"), y.TerminalTabContext = new y("TerminalTabContext"), y.TerminalTabEmptyAreaContext = new y("TerminalTabEmptyAreaContext"), y.TerminalStickyScrollContext = new y("TerminalStickyScrollContext"), y.WebviewContext = new y("WebviewContext"), y.InlineCompletionsActions = new y("InlineCompletionsActions"), y.InlineEditsActions = new y("InlineEditsActions"), y.NewFile = new y("NewFile"), y.MergeInput1Toolbar = new y("MergeToolbar1Toolbar"), y.MergeInput2Toolbar = new y("MergeToolbar2Toolbar"), y.MergeBaseToolbar = new y("MergeBaseToolbar"), y.MergeInputResultToolbar = new y("MergeToolbarResultToolbar"), y.InlineSuggestionToolbar = new y("InlineSuggestionToolbar"), y.InlineEditToolbar = new y("InlineEditToolbar"), y.ChatContext = new y("ChatContext"), y.ChatCodeBlock = new y("ChatCodeblock"), y.ChatCompareBlock = new y("ChatCompareBlock"), y.ChatMessageTitle = new y("ChatMessageTitle"), y.ChatMessageFooter = new y("ChatMessageFooter"), y.ChatExecute = new y("ChatExecute"), y.ChatExecuteSecondary = new y("ChatExecuteSecondary"), y.ChatInput = new y("ChatInput"), y.ChatInputSide = new y("ChatInputSide"), y.ChatModePicker = new y("ChatModePicker"), y.ChatEditingWidgetToolbar = new y("ChatEditingWidgetToolbar"), y.ChatEditingEditorContent = new y("ChatEditingEditorContent"), y.ChatEditingEditorHunk = new y("ChatEditingEditorHunk"), y.ChatEditingDeletedNotebookCell = new y("ChatEditingDeletedNotebookCell"), y.ChatInputAttachmentToolbar = new y("ChatInputAttachmentToolbar"), y.ChatEditingWidgetModifiedFilesToolbar = new y("ChatEditingWidgetModifiedFilesToolbar"), y.ChatInputResourceAttachmentContext = new y("ChatInputResourceAttachmentContext"), y.ChatInputSymbolAttachmentContext = new y("ChatInputSymbolAttachmentContext"), y.ChatInlineResourceAnchorContext = new y("ChatInlineResourceAnchorContext"), y.ChatInlineSymbolAnchorContext = new y("ChatInlineSymbolAnchorContext"), y.ChatMessageCheckpoint = new y("ChatMessageCheckpoint"), y.ChatMessageRestoreCheckpoint = new y("ChatMessageRestoreCheckpoint"), y.ChatEditingCodeBlockContext = new y("ChatEditingCodeBlockContext"), y.ChatTitleBarMenu = new y("ChatTitleBarMenu"), y.ChatAttachmentsContext = new y("ChatAttachmentsContext"), y.ChatToolOutputResourceToolbar = new y("ChatToolOutputResourceToolbar"), y.ChatTextEditorMenu = new y("ChatTextEditorMenu"), y.ChatTerminalMenu = new y("ChatTerminalMenu"), y.ChatToolOutputResourceContext = new y("ChatToolOutputResourceContext"), y.ChatSessionsMenu = new y("ChatSessionsMenu"), y.AccessibleView = new y("AccessibleView"), y.MultiDiffEditorFileToolbar = new y("MultiDiffEditorFileToolbar"), y.DiffEditorHunkToolbar = new y("DiffEditorHunkToolbar"), y.DiffEditorSelectionToolbar = new y("DiffEditorSelectionToolbar");
let $a = y;
const Ud = class Ud {
  static for(e) {
    let i = this._all.get(e);
    return i || (i = new Ud(e), this._all.set(e, i)), i;
  }
  static merge(e) {
    const i = /* @__PURE__ */ new Set();
    for (const n of e)
      n instanceof Ud && i.add(n.id);
    return i;
  }
  constructor(e) {
    this.id = e, this.has = (i) => i === e;
  }
};
Ud._all = /* @__PURE__ */ new Map();
let ea = Ud;
new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._menuItems = /* @__PURE__ */ new Map(), this._onDidChangeMenu = new LA({
      merge: ea.merge
    }), this.onDidChangeMenu = this._onDidChangeMenu.event;
  }
  addCommand(t) {
    return this._commands.set(t.id, t), this._onDidChangeMenu.fire(ea.for($a.CommandPalette)), Ee(() => {
      this._commands.delete(t.id) && this._onDidChangeMenu.fire(ea.for($a.CommandPalette));
    });
  }
  getCommand(t) {
    return this._commands.get(t);
  }
  getCommands() {
    const t = /* @__PURE__ */ new Map();
    return this._commands.forEach((e, i) => t.set(i, e)), t;
  }
  appendMenuItem(t, e) {
    let i = this._menuItems.get(t);
    i || (i = new Ro(), this._menuItems.set(t, i));
    const n = i.push(e);
    return this._onDidChangeMenu.fire(ea.for(t)), Ee(() => {
      n(), this._onDidChangeMenu.fire(ea.for(t));
    });
  }
  appendMenuItems(t) {
    const e = new De();
    for (const { id: i, item: n } of t)
      e.add(this.appendMenuItem(i, n));
    return e;
  }
  getMenuItems(t) {
    let e;
    return this._menuItems.has(t) ? e = [...this._menuItems.get(t)] : e = [], t === $a.CommandPalette && this._appendImplicitItems(e), e;
  }
  _appendImplicitItems(t) {
    const e = /* @__PURE__ */ new Set();
    for (const i of t)
      yU(i) && (e.add(i.command.id), i.alt && e.add(i.alt.id));
    this._commands.forEach((i, n) => {
      e.has(n) || t.push({ command: i });
    });
  }
}();
let IC = Sp = class {
  static label(e, i) {
    return i?.renderShortTitle && e.shortTitle ? typeof e.shortTitle == "string" ? e.shortTitle : e.shortTitle.value : typeof e.title == "string" ? e.title : e.title.value;
  }
  constructor(e, i, n, r, s, o, a) {
    this.hideActions = r, this.menuKeybinding = s, this._commandService = a, this.id = e.id, this.label = Sp.label(e, n), this.tooltip = (typeof e.tooltip == "string" ? e.tooltip : e.tooltip?.value) ?? "", this.enabled = !e.precondition || o.contextMatchesRules(e.precondition), this.checked = void 0;
    let l;
    if (e.toggled) {
      const c = e.toggled.condition ? e.toggled : { condition: e.toggled };
      this.checked = o.contextMatchesRules(c.condition), this.checked && c.tooltip && (this.tooltip = typeof c.tooltip == "string" ? c.tooltip : c.tooltip.value), this.checked && oi.isThemeIcon(c.icon) && (l = c.icon), this.checked && c.title && (this.label = typeof c.title == "string" ? c.title : c.title.value);
    }
    l || (l = oi.isThemeIcon(e.icon) ? e.icon : void 0), this.item = e, this.alt = i ? new Sp(
      i,
      void 0,
      n,
      r,
      void 0,
      o,
      a
    ) : void 0, this._options = n, this.class = l && oi.asClassName(l);
  }
  run(...e) {
    let i = [];
    return this._options?.arg && (i = [...i, this._options.arg]), this._options?.shouldForwardArgs && (i = [...i, ...e]), this._commandService.executeCommand(this.id, ...i);
  }
};
IC = Sp = W([
  M(5, Wx),
  M(6, M5)
], IC);
var CC;
(function(t) {
  t.ExtensionQueryService = "ExtensionQueryService", t.ExtensionLatestVersionUri = "ExtensionLatestVersionUriTemplate", t.ExtensionStatisticsUri = "ExtensionStatisticsUriTemplate", t.WebExtensionStatisticsUri = "WebExtensionStatisticsUriTemplate", t.PublisherViewUri = "PublisherViewUriTemplate", t.ExtensionDetailsViewUri = "ExtensionDetailsViewUriTemplate", t.ExtensionRatingViewUri = "ExtensionRatingViewUriTemplate", t.ExtensionResourceUri = "ExtensionResourceUriTemplate", t.ContactSupportUri = "ContactSupportUri";
})(CC || (CC = {}));
var TC;
(function(t) {
  t.None = "None", t.IncludeVersions = "IncludeVersions", t.IncludeFiles = "IncludeFiles", t.IncludeCategoryAndTags = "IncludeCategoryAndTags", t.IncludeSharedAccounts = "IncludeSharedAccounts", t.IncludeVersionProperties = "IncludeVersionProperties", t.ExcludeNonValidated = "ExcludeNonValidated", t.IncludeInstallationTargets = "IncludeInstallationTargets", t.IncludeAssetUri = "IncludeAssetUri", t.IncludeStatistics = "IncludeStatistics", t.IncludeLatestVersionOnly = "IncludeLatestVersionOnly", t.Unpublished = "Unpublished", t.IncludeNameConflictInfo = "IncludeNameConflictInfo", t.IncludeLatestPrereleaseAndStableVersionOnly = "IncludeLatestPrereleaseAndStableVersionOnly";
})(TC || (TC = {}));
var B0;
(function(t) {
  t.Available = "available", t.RequiresSignIn = "requiresSignIn", t.AccessDenied = "accessDenied", t.Unavailable = "unavailable";
})(B0 || (B0 = {}));
const O5 = pe("extensionsWorkbenchService");
$_(7210, "Extensions");
var W0;
(function(t) {
  t[t.Installing = 0] = "Installing", t[t.Installed = 1] = "Installed", t[t.Uninstalling = 2] = "Uninstalling", t[t.Uninstalled = 3] = "Uninstalled";
})(W0 || (W0 = {}));
var PC;
(function(t) {
  t.ReloadWindow = "reloadWindow", t.RestartExtensions = "restartExtensions", t.DownloadUpdate = "downloadUpdate", t.ApplyUpdate = "applyUpdate", t.QuitAndInstall = "quitAndInstall";
})(PC || (PC = {}));
var AC;
(function(t) {
  t.Readme = "readme", t.Features = "features", t.Changelog = "changelog", t.Dependencies = "dependencies", t.ExtensionPack = "extensionPack";
})(AC || (AC = {}));
let RC = class extends ve {
  constructor(e, i) {
    super(), this.containers = e, this._register(i.onChange(this.update, this));
  }
  set extension(e) {
    this.containers.forEach((i) => i.extension = e);
  }
  update(e) {
    for (const i of this.containers)
      e && i.extension ? N3(i.extension.identifier, e.identifier) && (i.extension.server && e.server && i.extension.server !== e.server ? i.updateWhenCounterExtensionChanges && i.update() : i.extension = e) : i.update();
  }
};
RC = W([
  M(1, O5)
], RC);
new T("defaultExtensionViews", !0);
new T("hasOutdatedExtensions", !1);
new T("hasGallery", !1);
new T("extensionsGalleryStatus", B0.Unavailable);
new T("extensionResultListFocused ", !0);
new T("searchMcpServers", !1);
new $a("extensionsSearchActionsMenu");
new $a("extensionsFilterSubMenu");
const xU = "vscode_searchExtensions_internal";
oi.fromId(ge.extensions.id), h(7223, "Search Extensions"), h(
  7224,
  "This is a tool for browsing Visual Studio Code Extensions Marketplace. It allows the model to search for extensions and retrieve detailed information about them. The model should use this tool whenever it needs to discover extensions or resolve information about known ones. To use the tool, the model has to provide the category of the extensions, relevant search keywords, or known extension IDs. Note that search results may include false positives, so reviewing and filtering is recommended."
), h(
  7225,
  "Search for extensions in the Visual Studio Code Extensions Marketplace"
), nf.Internal;
let LC = class {
  constructor(e) {
    this.extensionWorkbenchService = e;
  }
  async invoke(e, i, n, r) {
    const s = e.parameters;
    if (!s.keywords?.length && !s.category && !s.ids?.length)
      return {
        content: [{
          kind: "text",
          value: h(7226, "Please provide a category or keywords or ids to search for.")
        }]
      };
    const o = /* @__PURE__ */ new Map(), a = (u) => {
      for (const d of u)
        d.deprecationInfo || d.isMalicious || o.set(d.identifier.id.toLowerCase(), {
          id: d.identifier.id,
          name: d.displayName,
          description: d.description,
          installed: d.state === W0.Installed,
          installCount: d.installCount ?? 0,
          rating: d.rating ?? 0,
          categories: d.categories ?? [],
          tags: d.gallery?.tags ?? []
        });
    }, l = async (u) => {
      const d = await this.extensionWorkbenchService.queryGallery({
        text: u,
        pageSize: 10,
        sortBy: Xv.InstallCount
      }, r);
      d.firstPage.length && a(d.firstPage);
    };
    if (s.ids?.length) {
      const u = await this.extensionWorkbenchService.getExtensions(s.ids.map((d) => ({ id: d })), r);
      a(u);
    }
    if (s.keywords?.length)
      for (const u of s.keywords ?? [])
        if (u === "featured")
          await l("featured");
        else {
          let d = s.category ? `category:"${s.category}"` : "";
          d = u ? `${d} ${u}`.trim() : d, await l(d);
        }
    else
      await l(`category:"${s.category}"`);
    const c = Array.from(o.values());
    return {
      content: [{
        kind: "text",
        value: `Here are the list of extensions:
${JSON.stringify(c)}
. Important: Use the following format to display extensions to the user because there is a renderer available to parse these extensions in this format and display them with all details. So, do not describe about the extensions to the user.
\`\`\`vscode-extensions
extensionId1,extensionId2
\`\`\`
.`
      }],
      toolResultDetails: {
        input: JSON.stringify(s),
        output: [{ type: "embed", isText: !0, value: JSON.stringify(c.map((u) => u.id)) }]
      }
    };
  }
};
LC = W([
  M(0, O5)
], LC);
class NC {
  constructor(e) {
    this._apiObject = new Vi(() => {
      const i = this;
      return Object.freeze({
        get name() {
          return i._data.id;
        },
        get description() {
          return i._data.modelDescription;
        },
        get inputSchema() {
          return i._data.inputSchema;
        },
        get tags() {
          return i._data.tags ?? [];
        },
        get source() {
        }
      });
    }), this._apiObjectWithChatParticipantAdditions = new Vi(() => {
      const i = this, n = dy.to(i._data.source);
      return Object.freeze({
        get name() {
          return i._data.id;
        },
        get description() {
          return i._data.modelDescription;
        },
        get inputSchema() {
          return i._data.inputSchema;
        },
        get tags() {
          return i._data.tags ?? [];
        },
        get source() {
          return n;
        }
      });
    }), this._data = e;
  }
  update(e) {
    this._data = e;
  }
  get data() {
    return this._data;
  }
  get apiObject() {
    return this._apiObject.value;
  }
  get apiObjectWithChatParticipantAdditions() {
    return this._apiObjectWithChatParticipantAdditions.value;
  }
}
class EU {
  constructor(e, i) {
    this._languageModels = i, this._registeredTools = /* @__PURE__ */ new Map(), this._tokenCountFuncs = /* @__PURE__ */ new Map(), this._allTools = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadLanguageModelTools), this._proxy.$getTools().then((n) => {
      for (const r of n)
        this._allTools.set(r.id, new NC(Fi(r)));
    });
  }
  async $countTokensForInvocation(e, i, n) {
    const r = this._tokenCountFuncs.get(e);
    if (!r)
      throw new Error(`Tool invocation call ${e} not found`);
    return await r(i, n);
  }
  async invokeTool(e, i, n, r) {
    const s = on();
    n.tokenizationOptions && this._tokenCountFuncs.set(s, n.tokenizationOptions.countTokens);
    try {
      if (n.toolInvocationToken && !oU(n.toolInvocationToken))
        throw new Error("Invalid tool invocation token");
      if ((i === M0 || i === wC) && !lt(e, "chatParticipantPrivate"))
        throw new Error(`Invalid tool: ${i}`);
      const o = await this._proxy.$invokeTool({
        toolId: i,
        callId: s,
        parameters: n.input,
        tokenBudget: n.tokenizationOptions?.tokenBudget,
        context: n.toolInvocationToken,
        chatRequestId: lt(e, "chatParticipantPrivate") ? n.chatRequestId : void 0,
        chatInteractionId: lt(e, "chatParticipantPrivate") ? n.chatInteractionId : void 0
      }, r), a = o instanceof zi ? o.value : o;
      return Bm.to(Fi(a));
    } finally {
      this._tokenCountFuncs.delete(s);
    }
  }
  $onDidChangeTools(e) {
    const i = new Set(this._registeredTools.keys());
    for (const n of e) {
      i.delete(n.id);
      const r = this._allTools.get(n.id);
      r ? r.update(n) : this._allTools.set(n.id, new NC(Fi(n)));
    }
    for (const n of i)
      this._allTools.delete(n);
  }
  getTools(e) {
    const i = lt(e, "chatParticipantPrivate");
    return Array.from(this._allTools.values()).map(
      (n) => i ? n.apiObjectWithChatParticipantAdditions : n.apiObject
    ).filter((n) => {
      switch (n.name) {
        case M0:
        case wC:
        case pU:
        case xU:
          return lt(e, "chatParticipantPrivate");
        default:
          return !0;
      }
    });
  }
  async $invokeTool(e, i) {
    const n = this._registeredTools.get(e.toolId);
    if (!n)
      throw new Error(`Unknown tool ${e.toolId}`);
    const r = {
      input: e.parameters,
      toolInvocationToken: e.context
    };
    lt(n.extension, "chatParticipantPrivate") && (r.chatRequestId = e.chatRequestId, r.chatInteractionId = e.chatInteractionId, r.chatSessionId = e.context?.sessionId), lt(n.extension, "chatParticipantAdditions") && e.modelId && (r.model = await this.getModel(e.modelId, n.extension)), e.tokenBudget !== void 0 && (r.tokenizationOptions = {
      tokenBudget: e.tokenBudget,
      countTokens: this._tokenCountFuncs.get(e.callId) || ((a, l = xt.None) => this._proxy.$countTokensForInvocation(e.callId, a, l))
    });
    let s;
    lt(n.extension, "toolProgress") && (s = {
      report: (a) => {
        this._proxy.$acceptToolProgress(e.callId, {
          message: Ae.fromStrict(a.message),
          increment: a.increment,
          total: 100
        });
      }
    });
    const o = await GR(Promise.resolve(n.tool.invoke(r, i, s)), i);
    if (!o)
      throw new zn();
    return Bm.from(o, n.extension);
  }
  async getModel(e, i) {
    let n;
    if (e && (n = await this._languageModels.getLanguageModelByIdentifier(i, e)), !n && (n = await this._languageModels.getDefaultLanguageModel(i), !n))
      throw new Error("Language model unavailable");
    return n;
  }
  async $prepareToolInvocation(e, i, n) {
    const r = this._registeredTools.get(e);
    if (!r)
      throw new Error(`Unknown tool ${e}`);
    const s = {
      input: i.parameters,
      chatRequestId: i.chatRequestId,
      chatSessionId: i.chatSessionId,
      chatInteractionId: i.chatInteractionId
    };
    if (r.tool.prepareInvocation) {
      const o = await r.tool.prepareInvocation(s, n);
      return o ? ((o.pastTenseMessage || o.presentation) && $(r.extension, "chatParticipantPrivate"), {
        confirmationMessages: o.confirmationMessages ? {
          title: typeof o.confirmationMessages.title == "string" ? o.confirmationMessages.title : Ae.from(o.confirmationMessages.title),
          message: typeof o.confirmationMessages.message == "string" ? o.confirmationMessages.message : Ae.from(o.confirmationMessages.message)
        } : void 0,
        invocationMessage: Ae.fromStrict(o.invocationMessage),
        pastTenseMessage: Ae.fromStrict(o.pastTenseMessage),
        presentation: o.presentation
      }) : void 0;
    }
  }
  registerTool(e, i, n) {
    return this._registeredTools.set(i, { extension: e, tool: n }), this._proxy.$registerTool(i), Ee(() => {
      this._registeredTools.delete(i), this._proxy.$unregisterTool(i);
    });
  }
}
class SU {
  constructor(e, i, n, r) {
    this._documents = i, this._commands = n, this._uriTransformer = r, this._languageIds = [], this._handlePool = 0, this._ids = /* @__PURE__ */ new Set(), this._proxy = e.getProxy(ee.MainThreadLanguages);
  }
  $acceptLanguageIds(e) {
    this._languageIds = e;
  }
  async getLanguages() {
    return this._languageIds.slice(0);
  }
  async changeLanguage(e, i) {
    await this._proxy.$changeLanguage(e, i);
    const n = this._documents.getDocumentData(e);
    if (!n)
      throw new Error(`document '${e.toString()}' NOT found`);
    return n.document;
  }
  async tokenAtPosition(e, i) {
    const n = e.version, r = at.from(i), s = await this._proxy.$tokensAtPosition(e.uri, r), o = {
      type: po.Other,
      range: e.getWordRangeAtPosition(i) ?? new Oe(i.line, i.character, i.line, i.character)
    };
    if (!s)
      return o;
    const a = {
      range: z.to(s.range),
      type: Cb.to(s.type)
    };
    return !a.range.contains(i) || n !== e.version ? o : a;
  }
  createLanguageStatusItem(e, i, n) {
    const r = this._handlePool++, s = this._proxy, o = this._ids, a = `${e.identifier.value}/${i}`;
    if (o.has(a))
      throw new Error(`LanguageStatusItem with id '${i}' ALREADY exists`);
    o.add(a);
    const l = {
      selector: n,
      id: i,
      name: e.displayName ?? e.name,
      severity: fc.Information,
      command: void 0,
      text: "",
      detail: "",
      busy: !1
    };
    let c;
    const u = new De(), d = () => {
      if (c?.dispose(), !o.has(a)) {
        console.warn(`LanguageStatusItem (${i}) from ${e.identifier.value} has been disposed and CANNOT be updated anymore`);
        return;
      }
      c = t8(() => {
        u.clear(), this._proxy.$setLanguageStatus(r, {
          id: a,
          name: l.name ?? e.displayName ?? e.name,
          source: e.displayName ?? e.name,
          selector: iu.from(l.selector, this._uriTransformer),
          label: l.text,
          detail: l.detail ?? "",
          severity: l.severity === fc.Error ? Qt.Error : l.severity === fc.Warning ? Qt.Warning : Qt.Info,
          command: l.command && this._commands.toInternal(l.command, u),
          accessibilityInfo: l.accessibilityInformation,
          busy: l.busy
        });
      }, 0);
    }, f = {
      dispose() {
        u.dispose(), c?.dispose(), s.$removeLanguageStatus(r), o.delete(a);
      },
      get id() {
        return l.id;
      },
      get name() {
        return l.name;
      },
      set name(g) {
        l.name = g, d();
      },
      get selector() {
        return l.selector;
      },
      set selector(g) {
        l.selector = g, d();
      },
      get text() {
        return l.text;
      },
      set text(g) {
        l.text = g, d();
      },
      set text2(g) {
        $(e, "languageStatusText"), l.text = g, d();
      },
      get text2() {
        return $(e, "languageStatusText"), l.text;
      },
      get detail() {
        return l.detail;
      },
      set detail(g) {
        l.detail = g, d();
      },
      get severity() {
        return l.severity;
      },
      set severity(g) {
        l.severity = g, d();
      },
      get accessibilityInformation() {
        return l.accessibilityInformation;
      },
      set accessibilityInformation(g) {
        l.accessibilityInformation = g, d();
      },
      get command() {
        return l.command;
      },
      set command(g) {
        l.command = g, d();
      },
      get busy() {
        return l.busy;
      },
      set busy(g) {
        l.busy = g, d();
      }
    };
    return d(), f;
  }
}
function DU(t) {
  return t && t.title;
}
let V0 = class {
  constructor(e, i) {
    this._logService = i, this._proxy = e.getProxy(ee.MainThreadMessageService);
  }
  showMessage(e, i, n, r, s) {
    const o = {
      source: { identifier: e.identifier, label: e.displayName || e.name }
    };
    let a;
    typeof r == "string" || DU(r) ? a = [r, ...s] : (o.modal = r?.modal, o.useCustom = r?.useCustom, o.detail = r?.detail, a = s), o.useCustom && $(e, "resolvers");
    const l = [];
    let c = !1;
    for (let u = 0; u < a.length; u++) {
      const d = a[u];
      if (typeof d == "string")
        l.push({ title: d, handle: u, isCloseAffordance: !1 });
      else if (typeof d == "object") {
        const { title: f, isCloseAffordance: g } = d;
        l.push({ title: f, isCloseAffordance: !!g, handle: u }), g && (c ? this._logService.warn(`[${e.identifier}] Only one message item can have 'isCloseAffordance':`, d) : c = !0);
      } else
        this._logService.warn(`[${e.identifier}] Invalid message item:`, d);
    }
    return this._proxy.$showMessage(i, n, o, l).then((u) => {
      if (typeof u == "number")
        return a[u];
    });
  }
};
V0 = W([
  M(1, nt)
], V0);
class ov {
  constructor(e, i, n, r) {
    this.start = e, this.deletedCount = i, this.deletedItems = n, this.items = r;
  }
  asApiEvent() {
    return {
      range: new Wr(this.start, this.start + this.deletedCount),
      addedCells: this.items.map((e) => e.apiCell),
      removedCells: this.deletedItems
    };
  }
}
class z0 {
  static asModelAddData(e) {
    return {
      EOL: e.eol,
      lines: e.source,
      languageId: e.language,
      uri: e.uri,
      isDirty: !1,
      versionId: 1,
      encoding: "utf8"
    };
  }
  constructor(e, i, n) {
    this.notebook = e, this._extHostDocument = i, this._cellData = n, this.handle = n.handle, this.uri = x.revive(n.uri), this.cellKind = n.cellKind, this._outputs = n.outputs.map(Po.to), this._internalMetadata = n.internalMetadata ?? {}, this._metadata = Object.freeze(n.metadata ?? {}), this._previousResult = Object.freeze(
      lu.to(n.internalMetadata ?? {})
    );
  }
  get internalMetadata() {
    return this._internalMetadata;
  }
  get apiCell() {
    if (!this._apiCell) {
      const e = this, i = this._extHostDocument.getDocument(this.uri);
      if (!i)
        throw new Error(`MISSING extHostDocument for notebook cell: ${this.uri}`);
      const n = {
        get index() {
          return e.notebook.getCellIndex(e);
        },
        notebook: e.notebook.apiNotebook,
        kind: $h.to(this._cellData.cellKind),
        document: i.document,
        get mime() {
          return e._mime;
        },
        set mime(r) {
          e._mime = r;
        },
        get outputs() {
          return e._outputs.slice(0);
        },
        get metadata() {
          return e._metadata;
        },
        get executionSummary() {
          return e._previousResult;
        }
      };
      this._apiCell = Object.freeze(n);
    }
    return this._apiCell;
  }
  setOutputs(e) {
    this._outputs = e.map(Po.to);
  }
  setOutputItems(e, i, n) {
    const r = n.map(uu.to), s = this._outputs.find((o) => o.id === e);
    if (s && (i || (s.items.length = 0), s.items.push(...r), s.items.length > 1 && s.items.every((o) => BT(o.mime)))) {
      const o = /* @__PURE__ */ new Map(), a = [];
      s.items.forEach((l) => {
        let c;
        o.has(l.mime) ? c = o.get(l.mime) : (c = [], o.set(l.mime, c), a.push(l.mime)), c.push(l.data);
      }), s.items.length = 0, a.forEach((l) => {
        const c = E9(o.get(l));
        s.items.push({
          mime: l,
          data: c.data.buffer
        });
      });
    }
  }
  setMetadata(e) {
    this._metadata = Object.freeze(e);
  }
  setInternalMetadata(e) {
    this._internalMetadata = e, this._previousResult = Object.freeze(lu.to(e));
  }
  setMime(e) {
  }
}
const C_ = class C_ {
  constructor(e, i, n, r, s) {
    this._proxy = e, this._textDocumentsAndEditors = i, this._textDocuments = n, this.uri = r, this.handle = C_._handlePool++, this._cells = [], this._versionId = 0, this._isDirty = !1, this._disposed = !1, this._notebookType = s.viewType, this._metadata = Object.freeze(s.metadata ?? /* @__PURE__ */ Object.create(null)), this._spliceNotebookCells([[0, 0, s.cells]], !0, void 0), this._versionId = s.versionId;
  }
  dispose() {
    this._disposed = !0;
  }
  get versionId() {
    return this._versionId;
  }
  get apiNotebook() {
    if (!this._notebook) {
      const e = this, i = {
        get uri() {
          return e.uri;
        },
        get version() {
          return e._versionId;
        },
        get notebookType() {
          return e._notebookType;
        },
        get isDirty() {
          return e._isDirty;
        },
        get isUntitled() {
          return e.uri.scheme === de.untitled;
        },
        get isClosed() {
          return e._disposed;
        },
        get metadata() {
          return e._metadata;
        },
        get cellCount() {
          return e._cells.length;
        },
        cellAt(n) {
          return n = e._validateIndex(n), e._cells[n].apiCell;
        },
        getCells(n) {
          return (n ? e._getCells(n) : e._cells).map((s) => s.apiCell);
        },
        save() {
          return e._save();
        },
        [Symbol.for("debug.description")]() {
          return `NotebookDocument(${this.uri.toString()})`;
        }
      };
      this._notebook = Object.freeze(i);
    }
    return this._notebook;
  }
  acceptDocumentPropertiesChanged(e) {
    e.metadata && (this._metadata = Object.freeze({ ...this._metadata, ...e.metadata }));
  }
  acceptDirty(e) {
    this._isDirty = e;
  }
  acceptModelChanged(e, i, n) {
    this._versionId = e.versionId, this._isDirty = i, this.acceptDocumentPropertiesChanged({ metadata: n });
    const r = {
      notebook: this.apiNotebook,
      metadata: n,
      cellChanges: [],
      contentChanges: []
    }, s = [];
    for (const a of e.rawEvents)
      a.kind === tr.ModelChange ? this._spliceNotebookCells(a.changes, !1, r.contentChanges) : a.kind === tr.Move ? this._moveCells(a.index, a.length, a.newIdx, r.contentChanges) : a.kind === tr.Output ? (this._setCellOutputs(a.index, a.outputs), s.push({ cell: this._cells[a.index].apiCell, outputs: this._cells[a.index].apiCell.outputs })) : a.kind === tr.OutputItem ? (this._setCellOutputItems(a.index, a.outputId, a.append, a.outputItems), s.push({ cell: this._cells[a.index].apiCell, outputs: this._cells[a.index].apiCell.outputs })) : a.kind === tr.ChangeCellLanguage ? (this._changeCellLanguage(a.index, a.language), s.push({ cell: this._cells[a.index].apiCell, document: this._cells[a.index].apiCell.document })) : a.kind === tr.ChangeCellContent ? s.push({ cell: this._cells[a.index].apiCell, document: this._cells[a.index].apiCell.document }) : a.kind === tr.ChangeCellMime ? this._changeCellMime(a.index, a.mime) : a.kind === tr.ChangeCellMetadata ? (this._changeCellMetadata(a.index, a.metadata), s.push({ cell: this._cells[a.index].apiCell, metadata: this._cells[a.index].apiCell.metadata })) : a.kind === tr.ChangeCellInternalMetadata && (this._changeCellInternalMetadata(a.index, a.internalMetadata), s.push({ cell: this._cells[a.index].apiCell, executionSummary: this._cells[a.index].apiCell.executionSummary }));
    const o = /* @__PURE__ */ new Map();
    for (let a = 0; a < s.length; a++) {
      const l = s[a], c = o.get(l.cell);
      if (c === void 0) {
        const u = r.cellChanges.push({
          document: void 0,
          executionSummary: void 0,
          metadata: void 0,
          outputs: void 0,
          ...l
        });
        o.set(l.cell, u - 1);
      } else
        r.cellChanges[c] = {
          ...r.cellChanges[c],
          ...l
        };
    }
    return r;
  }
  _validateIndex(e) {
    return e = e | 0, e < 0 ? 0 : e >= this._cells.length ? this._cells.length - 1 : e;
  }
  _validateRange(e) {
    let i = e.start | 0, n = e.end | 0;
    return i < 0 && (i = 0), n > this._cells.length && (n = this._cells.length), e.with({ start: i, end: n });
  }
  _getCells(e) {
    e = this._validateRange(e);
    const i = [];
    for (let n = e.start; n < e.end; n++)
      i.push(this._cells[n]);
    return i;
  }
  async _save() {
    return this._disposed ? Promise.reject(new Error("Notebook has been closed")) : this._proxy.$trySaveNotebook(this.uri);
  }
  _spliceNotebookCells(e, i, n) {
    if (this._disposed)
      return;
    const r = [], s = [], o = [];
    if (e.reverse().forEach((a) => {
      const c = a[2].map((f) => {
        const g = new z0(this, this._textDocumentsAndEditors, f);
        return i || s.push(z0.asModelAddData(f)), g;
      }), u = new ov(a[0], a[1], [], c), d = this._cells.splice(a[0], a[1], ...c);
      for (const f of d)
        o.push(f.uri), u.deletedItems.push(f.apiCell);
      r.push(u);
    }), this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
      addedDocuments: s,
      removedDocuments: o
    }), n)
      for (const a of r)
        n.push(a.asApiEvent());
  }
  _moveCells(e, i, n, r) {
    const s = this._cells.splice(e, i);
    this._cells.splice(n, 0, ...s);
    const o = [
      new ov(e, i, s.map((a) => a.apiCell), []),
      new ov(n, 0, [], s)
    ];
    for (const a of o)
      r.push(a.asApiEvent());
  }
  _setCellOutputs(e, i) {
    this._cells[e].setOutputs(i);
  }
  _setCellOutputItems(e, i, n, r) {
    this._cells[e].setOutputItems(i, n, r);
  }
  _changeCellLanguage(e, i) {
    const n = this._cells[e];
    n.apiCell.document.languageId !== i && this._textDocuments.$acceptModelLanguageChanged(n.uri, i);
  }
  _changeCellMime(e, i) {
    const n = this._cells[e];
    n.apiCell.mime = i;
  }
  _changeCellMetadata(e, i) {
    this._cells[e].setMetadata(i);
  }
  _changeCellInternalMetadata(e, i) {
    this._cells[e].setInternalMetadata(i);
  }
  getCellFromApiCell(e) {
    return this._cells.find((i) => i.apiCell === e);
  }
  getCellFromIndex(e) {
    return this._cells[e];
  }
  getCell(e) {
    return this._cells.find((i) => i.handle === e);
  }
  getCellIndex(e) {
    return this._cells.indexOf(e);
  }
};
C_._handlePool = 0;
let q0 = C_;
const T_ = class T_ {
  constructor(e, i, n, r, s, o, a) {
    this.id = e, this._proxy = i, this.notebookData = n, this._visibleRanges = r, this._selections = s, this._viewColumn = o, this.viewType = a, this._visible = !1;
  }
  get apiEditor() {
    if (!this._editor) {
      const e = this;
      this._editor = {
        get notebook() {
          return e.notebookData.apiNotebook;
        },
        get selection() {
          return e._selections[0];
        },
        set selection(i) {
          this.selections = [i];
        },
        get selections() {
          return e._selections;
        },
        set selections(i) {
          if (!Array.isArray(i) || !i.every(Wr.isNotebookRange))
            throw ze("selections");
          e._selections = i.length === 0 ? [new Wr(0, 0)] : i, e._trySetSelections(e._selections);
        },
        get visibleRanges() {
          return e._visibleRanges;
        },
        revealRange(i, n) {
          e._proxy.$tryRevealRange(e.id, Jr.from(i), n ?? Yg.Default);
        },
        get viewColumn() {
          return e._viewColumn;
        },
        get replOptions() {
          if (e.viewType === "repl")
            return { appendIndex: this.notebook.cellCount - 1 };
        },
        [Symbol.for("debug.description")]() {
          return `NotebookEditor(${this.notebook.uri.toString()})`;
        }
      }, T_.apiEditorsToExtHost.set(this._editor, this);
    }
    return this._editor;
  }
  get visible() {
    return this._visible;
  }
  _acceptVisibility(e) {
    this._visible = e;
  }
  _acceptVisibleRanges(e) {
    this._visibleRanges = e;
  }
  _acceptSelections(e) {
    this._selections = e;
  }
  _trySetSelections(e) {
    this._proxy.$trySetSelections(this.id, e.map(Jr.from));
  }
  _acceptViewColumn(e) {
    this._viewColumn = e;
  }
};
T_.apiEditorsToExtHost = /* @__PURE__ */ new WeakMap();
let rf = T_;
class j0 {
  constructor(e, i) {
    this.piece = e, this.color = i, this.size_left = 0, this.lf_left = 0, this.parent = this, this.left = this, this.right = this;
  }
  next() {
    if (this.right !== me)
      return RE(this.right);
    let e = this;
    for (; e.parent !== me && e.parent.left !== e; )
      e = e.parent;
    return e.parent === me ? me : e.parent;
  }
  prev() {
    if (this.left !== me)
      return F5(this.left);
    let e = this;
    for (; e.parent !== me && e.parent.right !== e; )
      e = e.parent;
    return e.parent === me ? me : e.parent;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
var $e;
(function(t) {
  t[t.Black = 0] = "Black", t[t.Red = 1] = "Red";
})($e || ($e = {}));
const me = new j0(null, $e.Black);
me.parent = me;
me.left = me;
me.right = me;
me.color = $e.Black;
function RE(t) {
  for (; t.left !== me; )
    t = t.left;
  return t;
}
function F5(t) {
  for (; t.right !== me; )
    t = t.right;
  return t;
}
function LE(t) {
  return t === me ? 0 : t.size_left + t.piece.length + LE(t.right);
}
function NE(t) {
  return t === me ? 0 : t.lf_left + t.piece.lineFeedCnt + NE(t.right);
}
function av() {
  me.parent = me;
}
function Pd(t, e) {
  const i = e.right;
  i.size_left += e.size_left + (e.piece ? e.piece.length : 0), i.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0), e.right = i.left, i.left !== me && (i.left.parent = e), i.parent = e.parent, e.parent === me ? t.root = i : e.parent.left === e ? e.parent.left = i : e.parent.right = i, i.left = e, e.parent = i;
}
function Ad(t, e) {
  const i = e.left;
  e.left = i.right, i.right !== me && (i.right.parent = e), i.parent = e.parent, e.size_left -= i.size_left + (i.piece ? i.piece.length : 0), e.lf_left -= i.lf_left + (i.piece ? i.piece.lineFeedCnt : 0), e.parent === me ? t.root = i : e === e.parent.right ? e.parent.right = i : e.parent.left = i, i.right = e, e.parent = i;
}
function Gf(t, e) {
  let i, n;
  if (e.left === me ? (n = e, i = n.right) : e.right === me ? (n = e, i = n.left) : (n = RE(e.right), i = n.right), n === t.root) {
    t.root = i, i.color = $e.Black, e.detach(), av(), t.root.parent = me;
    return;
  }
  const r = n.color === $e.Red;
  if (n === n.parent.left ? n.parent.left = i : n.parent.right = i, n === e ? (i.parent = n.parent, td(t, i)) : (n.parent === e ? i.parent = n : i.parent = n.parent, td(t, i), n.left = e.left, n.right = e.right, n.parent = e.parent, n.color = e.color, e === t.root ? t.root = n : e === e.parent.left ? e.parent.left = n : e.parent.right = n, n.left !== me && (n.left.parent = n), n.right !== me && (n.right.parent = n), n.size_left = e.size_left, n.lf_left = e.lf_left, td(t, n)), e.detach(), i.parent.left === i) {
    const o = LE(i), a = NE(i);
    if (o !== i.parent.size_left || a !== i.parent.lf_left) {
      const l = o - i.parent.size_left, c = a - i.parent.lf_left;
      i.parent.size_left = o, i.parent.lf_left = a, cs(t, i.parent, l, c);
    }
  }
  if (td(t, i.parent), r) {
    av();
    return;
  }
  let s;
  for (; i !== t.root && i.color === $e.Black; )
    i === i.parent.left ? (s = i.parent.right, s.color === $e.Red && (s.color = $e.Black, i.parent.color = $e.Red, Pd(t, i.parent), s = i.parent.right), s.left.color === $e.Black && s.right.color === $e.Black ? (s.color = $e.Red, i = i.parent) : (s.right.color === $e.Black && (s.left.color = $e.Black, s.color = $e.Red, Ad(t, s), s = i.parent.right), s.color = i.parent.color, i.parent.color = $e.Black, s.right.color = $e.Black, Pd(t, i.parent), i = t.root)) : (s = i.parent.left, s.color === $e.Red && (s.color = $e.Black, i.parent.color = $e.Red, Ad(t, i.parent), s = i.parent.left), s.left.color === $e.Black && s.right.color === $e.Black ? (s.color = $e.Red, i = i.parent) : (s.left.color === $e.Black && (s.right.color = $e.Black, s.color = $e.Red, Pd(t, s), s = i.parent.left), s.color = i.parent.color, i.parent.color = $e.Black, s.left.color = $e.Black, Ad(t, i.parent), i = t.root));
  i.color = $e.Black, av();
}
function MC(t, e) {
  for (td(t, e); e !== t.root && e.parent.color === $e.Red; )
    if (e.parent === e.parent.parent.left) {
      const i = e.parent.parent.right;
      i.color === $e.Red ? (e.parent.color = $e.Black, i.color = $e.Black, e.parent.parent.color = $e.Red, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, Pd(t, e)), e.parent.color = $e.Black, e.parent.parent.color = $e.Red, Ad(t, e.parent.parent));
    } else {
      const i = e.parent.parent.left;
      i.color === $e.Red ? (e.parent.color = $e.Black, i.color = $e.Black, e.parent.parent.color = $e.Red, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, Ad(t, e)), e.parent.color = $e.Black, e.parent.parent.color = $e.Red, Pd(t, e.parent.parent));
    }
  t.root.color = $e.Black;
}
function cs(t, e, i, n) {
  for (; e !== t.root && e !== me; )
    e.parent.left === e && (e.parent.size_left += i, e.parent.lf_left += n), e = e.parent;
}
function td(t, e) {
  let i = 0, n = 0;
  if (e !== t.root) {
    for (; e !== t.root && e === e.parent.right; )
      e = e.parent;
    if (e !== t.root)
      for (e = e.parent, i = LE(e.left) - e.size_left, n = NE(e.left) - e.lf_left, e.size_left += i, e.lf_left += n; e !== t.root && (i !== 0 || n !== 0); )
        e.parent.left === e && (e.parent.size_left += i, e.parent.lf_left += n), e = e.parent;
  }
}
const rs = 65535;
function U5(t) {
  let e;
  return t[t.length - 1] < 65536 ? e = new Uint16Array(t.length) : e = new Uint32Array(t.length), e.set(t, 0), e;
}
class kU {
  constructor(e, i, n, r, s) {
    this.lineStarts = e, this.cr = i, this.lf = n, this.crlf = r, this.isBasicASCII = s;
  }
}
function gs(t, e = !0) {
  const i = [0];
  let n = 1;
  for (let r = 0, s = t.length; r < s; r++) {
    const o = t.charCodeAt(r);
    o === L.CarriageReturn ? r + 1 < s && t.charCodeAt(r + 1) === L.LineFeed ? (i[n++] = r + 2, r++) : i[n++] = r + 1 : o === L.LineFeed && (i[n++] = r + 1);
  }
  return e ? U5(i) : i;
}
function IU(t, e) {
  t.length = 0, t[0] = 0;
  let i = 1, n = 0, r = 0, s = 0, o = !0;
  for (let l = 0, c = e.length; l < c; l++) {
    const u = e.charCodeAt(l);
    u === L.CarriageReturn ? l + 1 < c && e.charCodeAt(l + 1) === L.LineFeed ? (s++, t[i++] = l + 2, l++) : (n++, t[i++] = l + 1) : u === L.LineFeed ? (r++, t[i++] = l + 1) : o && u !== L.Tab && (u < 32 || u > 126) && (o = !1);
  }
  const a = new kU(U5(t), n, r, s, o);
  return t.length = 0, a;
}
class Ki {
  constructor(e, i, n, r, s) {
    this.bufferIndex = e, this.start = i, this.end = n, this.lineFeedCnt = r, this.length = s;
  }
}
class ta {
  constructor(e, i) {
    this.buffer = e, this.lineStarts = i;
  }
}
class CU {
  constructor(e, i) {
    this._pieces = [], this._tree = e, this._BOM = i, this._index = 0, e.root !== me && e.iterate(e.root, (n) => (n !== me && this._pieces.push(n.piece), !0));
  }
  read() {
    return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
  }
}
class TU {
  constructor(e) {
    this._limit = e, this._cache = [];
  }
  get(e) {
    for (let i = this._cache.length - 1; i >= 0; i--) {
      const n = this._cache[i];
      if (n.nodeStartOffset <= e && n.nodeStartOffset + n.node.piece.length >= e)
        return n;
    }
    return null;
  }
  get2(e) {
    for (let i = this._cache.length - 1; i >= 0; i--) {
      const n = this._cache[i];
      if (n.nodeStartLineNumber && n.nodeStartLineNumber < e && n.nodeStartLineNumber + n.node.piece.lineFeedCnt >= e)
        return n;
    }
    return null;
  }
  set(e) {
    this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e);
  }
  validate(e) {
    let i = !1;
    const n = this._cache;
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      if (s.node.parent === null || s.nodeStartOffset >= e) {
        n[r] = null, i = !0;
        continue;
      }
    }
    if (i) {
      const r = [];
      for (const s of n)
        s !== null && r.push(s);
      this._cache = r;
    }
  }
}
class PU {
  constructor(e, i, n) {
    this.create(e, i, n);
  }
  create(e, i, n) {
    this._buffers = [
      new ta("", [0])
    ], this._lastChangeBufferPos = { line: 0, column: 0 }, this.root = me, this._lineCnt = 1, this._length = 0, this._EOL = i, this._EOLLength = i.length, this._EOLNormalized = n;
    let r = null;
    for (let s = 0, o = e.length; s < o; s++)
      if (e[s].buffer.length > 0) {
        e[s].lineStarts || (e[s].lineStarts = gs(e[s].buffer));
        const a = new Ki(
          s + 1,
          { line: 0, column: 0 },
          { line: e[s].lineStarts.length - 1, column: e[s].buffer.length - e[s].lineStarts[e[s].lineStarts.length - 1] },
          e[s].lineStarts.length - 1,
          e[s].buffer.length
        );
        this._buffers.push(e[s]), r = this.rbInsertRight(r, a);
      }
    this._searchCache = new TU(1), this._lastVisitedLine = { lineNumber: 0, value: "" }, this.computeBufferMetadata();
  }
  normalizeEOL(e) {
    const i = rs, n = i - Math.floor(i / 3), r = n * 2;
    let s = "", o = 0;
    const a = [];
    if (this.iterate(this.root, (l) => {
      const c = this.getNodeContent(l), u = c.length;
      if (o <= n || o + u < r)
        return s += c, o += u, !0;
      const d = s.replace(/\r\n|\r|\n/g, e);
      return a.push(new ta(d, gs(d))), s = c, o = u, !0;
    }), o > 0) {
      const l = s.replace(/\r\n|\r|\n/g, e);
      a.push(new ta(l, gs(l)));
    }
    this.create(a, e, !0);
  }
  getEOL() {
    return this._EOL;
  }
  setEOL(e) {
    this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e);
  }
  createSnapshot(e) {
    return new CU(this, e);
  }
  equal(e) {
    if (this.getLength() !== e.getLength() || this.getLineCount() !== e.getLineCount())
      return !1;
    let i = 0;
    return this.iterate(this.root, (r) => {
      if (r === me)
        return !0;
      const s = this.getNodeContent(r), o = s.length, a = e.nodeAt(i), l = e.nodeAt(i + o), c = e.getValueInRange2(a, l);
      return i += o, s === c;
    });
  }
  getOffsetAt(e, i) {
    let n = 0, r = this.root;
    for (; r !== me; )
      if (r.left !== me && r.lf_left + 1 >= e)
        r = r.left;
      else if (r.lf_left + r.piece.lineFeedCnt + 1 >= e) {
        n += r.size_left;
        const s = this.getAccumulatedValue(r, e - r.lf_left - 2);
        return n += s + i - 1;
      } else
        e -= r.lf_left + r.piece.lineFeedCnt, n += r.size_left + r.piece.length, r = r.right;
    return n;
  }
  getPositionAt(e) {
    e = Math.floor(e), e = Math.max(0, e);
    let i = this.root, n = 0;
    const r = e;
    for (; i !== me; )
      if (i.size_left !== 0 && i.size_left >= e)
        i = i.left;
      else if (i.size_left + i.piece.length >= e) {
        const s = this.getIndexOf(i, e - i.size_left);
        if (n += i.lf_left + s.index, s.index === 0) {
          const o = this.getOffsetAt(n + 1, 1), a = r - o;
          return new Pn(n + 1, a + 1);
        }
        return new Pn(n + 1, s.remainder + 1);
      } else if (e -= i.size_left + i.piece.length, n += i.lf_left + i.piece.lineFeedCnt, i.right === me) {
        const s = this.getOffsetAt(n + 1, 1), o = r - e - s;
        return new Pn(n + 1, o + 1);
      } else
        i = i.right;
    return new Pn(1, 1);
  }
  getValueInRange(e, i) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return "";
    const n = this.nodeAt2(e.startLineNumber, e.startColumn), r = this.nodeAt2(e.endLineNumber, e.endColumn), s = this.getValueInRange2(n, r);
    return i ? i !== this._EOL || !this._EOLNormalized ? s.replace(/\r\n|\r|\n/g, i) : i === this.getEOL() && this._EOLNormalized ? s : s.replace(/\r\n|\r|\n/g, i) : s;
  }
  getValueInRange2(e, i) {
    if (e.node === i.node) {
      const a = e.node, l = this._buffers[a.piece.bufferIndex].buffer, c = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start);
      return l.substring(c + e.remainder, c + i.remainder);
    }
    let n = e.node;
    const r = this._buffers[n.piece.bufferIndex].buffer, s = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
    let o = r.substring(s + e.remainder, s + n.piece.length);
    for (n = n.next(); n !== me; ) {
      const a = this._buffers[n.piece.bufferIndex].buffer, l = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
      if (n === i.node) {
        o += a.substring(l, l + i.remainder);
        break;
      } else
        o += a.substr(l, n.piece.length);
      n = n.next();
    }
    return o;
  }
  getLinesContent() {
    const e = [];
    let i = 0, n = "", r = !1;
    return this.iterate(this.root, (s) => {
      if (s === me)
        return !0;
      const o = s.piece;
      let a = o.length;
      if (a === 0)
        return !0;
      const l = this._buffers[o.bufferIndex].buffer, c = this._buffers[o.bufferIndex].lineStarts, u = o.start.line, d = o.end.line;
      let f = c[u] + o.start.column;
      if (r && (l.charCodeAt(f) === L.LineFeed && (f++, a--), e[i++] = n, n = "", r = !1, a === 0))
        return !0;
      if (u === d)
        return !this._EOLNormalized && l.charCodeAt(f + a - 1) === L.CarriageReturn ? (r = !0, n += l.substr(f, a - 1)) : n += l.substr(f, a), !0;
      n += this._EOLNormalized ? l.substring(f, Math.max(f, c[u + 1] - this._EOLLength)) : l.substring(f, c[u + 1]).replace(/(\r\n|\r|\n)$/, ""), e[i++] = n;
      for (let g = u + 1; g < d; g++)
        n = this._EOLNormalized ? l.substring(c[g], c[g + 1] - this._EOLLength) : l.substring(c[g], c[g + 1]).replace(/(\r\n|\r|\n)$/, ""), e[i++] = n;
      return !this._EOLNormalized && l.charCodeAt(c[d] + o.end.column - 1) === L.CarriageReturn ? (r = !0, o.end.column === 0 ? i-- : n = l.substr(c[d], o.end.column - 1)) : n = l.substr(c[d], o.end.column), !0;
    }), r && (e[i++] = n, n = ""), e[i++] = n, e;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(e) {
    return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, ""), this._lastVisitedLine.value);
  }
  _getCharCode(e) {
    if (e.remainder === e.node.piece.length) {
      const i = e.node.next();
      if (!i)
        return 0;
      const n = this._buffers[i.piece.bufferIndex], r = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      return n.buffer.charCodeAt(r);
    } else {
      const i = this._buffers[e.node.piece.bufferIndex], r = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
      return i.buffer.charCodeAt(r);
    }
  }
  getLineCharCode(e, i) {
    const n = this.nodeAt2(e, i + 1);
    return this._getCharCode(n);
  }
  getLineLength(e) {
    if (e === this.getLineCount()) {
      const i = this.getOffsetAt(e, 1);
      return this.getLength() - i;
    }
    return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength;
  }
  getCharCode(e) {
    const i = this.nodeAt(e);
    return this._getCharCode(i);
  }
  getNearestChunk(e) {
    const i = this.nodeAt(e);
    if (i.remainder === i.node.piece.length) {
      const n = i.node.next();
      if (!n || n === me)
        return "";
      const r = this._buffers[n.piece.bufferIndex], s = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
      return r.buffer.substring(s, s + n.piece.length);
    } else {
      const n = this._buffers[i.node.piece.bufferIndex], r = this.offsetInBuffer(i.node.piece.bufferIndex, i.node.piece.start), s = r + i.remainder, o = r + i.node.piece.length;
      return n.buffer.substring(s, o);
    }
  }
  findMatchesInNode(e, i, n, r, s, o, a, l, c, u, d) {
    const f = this._buffers[e.piece.bufferIndex], g = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start), _ = this.offsetInBuffer(e.piece.bufferIndex, s), w = this.offsetInBuffer(e.piece.bufferIndex, o);
    let v;
    const S = { line: 0, column: 0 };
    let E, A;
    i._wordSeparators ? (E = f.buffer.substring(_, w), A = (j) => j + _, i.reset(0)) : (E = f.buffer, A = (j) => j, i.reset(_));
    do
      if (v = i.next(E), v) {
        if (A(v.index) >= w)
          return u;
        this.positionInBuffer(e, A(v.index) - g, S);
        const j = this.getLineFeedCnt(e.piece.bufferIndex, s, S), V = S.line === s.line ? S.column - s.column + r : S.column + 1, le = V + v[0].length;
        if (d[u++] = vI(new ut(
          n + j,
          V,
          n + j,
          le
        ), v, l), A(v.index) + v[0].length >= w || u >= c)
          return u;
      }
    while (v);
    return u;
  }
  findMatchesLineByLine(e, i, n, r) {
    const s = [];
    let o = 0;
    const a = new vM(i.wordSeparators, i.regex);
    let l = this.nodeAt2(e.startLineNumber, e.startColumn);
    if (l === null)
      return [];
    const c = this.nodeAt2(e.endLineNumber, e.endColumn);
    if (c === null)
      return [];
    let u = this.positionInBuffer(l.node, l.remainder);
    const d = this.positionInBuffer(c.node, c.remainder);
    if (l.node === c.node)
      return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, u, d, i, n, r, o, s), s;
    let f = e.startLineNumber, g = l.node;
    for (; g !== c.node; ) {
      const w = this.getLineFeedCnt(g.piece.bufferIndex, u, g.piece.end);
      if (w >= 1) {
        const S = this._buffers[g.piece.bufferIndex].lineStarts, E = this.offsetInBuffer(g.piece.bufferIndex, g.piece.start), A = S[u.line + w], j = f === e.startLineNumber ? e.startColumn : 1;
        if (o = this.findMatchesInNode(g, a, f, j, u, this.positionInBuffer(g, A - E), i, n, r, o, s), o >= r)
          return s;
        f += w;
      }
      const v = f === e.startLineNumber ? e.startColumn - 1 : 0;
      if (f === e.endLineNumber) {
        const S = this.getLineContent(f).substring(v, e.endColumn - 1);
        return o = this._findMatchesInLine(i, a, S, e.endLineNumber, v, o, s, n, r), s;
      }
      if (o = this._findMatchesInLine(i, a, this.getLineContent(f).substr(v), f, v, o, s, n, r), o >= r)
        return s;
      f++, l = this.nodeAt2(f, 1), g = l.node, u = this.positionInBuffer(l.node, l.remainder);
    }
    if (f === e.endLineNumber) {
      const w = f === e.startLineNumber ? e.startColumn - 1 : 0, v = this.getLineContent(f).substring(w, e.endColumn - 1);
      return o = this._findMatchesInLine(i, a, v, e.endLineNumber, w, o, s, n, r), s;
    }
    const _ = f === e.startLineNumber ? e.startColumn : 1;
    return o = this.findMatchesInNode(c.node, a, f, _, u, d, i, n, r, o, s), s;
  }
  _findMatchesInLine(e, i, n, r, s, o, a, l, c) {
    const u = e.wordSeparators;
    if (!l && e.simpleSearch) {
      const f = e.simpleSearch, g = f.length, _ = n.length;
      let w = -g;
      for (; (w = n.indexOf(f, w + g)) !== -1; )
        if ((!u || r5(u, n, _, w, g)) && (a[o++] = new Kv(new ut(
          r,
          w + 1 + s,
          r,
          w + 1 + g + s
        ), null), o >= c))
          return o;
      return o;
    }
    let d;
    i.reset(0);
    do
      if (d = i.next(n), d && (a[o++] = vI(new ut(
        r,
        d.index + 1 + s,
        r,
        d.index + 1 + d[0].length + s
      ), d, l), o >= c))
        return o;
    while (d);
    return o;
  }
  insert(e, i, n = !1) {
    if (this._EOLNormalized = this._EOLNormalized && n, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== me) {
      const { node: r, remainder: s, nodeStartOffset: o } = this.nodeAt(e), a = r.piece, l = a.bufferIndex, c = this.positionInBuffer(r, s);
      if (r.piece.bufferIndex === 0 && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && o + a.length === e && i.length < rs) {
        this.appendToNode(r, i), this.computeBufferMetadata();
        return;
      }
      if (o === e)
        this.insertContentToNodeLeft(i, r), this._searchCache.validate(e);
      else if (o + r.piece.length > e) {
        const u = [];
        let d = new Ki(
          a.bufferIndex,
          c,
          a.end,
          this.getLineFeedCnt(a.bufferIndex, c, a.end),
          this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, c)
        );
        if (this.shouldCheckCRLF() && this.endWithCR(i) && this.nodeCharCodeAt(r, s) === 10) {
          const w = { line: d.start.line + 1, column: 0 };
          d = new Ki(
            d.bufferIndex,
            w,
            d.end,
            this.getLineFeedCnt(d.bufferIndex, w, d.end),
            d.length - 1
          ), i += `
`;
        }
        if (this.shouldCheckCRLF() && this.startWithLF(i))
          if (this.nodeCharCodeAt(r, s - 1) === 13) {
            const w = this.positionInBuffer(r, s - 1);
            this.deleteNodeTail(r, w), i = "\r" + i, r.piece.length === 0 && u.push(r);
          } else
            this.deleteNodeTail(r, c);
        else
          this.deleteNodeTail(r, c);
        const f = this.createNewPieces(i);
        d.length > 0 && this.rbInsertRight(r, d);
        let g = r;
        for (let _ = 0; _ < f.length; _++)
          g = this.rbInsertRight(g, f[_]);
        this.deleteNodes(u);
      } else
        this.insertContentToNodeRight(i, r);
    } else {
      const r = this.createNewPieces(i);
      let s = this.rbInsertLeft(null, r[0]);
      for (let o = 1; o < r.length; o++)
        s = this.rbInsertRight(s, r[o]);
    }
    this.computeBufferMetadata();
  }
  delete(e, i) {
    if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", i <= 0 || this.root === me)
      return;
    const n = this.nodeAt(e), r = this.nodeAt(e + i), s = n.node, o = r.node;
    if (s === o) {
      const f = this.positionInBuffer(s, n.remainder), g = this.positionInBuffer(s, r.remainder);
      if (n.nodeStartOffset === e) {
        if (i === s.piece.length) {
          const _ = s.next();
          Gf(this, s), this.validateCRLFWithPrevNode(_), this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(s, g), this._searchCache.validate(e), this.validateCRLFWithPrevNode(s), this.computeBufferMetadata();
        return;
      }
      if (n.nodeStartOffset + s.piece.length === e + i) {
        this.deleteNodeTail(s, f), this.validateCRLFWithNextNode(s), this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(s, f, g), this.computeBufferMetadata();
      return;
    }
    const a = [], l = this.positionInBuffer(s, n.remainder);
    this.deleteNodeTail(s, l), this._searchCache.validate(e), s.piece.length === 0 && a.push(s);
    const c = this.positionInBuffer(o, r.remainder);
    this.deleteNodeHead(o, c), o.piece.length === 0 && a.push(o);
    const u = s.next();
    for (let f = u; f !== me && f !== o; f = f.next())
      a.push(f);
    const d = s.piece.length === 0 ? s.prev() : s;
    this.deleteNodes(a), this.validateCRLFWithNextNode(d), this.computeBufferMetadata();
  }
  insertContentToNodeLeft(e, i) {
    const n = [];
    if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(i)) {
      const o = i.piece, a = { line: o.start.line + 1, column: 0 }, l = new Ki(
        o.bufferIndex,
        a,
        o.end,
        this.getLineFeedCnt(o.bufferIndex, a, o.end),
        o.length - 1
      );
      i.piece = l, e += `
`, cs(this, i, -1, -1), i.piece.length === 0 && n.push(i);
    }
    const r = this.createNewPieces(e);
    let s = this.rbInsertLeft(i, r[r.length - 1]);
    for (let o = r.length - 2; o >= 0; o--)
      s = this.rbInsertLeft(s, r[o]);
    this.validateCRLFWithPrevNode(s), this.deleteNodes(n);
  }
  insertContentToNodeRight(e, i) {
    this.adjustCarriageReturnFromNext(e, i) && (e += `
`);
    const n = this.createNewPieces(e), r = this.rbInsertRight(i, n[0]);
    let s = r;
    for (let o = 1; o < n.length; o++)
      s = this.rbInsertRight(s, n[o]);
    this.validateCRLFWithPrevNode(r);
  }
  positionInBuffer(e, i, n) {
    const r = e.piece, s = e.piece.bufferIndex, o = this._buffers[s].lineStarts, l = o[r.start.line] + r.start.column + i;
    let c = r.start.line, u = r.end.line, d = 0, f = 0, g = 0;
    for (; c <= u && (d = c + (u - c) / 2 | 0, g = o[d], d !== u); )
      if (f = o[d + 1], l < g)
        u = d - 1;
      else if (l >= f)
        c = d + 1;
      else
        break;
    return n ? (n.line = d, n.column = l - g, null) : {
      line: d,
      column: l - g
    };
  }
  getLineFeedCnt(e, i, n) {
    if (n.column === 0)
      return n.line - i.line;
    const r = this._buffers[e].lineStarts;
    if (n.line === r.length - 1)
      return n.line - i.line;
    const s = r[n.line + 1], o = r[n.line] + n.column;
    if (s > o + 1)
      return n.line - i.line;
    const a = o - 1;
    return this._buffers[e].buffer.charCodeAt(a) === 13 ? n.line - i.line + 1 : n.line - i.line;
  }
  offsetInBuffer(e, i) {
    return this._buffers[e].lineStarts[i.line] + i.column;
  }
  deleteNodes(e) {
    for (let i = 0; i < e.length; i++)
      Gf(this, e[i]);
  }
  createNewPieces(e) {
    if (e.length > rs) {
      const u = [];
      for (; e.length > rs; ) {
        const f = e.charCodeAt(rs - 1);
        let g;
        f === L.CarriageReturn || f >= 55296 && f <= 56319 ? (g = e.substring(0, rs - 1), e = e.substring(rs - 1)) : (g = e.substring(0, rs), e = e.substring(rs));
        const _ = gs(g);
        u.push(new Ki(
          this._buffers.length,
          { line: 0, column: 0 },
          { line: _.length - 1, column: g.length - _[_.length - 1] },
          _.length - 1,
          g.length
        )), this._buffers.push(new ta(g, _));
      }
      const d = gs(e);
      return u.push(new Ki(
        this._buffers.length,
        { line: 0, column: 0 },
        { line: d.length - 1, column: e.length - d[d.length - 1] },
        d.length - 1,
        e.length
      )), this._buffers.push(new ta(e, d)), u;
    }
    let i = this._buffers[0].buffer.length;
    const n = gs(e, !1);
    let r = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === i && i !== 0 && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 }, r = this._lastChangeBufferPos;
      for (let u = 0; u < n.length; u++)
        n[u] += i + 1;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(n.slice(1)), this._buffers[0].buffer += "_" + e, i += 1;
    } else {
      if (i !== 0)
        for (let u = 0; u < n.length; u++)
          n[u] += i;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(n.slice(1)), this._buffers[0].buffer += e;
    }
    const s = this._buffers[0].buffer.length, o = this._buffers[0].lineStarts.length - 1, a = s - this._buffers[0].lineStarts[o], l = { line: o, column: a }, c = new Ki(
      0,
      r,
      l,
      this.getLineFeedCnt(0, r, l),
      s - i
    );
    return this._lastChangeBufferPos = l, [c];
  }
  getLinesRawContent() {
    return this.getContentOfSubTree(this.root);
  }
  getLineRawContent(e, i = 0) {
    let n = this.root, r = "";
    const s = this._searchCache.get2(e);
    if (s) {
      n = s.node;
      const o = this.getAccumulatedValue(n, e - s.nodeStartLineNumber - 1), a = this._buffers[n.piece.bufferIndex].buffer, l = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
      if (s.nodeStartLineNumber + n.piece.lineFeedCnt === e)
        r = a.substring(l + o, l + n.piece.length);
      else {
        const c = this.getAccumulatedValue(n, e - s.nodeStartLineNumber);
        return a.substring(l + o, l + c - i);
      }
    } else {
      let o = 0;
      const a = e;
      for (; n !== me; )
        if (n.left !== me && n.lf_left >= e - 1)
          n = n.left;
        else if (n.lf_left + n.piece.lineFeedCnt > e - 1) {
          const l = this.getAccumulatedValue(n, e - n.lf_left - 2), c = this.getAccumulatedValue(n, e - n.lf_left - 1), u = this._buffers[n.piece.bufferIndex].buffer, d = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
          return o += n.size_left, this._searchCache.set({
            node: n,
            nodeStartOffset: o,
            nodeStartLineNumber: a - (e - 1 - n.lf_left)
          }), u.substring(d + l, d + c - i);
        } else if (n.lf_left + n.piece.lineFeedCnt === e - 1) {
          const l = this.getAccumulatedValue(n, e - n.lf_left - 2), c = this._buffers[n.piece.bufferIndex].buffer, u = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
          r = c.substring(u + l, u + n.piece.length);
          break;
        } else
          e -= n.lf_left + n.piece.lineFeedCnt, o += n.size_left + n.piece.length, n = n.right;
    }
    for (n = n.next(); n !== me; ) {
      const o = this._buffers[n.piece.bufferIndex].buffer;
      if (n.piece.lineFeedCnt > 0) {
        const a = this.getAccumulatedValue(n, 0), l = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
        return r += o.substring(l, l + a - i), r;
      } else {
        const a = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
        r += o.substr(a, n.piece.length);
      }
      n = n.next();
    }
    return r;
  }
  computeBufferMetadata() {
    let e = this.root, i = 1, n = 0;
    for (; e !== me; )
      i += e.lf_left + e.piece.lineFeedCnt, n += e.size_left + e.piece.length, e = e.right;
    this._lineCnt = i, this._length = n, this._searchCache.validate(this._length);
  }
  getIndexOf(e, i) {
    const n = e.piece, r = this.positionInBuffer(e, i), s = r.line - n.start.line;
    if (this.offsetInBuffer(n.bufferIndex, n.end) - this.offsetInBuffer(n.bufferIndex, n.start) === i) {
      const o = this.getLineFeedCnt(e.piece.bufferIndex, n.start, r);
      if (o !== s)
        return { index: o, remainder: 0 };
    }
    return { index: s, remainder: r.column };
  }
  getAccumulatedValue(e, i) {
    if (i < 0)
      return 0;
    const n = e.piece, r = this._buffers[n.bufferIndex].lineStarts, s = n.start.line + i + 1;
    return s > n.end.line ? r[n.end.line] + n.end.column - r[n.start.line] - n.start.column : r[s] - r[n.start.line] - n.start.column;
  }
  deleteNodeTail(e, i) {
    const n = e.piece, r = n.lineFeedCnt, s = this.offsetInBuffer(n.bufferIndex, n.end), o = i, a = this.offsetInBuffer(n.bufferIndex, o), l = this.getLineFeedCnt(n.bufferIndex, n.start, o), c = l - r, u = a - s, d = n.length + u;
    e.piece = new Ki(n.bufferIndex, n.start, o, l, d), cs(this, e, u, c);
  }
  deleteNodeHead(e, i) {
    const n = e.piece, r = n.lineFeedCnt, s = this.offsetInBuffer(n.bufferIndex, n.start), o = i, a = this.getLineFeedCnt(n.bufferIndex, o, n.end), l = this.offsetInBuffer(n.bufferIndex, o), c = a - r, u = s - l, d = n.length + u;
    e.piece = new Ki(n.bufferIndex, o, n.end, a, d), cs(this, e, u, c);
  }
  shrinkNode(e, i, n) {
    const r = e.piece, s = r.start, o = r.end, a = r.length, l = r.lineFeedCnt, c = i, u = this.getLineFeedCnt(r.bufferIndex, r.start, c), d = this.offsetInBuffer(r.bufferIndex, i) - this.offsetInBuffer(r.bufferIndex, s);
    e.piece = new Ki(r.bufferIndex, r.start, c, u, d), cs(this, e, d - a, u - l);
    const f = new Ki(
      r.bufferIndex,
      n,
      o,
      this.getLineFeedCnt(r.bufferIndex, n, o),
      this.offsetInBuffer(r.bufferIndex, o) - this.offsetInBuffer(r.bufferIndex, n)
    ), g = this.rbInsertRight(e, f);
    this.validateCRLFWithPrevNode(g);
  }
  appendToNode(e, i) {
    this.adjustCarriageReturnFromNext(i, e) && (i += `
`);
    const n = this.shouldCheckCRLF() && this.startWithLF(i) && this.endWithCR(e), r = this._buffers[0].buffer.length;
    this._buffers[0].buffer += i;
    const s = gs(i, !1);
    for (let g = 0; g < s.length; g++)
      s[g] += r;
    if (n) {
      const g = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: r - g };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(s.slice(1));
    const o = this._buffers[0].lineStarts.length - 1, a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[o], l = { line: o, column: a }, c = e.piece.length + i.length, u = e.piece.lineFeedCnt, d = this.getLineFeedCnt(0, e.piece.start, l), f = d - u;
    e.piece = new Ki(
      e.piece.bufferIndex,
      e.piece.start,
      l,
      d,
      c
    ), this._lastChangeBufferPos = l, cs(this, e, i.length, f);
  }
  nodeAt(e) {
    let i = this.root;
    const n = this._searchCache.get(e);
    if (n)
      return {
        node: n.node,
        nodeStartOffset: n.nodeStartOffset,
        remainder: e - n.nodeStartOffset
      };
    let r = 0;
    for (; i !== me; )
      if (i.size_left > e)
        i = i.left;
      else if (i.size_left + i.piece.length >= e) {
        r += i.size_left;
        const s = {
          node: i,
          remainder: e - i.size_left,
          nodeStartOffset: r
        };
        return this._searchCache.set(s), s;
      } else
        e -= i.size_left + i.piece.length, r += i.size_left + i.piece.length, i = i.right;
    return null;
  }
  nodeAt2(e, i) {
    let n = this.root, r = 0;
    for (; n !== me; )
      if (n.left !== me && n.lf_left >= e - 1)
        n = n.left;
      else if (n.lf_left + n.piece.lineFeedCnt > e - 1) {
        const s = this.getAccumulatedValue(n, e - n.lf_left - 2), o = this.getAccumulatedValue(n, e - n.lf_left - 1);
        return r += n.size_left, {
          node: n,
          remainder: Math.min(s + i - 1, o),
          nodeStartOffset: r
        };
      } else if (n.lf_left + n.piece.lineFeedCnt === e - 1) {
        const s = this.getAccumulatedValue(n, e - n.lf_left - 2);
        if (s + i - 1 <= n.piece.length)
          return {
            node: n,
            remainder: s + i - 1,
            nodeStartOffset: r
          };
        i -= n.piece.length - s;
        break;
      } else
        e -= n.lf_left + n.piece.lineFeedCnt, r += n.size_left + n.piece.length, n = n.right;
    for (n = n.next(); n !== me; ) {
      if (n.piece.lineFeedCnt > 0) {
        const s = this.getAccumulatedValue(n, 0), o = this.offsetOfNode(n);
        return {
          node: n,
          remainder: Math.min(i - 1, s),
          nodeStartOffset: o
        };
      } else if (n.piece.length >= i - 1) {
        const s = this.offsetOfNode(n);
        return {
          node: n,
          remainder: i - 1,
          nodeStartOffset: s
        };
      } else
        i -= n.piece.length;
      n = n.next();
    }
    return null;
  }
  nodeCharCodeAt(e, i) {
    if (e.piece.lineFeedCnt < 1)
      return -1;
    const n = this._buffers[e.piece.bufferIndex], r = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + i;
    return n.buffer.charCodeAt(r);
  }
  offsetOfNode(e) {
    if (!e)
      return 0;
    let i = e.size_left;
    for (; e !== this.root; )
      e.parent.right === e && (i += e.parent.size_left + e.parent.piece.length), e = e.parent;
    return i;
  }
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === `
`);
  }
  startWithLF(e) {
    if (typeof e == "string")
      return e.charCodeAt(0) === 10;
    if (e === me || e.piece.lineFeedCnt === 0)
      return !1;
    const i = e.piece, n = this._buffers[i.bufferIndex].lineStarts, r = i.start.line, s = n[r] + i.start.column;
    return r === n.length - 1 || n[r + 1] > s + 1 ? !1 : this._buffers[i.bufferIndex].buffer.charCodeAt(s) === 10;
  }
  endWithCR(e) {
    return typeof e == "string" ? e.charCodeAt(e.length - 1) === 13 : e === me || e.piece.lineFeedCnt === 0 ? !1 : this.nodeCharCodeAt(e, e.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(e) {
    if (this.shouldCheckCRLF() && this.startWithLF(e)) {
      const i = e.prev();
      this.endWithCR(i) && this.fixCRLF(i, e);
    }
  }
  validateCRLFWithNextNode(e) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const i = e.next();
      this.startWithLF(i) && this.fixCRLF(e, i);
    }
  }
  fixCRLF(e, i) {
    const n = [], r = this._buffers[e.piece.bufferIndex].lineStarts;
    let s;
    e.piece.end.column === 0 ? s = { line: e.piece.end.line - 1, column: r[e.piece.end.line] - r[e.piece.end.line - 1] - 1 } : s = { line: e.piece.end.line, column: e.piece.end.column - 1 };
    const o = e.piece.length - 1, a = e.piece.lineFeedCnt - 1;
    e.piece = new Ki(
      e.piece.bufferIndex,
      e.piece.start,
      s,
      a,
      o
    ), cs(this, e, -1, -1), e.piece.length === 0 && n.push(e);
    const l = { line: i.piece.start.line + 1, column: 0 }, c = i.piece.length - 1, u = this.getLineFeedCnt(i.piece.bufferIndex, l, i.piece.end);
    i.piece = new Ki(
      i.piece.bufferIndex,
      l,
      i.piece.end,
      u,
      c
    ), cs(this, i, -1, -1), i.piece.length === 0 && n.push(i);
    const d = this.createNewPieces(`\r
`);
    this.rbInsertRight(e, d[0]);
    for (let f = 0; f < n.length; f++)
      Gf(this, n[f]);
  }
  adjustCarriageReturnFromNext(e, i) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const n = i.next();
      if (this.startWithLF(n)) {
        if (e += `
`, n.piece.length === 1)
          Gf(this, n);
        else {
          const r = n.piece, s = { line: r.start.line + 1, column: 0 }, o = r.length - 1, a = this.getLineFeedCnt(r.bufferIndex, s, r.end);
          n.piece = new Ki(r.bufferIndex, s, r.end, a, o), cs(this, n, -1, -1);
        }
        return !0;
      }
    }
    return !1;
  }
  iterate(e, i) {
    if (e === me)
      return i(me);
    const n = this.iterate(e.left, i);
    return n && i(e) && this.iterate(e.right, i);
  }
  getNodeContent(e) {
    if (e === me)
      return "";
    const i = this._buffers[e.piece.bufferIndex], n = e.piece, r = this.offsetInBuffer(n.bufferIndex, n.start), s = this.offsetInBuffer(n.bufferIndex, n.end);
    return i.buffer.substring(r, s);
  }
  getPieceContent(e) {
    const i = this._buffers[e.bufferIndex], n = this.offsetInBuffer(e.bufferIndex, e.start), r = this.offsetInBuffer(e.bufferIndex, e.end);
    return i.buffer.substring(n, r);
  }
  rbInsertRight(e, i) {
    const n = new j0(i, $e.Red);
    if (n.left = me, n.right = me, n.parent = me, n.size_left = 0, n.lf_left = 0, this.root === me)
      this.root = n, n.color = $e.Black;
    else if (e.right === me)
      e.right = n, n.parent = e;
    else {
      const s = RE(e.right);
      s.left = n, n.parent = s;
    }
    return MC(this, n), n;
  }
  rbInsertLeft(e, i) {
    const n = new j0(i, $e.Red);
    if (n.left = me, n.right = me, n.parent = me, n.size_left = 0, n.lf_left = 0, this.root === me)
      this.root = n, n.color = $e.Black;
    else if (e.left === me)
      e.left = n, n.parent = e;
    else {
      const r = F5(e.left);
      r.right = n, n.parent = r;
    }
    return MC(this, n), n;
  }
  getContentOfSubTree(e) {
    let i = "";
    return this.iterate(e, (n) => (i += this.getNodeContent(n), !0)), i;
  }
}
var Ps;
(function(t) {
  t[t.Unknown = 0] = "Unknown", t[t.Invalid = 3] = "Invalid", t[t.LF = 1] = "LF", t[t.CRLF = 2] = "CRLF";
})(Ps || (Ps = {}));
function lv(t) {
  let e = 0, i = 0, n = 0, r = Ps.Unknown;
  for (let s = 0, o = t.length; s < o; s++) {
    const a = t.charCodeAt(s);
    a === L.CarriageReturn ? (e === 0 && (i = s), e++, s + 1 < o && t.charCodeAt(s + 1) === L.LineFeed ? (r |= Ps.CRLF, s++) : r |= Ps.Invalid, n = s + 1) : a === L.LineFeed && (r |= Ps.LF, e === 0 && (i = s), e++, n = s + 1);
  }
  return e === 0 && (i = t.length), [e, i, t.length - n, r];
}
let cv;
function AU() {
  return cv || (cv = new TextDecoder("UTF-16LE")), cv;
}
function RU(t, e, i) {
  const n = new Uint16Array(t.buffer, e, i);
  return i > 0 && (n[0] === 65279 || n[0] === 65534) ? LU(t, e, i) : AU().decode(n);
}
function LU(t, e, i) {
  const n = [];
  let r = 0;
  for (let s = 0; s < i; s++) {
    const o = fA(t, e);
    e += 2, n[r++] = String.fromCharCode(o);
  }
  return n.join("");
}
function Qf(t) {
  return t.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
class ir {
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  constructor(e, i, n, r) {
    this.oldPosition = e, this.oldText = i, this.newPosition = n, this.newText = r;
  }
  toString() {
    return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${Qf(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${Qf(this.oldText)}")` : `(replace@${this.oldPosition} "${Qf(this.oldText)}" with "${Qf(this.newText)}")`;
  }
  static _writeStringSize(e) {
    return 4 + 2 * e.length;
  }
  static _writeString(e, i, n) {
    const r = i.length;
    Yf(e, r, n), n += 4;
    for (let s = 0; s < r; s++)
      pA(e, i.charCodeAt(s), n), n += 2;
    return n;
  }
  static _readString(e, i) {
    const n = Jf(e, i);
    return i += 4, RU(e, i, n);
  }
  writeSize() {
    return 8 + ir._writeStringSize(this.oldText) + ir._writeStringSize(this.newText);
  }
  write(e, i) {
    return Yf(e, this.oldPosition, i), i += 4, Yf(e, this.newPosition, i), i += 4, i = ir._writeString(e, this.oldText, i), i = ir._writeString(e, this.newText, i), i;
  }
  static read(e, i, n) {
    const r = Jf(e, i);
    i += 4;
    const s = Jf(e, i);
    i += 4;
    const o = ir._readString(e, i);
    i += ir._writeStringSize(o);
    const a = ir._readString(e, i);
    return i += ir._writeStringSize(a), n.push(new ir(r, o, s, a)), i;
  }
}
class Yl extends ve {
  constructor(e, i, n, r, s, o, a) {
    super(), this._onDidChangeContent = this._register(new N()), this.onDidChangeContent = this._onDidChangeContent.event, this._BOM = i, this._mightContainNonBasicASCII = !o, this._mightContainRTL = r, this._mightContainUnusualLineTerminators = s, this._pieceTree = new PU(e, n, a);
  }
  equals(e) {
    return !(e instanceof Yl) || this._BOM !== e._BOM || this.getEOL() !== e.getEOL() ? !1 : this._pieceTree.equal(e._pieceTree);
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = !1;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(e) {
    return this._pieceTree.createSnapshot(e ? this._BOM : "");
  }
  getOffsetAt(e, i) {
    return this._pieceTree.getOffsetAt(e, i);
  }
  getPositionAt(e) {
    return this._pieceTree.getPositionAt(e);
  }
  getRangeAt(e, i) {
    const n = e + i, r = this.getPositionAt(e), s = this.getPositionAt(n);
    return new ut(
      r.lineNumber,
      r.column,
      s.lineNumber,
      s.column
    );
  }
  getValueInRange(e, i = fs.TextDefined) {
    if (e.isEmpty())
      return "";
    const n = this._getEndOfLine(i);
    return this._pieceTree.getValueInRange(e, n);
  }
  getValueLengthInRange(e, i = fs.TextDefined) {
    if (e.isEmpty())
      return 0;
    if (e.startLineNumber === e.endLineNumber)
      return e.endColumn - e.startColumn;
    const n = this.getOffsetAt(e.startLineNumber, e.startColumn), r = this.getOffsetAt(e.endLineNumber, e.endColumn);
    let s = 0;
    const o = this._getEndOfLine(i), a = this.getEOL();
    if (o.length !== a.length) {
      const l = o.length - a.length, c = e.endLineNumber - e.startLineNumber;
      s = l * c;
    }
    return r - n + s;
  }
  getCharacterCountInRange(e, i = fs.TextDefined) {
    if (this._mightContainNonBasicASCII) {
      let n = 0;
      const r = e.startLineNumber, s = e.endLineNumber;
      for (let o = r; o <= s; o++) {
        const a = this.getLineContent(o), l = o === r ? e.startColumn - 1 : 0, c = o === s ? e.endColumn - 1 : a.length;
        for (let u = l; u < c; u++)
          kx(a.charCodeAt(u)) ? (n = n + 1, u = u + 1) : n = n + 1;
      }
      return n += this._getEndOfLine(i).length * (s - r), n;
    }
    return this.getValueLengthInRange(e, i);
  }
  getNearestChunk(e) {
    return this._pieceTree.getNearestChunk(e);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(e) {
    return this._pieceTree.getLineContent(e);
  }
  getLineCharCode(e, i) {
    return this._pieceTree.getLineCharCode(e, i);
  }
  getCharCode(e) {
    return this._pieceTree.getCharCode(e);
  }
  getLineLength(e) {
    return this._pieceTree.getLineLength(e);
  }
  getLineMinColumn(e) {
    return 1;
  }
  getLineMaxColumn(e) {
    return this.getLineLength(e) + 1;
  }
  getLineFirstNonWhitespaceColumn(e) {
    const i = F1(this.getLineContent(e));
    return i === -1 ? 0 : i + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const i = bR(this.getLineContent(e));
    return i === -1 ? 0 : i + 2;
  }
  _getEndOfLine(e) {
    switch (e) {
      case fs.LF:
        return `
`;
      case fs.CRLF:
        return `\r
`;
      case fs.TextDefined:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(e) {
    this._pieceTree.setEOL(e);
  }
  applyEdits(e, i, n) {
    let r = this._mightContainRTL, s = this._mightContainUnusualLineTerminators, o = this._mightContainNonBasicASCII, a = !0, l = [];
    for (let w = 0; w < e.length; w++) {
      const v = e[w];
      a && v._isTracked && (a = !1);
      const S = v.range;
      if (v.text) {
        let le = !0;
        o || (le = !IR(v.text), o = le), !r && le && (r = R4(v.text)), !s && le && (s = L4(v.text));
      }
      let E = "", A = 0, j = 0, V = 0;
      if (v.text) {
        let le;
        [A, j, V, le] = lv(v.text);
        const Q = this.getEOL(), re = Q === `\r
` ? Ps.CRLF : Ps.LF;
        le === Ps.Unknown || le === re ? E = v.text : E = v.text.replace(/\r\n|\r|\n/g, Q);
      }
      l[w] = {
        sortIndex: w,
        identifier: v.identifier || null,
        range: S,
        rangeOffset: this.getOffsetAt(S.startLineNumber, S.startColumn),
        rangeLength: this.getValueLengthInRange(S),
        text: E,
        eolCount: A,
        firstLineLength: j,
        lastLineLength: V,
        forceMoveMarkers: !!v.forceMoveMarkers,
        isAutoWhitespaceEdit: v.isAutoWhitespaceEdit || !1
      };
    }
    l.sort(Yl._sortOpsAscending);
    let c = !1;
    for (let w = 0, v = l.length - 1; w < v; w++) {
      const S = l[w].range.getEndPosition(), E = l[w + 1].range.getStartPosition();
      if (E.isBeforeOrEqual(S)) {
        if (E.isBefore(S))
          throw new Error("Overlapping ranges are not allowed!");
        c = !0;
      }
    }
    a && (l = this._reduceOperations(l));
    const u = n || i ? Yl._getInverseEditRanges(l) : [], d = [];
    if (i)
      for (let w = 0; w < l.length; w++) {
        const v = l[w], S = u[w];
        if (v.isAutoWhitespaceEdit && v.range.isEmpty())
          for (let E = S.startLineNumber; E <= S.endLineNumber; E++) {
            let A = "";
            E === S.startLineNumber && (A = this.getLineContent(v.range.startLineNumber), F1(A) !== -1) || d.push({ lineNumber: E, oldContent: A });
          }
      }
    let f = null;
    if (n) {
      let w = 0;
      f = [];
      for (let v = 0; v < l.length; v++) {
        const S = l[v], E = u[v], A = this.getValueInRange(S.range), j = S.rangeOffset + w;
        w += S.text.length - A.length, f[v] = {
          sortIndex: S.sortIndex,
          identifier: S.identifier,
          range: E,
          text: A,
          textChange: new ir(S.rangeOffset, A, j, S.text)
        };
      }
      c || f.sort((v, S) => v.sortIndex - S.sortIndex);
    }
    this._mightContainRTL = r, this._mightContainUnusualLineTerminators = s, this._mightContainNonBasicASCII = o;
    const g = this._doApplyEdits(l);
    let _ = null;
    if (i && d.length > 0) {
      d.sort((w, v) => v.lineNumber - w.lineNumber), _ = [];
      for (let w = 0, v = d.length; w < v; w++) {
        const S = d[w].lineNumber;
        if (w > 0 && d[w - 1].lineNumber === S)
          continue;
        const E = d[w].oldContent, A = this.getLineContent(S);
        A.length === 0 || A === E || F1(A) !== -1 || _.push(S);
      }
    }
    return this._onDidChangeContent.fire(), new G7(f, g, _);
  }
  _reduceOperations(e) {
    return e.length < 1e3 ? e : [this._toSingleEditOperation(e)];
  }
  _toSingleEditOperation(e) {
    let i = !1;
    const n = e[0].range, r = e[e.length - 1].range, s = new ut(
      n.startLineNumber,
      n.startColumn,
      r.endLineNumber,
      r.endColumn
    );
    let o = n.startLineNumber, a = n.startColumn;
    const l = [];
    for (let g = 0, _ = e.length; g < _; g++) {
      const w = e[g], v = w.range;
      i = i || w.forceMoveMarkers, l.push(this.getValueInRange(new ut(o, a, v.startLineNumber, v.startColumn))), w.text.length > 0 && l.push(w.text), o = v.endLineNumber, a = v.endColumn;
    }
    const c = l.join(""), [u, d, f] = lv(c);
    return {
      sortIndex: 0,
      identifier: e[0].identifier,
      range: s,
      rangeOffset: this.getOffsetAt(s.startLineNumber, s.startColumn),
      rangeLength: this.getValueLengthInRange(s, fs.TextDefined),
      text: c,
      eolCount: u,
      firstLineLength: d,
      lastLineLength: f,
      forceMoveMarkers: i,
      isAutoWhitespaceEdit: !1
    };
  }
  _doApplyEdits(e) {
    e.sort(Yl._sortOpsDescending);
    const i = [];
    for (let n = 0; n < e.length; n++) {
      const r = e[n], s = r.range.startLineNumber, o = r.range.startColumn, a = r.range.endLineNumber, l = r.range.endColumn;
      if (s === a && o === l && r.text.length === 0)
        continue;
      r.text ? (this._pieceTree.delete(r.rangeOffset, r.rangeLength), this._pieceTree.insert(r.rangeOffset, r.text, !0)) : this._pieceTree.delete(r.rangeOffset, r.rangeLength);
      const c = new ut(s, o, a, l);
      i.push({
        range: c,
        rangeLength: r.rangeLength,
        text: r.text,
        rangeOffset: r.rangeOffset,
        forceMoveMarkers: r.forceMoveMarkers
      });
    }
    return i;
  }
  findMatchesLineByLine(e, i, n, r) {
    return this._pieceTree.findMatchesLineByLine(e, i, n, r);
  }
  getPieceTree() {
    return this._pieceTree;
  }
  static _getInverseEditRange(e, i) {
    const n = e.startLineNumber, r = e.startColumn, [s, o, a] = lv(i);
    let l;
    if (i.length > 0) {
      const c = s + 1;
      c === 1 ? l = new ut(
        n,
        r,
        n,
        r + o
      ) : l = new ut(
        n,
        r,
        n + c - 1,
        a + 1
      );
    } else
      l = new ut(n, r, n, r);
    return l;
  }
  static _getInverseEditRanges(e) {
    const i = [];
    let n = 0, r = 0, s = null;
    for (let o = 0, a = e.length; o < a; o++) {
      const l = e[o];
      let c, u;
      s ? s.range.endLineNumber === l.range.startLineNumber ? (c = n, u = r + (l.range.startColumn - s.range.endColumn)) : (c = n + (l.range.startLineNumber - s.range.endLineNumber), u = l.range.startColumn) : (c = l.range.startLineNumber, u = l.range.startColumn);
      let d;
      if (l.text.length > 0) {
        const f = l.eolCount + 1;
        f === 1 ? d = new ut(
          c,
          u,
          c,
          u + l.firstLineLength
        ) : d = new ut(
          c,
          u,
          c + f - 1,
          l.lastLineLength + 1
        );
      } else
        d = new ut(c, u, c, u);
      n = d.endLineNumber, r = d.endColumn, i.push(d), s = l;
    }
    return i;
  }
  static _sortOpsAscending(e, i) {
    const n = ut.compareRangesUsingEnds(e.range, i.range);
    return n === 0 ? e.sortIndex - i.sortIndex : n;
  }
  static _sortOpsDescending(e, i) {
    const n = ut.compareRangesUsingEnds(e.range, i.range);
    return n === 0 ? i.sortIndex - e.sortIndex : -n;
  }
}
class NU {
  constructor(e, i, n, r, s, o, a, l, c) {
    this._chunks = e, this._bom = i, this._cr = n, this._lf = r, this._crlf = s, this._containsRTL = o, this._containsUnusualLineTerminators = a, this._isBasicASCII = l, this._normalizeEOL = c;
  }
  _getEOL(e) {
    const i = this._cr + this._lf + this._crlf, n = this._cr + this._crlf;
    return i === 0 ? e === Kd.LF ? `
` : `\r
` : n > i / 2 ? `\r
` : `
`;
  }
  create(e) {
    const i = this._getEOL(e), n = this._chunks;
    if (this._normalizeEOL && (i === `\r
` && (this._cr > 0 || this._lf > 0) || i === `
` && (this._cr > 0 || this._crlf > 0)))
      for (let s = 0, o = n.length; s < o; s++) {
        const a = n[s].buffer.replace(/\r\n|\r|\n/g, i), l = gs(a);
        n[s] = new ta(a, l);
      }
    const r = new Yl(
      n,
      this._bom,
      i,
      this._containsRTL,
      this._containsUnusualLineTerminators,
      this._isBasicASCII,
      this._normalizeEOL
    );
    return { textBuffer: r, disposable: r };
  }
  getFirstLineText(e) {
    return this._chunks[0].buffer.substr(0, e).split(/\r\n|\r|\n/)[0];
  }
}
class OC {
  constructor() {
    this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.containsUnusualLineTerminators = !1, this.isBasicASCII = !0;
  }
  acceptChunk(e) {
    if (e.length === 0)
      return;
    this.chunks.length === 0 && PR(e) && (this.BOM = TR, e = e.substr(1));
    const i = e.charCodeAt(e.length - 1);
    i === L.CarriageReturn || i >= 55296 && i <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), !1), this._hasPreviousChar = !0, this._previousChar = i) : (this._acceptChunk1(e, !1), this._hasPreviousChar = !1, this._previousChar = i);
  }
  _acceptChunk1(e, i) {
    !i && e.length === 0 || (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e));
  }
  _acceptChunk2(e) {
    const i = IU(this._tmpLineStarts, e);
    this.chunks.push(new ta(e, i.lineStarts)), this.cr += i.cr, this.lf += i.lf, this.crlf += i.crlf, i.isBasicASCII || (this.isBasicASCII = !1, this.containsRTL || (this.containsRTL = R4(e)), this.containsUnusualLineTerminators || (this.containsUnusualLineTerminators = L4(e)));
  }
  finish(e = !0) {
    return this._finish(), new NU(
      this.chunks,
      this.BOM,
      this.cr,
      this.lf,
      this.crlf,
      this.containsRTL,
      this.containsUnusualLineTerminators,
      this.isBasicASCII,
      e
    );
  }
  _finish() {
    if (this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar) {
      this._hasPreviousChar = !1;
      const e = this.chunks[this.chunks.length - 1];
      e.buffer += String.fromCharCode(this._previousChar);
      const i = gs(e.buffer);
      e.lineStarts = i, this._previousChar === L.CarriageReturn && this.cr++;
    }
  }
}
class MU extends ve {
  constructor(e, i, n) {
    super(), this._source = e, this._inputTextBuffer = i, this._outputs = n, this._outputTextBuffers = void 0;
  }
  _getFullModelRange(e) {
    const i = e.getLineCount();
    return new ut(1, 1, i, this._getLineMaxColumn(e, i));
  }
  _getLineMaxColumn(e, i) {
    if (i < 1 || i > e.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return e.getLineLength(i) + 1;
  }
  get inputTextBuffer() {
    if (!this._inputTextBuffer) {
      const e = new OC();
      e.acceptChunk(this._source);
      const i = e.finish(!0), { textBuffer: n, disposable: r } = i.create(Kd.LF);
      this._inputTextBuffer = n, this._register(r);
    }
    return this._inputTextBuffer;
  }
  get outputTextBuffers() {
    return this._outputTextBuffers || (this._outputTextBuffers = this._outputs.map((e) => {
      const i = new OC();
      i.acceptChunk(e);
      const n = i.finish(!0), { textBuffer: r, disposable: s } = n.create(Kd.LF);
      return this._register(s), r;
    })), this._outputTextBuffers;
  }
  findInInputs(e) {
    const n = new _I(e, !1, !1, null).parseSearchRequest();
    if (!n)
      return [];
    const r = this._getFullModelRange(this.inputTextBuffer);
    return this.inputTextBuffer.findMatchesLineByLine(r, n, !0, 5e3);
  }
  findInOutputs(e) {
    const n = new _I(e, !1, !1, null).parseSearchRequest();
    return n ? this.outputTextBuffers.map((r) => {
      const s = r.findMatchesLineByLine(this._getFullModelRange(r), n, !0, 5e3);
      if (s.length !== 0)
        return {
          textBuffer: r,
          matches: s
        };
    }).filter((r) => !!r) : [];
  }
}
function FC(t, e) {
  let i = -1;
  const n = [];
  let r = [];
  return t.forEach((o) => {
    o.range.startLineNumber !== i && r.length > 0 && (n.push([...r]), r = []), r.push(o), i = o.range.endLineNumber;
  }), r.length > 0 && n.push([...r]), n.map((o) => {
    const a = [], l = o[0].range.startLineNumber, c = o[o.length - 1].range.endLineNumber;
    for (let u = l; u <= c; u++)
      a.push(e.getLineContent(u));
    return new K6(a.join(`
`) + `
`, o.map((u) => new ut(
      u.range.startLineNumber - 1,
      u.range.startColumn - 1,
      u.range.endLineNumber - 1,
      u.range.endColumn - 1
    )));
  });
}
const OU = pe("remoteAgentService"), FU = pe("IUserDataProfilesService"), UU = Object.freeze({
  id: "workbench",
  order: 7,
  title: h(3857, "Workbench"),
  type: "object"
}), $U = Object.freeze({
  id: "security",
  scope: Lt.APPLICATION,
  title: h(3858, "Security"),
  type: "object",
  order: 7
});
Object.freeze({
  id: "problems",
  title: h(3859, "Problems"),
  type: "object",
  order: 101
});
const HU = Object.freeze({
  id: "window",
  order: 8,
  title: h(3860, "Window"),
  type: "object"
}), BU = {
  ConfigurationMigration: "base.contributions.configuration.migration"
};
class WU {
  constructor() {
    this.migrations = [], this._onDidRegisterConfigurationMigrations = new N(), this.onDidRegisterConfigurationMigration = this._onDidRegisterConfigurationMigrations.event;
  }
  registerConfigurationMigrations(e) {
    this.migrations.push(...e);
  }
}
const Dp = new WU();
ai.add(BU.ConfigurationMigration, Dp);
var Ac;
let UC = (Ac = class extends ve {
  constructor(e, i) {
    super(), this.configurationService = e, this.workspaceService = i, this._register(this.workspaceService.onDidChangeWorkspaceFolders(async (n) => {
      for (const r of n.added)
        await this.migrateConfigurationsForFolder(r, Dp.migrations);
    })), this.migrateConfigurations(Dp.migrations), this._register(Dp.onDidRegisterConfigurationMigration((n) => this.migrateConfigurations(n)));
  }
  async migrateConfigurations(e) {
    await this.migrateConfigurationsForFolder(void 0, e);
    for (const i of this.workspaceService.getWorkspace().folders)
      await this.migrateConfigurationsForFolder(i, e);
  }
  async migrateConfigurationsForFolder(e, i) {
    await Promise.all([i.map(
      (n) => this.migrateConfigurationsForFolderAndOverride(n, e?.uri)
    )]);
  }
  async migrateConfigurationsForFolderAndOverride(e, i) {
    const n = this.configurationService.inspect(e.key, { resource: i }), r = this.workspaceService.getWorkbenchState() === Vp.WORKSPACE ? [
      ["user", ti.USER],
      ["userLocal", ti.USER_LOCAL],
      ["userRemote", ti.USER_REMOTE],
      ["workspace", ti.WORKSPACE],
      ["workspaceFolder", ti.WORKSPACE_FOLDER]
    ] : [
      ["user", ti.USER],
      ["userLocal", ti.USER_LOCAL],
      ["userRemote", ti.USER_REMOTE],
      ["workspace", ti.WORKSPACE]
    ];
    for (const [s, o] of r) {
      const a = n[s];
      if (!a)
        continue;
      const l = [];
      if (a.value !== void 0) {
        const c = await this.runMigration(e, s, a.value, i, void 0);
        for (const u of c ?? [])
          l.push([u, []]);
      }
      for (const { identifiers: c, value: u } of a.overrides ?? [])
        if (u !== void 0) {
          const d = await this.runMigration(e, s, u, i, c);
          for (const f of d ?? [])
            l.push([f, c]);
        }
      l.length && await Promise.allSettled(l.map(
        async ([[c, u], d]) => this.configurationService.updateValue(c, u.value, { resource: i, overrideIdentifiers: d }, o)
      ));
    }
  }
  async runMigration(e, i, n, r, s) {
    const o = (l) => {
      const u = this.configurationService.inspect(l, { resource: r })[i];
      if (u)
        return s ? u.overrides?.find(({ identifiers: d }) => sn(d, s))?.value : u.value;
    }, a = await e.migrateFn(n, o);
    return Array.isArray(a) ? a : [[e.key, a]];
  }
}, Ac.ID = "workbench.contrib.configurationMigration", Ac);
UC = W([
  M(0, c1),
  M(1, s5)
], UC);
var Rc;
let $C = (Rc = class extends ve {
  constructor(e) {
    super(), this.remoteAgentService = e, this._ready = new ko(), this.ready = this._ready.p, this.create();
  }
  async create() {
    try {
      await this.doCreate();
    } finally {
      this._ready.complete();
    }
  }
  async doCreate() {
    if (!ji && (await this.remoteAgentService.getEnvironment())?.os !== zr.Windows)
      return;
    ai.as(ml.Configuration).registerConfiguration({
      ...$U,
      properties: {
        "security.allowedUNCHosts": {
          type: "array",
          items: {
            type: "string",
            pattern: "^[^\\\\]+$",
            patternErrorMessage: h(3861, "UNC host names must not contain backslashes.")
          },
          default: [],
          markdownDescription: h(
            3862,
            "A set of UNC host names (without leading or trailing backslash, for example `192.168.0.1` or `my-server`) to allow without user confirmation. If a UNC host is being accessed that is not allowed via this setting or has not been acknowledged via user confirmation, an error will occur and the operation stopped. A restart is required when changing this setting. Find out more about this setting at https://aka.ms/vscode-windows-unc."
          ),
          scope: Lt.APPLICATION_MACHINE
        },
        "security.restrictUNCAccess": {
          type: "boolean",
          default: !0,
          markdownDescription: h(
            3863,
            "If enabled, only allows access to UNC host names that are allowed by the `#security.allowedUNCHosts#` setting or after user confirmation. Find out more about this setting at https://aka.ms/vscode-windows-unc."
          ),
          scope: Lt.APPLICATION_MACHINE
        }
      }
    });
  }
}, Rc.ID = "workbench.contrib.dynamicWorkbenchSecurityConfiguration", Rc);
$C = W([
  M(0, OU)
], $C);
const Qu = "window.newWindowProfile";
var Lc;
let HC = (Lc = class extends ve {
  constructor(e, i) {
    super(), this.userDataProfilesService = e, this.configurationService = i, this.registerNewWindowProfileConfiguration(), this._register(this.userDataProfilesService.onDidChangeProfiles((n) => this.registerNewWindowProfileConfiguration())), this.setNewWindowProfile(), this.checkAndResetNewWindowProfileConfig(), this._register(i.onDidChangeConfiguration((n) => {
      n.source !== ti.DEFAULT && n.affectsConfiguration(Qu) && this.setNewWindowProfile();
    })), this._register(this.userDataProfilesService.onDidChangeProfiles(() => this.checkAndResetNewWindowProfileConfig()));
  }
  registerNewWindowProfileConfiguration() {
    const e = ai.as(ml.Configuration), i = {
      ...HU,
      properties: {
        [Qu]: {
          type: ["string", "null"],
          default: null,
          enum: [...this.userDataProfilesService.profiles.map((n) => n.name), null],
          enumItemLabels: [...this.userDataProfilesService.profiles.map((n) => ""), h(3864, "Active Window")],
          description: h(
            3865,
            "Specifies the profile to use when opening a new window. If a profile name is provided, the new window will use that profile. If no profile name is provided, the new window will use the profile of the active window or the Default profile if no active window exists."
          ),
          scope: Lt.APPLICATION
        }
      }
    };
    this.configurationNode ? e.updateConfigurations({ add: [i], remove: [this.configurationNode] }) : e.registerConfiguration(i), this.configurationNode = i;
  }
  setNewWindowProfile() {
    const e = this.configurationService.getValue(Qu);
    this.newWindowProfile = e ? this.userDataProfilesService.profiles.find((i) => i.name === e) : void 0;
  }
  checkAndResetNewWindowProfileConfig() {
    const e = this.configurationService.getValue(Qu);
    if (!e)
      return;
    const i = this.newWindowProfile ? this.userDataProfilesService.profiles.find((n) => n.id === this.newWindowProfile.id) : void 0;
    e !== i?.name && this.configurationService.updateValue(Qu, i?.name);
  }
}, Lc.ID = "workbench.contrib.dynamicWindowConfiguration", Lc);
HC = W([
  M(0, FU),
  M(1, c1)
], HC);
const VU = ai.as(ml.Configuration), zU = {
  ...UU,
  properties: {
    "workbench.editorAssociations": {
      type: "object",
      markdownDescription: h(
        13014,
        'Configure [glob patterns](https://aka.ms/vscode-glob-patterns) to editors (for example `"*.hex": "hexEditor.hexedit"`). These have precedence over the default behavior.'
      ),
      additionalProperties: {
        type: "string"
      }
    }
  }
};
VU.registerConfiguration(zU);
var G0;
(function(t) {
  t.builtin = "builtin", t.option = "option", t.exclusive = "exclusive", t.default = "default";
})(G0 || (G0 = {}));
var BC;
(function(t) {
  t[t.ABORT = 1] = "ABORT", t[t.NONE = 2] = "NONE";
})(BC || (BC = {}));
function qU(t, e) {
  if ((/* @__PURE__ */ new Set([
    de.extension,
    de.webviewPanel,
    de.vscodeWorkspaceTrust,
    de.vscodeSettings
  ])).has(e.scheme))
    return !1;
  const r = typeof t == "string" && t.indexOf(dt.sep) >= 0 ? `${e.scheme}:${e.path}` : Fs(e);
  return wd(typeof t == "string" ? t.toLowerCase() : t, r.toLowerCase());
}
const oa = class oa {
  get activeNotebookEditor() {
    return this._activeNotebookEditor?.apiEditor;
  }
  get visibleNotebookEditors() {
    return this._visibleNotebookEditors.map((e) => e.apiEditor);
  }
  constructor(e, i, n, r, s, o, a) {
    this._textDocumentsAndEditors = n, this._textDocuments = r, this._extHostFileSystem = s, this._extHostSearch = o, this._logService = a, this._notebookStatusBarItemProviders = /* @__PURE__ */ new Map(), this._documents = new fi(), this._editors = /* @__PURE__ */ new Map(), this._onDidChangeActiveNotebookEditor = new N(), this.onDidChangeActiveNotebookEditor = this._onDidChangeActiveNotebookEditor.event, this._visibleNotebookEditors = [], this._onDidOpenNotebookDocument = new N(), this.onDidOpenNotebookDocument = this._onDidOpenNotebookDocument.event, this._onDidCloseNotebookDocument = new N(), this.onDidCloseNotebookDocument = this._onDidCloseNotebookDocument.event, this._onDidChangeVisibleNotebookEditors = new N(), this.onDidChangeVisibleNotebookEditors = this._onDidChangeVisibleNotebookEditors.event, this._statusBarCache = new Nn("NotebookCellStatusBarCache"), this._handlePool = 0, this._notebookSerializer = /* @__PURE__ */ new Map(), this._notebookProxy = e.getProxy(ee.MainThreadNotebook), this._notebookDocumentsProxy = e.getProxy(ee.MainThreadNotebookDocuments), this._notebookEditorsProxy = e.getProxy(ee.MainThreadNotebookEditors), this._commandsConverter = i.converter, i.registerArgumentProcessor({
      processArgument: (l) => {
        if (l && l.$mid === tt.NotebookCellActionContext) {
          const c = l.notebookEditor?.notebookUri, u = l.cell.handle, f = this._documents.get(c)?.getCell(u);
          if (f)
            return f.apiCell;
        }
        if (l && l.$mid === tt.NotebookActionContext) {
          const c = l.uri, u = this._documents.get(c);
          if (u)
            return u.apiNotebook;
        }
        return l;
      }
    }), oa._registerApiCommands(i);
  }
  getEditorById(e) {
    const i = this._editors.get(e);
    if (!i)
      throw new Error(`unknown text editor: ${e}. known editors: ${[...this._editors.keys()]} `);
    return i;
  }
  getIdByEditor(e) {
    for (const [i, n] of this._editors)
      if (n.apiEditor === e)
        return i;
  }
  get notebookDocuments() {
    return [...this._documents.values()];
  }
  getNotebookDocument(e, i) {
    const n = this._documents.get(e);
    if (!n && !i)
      throw new Error(`NO notebook document for '${e}'`);
    return n;
  }
  static _convertNotebookRegistrationData(e, i) {
    if (!i)
      return;
    const n = i.filenamePattern.map((r) => Sm.from(r)).filter((r) => r !== void 0);
    if (i.filenamePattern && !n) {
      console.warn(`Notebook content provider view options file name pattern is invalid ${i.filenamePattern}`);
      return;
    }
    return {
      extension: e.identifier,
      providerDisplayName: e.displayName || e.name,
      displayName: i.displayName,
      filenamePattern: n,
      priority: i.exclusive ? G0.exclusive : void 0
    };
  }
  registerNotebookCellStatusBarItemProvider(e, i, n) {
    const r = oa._notebookStatusBarItemProviderHandlePool++, s = typeof n.onDidChangeCellStatusBarItems == "function" ? oa._notebookStatusBarItemProviderHandlePool++ : void 0;
    this._notebookStatusBarItemProviders.set(r, n), this._notebookProxy.$registerNotebookCellStatusBarItemProvider(r, s, i);
    let o;
    return s !== void 0 && (o = n.onDidChangeCellStatusBarItems((a) => this._notebookProxy.$emitCellStatusBarEvent(s))), new Ve(() => {
      this._notebookStatusBarItemProviders.delete(r), this._notebookProxy.$unregisterNotebookCellStatusBarItemProvider(r, s), o?.dispose();
    });
  }
  async createNotebookDocument(e) {
    const i = await this._notebookDocumentsProxy.$tryCreateNotebook({
      viewType: e.viewType,
      content: e.content && Zs.from(e.content)
    });
    return x.revive(i);
  }
  async openNotebookDocument(e) {
    const i = this._documents.get(e);
    if (i)
      return i.apiNotebook;
    const n = await this._notebookDocumentsProxy.$tryOpenNotebook(e), r = this._documents.get(x.revive(n));
    return Fc(r?.apiNotebook);
  }
  async showNotebookDocument(e, i) {
    let n;
    typeof i == "object" ? n = {
      position: si.from(i.viewColumn),
      preserveFocus: i.preserveFocus,
      selections: i.selections && i.selections.map(Jr.from),
      pinned: typeof i.preview == "boolean" ? !i.preview : void 0,
      label: typeof i.asRepl == "string" ? i.asRepl : typeof i.asRepl == "object" ? i.asRepl.label : void 0
    } : n = {
      preserveFocus: !1,
      pinned: !0
    };
    const r = i?.asRepl ? "repl" : e.notebookType, s = await this._notebookEditorsProxy.$tryShowNotebookDocument(e.uri, r, n), o = s && this._editors.get(s)?.apiEditor;
    if (o)
      return o;
    throw s ? new Error(`Could NOT open editor for "${e.uri.toString()}" because another editor opened in the meantime.`) : new Error(`Could NOT open editor for "${e.uri.toString()}".`);
  }
  async $provideNotebookCellStatusBarItems(e, i, n, r) {
    const s = this._notebookStatusBarItemProviders.get(e), o = x.revive(i), a = this._documents.get(o);
    if (!a || !s)
      return;
    const l = a.getCellFromIndex(n);
    if (!l)
      return;
    const c = await s.provideCellStatusBarItems(l.apiCell, r);
    if (!c)
      return;
    const u = new De(), d = this._statusBarCache.add([u]), g = (Array.isArray(c) ? c : [c]).map(
      (_) => zb.from(_, this._commandsConverter, u)
    );
    return {
      cacheId: d,
      items: g
    };
  }
  $releaseNotebookCellStatusBarItems(e) {
    this._statusBarCache.delete(e);
  }
  registerNotebookSerializer(e, i, n, r, s) {
    if (qd(i))
      throw new Error("viewType cannot be empty or just whitespace");
    const o = this._handlePool++;
    return this._notebookSerializer.set(o, { viewType: i, serializer: n, options: r }), this._notebookProxy.$registerNotebookSerializer(o, { id: e.identifier, location: e.extensionLocation }, i, jb.from(r), oa._convertNotebookRegistrationData(e, s)), Ee(() => {
      this._notebookProxy.$unregisterNotebookSerializer(o);
    });
  }
  async $dataToNotebook(e, i, n) {
    const r = this._notebookSerializer.get(e);
    if (!r)
      throw new Error("NO serializer found");
    const s = await r.serializer.deserializeNotebook(i.buffer, n);
    return new zi(Zs.from(s));
  }
  async $notebookToData(e, i, n) {
    const r = this._notebookSerializer.get(e);
    if (!r)
      throw new Error("NO serializer found");
    const s = await r.serializer.serializeNotebook(Zs.to(i.value), n);
    return ue.wrap(s);
  }
  async $saveNotebook(e, i, n, r, s) {
    const o = x.revive(i), a = this._notebookSerializer.get(e);
    if (this.trace(`enter saveNotebook(versionId: ${n}, ${o.toString()})`), !a)
      throw new Error("NO serializer found");
    const l = this._documents.get(o);
    if (!l)
      throw new Error("Document NOT found");
    if (l.versionId !== n)
      throw new Error(
        "Document version mismatch, expected: " + n + ", actual: " + l.versionId
      );
    if (!this._extHostFileSystem.value.isWritableFileSystem(o.scheme))
      throw new Uv(h(2631, "Unable to modify read-only file '{0}'", this._resourceForError(o)), Dn.FILE_PERMISSION_DENIED);
    const c = {
      metadata: IS(l.apiNotebook.metadata, (_) => !(a.options?.transientDocumentMetadata ?? {})[_]),
      cells: []
    };
    for (const _ of l.apiNotebook.getCells()) {
      const w = new Y_(_.kind, _.document.getText(), _.document.languageId, _.mime, a.options?.transientOutputs ? [] : [..._.outputs], _.metadata, _.executionSummary);
      w.metadata = IS(_.metadata, (v) => !(a.options?.transientCellMetadata ?? {})[v]), c.cells.push(w);
    }
    if (await this._validateWriteFile(o, r), s.isCancellationRequested)
      throw new Error("canceled");
    const u = await a.serializer.serializeNotebook(c, s);
    if (s.isCancellationRequested)
      throw new Error("canceled");
    this.trace(`serialized versionId: ${n} ${o.toString()}`), await this._extHostFileSystem.value.writeFile(o, u), this.trace(`Finished write versionId: ${n} ${o.toString()}`);
    const d = this._extHostFileSystem.getFileSystemProviderExtUri(o.scheme), f = await this._extHostFileSystem.value.stat(o), g = {
      name: d.basename(o),
      isFile: (f.type & Da.File) !== 0,
      isDirectory: (f.type & Da.Directory) !== 0,
      isSymbolicLink: (f.type & Da.SymbolicLink) !== 0,
      mtime: f.mtime,
      ctime: f.ctime,
      size: f.size,
      readonly: !!((f.permissions ?? 0) & Vc.Readonly) || !this._extHostFileSystem.value.isWritableFileSystem(o.scheme),
      locked: !!((f.permissions ?? 0) & Vc.Locked),
      etag: TS({ mtime: f.mtime, size: f.size }),
      children: void 0
    };
    return this.trace(`exit saveNotebook(versionId: ${n}, ${o.toString()})`), g;
  }
  async $searchInNotebooks(e, i, n, r, s) {
    const o = this._notebookSerializer.get(e)?.serializer;
    if (!o)
      return {
        limitHit: !1,
        results: []
      };
    const a = new e4();
    await (async (f, g, _) => {
      await Promise.all(f.map(async (w) => await Promise.all(w.filenamePatterns.map((v) => {
        const S = {
          _reason: _._reason,
          folderQueries: _.folderQueries,
          includePattern: _.includePattern,
          excludePattern: _.excludePattern,
          maxResults: _.maxResults,
          type: Fa.File,
          filePattern: v
        };
        return this._extHostSearch.doInternalFileSearchWithCustomCallback(S, g, (E) => {
          E.forEach((A) => {
            a.has(A) || r.some((V) => w.isFromSettings && !V.isFromSettings ? !1 : V.filenamePatterns.some((le) => qU(le, A))) || a.add(A);
          });
        }).catch((E) => {
          if (E.code === "ENOENT")
            return console.warn("Could not find notebook search results, ignoring notebook results."), {
              limitHit: !1,
              messages: []
            };
          throw E;
        });
      }))));
    })(n, s, i);
    const c = new fi();
    let u = !1;
    const d = Array.from(a).map(async (f) => {
      const g = [];
      try {
        if (s.isCancellationRequested)
          return;
        if (i.maxResults && [...c.values()].reduce((S, E) => S + E.cellResults.length, 0) > i.maxResults) {
          u = !0;
          return;
        }
        const _ = [], w = this._documents.get(f);
        if (w)
          w.apiNotebook.getCells().forEach((E) => _.push({
            input: E.document.getText(),
            outputs: E.outputs.flatMap((A) => A.items.map((j) => j.data.toString()))
          }));
        else {
          const S = await this._extHostFileSystem.value.readFile(f), E = ue.fromString(S.toString()), A = await o.deserializeNotebook(E.buffer, s);
          if (s.isCancellationRequested)
            return;
          Zs.from(A).cells.forEach((V) => _.push({
            input: V.source,
            outputs: V.outputs.flatMap((le) => le.items.map((Q) => Q.valueBytes.toString()))
          }));
        }
        if (s.isCancellationRequested)
          return;
        _.forEach((S, E) => {
          const A = i.contentPattern.pattern, j = new MU(S.input, void 0, S.outputs), V = j.findInInputs(A), le = j.findInOutputs(A), Q = le.flatMap((re) => FC(re.matches, re.textBuffer)).map((re, K) => (re.webviewIndex = K, re));
          if (V.length > 0 || le.length > 0) {
            const re = {
              index: E,
              contentResults: FC(V, j.inputTextBuffer),
              webviewResults: Q
            };
            g.push(re);
          }
        });
        const v = {
          resource: f,
          cellResults: g
        };
        c.set(f, v);
        return;
      } catch {
        return;
      }
    });
    return await Promise.all(d), {
      limitHit: u,
      results: [...c.values()]
    };
  }
  async _validateWriteFile(e, i) {
    const n = await this._extHostFileSystem.value.stat(e);
    if (typeof i?.mtime == "number" && typeof i.etag == "string" && i.etag !== I8 && typeof n.mtime == "number" && typeof n.size == "number" && i.mtime < n.mtime && i.etag !== TS({ mtime: i.mtime, size: n.size }))
      throw new Uv(h(2632, "File Modified Since"), Dn.FILE_MODIFIED_SINCE, i);
  }
  _resourceForError(e) {
    return e.scheme === de.file ? e.fsPath : e.toString();
  }
  _createExtHostEditor(e, i, n) {
    if (this._editors.has(i))
      throw new Error(`editor with id ALREADY EXSIST: ${i}`);
    const r = new rf(i, this._notebookEditorsProxy, e, n.visibleRanges.map(Jr.to), n.selections.map(Jr.to), typeof n.viewColumn == "number" ? si.to(n.viewColumn) : void 0, n.viewType);
    this._editors.set(i, r);
  }
  $acceptDocumentAndEditorsDelta(e) {
    if (e.value.removedDocuments)
      for (const i of e.value.removedDocuments) {
        const n = x.revive(i), r = this._documents.get(n);
        r && (r.dispose(), this._documents.delete(n), this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({ removedDocuments: r.apiNotebook.getCells().map((s) => s.document.uri) }), this._onDidCloseNotebookDocument.fire(r.apiNotebook));
        for (const s of this._editors.values())
          s.notebookData.uri.toString() === n.toString() && this._editors.delete(s.id);
      }
    if (e.value.addedDocuments) {
      const i = [];
      for (const n of e.value.addedDocuments) {
        const r = x.revive(n.uri);
        if (this._documents.has(r))
          throw new Error(`adding EXISTING notebook ${r} `);
        const s = new q0(
          this._notebookDocumentsProxy,
          this._textDocumentsAndEditors,
          this._textDocuments,
          r,
          n
        );
        i.push(...n.cells.map((o) => z0.asModelAddData(o))), this._documents.get(r)?.dispose(), this._documents.set(r, s), this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({ addedDocuments: i }), this._onDidOpenNotebookDocument.fire(s.apiNotebook);
      }
    }
    if (e.value.addedEditors)
      for (const i of e.value.addedEditors) {
        if (this._editors.has(i.id))
          return;
        const n = x.revive(i.documentUri), r = this._documents.get(n);
        r && this._createExtHostEditor(r, i.id, i);
      }
    if (e.value.removedEditors)
      for (const i of e.value.removedEditors) {
        const n = this._editors.get(i);
        n && (this._editors.delete(i), this._activeNotebookEditor?.id === n.id && (this._activeNotebookEditor = void 0));
      }
    if (e.value.visibleEditors) {
      this._visibleNotebookEditors = e.value.visibleEditors.map((n) => this._editors.get(n)).filter((n) => !!n);
      const i = /* @__PURE__ */ new Set();
      this._visibleNotebookEditors.forEach((n) => i.add(n.id));
      for (const n of this._editors.values()) {
        const r = i.has(n.id);
        n._acceptVisibility(r);
      }
      this._visibleNotebookEditors = [...this._editors.values()].map((n) => n).filter((n) => n.visible), this._onDidChangeVisibleNotebookEditors.fire(this.visibleNotebookEditors);
    }
    e.value.newActiveEditor === null ? this._activeNotebookEditor = void 0 : e.value.newActiveEditor && (this._editors.get(e.value.newActiveEditor) || console.error(`FAILED to find active notebook editor ${e.value.newActiveEditor}`), this._activeNotebookEditor = this._editors.get(e.value.newActiveEditor)), e.value.newActiveEditor !== void 0 && this._onDidChangeActiveNotebookEditor.fire(this._activeNotebookEditor?.apiEditor);
  }
  static _registerApiCommands(e) {
    const i = q.String.with("notebookType", "A notebook type"), n = new Pe(
      "vscode.executeDataToNotebook",
      "_executeDataToNotebook",
      "Invoke notebook serializer",
      [i, new q(
        "data",
        "Bytes to convert to data",
        (s) => s instanceof Uint8Array,
        (s) => ue.wrap(s)
      )],
      new Se("Notebook Data", (s) => Zs.to(s.value))
    ), r = new Pe(
      "vscode.executeNotebookToData",
      "_executeNotebookToData",
      "Invoke notebook serializer",
      [i, new q(
        "NotebookData",
        "Notebook data to convert to bytes",
        (s) => !0,
        (s) => new zi(Zs.from(s))
      )],
      new Se("Bytes", (s) => s.buffer)
    );
    e.registerApiCommand(n), e.registerApiCommand(r);
  }
  trace(e) {
    this._logService.trace(`[Extension Host Notebook] ${e}`);
  }
};
oa._notebookStatusBarItemProviderHandlePool = 0;
let Q0 = oa;
class jU {
  constructor(e, i, n, r = { timeout: 1500, errors: 3 }) {
    this._logService = e, this._notebooksAndEditors = i, this._mainThreadBulkEdits = n, this._thresholds = r, this._onWillSaveNotebookDocumentEvent = new id();
  }
  dispose() {
  }
  getOnWillSaveNotebookDocumentEvent(e) {
    return (i, n, r) => {
      const s = function(a) {
        i.call(n, a);
      };
      return s.extension = e, this._onWillSaveNotebookDocumentEvent.event(s, void 0, r);
    };
  }
  async $participateInSave(e, i, n) {
    const r = x.revive(e), s = this._notebooksAndEditors.getNotebookDocument(r);
    if (!s)
      throw new Error("Unable to resolve notebook document");
    const o = [];
    if (await this._onWillSaveNotebookDocumentEvent.fireAsync({ notebook: s.apiNotebook, reason: bm.to(i) }, n, async (l, c) => {
      const u = Date.now(), d = await await Promise.resolve(l);
      Date.now() - u > this._thresholds.timeout && this._logService.warn("onWillSaveNotebookDocument-listener from extension", c.extension.identifier), !n.isCancellationRequested && d && (d instanceof tl ? o.push(d) : this._logService.warn("onWillSaveNotebookDocument-listener from extension", c.extension.identifier, "ignored due to invalid data"));
    }), n.isCancellationRequested)
      return !1;
    if (o.length === 0)
      return !0;
    const a = { edits: [] };
    for (const l of o) {
      const { edits: c } = yn.from(l);
      a.edits = a.edits.concat(c);
    }
    return this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new zi(a));
  }
}
class GU {
  constructor(e) {
    this._notebooksAndEditors = e, this._onDidSaveNotebookDocument = new N(), this.onDidSaveNotebookDocument = this._onDidSaveNotebookDocument.event, this._onDidChangeNotebookDocument = new N(), this.onDidChangeNotebookDocument = this._onDidChangeNotebookDocument.event;
  }
  $acceptModelChanged(e, i, n, r) {
    const o = this._notebooksAndEditors.getNotebookDocument(x.revive(e)).acceptModelChanged(i.value, n, r);
    this._onDidChangeNotebookDocument.fire(o);
  }
  $acceptDirtyStateChanged(e, i) {
    this._notebooksAndEditors.getNotebookDocument(x.revive(e)).acceptDirty(i);
  }
  $acceptModelSaved(e) {
    const i = this._notebooksAndEditors.getNotebookDocument(x.revive(e));
    this._onDidSaveNotebookDocument.fire(i.apiNotebook);
  }
}
let K0 = class {
  constructor(e, i) {
    this._logService = e, this._notebooksAndEditors = i, this._onDidChangeNotebookEditorSelection = new N(), this._onDidChangeNotebookEditorVisibleRanges = new N(), this.onDidChangeNotebookEditorSelection = this._onDidChangeNotebookEditorSelection.event, this.onDidChangeNotebookEditorVisibleRanges = this._onDidChangeNotebookEditorVisibleRanges.event;
  }
  $acceptEditorPropertiesChanged(e, i) {
    this._logService.debug("ExtHostNotebook#$acceptEditorPropertiesChanged", e, i);
    const n = this._notebooksAndEditors.getEditorById(e);
    i.visibleRanges && n._acceptVisibleRanges(i.visibleRanges.ranges.map(Jr.to)), i.selections && n._acceptSelections(i.selections.selections.map(Jr.to)), i.visibleRanges && this._onDidChangeNotebookEditorVisibleRanges.fire({
      notebookEditor: n.apiEditor,
      visibleRanges: n.apiEditor.visibleRanges
    }), i.selections && this._onDidChangeNotebookEditorSelection.fire(Object.freeze({
      notebookEditor: n.apiEditor,
      selections: n.apiEditor.selections
    }));
  }
  $acceptEditorViewColumns(e) {
    for (const i in e)
      this._notebooksAndEditors.getEditorById(i)._acceptViewColumn(si.to(e[i]));
  }
};
K0 = W([
  M(0, nt)
], K0);
var Xl;
(function(t) {
  t[t.Output = 1] = "Output", t[t.OutputItems = 2] = "OutputItems", t[t.ExecutionState = 3] = "ExecutionState";
})(Xl || (Xl = {}));
const QU = 100;
var WC;
(function(t) {
  t[t.Disconnected = 1] = "Disconnected", t[t.Connected = 2] = "Connected", t[t.Initializing = 3] = "Initializing";
})(WC || (WC = {}));
let J0 = class {
  constructor(e, i, n, r, s) {
    this._initData = i, this._extHostNotebook = n, this._commands = r, this._logService = s, this._activeExecutions = new fi(), this._activeNotebookExecutions = new fi(), this._kernelDetectionTask = /* @__PURE__ */ new Map(), this._kernelDetectionTaskHandlePool = 0, this._kernelSourceActionProviders = /* @__PURE__ */ new Map(), this._kernelSourceActionProviderHandlePool = 0, this._kernelData = /* @__PURE__ */ new Map(), this._handlePool = 0, this.id = 0, this.variableStore = {}, this._proxy = e.getProxy(ee.MainThreadNotebookKernels);
    const o = new Pe(
      "notebook.selectKernel",
      "_notebook.selectKernel",
      "Trigger kernel picker for specified notebook editor widget",
      [
        new q("options", "Select kernel options", (l) => !0, (l) => {
          if (l && "notebookEditor" in l && "id" in l) {
            const c = this._extHostNotebook.getIdByEditor(l.notebookEditor);
            return {
              id: l.id,
              extension: l.extension,
              notebookEditorId: c
            };
          } else if (l && "notebookEditor" in l) {
            const c = this._extHostNotebook.getIdByEditor(l.notebookEditor);
            if (c === void 0)
              throw new Error(
                `Cannot invoke 'notebook.selectKernel' for unrecognized notebook editor ${l.notebookEditor.notebook.uri.toString()}`
              );
            return "skipIfAlreadySelected" in l ? { notebookEditorId: c, skipIfAlreadySelected: l.skipIfAlreadySelected } : { notebookEditorId: c };
          }
          return l;
        })
      ],
      Se.Void
    ), a = new Pe(
      "vscode.executeNotebookVariableProvider",
      "_executeNotebookVariableProvider",
      "Execute notebook variable provider",
      [q.Uri],
      new Se("A promise that resolves to an array of variables", (l, c) => l.map((u) => ({
        variable: {
          name: u.name,
          value: u.value,
          expression: u.expression,
          type: u.type,
          language: u.language
        },
        hasNamedChildren: u.hasNamedChildren,
        indexedChildrenCount: u.indexedChildrenCount
      })))
    );
    this._commands.registerApiCommand(o), this._commands.registerApiCommand(a);
  }
  createNotebookController(e, i, n, r, s, o) {
    for (const V of this._kernelData.values())
      if (V.controller.id === i && ht.equals(e.identifier, V.extensionId))
        throw new Error(`notebook controller with id '${i}' ALREADY exist`);
    const a = this._handlePool++, l = this;
    this._logService.trace(`NotebookController[${a}], CREATED by ${e.identifier.value}, ${i}`);
    const c = () => console.warn(`NO execute handler from notebook controller '${g.id}' of extension: '${e.identifier}'`);
    let u = !1;
    const d = new N(), f = new N(), g = {
      id: Kf(e.identifier, i),
      notebookType: n,
      extensionId: e.identifier,
      extensionLocation: e.extensionLocation,
      label: r || e.identifier.value,
      preloads: o ? o.map(Dm.from) : []
    };
    let _ = s ?? c, w, v;
    this._proxy.$addKernel(a, g).catch((V) => {
      console.log(V), u = !0;
    });
    let S = 0;
    const E = () => {
      if (u)
        return;
      const V = ++S;
      Promise.resolve().then(() => {
        V === S && this._proxy.$updateKernel(a, g);
      });
    }, A = new fi(), j = {
      get id() {
        return i;
      },
      get notebookType() {
        return g.notebookType;
      },
      onDidChangeSelectedNotebooks: d.event,
      get label() {
        return g.label;
      },
      set label(V) {
        g.label = V ?? e.displayName ?? e.name, E();
      },
      get detail() {
        return g.detail ?? "";
      },
      set detail(V) {
        g.detail = V, E();
      },
      get description() {
        return g.description ?? "";
      },
      set description(V) {
        g.description = V, E();
      },
      get supportedLanguages() {
        return g.supportedLanguages;
      },
      set supportedLanguages(V) {
        g.supportedLanguages = V, E();
      },
      get supportsExecutionOrder() {
        return g.supportsExecutionOrder ?? !1;
      },
      set supportsExecutionOrder(V) {
        g.supportsExecutionOrder = V, E();
      },
      get rendererScripts() {
        return g.preloads ? g.preloads.map(Dm.to) : [];
      },
      get executeHandler() {
        return _;
      },
      set executeHandler(V) {
        _ = V ?? c;
      },
      get interruptHandler() {
        return w;
      },
      set interruptHandler(V) {
        w = V, g.supportsInterrupt = !!V, E();
      },
      set variableProvider(V) {
        $(e, "notebookVariableProvider"), v = V, g.hasVariableProvider = !!V, V?.onDidChangeVariables((le) => l._proxy.$variablesUpdated(le.uri)), E();
      },
      get variableProvider() {
        return v;
      },
      createNotebookCellExecution(V) {
        if (u)
          throw new Error("notebook controller is DISPOSED");
        if (!A.has(V.notebook.uri))
          throw l._logService.trace(`NotebookController[${a}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(A.keys()).map((le) => le.toString())), new Error(`notebook controller is NOT associated to notebook: ${V.notebook.uri.toString()}`);
        return l._createNotebookCellExecution(V, Kf(e.identifier, this.id));
      },
      createNotebookExecution(V) {
        if ($(e, "notebookExecution"), u)
          throw new Error("notebook controller is DISPOSED");
        if (!A.has(V.uri))
          throw l._logService.trace(`NotebookController[${a}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(A.keys()).map((le) => le.toString())), new Error(`notebook controller is NOT associated to notebook: ${V.uri.toString()}`);
        return l._createNotebookExecution(V, Kf(e.identifier, this.id));
      },
      dispose: () => {
        u || (this._logService.trace(`NotebookController[${a}], DISPOSED`), u = !0, this._kernelData.delete(a), d.dispose(), f.dispose(), this._proxy.$removeKernel(a));
      },
      updateNotebookAffinity(V, le) {
        le === Xg.Hidden && $(e, "notebookControllerAffinityHidden"), l._proxy.$updateNotebookPriority(a, V.uri, le);
      },
      onDidReceiveMessage: f.event,
      postMessage(V, le) {
        return $(e, "notebookMessaging"), l._proxy.$postMessage(a, le && l._extHostNotebook.getIdByEditor(le), V);
      },
      asWebviewUri(V) {
        return $(e, "notebookMessaging"), Id(V, l._initData.remote);
      }
    };
    return this._kernelData.set(a, {
      extensionId: e.identifier,
      controller: j,
      onDidReceiveMessage: f,
      onDidChangeSelection: d,
      associatedNotebooks: A
    }), j;
  }
  getIdByController(e) {
    for (const [i, n] of this._kernelData)
      if (n.controller === e)
        return Kf(n.extensionId, e.id);
    return null;
  }
  createNotebookControllerDetectionTask(e, i) {
    const n = this._kernelDetectionTaskHandlePool++, r = this;
    this._logService.trace(`NotebookControllerDetectionTask[${n}], CREATED by ${e.identifier.value}`), this._proxy.$addKernelDetectionTask(n, i);
    const s = {
      dispose: () => {
        this._kernelDetectionTask.delete(n), r._proxy.$removeKernelDetectionTask(n);
      }
    };
    return this._kernelDetectionTask.set(n, s), s;
  }
  registerKernelSourceActionProvider(e, i, n) {
    const r = this._kernelSourceActionProviderHandlePool++, s = typeof n.onDidChangeNotebookKernelSourceActions == "function" ? r : void 0, o = this;
    this._kernelSourceActionProviders.set(r, n), this._logService.trace(`NotebookKernelSourceActionProvider[${r}], CREATED by ${e.identifier.value}`), this._proxy.$addKernelSourceActionProvider(r, r, i);
    let a;
    return s !== void 0 && (a = n.onDidChangeNotebookKernelSourceActions((l) => this._proxy.$emitNotebookKernelSourceActionsChangeEvent(s))), {
      dispose: () => {
        this._kernelSourceActionProviders.delete(r), o._proxy.$removeKernelSourceActionProvider(r, r), a?.dispose();
      }
    };
  }
  async $provideKernelSourceActions(e, i) {
    const n = this._kernelSourceActionProviders.get(e);
    if (n) {
      const r = new De();
      return (await n.provideNotebookKernelSourceActions(i) ?? []).map(
        (o) => qb.from(o, this._commands.converter, r)
      );
    }
    return [];
  }
  $acceptNotebookAssociation(e, i, n) {
    const r = this._kernelData.get(e);
    if (r) {
      const s = this._extHostNotebook.getNotebookDocument(x.revive(i));
      n ? r.associatedNotebooks.set(s.uri, !0) : r.associatedNotebooks.delete(s.uri), this._logService.trace(`NotebookController[${e}] ASSOCIATE notebook`, s.uri.toString(), n), r.onDidChangeSelection.fire({
        selected: n,
        notebook: s.apiNotebook
      });
    }
  }
  async $executeCells(e, i, n) {
    const r = this._kernelData.get(e);
    if (!r)
      return;
    const s = this._extHostNotebook.getNotebookDocument(x.revive(i)), o = [];
    for (const a of n) {
      const l = s.getCell(a);
      l && o.push(l.apiCell);
    }
    try {
      this._logService.trace(`NotebookController[${e}] EXECUTE cells`, s.uri.toString(), o.length), await r.controller.executeHandler.call(r.controller, o, s.apiNotebook, r.controller);
    } catch (a) {
      this._logService.error(`NotebookController[${e}] execute cells FAILED`, a), console.error(a);
    }
  }
  async $cancelCells(e, i, n) {
    const r = this._kernelData.get(e);
    if (!r)
      return;
    const s = this._extHostNotebook.getNotebookDocument(x.revive(i));
    if (r.controller.interruptHandler)
      await r.controller.interruptHandler.call(r.controller, s.apiNotebook);
    else
      for (const o of n) {
        const a = s.getCell(o);
        a && this._activeExecutions.get(a.uri)?.cancel();
      }
    if (r.controller.interruptHandler) {
      const o = this._activeNotebookExecutions.get(s.uri);
      this._activeNotebookExecutions.delete(s.uri), n.length && Array.isArray(o) && o.length && o.forEach((a) => a.dispose());
    }
  }
  async $provideVariables(e, i, n, r, s, o, a) {
    const l = this._kernelData.get(e);
    if (!l)
      return;
    const c = this._extHostNotebook.getNotebookDocument(x.revive(n)), u = l.controller.variableProvider;
    if (!u)
      return;
    let d;
    if (r !== void 0) {
      if (d = this.variableStore[r], !d)
        return;
    } else
      this.variableStore = {};
    const f = s === "named" ? kh.Named : kh.Indexed, g = u.provideVariables(c.apiNotebook, d, f, o, a);
    let _ = 0;
    for await (const w of g) {
      if (a.isCancellationRequested)
        return;
      const v = {
        id: this.id++,
        name: w.variable.name,
        value: w.variable.value,
        type: w.variable.type,
        interfaces: w.variable.interfaces,
        language: w.variable.language,
        expression: w.variable.expression,
        hasNamedChildren: w.hasNamedChildren,
        indexedChildrenCount: w.indexedChildrenCount,
        extensionId: l.extensionId.value
      };
      if (this.variableStore[v.id] = w.variable, this._proxy.$receiveVariable(i, v), _++ >= QU)
        return;
    }
  }
  $acceptKernelMessageFromRenderer(e, i, n) {
    const r = this._kernelData.get(e);
    if (!r)
      return;
    const s = this._extHostNotebook.getEditorById(i);
    r.onDidReceiveMessage.fire(Object.freeze({ editor: s.apiEditor, message: n }));
  }
  _createNotebookCellExecution(e, i) {
    if (e.index < 0)
      throw new Error("CANNOT execute cell that has been REMOVED from notebook");
    const r = this._extHostNotebook.getNotebookDocument(e.notebook.uri).getCellFromApiCell(e);
    if (!r)
      throw new Error("invalid cell");
    if (this._activeExecutions.has(r.uri))
      throw new Error(`duplicate execution for ${r.uri}`);
    const s = new Y0(i, r, this._proxy);
    this._activeExecutions.set(r.uri, s);
    const o = s.onDidChangeState(() => {
      s.state === or.Resolved && (s.dispose(), o.dispose(), this._activeExecutions.delete(r.uri));
    });
    return s.asApiObject();
  }
  _createNotebookExecution(e, i) {
    const n = this._extHostNotebook.getNotebookDocument(e.uri), r = e.getCells().find((a) => {
      const l = n.getCellFromApiCell(a);
      return l && this._activeExecutions.has(l.uri);
    });
    if (r)
      throw new Error(`duplicate cell execution for ${r.document.uri}`);
    if (this._activeNotebookExecutions.has(n.uri))
      throw new Error(`duplicate notebook execution for ${n.uri}`);
    const s = new X0(i, n, this._proxy), o = s.onDidChangeState(() => {
      s.state === Es.Resolved && (s.dispose(), o.dispose(), this._activeNotebookExecutions.delete(n.uri));
    });
    return this._activeNotebookExecutions.set(n.uri, [s, o]), s.asApiObject();
  }
};
J0 = W([
  M(4, nt)
], J0);
var or;
(function(t) {
  t[t.Init = 0] = "Init", t[t.Started = 1] = "Started", t[t.Resolved = 2] = "Resolved";
})(or || (or = {}));
const P_ = class P_ extends ve {
  get state() {
    return this._state;
  }
  constructor(e, i, n) {
    super(), this._cell = i, this._proxy = n, this._handle = P_.HANDLE++, this._onDidChangeState = new N(), this.onDidChangeState = this._onDidChangeState.event, this._state = or.Init, this._tokenSource = this._register(new Pt()), this._collector = new JU(10, (r) => this.update(r)), this._executionOrder = i.internalMetadata.executionOrder, this._proxy.$createExecution(this._handle, e, this._cell.notebook.uri, this._cell.handle);
  }
  cancel() {
    this._tokenSource.cancel();
  }
  async updateSoon(e) {
    await this._collector.addItem(e);
  }
  async update(e) {
    const i = Array.isArray(e) ? e : [e];
    return this._proxy.$updateExecution(this._handle, new zi(i));
  }
  verifyStateForOutput() {
    if (this._state === or.Init)
      throw new Error("Must call start before modifying cell output");
    if (this._state === or.Resolved)
      throw new Error("Cannot modify cell output after calling resolve");
  }
  cellIndexToHandle(e) {
    let i = this._cell;
    if (e && (i = this._cell.notebook.getCellFromApiCell(e)), !i)
      throw new Error("INVALID cell");
    return i.handle;
  }
  validateAndConvertOutputs(e) {
    return e.map((i) => {
      const n = Kg.ensureUniqueMimeTypes(i.items, !0);
      return n === i.items ? Po.from(i) : Po.from({
        items: n,
        id: i.id,
        metadata: i.metadata
      });
    });
  }
  async updateOutputs(e, i, n) {
    const r = this.cellIndexToHandle(i), s = this.validateAndConvertOutputs(qn(e));
    return this.updateSoon({
      editType: Xl.Output,
      cellHandle: r,
      append: n,
      outputs: s
    });
  }
  async updateOutputItems(e, i, n) {
    return e = Kg.ensureUniqueMimeTypes(qn(e), !0), this.updateSoon({
      editType: Xl.OutputItems,
      items: e.map(uu.from),
      outputId: i.id,
      append: n
    });
  }
  asApiObject() {
    const e = this;
    return Object.freeze({
      get token() {
        return e._tokenSource.token;
      },
      get cell() {
        return e._cell.apiCell;
      },
      get executionOrder() {
        return e._executionOrder;
      },
      set executionOrder(n) {
        e._executionOrder = n, e.update([{
          editType: Xl.ExecutionState,
          executionOrder: e._executionOrder
        }]);
      },
      start(n) {
        if (e._state === or.Resolved || e._state === or.Started)
          throw new Error("Cannot call start again");
        e._state = or.Started, e._onDidChangeState.fire(), e.update({
          editType: Xl.ExecutionState,
          runStartTime: n
        });
      },
      end(n, r, s) {
        if (e._state === or.Resolved)
          throw new Error("Cannot call resolve twice");
        e._state = or.Resolved, e._onDidChangeState.fire(), e._collector.flush();
        const o = KU(s);
        e._proxy.$completeExecution(e._handle, new zi({
          runEndTime: r,
          lastRunSuccess: n,
          error: o
        }));
      },
      clearOutput(n) {
        return e.verifyStateForOutput(), e.updateOutputs([], n, !1);
      },
      appendOutput(n, r) {
        return e.verifyStateForOutput(), e.updateOutputs(n, r, !0);
      },
      replaceOutput(n, r) {
        return e.verifyStateForOutput(), e.updateOutputs(n, r, !1);
      },
      appendOutputItems(n, r) {
        return e.verifyStateForOutput(), e.updateOutputItems(n, r, !0);
      },
      replaceOutputItems(n, r) {
        return e.verifyStateForOutput(), e.updateOutputItems(n, r, !1);
      }
    });
  }
};
P_.HANDLE = 0;
let Y0 = P_;
function KU(t) {
  const e = (r) => r ? {
    startLineNumber: r.start.line,
    startColumn: r.start.character,
    endLineNumber: r.end.line,
    endColumn: r.end.character
  } : void 0, i = (r) => ({
    uri: r.uri,
    position: r.position,
    label: r.label
  });
  return t ? {
    name: t.name,
    message: t.message,
    stack: t.stack instanceof Array ? t.stack.map((r) => i(r)) : t.stack,
    location: e(t.location),
    uri: t.uri
  } : void 0;
}
var Es;
(function(t) {
  t[t.Init = 0] = "Init", t[t.Started = 1] = "Started", t[t.Resolved = 2] = "Resolved";
})(Es || (Es = {}));
const A_ = class A_ extends ve {
  get state() {
    return this._state;
  }
  constructor(e, i, n) {
    super(), this._notebook = i, this._proxy = n, this._handle = A_.HANDLE++, this._onDidChangeState = new N(), this.onDidChangeState = this._onDidChangeState.event, this._state = Es.Init, this._tokenSource = this._register(new Pt()), this._proxy.$createNotebookExecution(this._handle, e, this._notebook.uri);
  }
  cancel() {
    this._tokenSource.cancel();
  }
  asApiObject() {
    return Object.freeze({
      start: () => {
        if (this._state === Es.Resolved || this._state === Es.Started)
          throw new Error("Cannot call start again");
        this._state = Es.Started, this._onDidChangeState.fire(), this._proxy.$beginNotebookExecution(this._handle);
      },
      end: () => {
        if (this._state === Es.Resolved)
          throw new Error("Cannot call resolve twice");
        this._state = Es.Resolved, this._onDidChangeState.fire(), this._proxy.$completeNotebookExecution(this._handle);
      }
    });
  }
};
A_.HANDLE = 0;
let X0 = A_;
class JU {
  constructor(e, i) {
    this.delay = e, this.callback = i, this.batch = [], this.startedTimer = Date.now();
  }
  addItem(e) {
    return this.batch.push(e), this.currentDeferred || (this.currentDeferred = new ko(), this.startedTimer = Date.now(), qr(this.delay).then(() => this.flush())), Date.now() - this.startedTimer > this.delay ? this.flush() : this.currentDeferred.p;
  }
  flush() {
    if (this.batch.length === 0 || !this.currentDeferred)
      return Promise.resolve();
    const e = this.currentDeferred;
    this.currentDeferred = void 0;
    const i = this.batch;
    return this.batch = [], this.callback(i).finally(() => e.complete());
  }
}
function Kf(t, e) {
  return `${t.value}/${e}`;
}
class YU {
  constructor(e, i) {
    this._extHostNotebook = i, this._rendererMessageEmitters = /* @__PURE__ */ new Map(), this.proxy = e.getProxy(ee.MainThreadNotebookRenderers);
  }
  $postRendererMessage(e, i, n) {
    const r = this._extHostNotebook.getEditorById(e);
    this._rendererMessageEmitters.get(i)?.fire({ editor: r.apiEditor, message: n });
  }
  createRendererMessaging(e, i) {
    if (!e.contributes?.notebookRenderer?.some((r) => r.id === i))
      throw new Error(
        `Extensions may only call createRendererMessaging() for renderers they contribute (got ${i})`
      );
    return {
      onDidReceiveMessage: (r, s, o) => this.getOrCreateEmitterFor(i).event(r, s, o),
      postMessage: (r, s) => {
        rf.apiEditorsToExtHost.has(r) && ([r, s] = [s, r]);
        const o = s && rf.apiEditorsToExtHost.get(s);
        return this.proxy.$postMessage(o?.id, i, r);
      }
    };
  }
  getOrCreateEmitterFor(e) {
    let i = this._rendererMessageEmitters.get(e);
    return i || (i = new N({
      onDidRemoveLastListener: () => {
        i?.dispose(), this._rendererMessageEmitters.delete(e);
      }
    }), this._rendererMessageEmitters.set(e, i), i);
  }
}
class XU {
  constructor(e) {
    this.handlers = /* @__PURE__ */ new Map(), this.proxy = e.getProxy(ee.MainThreadProfileContentHandlers);
  }
  registerProfileContentHandler(e, i, n) {
    if ($(e, "profileContentHandlers"), this.handlers.has(i))
      throw new Error(`Handler with id '${i}' already registered`);
    return this.handlers.set(i, n), this.proxy.$registerProfileContentHandler(i, n.name, n.description, e.identifier.value), Ee(() => {
      this.handlers.delete(i), this.proxy.$unregisterProfileContentHandler(i);
    });
  }
  async $saveProfile(e, i, n, r) {
    const s = this.handlers.get(e);
    if (!s)
      throw new Error(`Unknown handler with id: ${e}`);
    return s.saveProfile(i, n, r);
  }
  async $readProfile(e, i, n) {
    const r = this.handlers.get(e);
    if (!r)
      throw new Error(`Unknown handler with id: ${e}`);
    return r.readProfile(it(i) ? i : x.revive(i), n);
  }
}
const R_ = class R_ {
  constructor(e, i) {
    this.uriTransformer = i, this.providers = /* @__PURE__ */ new Map(), this.proxy = e.getProxy(ee.MainThreadQuickDiff);
  }
  $provideOriginalResource(e, i, n) {
    const r = x.revive(i), s = this.providers.get(e);
    return s ? Ai(() => s.provideOriginalResource(r, n)).then((o) => o || null) : Promise.resolve(null);
  }
  registerQuickDiffProvider(e, i, n, r, s, o) {
    const a = R_.handlePool++;
    this.providers.set(a, n);
    const l = ht.toKey(e.identifier);
    return this.proxy.$registerQuickDiffProvider(a, iu.from(i, this.uriTransformer), `${l}.${r}`, s, o), {
      dispose: () => {
        this.proxy.$unregisterQuickDiffProvider(a), this.providers.delete(a);
      }
    };
  }
};
R_.handlePool = 0;
let Z0 = R_;
function ZU(t, e, i) {
  const n = t.getProxy(ee.MainThreadQuickOpen);
  class r {
    constructor(_, w) {
      this._sessions = /* @__PURE__ */ new Map(), this._instances = 0, this._workspace = _, this._commands = w;
    }
    showQuickPick(_, w, v, S = xt.None) {
      this._onDidSelectItem = void 0;
      const E = Promise.resolve(w), A = ++this._instances, j = n.$show(A, {
        title: v?.title,
        placeHolder: v?.placeHolder,
        matchOnDescription: v?.matchOnDescription,
        matchOnDetail: v?.matchOnDetail,
        ignoreFocusLost: v?.ignoreFocusOut,
        canPickMany: v?.canPickMany
      }, S), V = {}, le = j.then(() => V);
      return Promise.race([le, E]).then((Q) => {
        if (Q === V)
          return;
        const re = lt(_, "quickPickItemTooltip");
        return E.then((K) => {
          const ye = [];
          for (let Fe = 0; Fe < K.length; Fe++) {
            const Te = K[Fe];
            if (typeof Te == "string")
              ye.push({ label: Te, handle: Fe });
            else if (Te.kind === Dh.Separator)
              ye.push({ type: "separator", label: Te.label });
            else {
              Te.tooltip && !re && console.warn(`Extension '${_.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${_.identifier.value}`);
              const X = Te.iconPath ? c(Te.iconPath) : void 0;
              ye.push({
                label: Te.label,
                iconPath: X?.iconPath,
                iconClass: X?.iconClass,
                description: Te.description,
                detail: Te.detail,
                picked: Te.picked,
                alwaysShow: Te.alwaysShow,
                tooltip: re ? Ae.fromStrict(Te.tooltip) : void 0,
                handle: Fe
              });
            }
          }
          return v && typeof v.onDidSelectItem == "function" && (this._onDidSelectItem = (Fe) => {
            v.onDidSelectItem(K[Fe]);
          }), n.$setItems(A, ye), j.then((Fe) => {
            if (typeof Fe == "number")
              return K[Fe];
            if (Array.isArray(Fe))
              return Fe.map((Te) => K[Te]);
          });
        });
      }).then(void 0, (Q) => {
        if (!Yr(Q))
          return n.$setError(A, Q), Promise.reject(Q);
      });
    }
    $onItemSelected(_) {
      this._onDidSelectItem?.(_);
    }
    showInput(_, w = xt.None) {
      return this._validateInput = _?.validateInput, n.$input(_, typeof this._validateInput == "function", w).then(void 0, (v) => {
        if (!Yr(v))
          return Promise.reject(v);
      });
    }
    async $validateInput(_) {
      if (!this._validateInput)
        return;
      const w = await this._validateInput(_);
      if (!w || typeof w == "string")
        return w;
      let v;
      switch (w.severity) {
        case yc.Info:
          v = Qt.Info;
          break;
        case yc.Warning:
          v = Qt.Warning;
          break;
        case yc.Error:
          v = Qt.Error;
          break;
        default:
          v = w.message ? Qt.Error : Qt.Ignore;
          break;
      }
      return {
        content: w.message,
        severity: v
      };
    }
    async showWorkspaceFolderPick(_, w = xt.None) {
      const v = await this._commands.executeCommand("_workbench.pickWorkspaceFolder", [_]);
      if (!v)
        return;
      const S = await this._workspace.getWorkspaceFolders2();
      if (S)
        return S.find((E) => E.uri.toString() === v.uri.toString());
    }
    createQuickPick(_) {
      const w = new u(_, () => this._sessions.delete(w._id));
      return this._sessions.set(w._id, w), w;
    }
    createInputBox(_) {
      const w = new d(_, () => this._sessions.delete(w._id));
      return this._sessions.set(w._id, w), w;
    }
    $onDidChangeValue(_, w) {
      this._sessions.get(_)?._fireDidChangeValue(w);
    }
    $onDidAccept(_) {
      this._sessions.get(_)?._fireDidAccept();
    }
    $onDidChangeActive(_, w) {
      const v = this._sessions.get(_);
      v instanceof u && v._fireDidChangeActive(w);
    }
    $onDidChangeSelection(_, w) {
      const v = this._sessions.get(_);
      v instanceof u && v._fireDidChangeSelection(w);
    }
    $onDidTriggerButton(_, w) {
      this._sessions.get(_)?._fireDidTriggerButton(w);
    }
    $onDidTriggerItemButton(_, w, v) {
      const S = this._sessions.get(_);
      S instanceof u && S._fireDidTriggerItemButton(w, v);
    }
    $onDidHide(_) {
      this._sessions.get(_)?._fireDidHide();
    }
  }
  const f = class f {
    constructor(_, w) {
      this._extension = _, this._onDidDispose = w, this._id = u._nextId++, this._visible = !1, this._expectingHide = !1, this._enabled = !0, this._busy = !1, this._ignoreFocusOut = !0, this._value = "", this._valueSelection = void 0, this._buttons = [], this._handlesToButtons = /* @__PURE__ */ new Map(), this._onDidAcceptEmitter = new N(), this._onDidChangeValueEmitter = new N(), this._onDidTriggerButtonEmitter = new N(), this._onDidHideEmitter = new N(), this._pendingUpdate = { id: this._id }, this._disposed = !1, this._disposables = [
        this._onDidTriggerButtonEmitter,
        this._onDidHideEmitter,
        this._onDidAcceptEmitter,
        this._onDidChangeValueEmitter
      ], this.onDidChangeValue = this._onDidChangeValueEmitter.event, this.onDidAccept = this._onDidAcceptEmitter.event, this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event, this.onDidHide = this._onDidHideEmitter.event;
    }
    get title() {
      return this._title;
    }
    set title(_) {
      this._title = _, this.update({ title: _ });
    }
    get step() {
      return this._steps;
    }
    set step(_) {
      this._steps = _, this.update({ step: _ });
    }
    get totalSteps() {
      return this._totalSteps;
    }
    set totalSteps(_) {
      this._totalSteps = _, this.update({ totalSteps: _ });
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(_) {
      this._enabled = _, this.update({ enabled: _ });
    }
    get busy() {
      return this._busy;
    }
    set busy(_) {
      this._busy = _, this.update({ busy: _ });
    }
    get ignoreFocusOut() {
      return this._ignoreFocusOut;
    }
    set ignoreFocusOut(_) {
      this._ignoreFocusOut = _, this.update({ ignoreFocusOut: _ });
    }
    get value() {
      return this._value;
    }
    set value(_) {
      this._value = _, this.update({ value: _ });
    }
    get valueSelection() {
      return this._valueSelection;
    }
    set valueSelection(_) {
      this._valueSelection = _, this.update({ valueSelection: _ });
    }
    get placeholder() {
      return this._placeholder;
    }
    set placeholder(_) {
      this._placeholder = _, this.update({ placeholder: _ });
    }
    get buttons() {
      return this._buttons;
    }
    set buttons(_) {
      const w = lt(this._extension, "quickInputButtonLocation");
      !w && _.some((v) => v.location) && console.warn(`Extension '${this._extension.identifier.value}' uses a button location which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this._extension.identifier.value}`), this._buttons = _.slice(), this._handlesToButtons.clear(), _.forEach((v, S) => {
        const E = v === Sh.Back ? -1 : S;
        this._handlesToButtons.set(E, v);
      }), this.update({
        buttons: _.map((v, S) => ({
          ...c(v.iconPath),
          tooltip: v.tooltip,
          handle: v === Sh.Back ? -1 : S,
          location: w ? v.location : void 0
        }))
      });
    }
    show() {
      this._visible = !0, this._expectingHide = !0, this.update({ visible: !0 });
    }
    hide() {
      this._visible = !1, this.update({ visible: !1 });
    }
    _fireDidAccept() {
      this._onDidAcceptEmitter.fire();
    }
    _fireDidChangeValue(_) {
      this._value = _, this._onDidChangeValueEmitter.fire(_);
    }
    _fireDidTriggerButton(_) {
      const w = this._handlesToButtons.get(_);
      w && this._onDidTriggerButtonEmitter.fire(w);
    }
    _fireDidHide() {
      this._expectingHide && (this._expectingHide = this._visible, this._onDidHideEmitter.fire());
    }
    dispose() {
      this._disposed || (this._disposed = !0, this._fireDidHide(), this._disposables = Wn(this._disposables), this._updateTimeout && (clearTimeout(this._updateTimeout), this._updateTimeout = void 0), this._onDidDispose(), n.$dispose(this._id));
    }
    update(_) {
      if (!this._disposed) {
        for (const w of Object.keys(_)) {
          const v = _[w];
          this._pendingUpdate[w] = v === void 0 ? null : v;
        }
        "visible" in this._pendingUpdate ? (this._updateTimeout && (clearTimeout(this._updateTimeout), this._updateTimeout = void 0), this.dispatchUpdate()) : this._visible && !this._updateTimeout && (this._updateTimeout = setTimeout(() => {
          this._updateTimeout = void 0, this.dispatchUpdate();
        }, 0));
      }
    }
    dispatchUpdate() {
      n.$createOrUpdate(this._pendingUpdate), this._pendingUpdate = { id: this._id };
    }
  };
  f._nextId = 1;
  let s = f;
  function o(g) {
    if (g instanceof qi)
      return { id: g.id };
    const _ = l(g), w = a(g);
    return {
      dark: typeof _ == "string" ? x.file(_) : _,
      light: typeof w == "string" ? x.file(w) : w
    };
  }
  function a(g) {
    return typeof g == "object" && "light" in g ? g.light : g;
  }
  function l(g) {
    return typeof g == "object" && "dark" in g ? g.dark : g;
  }
  function c(g) {
    const _ = o(g);
    let w, v;
    return "id" in _ ? v = oi.asClassName(_) : w = _, {
      iconPath: w,
      iconClass: v
    };
  }
  class u extends s {
    constructor(_, w) {
      super(_, w), this._items = [], this._handlesToItems = /* @__PURE__ */ new Map(), this._itemsToHandles = /* @__PURE__ */ new Map(), this._canSelectMany = !1, this._matchOnDescription = !0, this._matchOnDetail = !0, this._sortByLabel = !0, this._keepScrollPosition = !1, this._activeItems = [], this._onDidChangeActiveEmitter = new N(), this._selectedItems = [], this._onDidChangeSelectionEmitter = new N(), this._onDidTriggerItemButtonEmitter = new N(), this.onDidChangeActive = this._onDidChangeActiveEmitter.event, this.onDidChangeSelection = this._onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this._onDidTriggerItemButtonEmitter.event, this._disposables.push(this._onDidChangeActiveEmitter, this._onDidChangeSelectionEmitter, this._onDidTriggerItemButtonEmitter), this.update({ type: "quickPick" });
    }
    get items() {
      return this._items;
    }
    set items(_) {
      this._items = _.slice(), this._handlesToItems.clear(), this._itemsToHandles.clear(), _.forEach((S, E) => {
        this._handlesToItems.set(E, S), this._itemsToHandles.set(S, E);
      });
      const w = lt(this._extension, "quickPickItemTooltip"), v = [];
      for (let S = 0; S < _.length; S++) {
        const E = _[S];
        if (E.kind === Dh.Separator)
          v.push({ type: "separator", label: E.label });
        else {
          E.tooltip && !w && console.warn(`Extension '${this._extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this._extension.identifier.value}`);
          const A = E.iconPath ? c(E.iconPath) : void 0;
          v.push({
            handle: S,
            label: E.label,
            iconPath: A?.iconPath,
            iconClass: A?.iconClass,
            description: E.description,
            detail: E.detail,
            picked: E.picked,
            alwaysShow: E.alwaysShow,
            tooltip: w ? Ae.fromStrict(E.tooltip) : void 0,
            buttons: E.buttons?.map((j, V) => ({
              ...c(j.iconPath),
              tooltip: j.tooltip,
              handle: V
            }))
          });
        }
      }
      this.update({
        items: v
      });
    }
    get canSelectMany() {
      return this._canSelectMany;
    }
    set canSelectMany(_) {
      this._canSelectMany = _, this.update({ canSelectMany: _ });
    }
    get matchOnDescription() {
      return this._matchOnDescription;
    }
    set matchOnDescription(_) {
      this._matchOnDescription = _, this.update({ matchOnDescription: _ });
    }
    get matchOnDetail() {
      return this._matchOnDetail;
    }
    set matchOnDetail(_) {
      this._matchOnDetail = _, this.update({ matchOnDetail: _ });
    }
    get sortByLabel() {
      return this._sortByLabel;
    }
    set sortByLabel(_) {
      this._sortByLabel = _, this.update({ sortByLabel: _ });
    }
    get keepScrollPosition() {
      return this._keepScrollPosition;
    }
    set keepScrollPosition(_) {
      this._keepScrollPosition = _, this.update({ keepScrollPosition: _ });
    }
    get activeItems() {
      return this._activeItems;
    }
    set activeItems(_) {
      this._activeItems = _.filter((w) => this._itemsToHandles.has(w)), this.update({ activeItems: this._activeItems.map((w) => this._itemsToHandles.get(w)) });
    }
    get selectedItems() {
      return this._selectedItems;
    }
    set selectedItems(_) {
      this._selectedItems = _.filter((w) => this._itemsToHandles.has(w)), this.update({ selectedItems: this._selectedItems.map((w) => this._itemsToHandles.get(w)) });
    }
    _fireDidChangeActive(_) {
      const w = Kt(_.map((v) => this._handlesToItems.get(v)));
      this._activeItems = w, this._onDidChangeActiveEmitter.fire(w);
    }
    _fireDidChangeSelection(_) {
      const w = Kt(_.map((v) => this._handlesToItems.get(v)));
      this._selectedItems = w, this._onDidChangeSelectionEmitter.fire(w);
    }
    _fireDidTriggerItemButton(_, w) {
      const v = this._handlesToItems.get(_);
      if (!v || !v.buttons || !v.buttons.length)
        return;
      const S = v.buttons[w];
      S && this._onDidTriggerItemButtonEmitter.fire({
        button: S,
        item: v
      });
    }
  }
  class d extends s {
    constructor(_, w) {
      super(_, w), this._password = !1, this.update({ type: "inputBox" });
    }
    get password() {
      return this._password;
    }
    set password(_) {
      this._password = _, this.update({ password: _ });
    }
    get prompt() {
      return this._prompt;
    }
    set prompt(_) {
      this._prompt = _, this.update({ prompt: _ });
    }
    get validationMessage() {
      return this._validationMessage;
    }
    set validationMessage(_) {
      this._validationMessage = _, _ ? typeof _ == "string" ? this.update({ validationMessage: _, severity: Qt.Error }) : this.update({ validationMessage: _.message, severity: _.severity ?? Qt.Error }) : this.update({ validationMessage: void 0, severity: Qt.Ignore });
    }
  }
  return new r(e, i);
}
const VC = new Vi(() => {
  const t = i5.Collator(void 0, { numeric: !0, sensitivity: "base" }).value;
  return {
    collator: t,
    collatorIsNumeric: t.resolvedOptions().numeric
  };
});
function e$(t, e, i = !1) {
  const n = t || "", r = e || "", s = VC.value.collator.compare(n, r);
  return VC.value.collatorIsNumeric && s === 0 && n !== r ? n < r ? -1 : 1 : s;
}
function t$(t, e, i = !1) {
  return i || (t = t && t.toLowerCase(), e = e && e.toLowerCase()), t === e ? 0 : t < e ? -1 : 1;
}
function kp(t, e, i = !1) {
  const n = t.split(Vn), r = e.split(Vn), s = n.length - 1, o = r.length - 1;
  let a, l;
  for (let c = 0; ; c++) {
    if (a = s === c, l = o === c, a && l)
      return e$(n[c], r[c], i);
    if (a)
      return -1;
    if (l)
      return 1;
    const u = t$(n[c], r[c], i);
    if (u !== 0)
      return u;
  }
}
function zC(t) {
  return t instanceof x;
}
function i$(t, e) {
  return t.scheme === de.file && e.scheme === de.file && So ? t.toString() === e.toString() : t.toString().toLowerCase() === e.toString().toLowerCase();
}
function uv(t) {
  if (t)
    return typeof t.iconPath == "string" ? x.file(t.iconPath) : x.isUri(t.iconPath) || oi.isThemeIcon(t.iconPath) ? t.iconPath : void 0;
}
function wo(t) {
  if (t) {
    if (x.isUri(t))
      return t;
    if (oi.isThemeIcon(t))
      return t;
    {
      const e = t;
      return { light: e.light, dark: e.dark };
    }
  } else return;
}
function n$(t) {
  const e = wo(t.authorIcon), i = t.references?.map((n) => ({
    ...n,
    icon: wo(n.icon)
  }));
  return { ...t, authorIcon: e, references: i };
}
function dv(t) {
  return t ? { ...t, icon: wo(t.icon) } : void 0;
}
function hv(t, e) {
  if (!t.iconPath && !e.iconPath)
    return 0;
  if (t.iconPath) {
    if (!e.iconPath)
      return 1;
  } else return -1;
  const i = typeof t.iconPath == "string" ? t.iconPath : x.isUri(t.iconPath) ? t.iconPath.fsPath : t.iconPath.id, n = typeof e.iconPath == "string" ? e.iconPath : x.isUri(e.iconPath) ? e.iconPath.fsPath : e.iconPath.id;
  return kp(i, n);
}
function r$(t, e) {
  let i = 0;
  if (t.strikeThrough !== e.strikeThrough)
    return t.strikeThrough ? 1 : -1;
  if (t.faded !== e.faded)
    return t.faded ? 1 : -1;
  if (t.tooltip !== e.tooltip)
    return (t.tooltip || "").localeCompare(e.tooltip || "");
  if (i = hv(t, e), i !== 0)
    return i;
  if (t.light && e.light)
    i = hv(t.light, e.light);
  else {
    if (t.light)
      return 1;
    if (e.light)
      return -1;
  }
  if (i !== 0)
    return i;
  if (t.dark && e.dark)
    i = hv(t.dark, e.dark);
  else {
    if (t.dark)
      return 1;
    if (e.dark)
      return -1;
  }
  return i;
}
function s$(t, e) {
  if (t.command !== e.command)
    return t.command < e.command ? -1 : 1;
  if (t.title !== e.title)
    return t.title < e.title ? -1 : 1;
  if (t.tooltip !== e.tooltip) {
    if (t.tooltip !== void 0 && e.tooltip !== void 0)
      return t.tooltip < e.tooltip ? -1 : 1;
    if (t.tooltip !== void 0)
      return 1;
    if (e.tooltip !== void 0)
      return -1;
  }
  if (t.arguments === e.arguments)
    return 0;
  if (t.arguments)
    if (e.arguments) {
      if (t.arguments.length !== e.arguments.length)
        return t.arguments.length - e.arguments.length;
    } else return 1;
  else return -1;
  for (let i = 0; i < t.arguments.length; i++) {
    const n = t.arguments[i], r = e.arguments[i];
    if (n !== r && !(zC(n) && zC(r) && i$(n, r)))
      return n < r ? -1 : 1;
  }
  return 0;
}
function qC(t, e) {
  let i = kp(t.resourceUri.fsPath, e.resourceUri.fsPath, !0);
  if (i !== 0)
    return i;
  if (t.command && e.command)
    i = s$(t.command, e.command);
  else {
    if (t.command)
      return 1;
    if (e.command)
      return -1;
  }
  if (i !== 0)
    return i;
  if (t.decorations && e.decorations)
    i = r$(t.decorations, e.decorations);
  else {
    if (t.decorations)
      return 1;
    if (e.decorations)
      return -1;
  }
  if (i !== 0)
    return i;
  if (t.multiFileDiffEditorModifiedUri && e.multiFileDiffEditorModifiedUri)
    i = kp(t.multiFileDiffEditorModifiedUri.fsPath, e.multiFileDiffEditorModifiedUri.fsPath, !0);
  else {
    if (t.multiFileDiffEditorModifiedUri)
      return 1;
    if (e.multiFileDiffEditorModifiedUri)
      return -1;
  }
  if (i !== 0)
    return i;
  if (t.multiDiffEditorOriginalUri && e.multiDiffEditorOriginalUri)
    i = kp(t.multiDiffEditorOriginalUri.fsPath, e.multiDiffEditorOriginalUri.fsPath, !0);
  else {
    if (t.multiDiffEditorOriginalUri)
      return 1;
    if (e.multiDiffEditorOriginalUri)
      return -1;
  }
  return i;
}
function o$(t, e) {
  for (let i = 0; i < t.length; i++)
    if (t[i] !== e[i])
      return !1;
  return !0;
}
function a$(t, e) {
  return t.command === e.command && t.title === e.title && t.tooltip === e.tooltip && (t.arguments && e.arguments ? o$(t.arguments, e.arguments) : t.arguments === e.arguments);
}
function l$(t, e) {
  return An(t, e, a$);
}
class c$ {
  #e;
  #t;
  get value() {
    return this._value;
  }
  set value(e) {
    e = e ?? "", this.#e.$setInputBoxValue(this._sourceControlHandle, e), this.updateValue(e);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this.#e.$setInputBoxPlaceholder(this._sourceControlHandle, e), this._placeholder = e;
  }
  get validateInput() {
    return $(this._extension, "scmValidation"), this._validateInput;
  }
  set validateInput(e) {
    if ($(this._extension, "scmValidation"), e && typeof e != "function")
      throw new Error(
        `[${this._extension.identifier.value}]: Invalid SCM input box validation function`
      );
    this._validateInput = e, this.#e.$setValidationProviderIsEnabled(this._sourceControlHandle, !!e);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    e = !!e, this._enabled !== e && (this._enabled = e, this.#e.$setInputBoxEnablement(this._sourceControlHandle, e));
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    e = !!e, this._visible !== e && (this._visible = e, this.#e.$setInputBoxVisibility(this._sourceControlHandle, e));
  }
  get document() {
    return $(this._extension, "scmTextDocument"), this.#t.getDocument(this._documentUri);
  }
  constructor(e, i, n, r, s) {
    this._extension = e, this._sourceControlHandle = r, this._documentUri = s, this._value = "", this._onDidChange = new N(), this._placeholder = "", this._enabled = !0, this._visible = !0, this.#t = i, this.#e = n;
  }
  showValidationMessage(e, i) {
    $(this._extension, "scmValidation"), this.#e.$showValidationMessage(this._sourceControlHandle, e, i);
  }
  $onInputBoxValueChange(e) {
    this.updateValue(e);
  }
  updateValue(e) {
    this._value = e, this._onDidChange.fire(e);
  }
}
const L_ = class L_ {
  get disposed() {
    return this._disposed;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._label = e, this._proxy.$updateGroupLabel(this._sourceControlHandle, this.handle, e);
  }
  get contextValue() {
    return this._contextValue;
  }
  set contextValue(e) {
    this._contextValue = e, this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features);
  }
  get hideWhenEmpty() {
    return this._hideWhenEmpty;
  }
  set hideWhenEmpty(e) {
    this._hideWhenEmpty = e, this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features);
  }
  get features() {
    return {
      contextValue: this.contextValue,
      hideWhenEmpty: this.hideWhenEmpty
    };
  }
  get resourceStates() {
    return [...this._resourceStates];
  }
  set resourceStates(e) {
    this._resourceStates = [...e], this._onDidUpdateResourceStates.fire();
  }
  constructor(e, i, n, r, s, o, a) {
    this._proxy = e, this._commands = i, this._sourceControlHandle = n, this._id = r, this._label = s, this.multiDiffEditorEnableViewChanges = o, this._extension = a, this._resourceHandlePool = 0, this._resourceStates = [], this._resourceStatesMap = /* @__PURE__ */ new Map(), this._resourceStatesCommandsMap = /* @__PURE__ */ new Map(), this._resourceStatesDisposablesMap = /* @__PURE__ */ new Map(), this._onDidUpdateResourceStates = new N(), this.onDidUpdateResourceStates = this._onDidUpdateResourceStates.event, this._disposed = !1, this._onDidDispose = new N(), this.onDidDispose = this._onDidDispose.event, this._handlesSnapshot = [], this._resourceSnapshot = [], this._contextValue = void 0, this._hideWhenEmpty = void 0, this.handle = L_._handlePool++;
  }
  getResourceState(e) {
    return this._resourceStatesMap.get(e);
  }
  $executeResourceCommand(e, i) {
    const n = this._resourceStatesCommandsMap.get(e);
    return n ? Ai(() => this._commands.executeCommand(n.command, ...n.arguments || [], i)) : Promise.resolve(void 0);
  }
  _takeResourceStateSnapshot() {
    const e = [...this._resourceStates].sort(qC), n = ZC(this._resourceSnapshot, e, qC).map((o) => {
      const a = o.toInsert.map((l) => {
        const c = this._resourceHandlePool++;
        this._resourceStatesMap.set(c, l);
        const u = l.resourceUri;
        let d;
        if (l.command)
          if (l.command.command === "vscode.open" || l.command.command === "vscode.diff" || l.command.command === "vscode.changes") {
            const re = new De();
            d = this._commands.converter.toInternal(l.command, re), this._resourceStatesDisposablesMap.set(c, re);
          } else
            this._resourceStatesCommandsMap.set(c, l.command);
        const f = lt(this._extension, "scmMultiDiffEditor"), g = f ? l.multiDiffEditorOriginalUri : void 0, _ = f ? l.multiFileDiffEditorModifiedUri : void 0, w = uv(l.decorations), v = l.decorations && uv(l.decorations.light) || w, S = l.decorations && uv(l.decorations.dark) || w, E = [v, S], A = l.decorations && l.decorations.tooltip || "", j = l.decorations && !!l.decorations.strikeThrough, V = l.decorations && !!l.decorations.faded, le = l.contextValue || "";
        return { rawResource: [c, u, E, A, j, V, le, d, g, _], handle: c };
      });
      return { start: o.start, deleteCount: o.deleteCount, toInsert: a };
    }), r = n.map(({ start: o, deleteCount: a, toInsert: l }) => [o, a, l.map((c) => c.rawResource)]), s = n.reverse();
    for (const { start: o, deleteCount: a, toInsert: l } of s) {
      const c = l.map((d) => d.handle), u = this._handlesSnapshot.splice(o, a, ...c);
      for (const d of u)
        this._resourceStatesMap.delete(d), this._resourceStatesCommandsMap.delete(d), this._resourceStatesDisposablesMap.get(d)?.dispose(), this._resourceStatesDisposablesMap.delete(d);
    }
    return this._resourceSnapshot = e, r;
  }
  dispose() {
    this._disposed = !0, this._onDidDispose.fire();
  }
};
L_._handlePool = 0;
let ex = L_;
var Zt;
const N_ = class N_ {
  constructor(e, i, n, r, s, o, a, l, c) {
    If(this, Zt);
    this._extension = e, this._commands = r, this._id = s, this._label = o, this._rootUri = a, this._onDidDispose = new N(), this.onDidDispose = this._onDidDispose.event, this._groups = /* @__PURE__ */ new Map(), this._contextValue = void 0, this._count = void 0, this._quickDiffProvider = void 0, this._secondaryQuickDiffProvider = void 0, this._historyProviderDisposable = new Ss(), this._commitTemplate = void 0, this._acceptInputDisposables = new Ss(), this._acceptInputCommand = void 0, this._actionButtonDisposables = new Ss(), this._statusBarDisposables = new Ss(), this._statusBarCommands = void 0, this._selected = !1, this._onDidChangeSelection = new N(), this.onDidChangeSelection = this._onDidChangeSelection.event, this.handle = N_._handlePool++, this.createdResourceGroups = /* @__PURE__ */ new Map(), this.updatedResourceGroups = /* @__PURE__ */ new Set(), Cf(this, Zt, n);
    const u = x.from({
      scheme: de.vscodeSourceControl,
      path: `${s}/scm${this.handle}/input`,
      query: a ? `rootUri=${encodeURIComponent(a.toString())}` : void 0
    });
    this._inputBox = new c$(
      e,
      i,
      zt(this, Zt),
      this.handle,
      u
    ), zt(this, Zt).$registerSourceControl(this.handle, c?.handle, s, o, a, wo(l), u), this.onDidDisposeParent = c ? c.onDidDispose : It.None;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  get rootUri() {
    return this._rootUri;
  }
  get contextValue() {
    return $(this._extension, "scmProviderOptions"), this._contextValue;
  }
  set contextValue(e) {
    $(this._extension, "scmProviderOptions"), this._contextValue !== e && (this._contextValue = e, zt(this, Zt).$updateSourceControl(this.handle, { contextValue: e }));
  }
  get inputBox() {
    return this._inputBox;
  }
  get count() {
    return this._count;
  }
  set count(e) {
    this._count !== e && (this._count = e, zt(this, Zt).$updateSourceControl(this.handle, { count: e }));
  }
  get quickDiffProvider() {
    return this._quickDiffProvider;
  }
  set quickDiffProvider(e) {
    this._quickDiffProvider = e;
    let i;
    lt(this._extension, "quickDiffProvider") && (i = e?.label), zt(this, Zt).$updateSourceControl(this.handle, { hasQuickDiffProvider: !!e, quickDiffLabel: i });
  }
  get secondaryQuickDiffProvider() {
    return $(this._extension, "quickDiffProvider"), this._secondaryQuickDiffProvider;
  }
  set secondaryQuickDiffProvider(e) {
    $(this._extension, "quickDiffProvider"), this._secondaryQuickDiffProvider = e;
    const i = e?.label;
    zt(this, Zt).$updateSourceControl(this.handle, { hasSecondaryQuickDiffProvider: !!e, secondaryQuickDiffLabel: i });
  }
  get historyProvider() {
    return $(this._extension, "scmHistoryProvider"), this._historyProvider;
  }
  set historyProvider(e) {
    $(this._extension, "scmHistoryProvider"), this._historyProvider = e, this._historyProviderDisposable.value = new De(), zt(this, Zt).$updateSourceControl(this.handle, { hasHistoryProvider: !!e }), e && (this._historyProviderDisposable.value.add(e.onDidChangeCurrentHistoryItemRefs(() => {
      const i = dv(e?.currentHistoryItemRef), n = dv(e?.currentHistoryItemRemoteRef), r = dv(e?.currentHistoryItemBaseRef);
      zt(this, Zt).$onDidChangeHistoryProviderCurrentHistoryItemRefs(this.handle, i, n, r);
    })), this._historyProviderDisposable.value.add(e.onDidChangeHistoryItemRefs((i) => {
      if (i.added.length === 0 && i.modified.length === 0 && i.removed.length === 0)
        return;
      const n = i.added.map((o) => ({ ...o, icon: wo(o.icon) })), r = i.modified.map((o) => ({ ...o, icon: wo(o.icon) })), s = i.removed.map((o) => ({ ...o, icon: wo(o.icon) }));
      zt(this, Zt).$onDidChangeHistoryProviderHistoryItemRefs(this.handle, { added: n, modified: r, removed: s, silent: i.silent });
    })));
  }
  get commitTemplate() {
    return this._commitTemplate;
  }
  set commitTemplate(e) {
    e !== this._commitTemplate && (this._commitTemplate = e, zt(this, Zt).$updateSourceControl(this.handle, { commitTemplate: e }));
  }
  get acceptInputCommand() {
    return this._acceptInputCommand;
  }
  set acceptInputCommand(e) {
    this._acceptInputDisposables.value = new De(), this._acceptInputCommand = e;
    const i = this._commands.converter.toInternal(e, this._acceptInputDisposables.value);
    zt(this, Zt).$updateSourceControl(this.handle, { acceptInputCommand: i });
  }
  get actionButton() {
    return $(this._extension, "scmActionButton"), this._actionButton;
  }
  set actionButton(e) {
    if ($(this._extension, "scmActionButton"), xb(this._actionButton, e))
      return;
    this._actionButton = e, this._actionButtonDisposables.value = new De();
    const i = e !== void 0 ? {
      command: {
        ...this._commands.converter.toInternal(e.command, this._actionButtonDisposables.value),
        shortTitle: e.command.shortTitle
      },
      secondaryCommands: e.secondaryCommands?.map((n) => n.map(
        (r) => this._commands.converter.toInternal(r, this._actionButtonDisposables.value)
      )),
      enabled: e.enabled
    } : void 0;
    zt(this, Zt).$updateSourceControl(this.handle, { actionButton: i ?? null });
  }
  get statusBarCommands() {
    return this._statusBarCommands;
  }
  set statusBarCommands(e) {
    if (this._statusBarCommands && e && l$(this._statusBarCommands, e))
      return;
    this._statusBarDisposables.value = new De(), this._statusBarCommands = e;
    const i = (e || []).map(
      (n) => this._commands.converter.toInternal(n, this._statusBarDisposables.value)
    );
    zt(this, Zt).$updateSourceControl(this.handle, { statusBarCommands: i });
  }
  get selected() {
    return this._selected;
  }
  createResourceGroup(e, i, n) {
    const r = lt(this._extension, "scmMultiDiffEditor") && n?.multiDiffEditorEnableViewChanges === !0, s = new ex(
      zt(this, Zt),
      this._commands,
      this.handle,
      e,
      i,
      r,
      this._extension
    ), o = It.once(s.onDidDispose)(() => this.createdResourceGroups.delete(s));
    return this.createdResourceGroups.set(s, o), this.eventuallyAddResourceGroups(), s;
  }
  eventuallyAddResourceGroups() {
    const e = [], i = [];
    for (const [n, r] of this.createdResourceGroups) {
      r.dispose();
      const s = n.onDidUpdateResourceStates(() => {
        this.updatedResourceGroups.add(n), this.eventuallyUpdateResourceStates();
      });
      It.once(n.onDidDispose)(() => {
        this.updatedResourceGroups.delete(n), s.dispose(), this._groups.delete(n.handle), zt(this, Zt).$unregisterGroup(this.handle, n.handle);
      }), e.push([n.handle, n.id, n.label, n.features, n.multiDiffEditorEnableViewChanges]);
      const o = n._takeResourceStateSnapshot();
      o.length > 0 && i.push([n.handle, o]), this._groups.set(n.handle, n);
    }
    zt(this, Zt).$registerGroups(this.handle, e, i), this.createdResourceGroups.clear();
  }
  eventuallyUpdateResourceStates() {
    const e = [];
    this.updatedResourceGroups.forEach((i) => {
      const n = i._takeResourceStateSnapshot();
      n.length !== 0 && e.push([i.handle, n]);
    }), e.length > 0 && zt(this, Zt).$spliceResourceStates(this.handle, e), this.updatedResourceGroups.clear();
  }
  getResourceGroup(e) {
    return this._groups.get(e);
  }
  setSelectionState(e) {
    this._selected = e, this._onDidChangeSelection.fire(e);
  }
  dispose() {
    this._acceptInputDisposables.dispose(), this._actionButtonDisposables.dispose(), this._statusBarDisposables.dispose(), this._groups.forEach((e) => e.dispose()), zt(this, Zt).$unregisterSourceControl(this.handle), this._onDidDispose.fire(), this._onDidDispose.dispose();
  }
};
Zt = new WeakMap(), N_._handlePool = 0;
let ll = N_;
ll.__decorator = W([
  t5(100)
], ll.prototype, "eventuallyAddResourceGroups", null);
ll.__decorator = W([
  t5(100)
], ll.prototype, "eventuallyUpdateResourceStates", null);
let tx = class {
  get onDidChangeActiveProvider() {
    return this._onDidChangeActiveProvider.event;
  }
  constructor(e, i, n, r) {
    this._commands = i, this._extHostDocuments = n, this.logService = r, this._sourceControls = /* @__PURE__ */ new Map(), this._sourceControlsByExtension = new Io(), this._onDidChangeActiveProvider = new N(), this._proxy = e.getProxy(ee.MainThreadSCM), this._telemetry = e.getProxy(ee.MainThreadTelemetry), i.registerArgumentProcessor({
      processArgument: (s) => {
        if (s && s.$mid === tt.ScmResource) {
          const o = this._sourceControls.get(s.sourceControlHandle);
          if (!o)
            return s;
          const a = o.getResourceGroup(s.groupHandle);
          return a ? a.getResourceState(s.handle) : s;
        } else if (s && s.$mid === tt.ScmResourceGroup) {
          const o = this._sourceControls.get(s.sourceControlHandle);
          return o ? o.getResourceGroup(s.groupHandle) : s;
        } else if (s && s.$mid === tt.ScmProvider) {
          const o = this._sourceControls.get(s.handle);
          return o || s;
        }
        return s;
      }
    });
  }
  createSourceControl(e, i, n, r, s, o) {
    this.logService.trace("ExtHostSCM#createSourceControl", e.identifier.value, i, n, r), this._telemetry.$publicLog2("api/scm/createSourceControl", {
      extensionId: e.identifier.value
    });
    const a = o ? Oi.find(this._sourceControls.values(), (u) => u === o) : void 0, l = new ll(
      e,
      this._extHostDocuments,
      this._proxy,
      this._commands,
      i,
      n,
      r,
      s,
      a
    );
    this._sourceControls.set(l.handle, l);
    const c = this._sourceControlsByExtension.get(e.identifier) || [];
    return c.push(l), this._sourceControlsByExtension.set(e.identifier, c), l;
  }
  getLastInputBox(e) {
    this.logService.trace("ExtHostSCM#getLastInputBox", e.identifier.value);
    const i = this._sourceControlsByExtension.get(e.identifier), n = i && i[i.length - 1];
    return n && n.inputBox;
  }
  $provideOriginalResource(e, i, n) {
    const r = x.revive(i);
    this.logService.trace("ExtHostSCM#$provideOriginalResource", e, r.toString());
    const s = this._sourceControls.get(e);
    return !s || !s.quickDiffProvider || !s.quickDiffProvider.provideOriginalResource ? Promise.resolve(null) : Ai(() => s.quickDiffProvider.provideOriginalResource(r, n)).then((o) => o || null);
  }
  $provideSecondaryOriginalResource(e, i, n) {
    const r = x.revive(i);
    this.logService.trace("ExtHostSCM#$provideSecondaryOriginalResource", e, r.toString());
    const s = this._sourceControls.get(e);
    return !s || !s.secondaryQuickDiffProvider || !s.secondaryQuickDiffProvider.provideOriginalResource ? Promise.resolve(null) : Ai(() => s.secondaryQuickDiffProvider.provideOriginalResource(r, n)).then((o) => o || null);
  }
  $onInputBoxValueChange(e, i) {
    this.logService.trace("ExtHostSCM#$onInputBoxValueChange", e);
    const n = this._sourceControls.get(e);
    return n && n.inputBox.$onInputBoxValueChange(i), Promise.resolve(void 0);
  }
  $executeResourceCommand(e, i, n, r) {
    this.logService.trace("ExtHostSCM#$executeResourceCommand", e, i, n);
    const s = this._sourceControls.get(e);
    if (!s)
      return Promise.resolve(void 0);
    const o = s.getResourceGroup(i);
    return o ? o.$executeResourceCommand(n, r) : Promise.resolve(void 0);
  }
  $validateInput(e, i, n) {
    this.logService.trace("ExtHostSCM#$validateInput", e);
    const r = this._sourceControls.get(e);
    return !r || !r.inputBox.validateInput ? Promise.resolve(void 0) : Ai(() => r.inputBox.validateInput(i, n)).then((s) => {
      if (!s)
        return Promise.resolve(void 0);
      const o = Ae.fromStrict(s.message);
      return o ? Promise.resolve([o, s.type]) : Promise.resolve(void 0);
    });
  }
  $setSelectedSourceControl(e) {
    return this.logService.trace("ExtHostSCM#$setSelectedSourceControl", e), e !== void 0 && this._sourceControls.get(e)?.setSelectionState(!0), this._selectedSourceControlHandle !== void 0 && this._sourceControls.get(this._selectedSourceControlHandle)?.setSelectionState(!1), this._selectedSourceControlHandle = e, Promise.resolve(void 0);
  }
  async $resolveHistoryItemChatContext(e, i, n) {
    try {
      return await this._sourceControls.get(e)?.historyProvider?.resolveHistoryItemChatContext(i, n) ?? void 0;
    } catch (r) {
      this.logService.error("ExtHostSCM#$resolveHistoryItemChatContext", r);
      return;
    }
  }
  async $resolveHistoryItemRefsCommonAncestor(e, i, n) {
    try {
      return await this._sourceControls.get(e)?.historyProvider?.resolveHistoryItemRefsCommonAncestor(i, n) ?? void 0;
    } catch (r) {
      this.logService.error("ExtHostSCM#$resolveHistoryItemRefsCommonAncestor", r);
      return;
    }
  }
  async $provideHistoryItemRefs(e, i, n) {
    try {
      return (await this._sourceControls.get(e)?.historyProvider?.provideHistoryItemRefs(i, n))?.map((o) => ({ ...o, icon: wo(o.icon) })) ?? void 0;
    } catch (r) {
      this.logService.error("ExtHostSCM#$provideHistoryItemRefs", r);
      return;
    }
  }
  async $provideHistoryItems(e, i, n) {
    try {
      return (await this._sourceControls.get(e)?.historyProvider?.provideHistoryItems(i, n))?.map((o) => n$(o)) ?? void 0;
    } catch (r) {
      this.logService.error("ExtHostSCM#$provideHistoryItems", r);
      return;
    }
  }
  async $provideHistoryItemChanges(e, i, n, r) {
    try {
      return await this._sourceControls.get(e)?.historyProvider?.provideHistoryItemChanges(i, n, r) ?? void 0;
    } catch (s) {
      this.logService.error("ExtHostSCM#$provideHistoryItemChanges", s);
      return;
    }
  }
};
tx = W([
  M(3, nt)
], tx);
const M_ = class M_ {
  constructor(e, i) {
    this.uriTransformer = i, this.providers = /* @__PURE__ */ new Map(), this.proxy = e.getProxy(ee.MainThreadShare);
  }
  async $provideShare(e, i, n) {
    return await this.providers.get(e)?.provideShare({ selection: z.to(i.selection), resourceUri: x.revive(i.resourceUri) }, n) ?? void 0;
  }
  registerShareProvider(e, i) {
    const n = M_.handlePool++;
    return this.providers.set(n, i), this.proxy.$registerShareProvider(n, iu.from(e, this.uriTransformer), i.id, i.label, i.priority), {
      dispose: () => {
        this.proxy.$unregisterShareProvider(n), this.providers.delete(n);
      }
    };
  }
};
M_.handlePool = 0;
let ix = M_;
const O_ = class O_ {
  constructor(e) {
    this.providers = /* @__PURE__ */ new Map(), this.sessions = /* @__PURE__ */ new Map(), this.synthesizers = /* @__PURE__ */ new Map(), this.proxy = e.getProxy(ee.MainThreadSpeech);
  }
  async $createSpeechToTextSession(e, i, n) {
    const r = this.providers.get(e);
    if (!r)
      return;
    const s = new De(), o = new Pt();
    this.sessions.set(i, o);
    const a = await r.provideSpeechToTextSession(o.token, n ? { language: n } : void 0);
    a && (s.add(a.onDidChange((l) => {
      o.token.isCancellationRequested || this.proxy.$emitSpeechToTextEvent(i, l);
    })), s.add(o.token.onCancellationRequested(() => s.dispose())));
  }
  async $cancelSpeechToTextSession(e) {
    this.sessions.get(e)?.dispose(!0), this.sessions.delete(e);
  }
  async $createTextToSpeechSession(e, i, n) {
    const r = this.providers.get(e);
    if (!r)
      return;
    const s = new De(), o = new Pt();
    this.sessions.set(i, o);
    const a = await r.provideTextToSpeechSession(o.token, n ? { language: n } : void 0);
    a && (this.synthesizers.set(i, a), s.add(a.onDidChange((l) => {
      o.token.isCancellationRequested || this.proxy.$emitTextToSpeechEvent(i, l);
    })), s.add(o.token.onCancellationRequested(() => s.dispose())));
  }
  async $synthesizeSpeech(e, i) {
    this.synthesizers.get(e)?.synthesize(i);
  }
  async $cancelTextToSpeechSession(e) {
    this.sessions.get(e)?.dispose(!0), this.sessions.delete(e), this.synthesizers.delete(e);
  }
  async $createKeywordRecognitionSession(e, i) {
    const n = this.providers.get(e);
    if (!n)
      return;
    const r = new De(), s = new Pt();
    this.sessions.set(i, s);
    const o = await n.provideKeywordRecognitionSession(s.token);
    o && (r.add(o.onDidChange((a) => {
      s.token.isCancellationRequested || this.proxy.$emitKeywordRecognitionEvent(i, a);
    })), r.add(s.token.onCancellationRequested(() => r.dispose())));
  }
  async $cancelKeywordRecognitionSession(e) {
    this.sessions.get(e)?.dispose(!0), this.sessions.delete(e);
  }
  registerProvider(e, i, n) {
    const r = O_.ID_POOL++;
    return this.providers.set(r, n), this.proxy.$registerProvider(r, i, { extension: e, displayName: e.value }), Ee(() => {
      this.proxy.$unregisterProvider(r), this.providers.delete(r);
    });
  }
};
O_.ID_POOL = 1;
let nx = O_;
var Nc, Mc;
const aa = class aa {
  constructor(e, i, n, r, s, o = fo.Left, a, l) {
    If(this, Nc);
    If(this, Mc);
    if (this._onDispose = l, this._disposed = !1, this._text = "", this._staleCommandRegistrations = new De(), Cf(this, Nc, e), Cf(this, Mc, i), s && r) {
      this._entryId = G9(r.identifier, s);
      const c = n.get(this._entryId);
      c && (o = c.alignLeft ? fo.Left : fo.Right, a = c.priority, this._visible = !0, this.name = c.name, this.text = c.text, this.tooltip = c.tooltip, this.command = c.command, this.accessibilityInformation = c.accessibilityInformation);
    } else
      this._entryId = String(aa.ID_GEN++);
    this._extension = r, this._id = s, this._alignment = o, this._priority = this.validatePriority(a);
  }
  validatePriority(e) {
    if (xa(e))
      return e === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : e === Number.NEGATIVE_INFINITY ? -Number.MAX_VALUE : e;
  }
  get id() {
    return this._id ?? this._extension.identifier.value;
  }
  get entryId() {
    return this._entryId;
  }
  get alignment() {
    return this._alignment;
  }
  get priority() {
    return this._priority;
  }
  get text() {
    return this._text;
  }
  get name() {
    return this._name;
  }
  get tooltip() {
    return this._tooltip;
  }
  get tooltip2() {
    return this._extension && $(this._extension, "statusBarItemTooltip"), this._tooltip2;
  }
  get color() {
    return this._color;
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  get command() {
    return this._command?.fromApi;
  }
  get accessibilityInformation() {
    return this._accessibilityInformation;
  }
  set text(e) {
    this._text = e, this.update();
  }
  set name(e) {
    this._name = e, this.update();
  }
  set tooltip(e) {
    this._tooltip = e, this.update();
  }
  set tooltip2(e) {
    this._extension && $(this._extension, "statusBarItemTooltip"), this._tooltip2 = e, this.update();
  }
  set color(e) {
    this._color = e, this.update();
  }
  set backgroundColor(e) {
    e && !aa.ALLOWED_BACKGROUND_COLORS.has(e.id) && (e = void 0), this._backgroundColor = e, this.update();
  }
  set command(e) {
    this._command?.fromApi !== e && (this._latestCommandRegistration && this._staleCommandRegistrations.add(this._latestCommandRegistration), this._latestCommandRegistration = new De(), typeof e == "string" ? this._command = {
      fromApi: e,
      internal: zt(this, Mc).toInternal({ title: "", command: e }, this._latestCommandRegistration)
    } : e ? this._command = {
      fromApi: e,
      internal: zt(this, Mc).toInternal(e, this._latestCommandRegistration)
    } : this._command = void 0, this.update());
  }
  set accessibilityInformation(e) {
    this._accessibilityInformation = e, this.update();
  }
  show() {
    this._visible = !0, this.update();
  }
  hide() {
    clearTimeout(this._timeoutHandle), this._visible = !1, zt(this, Nc).$disposeEntry(this._entryId);
  }
  update() {
    this._disposed || !this._visible || (clearTimeout(this._timeoutHandle), this._timeoutHandle = setTimeout(() => {
      this._timeoutHandle = void 0;
      let e;
      this._extension ? this._id ? e = `${this._extension.identifier.value}.${this._id}` : e = this._extension.identifier.value : e = this._id;
      let i;
      this._name ? i = this._name : i = h(
        2633,
        "{0} (Extension)",
        this._extension.displayName || this._extension.name
      );
      let n = this._color;
      this._backgroundColor && (n = aa.ALLOWED_BACKGROUND_COLORS.get(this._backgroundColor.id));
      let r, s;
      typeof this._tooltip2 == "function" ? (r = Ae.fromStrict(this._tooltip), s = !0) : (r = Ae.fromStrict(this._tooltip2 ?? this._tooltip), s = !1), zt(this, Nc).$setEntry(this._entryId, e, this._extension?.identifier.value, i, this._text, r, s, this._command?.internal, n, this._backgroundColor, this._alignment === fo.Left, this._priority, this._accessibilityInformation), this._staleCommandRegistrations.clear();
    }, 0));
  }
  dispose() {
    this.hide(), this._onDispose?.(), this._disposed = !0;
  }
};
Nc = new WeakMap(), Mc = new WeakMap(), aa.ID_GEN = 0, aa.ALLOWED_BACKGROUND_COLORS = /* @__PURE__ */ new Map([
  ["statusBarItem.errorBackground", new gh("statusBarItem.errorForeground")],
  ["statusBarItem.warningBackground", new gh("statusBarItem.warningForeground")]
]);
let rx = aa;
class u$ {
  constructor(e) {
    this._messages = [], this._item = e.createStatusBarEntry(void 0, "status.extensionMessage", fo.Left, Number.MIN_VALUE), this._item.name = h(2634, "Extension Status");
  }
  dispose() {
    this._messages.length = 0, this._item.dispose();
  }
  setMessage(e) {
    const i = { message: e };
    return this._messages.unshift(i), this._update(), new Ve(() => {
      const n = this._messages.indexOf(i);
      n >= 0 && (this._messages.splice(n, 1), this._update());
    });
  }
  _update() {
    this._messages.length > 0 ? (this._item.text = this._messages[0].message, this._item.show()) : this._item.hide();
  }
}
class d$ {
  constructor(e, i) {
    this._entries = /* @__PURE__ */ new Map(), this._existingItems = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadStatusBar), this._commands = i, this._statusMessage = new u$(this);
  }
  $acceptStaticEntries(e) {
    for (const i of e)
      this._existingItems.set(i.entryId, i);
  }
  async $provideTooltip(e, i) {
    const n = this._entries.get(e);
    if (!n)
      return;
    const r = typeof n.tooltip2 == "function" ? await n.tooltip2(i) : n.tooltip2;
    return i.isCancellationRequested ? void 0 : Ae.fromStrict(r);
  }
  createStatusBarEntry(e, i, n, r) {
    const s = new rx(
      this._proxy,
      this._commands,
      this._existingItems,
      e,
      i,
      n,
      r,
      () => this._entries.delete(s.entryId)
    );
    return this._entries.set(s.entryId, s), s;
  }
  setStatusBarMessage(e, i) {
    const n = this._statusMessage.setMessage(e);
    let r;
    return typeof i == "number" ? r = setTimeout(() => n.dispose(), i) : typeof i < "u" && i.then(() => n.dispose(), () => n.dispose()), new Ve(() => {
      n.dispose(), clearTimeout(r);
    });
  }
}
class h$ extends ve {
  constructor(e, i) {
    super(), this._extHostDocumentsAndEditors = i, this._onDidChangeTextEditorSelection = new N(), this._onDidChangeTextEditorOptions = new N(), this._onDidChangeTextEditorVisibleRanges = new N(), this._onDidChangeTextEditorViewColumn = new N(), this._onDidChangeTextEditorDiffInformation = new N(), this._onDidChangeActiveTextEditor = new N(), this._onDidChangeVisibleTextEditors = new N(), this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event, this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event, this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event, this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event, this.onDidChangeTextEditorDiffInformation = this._onDidChangeTextEditorDiffInformation.event, this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event, this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event, this._proxy = e.getProxy(ee.MainThreadTextEditors), this._register(this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors((n) => this._onDidChangeVisibleTextEditors.fire(n))), this._register(this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor((n) => this._onDidChangeActiveTextEditor.fire(n)));
  }
  getActiveTextEditor() {
    return this._extHostDocumentsAndEditors.activeEditor();
  }
  getVisibleTextEditors(e) {
    const i = this._extHostDocumentsAndEditors.allEditors();
    return e ? i : i.map((n) => n.value);
  }
  async showTextDocument(e, i, n) {
    let r;
    typeof i == "number" ? r = {
      position: si.from(i),
      preserveFocus: n
    } : typeof i == "object" ? r = {
      position: si.from(i.viewColumn),
      preserveFocus: i.preserveFocus,
      selection: typeof i.selection == "object" ? z.from(i.selection) : void 0,
      pinned: typeof i.preview == "boolean" ? !i.preview : void 0
    } : r = {
      preserveFocus: !1
    };
    const s = await this._proxy.$tryShowTextDocument(e.uri, r), o = s && this._extHostDocumentsAndEditors.getEditor(s);
    if (o)
      return o.value;
    throw s ? new Error(`Could NOT open editor for "${e.uri.toString()}" because another editor opened in the meantime.`) : new Error(`Could NOT open editor for "${e.uri.toString()}".`);
  }
  createTextEditorDecorationType(e, i) {
    return new t0(this._proxy, e, i).value;
  }
  $acceptEditorPropertiesChanged(e, i) {
    const n = this._extHostDocumentsAndEditors.getEditor(e);
    if (!n)
      throw new Error("unknown text editor");
    if (i.options && n._acceptOptions(i.options), i.selections) {
      const r = i.selections.selections.map(vr.to);
      n._acceptSelections(r);
    }
    if (i.visibleRanges) {
      const r = Kt(i.visibleRanges.map(z.to));
      n._acceptVisibleRanges(r);
    }
    if (i.options && this._onDidChangeTextEditorOptions.fire({
      textEditor: n.value,
      options: { ...i.options, lineNumbers: Sc.to(i.options.lineNumbers) }
    }), i.selections) {
      const r = Qc.fromValue(i.selections.source), s = i.selections.selections.map(vr.to);
      this._onDidChangeTextEditorSelection.fire({
        textEditor: n.value,
        selections: s,
        kind: r
      });
    }
    if (i.visibleRanges) {
      const r = Kt(i.visibleRanges.map(z.to));
      this._onDidChangeTextEditorVisibleRanges.fire({
        textEditor: n.value,
        visibleRanges: r
      });
    }
  }
  $acceptEditorPositionData(e) {
    for (const i in e) {
      const n = this._extHostDocumentsAndEditors.getEditor(i);
      if (!n)
        throw new Error("Unknown text editor");
      const r = si.to(e[i]);
      n.value.viewColumn !== r && (n._acceptViewColumn(r), this._onDidChangeTextEditorViewColumn.fire({ textEditor: n.value, viewColumn: r }));
    }
  }
  $acceptEditorDiffInformation(e, i) {
    const n = this._extHostDocumentsAndEditors.getEditor(e);
    if (!n)
      throw new Error("unknown text editor");
    if (!i) {
      n._acceptDiffInformation(void 0), this._onDidChangeTextEditorDiffInformation.fire({
        textEditor: n.value,
        diffInformation: void 0
      });
      return;
    }
    const r = this, s = i.map((o) => {
      const a = x.revive(o.original), l = x.revive(o.modified), c = o.changes.map((u) => {
        const [d, f, g, _] = u;
        let w;
        return d === f ? w = _c.Addition : g === _ ? w = _c.Deletion : w = _c.Modification, {
          original: {
            startLineNumber: d,
            endLineNumberExclusive: f
          },
          modified: {
            startLineNumber: g,
            endLineNumberExclusive: _
          },
          kind: w
        };
      });
      return Object.freeze({
        documentVersion: o.documentVersion,
        original: a,
        modified: l,
        changes: c,
        get isStale() {
          return r._extHostDocumentsAndEditors.getDocument(l)?.version !== o.documentVersion;
        }
      });
    });
    n._acceptDiffInformation(s), this._onDidChangeTextEditorDiffInformation.fire({
      textEditor: n.value,
      diffInformation: s
    });
  }
  getDiffInformation(e) {
    return Promise.resolve(this._proxy.$getDiffInformation(e));
  }
}
let sx = class {
  constructor(e) {
    this._actual = new Qg(co.Dark), this._onDidChangeActiveColorTheme = new N();
  }
  get activeColorTheme() {
    return this._actual;
  }
  $onColorThemeChange(e) {
    let i;
    switch (e) {
      case "light":
        i = co.Light;
        break;
      case "hcDark":
        i = co.HighContrast;
        break;
      case "hcLight":
        i = co.HighContrastLight;
        break;
      default:
        i = co.Dark;
    }
    this._actual = new Qg(i), this._onDidChangeActiveColorTheme.fire(this._actual);
  }
  get onDidChangeActiveColorTheme() {
    return this._onDidChangeActiveColorTheme.event;
  }
};
sx = W([
  M(0, Ye)
], sx);
class f$ {
  constructor(e, i) {
    this._providers = /* @__PURE__ */ new Map(), this._itemsBySourceAndUriMap = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadTimeline), i.registerArgumentProcessor({
      processArgument: (n, r) => {
        if (n && n.$mid === tt.TimelineActionContext)
          if (this._providers.get(n.source) && r && lt(r, "timeline")) {
            const s = n.uri === void 0 ? void 0 : x.revive(n.uri);
            return this._itemsBySourceAndUriMap.get(n.source)?.get(jC(s))?.get(n.handle);
          } else
            return;
        return n;
      }
    });
  }
  async $getTimeline(e, i, n, r) {
    return this._providers.get(e)?.provider.provideTimeline(x.revive(i), n, r);
  }
  registerTimelineProvider(e, i, n, r) {
    const s = new De(), o = this.convertTimelineItem(i.id, r, s).bind(this);
    let a;
    i.onDidChange && (a = i.onDidChange((c) => this._proxy.$emitTimelineChangeEvent({ uri: void 0, reset: !0, ...c, id: i.id }), this));
    const l = this._itemsBySourceAndUriMap;
    return this.registerTimelineProviderCore({
      ...i,
      scheme: e,
      onDidChange: void 0,
      async provideTimeline(c, u, d) {
        u?.resetCache && (s.clear(), l.get(i.id)?.clear());
        const f = await i.provideTimeline(c, u, d);
        if (f == null)
          return;
        const g = o(c, u);
        return {
          ...f,
          source: i.id,
          items: f.items.map(g)
        };
      },
      dispose() {
        for (const c of l.values())
          c.get(i.id)?.clear();
        a?.dispose(), s.dispose();
      }
    }, n);
  }
  convertTimelineItem(e, i, n) {
    return (r, s) => {
      let o;
      if (s?.cacheResults) {
        let a = this._itemsBySourceAndUriMap.get(e);
        a === void 0 && (a = /* @__PURE__ */ new Map(), this._itemsBySourceAndUriMap.set(e, a));
        const l = jC(r);
        o = a.get(l), o === void 0 && (o = /* @__PURE__ */ new Map(), a.set(l, o));
      }
      return (a) => {
        const { iconPath: l, ...c } = a, u = `${e}|${a.id ?? a.timestamp}`;
        o?.set(u, a);
        let d, f, g;
        a.iconPath && (l instanceof qi ? g = { id: l.id, color: l.color } : x.isUri(l) ? (d = l, f = l) : { light: d, dark: f } = l);
        let _;
        return bn.isMarkdownString(c.tooltip) ? _ = Ae.from(c.tooltip) : it(c.tooltip) ? _ = c.tooltip : bn.isMarkdownString(c.detail) ? (console.warn("Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip"), _ = Ae.from(c.detail)) : it(c.detail) && (console.warn("Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip"), _ = c.detail), {
          ...c,
          id: c.id ?? void 0,
          handle: u,
          source: e,
          command: a.command ? i.toInternal(a.command, n) : void 0,
          icon: d,
          iconDark: f,
          themeIcon: g,
          tooltip: _,
          accessibilityInformation: a.accessibilityInformation
        };
      };
    };
  }
  registerTimelineProviderCore(e, i) {
    if (this._providers.get(e.id))
      throw new Error(`Timeline Provider ${e.id} already exists.`);
    return this._proxy.$registerTimelineProvider({
      id: e.id,
      label: e.label,
      scheme: e.scheme
    }), this._providers.set(e.id, { provider: e, extension: i }), Ee(() => {
      for (const r of this._itemsBySourceAndUriMap.values())
        r.get(e.id)?.clear();
      this._providers.delete(e.id), this._proxy.$unregisterTimelineProvider(e.id), e.dispose();
    });
  }
}
function jC(t) {
  return t?.toString();
}
h(4105, "Views");
wf("default-view-icon", ge.window, h(4106, "Default view icon."));
var c_;
(function(t) {
  t.ViewContainersRegistry = "workbench.registry.view.containers", t.ViewsRegistry = "workbench.registry.view";
})(c_ || (c_ = {}));
var Rd;
(function(t) {
  t[t.Sidebar = 0] = "Sidebar", t[t.Panel = 1] = "Panel", t[t.AuxiliaryBar = 2] = "AuxiliaryBar";
})(Rd || (Rd = {}));
Rd.Sidebar, Rd.Panel, Rd.AuxiliaryBar;
class p$ extends ve {
  constructor() {
    super(...arguments), this._onDidRegister = this._register(new N()), this.onDidRegister = this._onDidRegister.event, this._onDidDeregister = this._register(new N()), this.onDidDeregister = this._onDidDeregister.event, this.viewContainers = /* @__PURE__ */ new Map(), this.defaultViewContainers = [];
  }
  get all() {
    return [...this.viewContainers.values()].flat();
  }
  registerViewContainer(e, i, n) {
    const r = this.get(e.id);
    if (r)
      return r;
    const s = e;
    return s.openCommandActionDescriptor = n?.doNotRegisterOpenCommand ? void 0 : s.openCommandActionDescriptor ?? { id: s.id }, J5(this.viewContainers, i, []).push(s), n?.isDefault && this.defaultViewContainers.push(s), this._onDidRegister.fire({ viewContainer: s, viewContainerLocation: i }), s;
  }
  deregisterViewContainer(e) {
    for (const i of this.viewContainers.keys()) {
      const n = this.viewContainers.get(i), r = n?.indexOf(e);
      if (r !== -1) {
        n?.splice(r, 1), n.length === 0 && this.viewContainers.delete(i), this._onDidDeregister.fire({ viewContainer: e, viewContainerLocation: i });
        return;
      }
    }
  }
  get(e) {
    return this.all.filter((i) => i.id === e)[0];
  }
  getViewContainers(e) {
    return [...this.viewContainers.get(e) || []];
  }
  getViewContainerLocation(e) {
    return [...this.viewContainers.keys()].filter((i) => this.getViewContainers(i).filter((n) => n?.id === e.id).length > 0)[0];
  }
  getDefaultViewContainer(e) {
    return this.defaultViewContainers.find((i) => this.getViewContainerLocation(i) === e);
  }
}
ai.add(c_.ViewContainersRegistry, new p$());
var u_;
(function(t) {
  t.Open = "2_open", t.Debug = "4_debug", t.SCM = "5_scm", t.More = "9_more";
})(u_ || (u_ = {}));
function g$(t, e) {
  const i = t.group ?? u_.More, n = e.group ?? u_.More;
  return i !== n ? i.localeCompare(n) : (t.order ?? 5) - (e.order ?? 5);
}
class m$ extends ve {
  constructor() {
    super(...arguments), this._onViewsRegistered = this._register(new N()), this.onViewsRegistered = this._onViewsRegistered.event, this._onViewsDeregistered = this._register(new N()), this.onViewsDeregistered = this._onViewsDeregistered.event, this._onDidChangeContainer = this._register(new N()), this.onDidChangeContainer = this._onDidChangeContainer.event, this._onDidChangeViewWelcomeContent = this._register(new N()), this.onDidChangeViewWelcomeContent = this._onDidChangeViewWelcomeContent.event, this._viewContainers = [], this._views = /* @__PURE__ */ new Map(), this._viewWelcomeContents = new tA();
  }
  registerViews(e, i) {
    this.registerViews2([{ views: e, viewContainer: i }]);
  }
  registerViews2(e) {
    e.forEach(({ views: i, viewContainer: n }) => this.addViews(i, n)), this._onViewsRegistered.fire(e);
  }
  deregisterViews(e, i) {
    const n = this.removeViews(e, i);
    n.length && this._onViewsDeregistered.fire({ views: n, viewContainer: i });
  }
  moveViews(e, i) {
    for (const n of this._views.keys())
      if (n !== i) {
        const r = this.removeViews(e, n);
        r.length && (this.addViews(r, i), this._onDidChangeContainer.fire({ views: r, from: n, to: i }));
      }
  }
  getViews(e) {
    return this._views.get(e) || [];
  }
  getView(e) {
    for (const i of this._viewContainers) {
      const n = (this._views.get(i) || []).filter((r) => r.id === e)[0];
      if (n)
        return n;
    }
    return null;
  }
  getViewContainer(e) {
    for (const i of this._viewContainers)
      if ((this._views.get(i) || []).filter((r) => r.id === e)[0])
        return i;
    return null;
  }
  registerViewWelcomeContent(e, i) {
    return this._viewWelcomeContents.add(e, i), this._onDidChangeViewWelcomeContent.fire(e), Ee(() => {
      this._viewWelcomeContents.delete(e, i), this._onDidChangeViewWelcomeContent.fire(e);
    });
  }
  registerViewWelcomeContent2(e, i) {
    const n = /* @__PURE__ */ new Map();
    for (const [r, s] of i)
      this._viewWelcomeContents.add(e, s), n.set(r, Ee(() => {
        this._viewWelcomeContents.delete(e, s), this._onDidChangeViewWelcomeContent.fire(e);
      }));
    return this._onDidChangeViewWelcomeContent.fire(e), n;
  }
  getViewWelcomeContent(e) {
    const i = [];
    return this._viewWelcomeContents.forEach(e, (n) => i.push(n)), i.sort(g$);
  }
  addViews(e, i) {
    let n = this._views.get(i);
    n || (n = [], this._views.set(i, n), this._viewContainers.push(i));
    for (const r of e) {
      if (this.getView(r.id) !== null)
        throw new Error(h(4107, "A view with id '{0}' is already registered", r.id));
      n.push(r);
    }
  }
  removeViews(e, i) {
    const n = this._views.get(i);
    if (!n)
      return [];
    const r = [], s = [];
    for (const o of n)
      e.includes(o) ? r.push(o) : s.push(o);
    return r.length && (s.length ? this._views.set(i, s) : (this._views.delete(i), this._viewContainers.splice(this._viewContainers.indexOf(i), 1))), r;
  }
}
ai.add(c_.ViewsRegistry, new m$());
var GC;
(function(t) {
  t[t.Default = 0] = "Default", t[t.Expand = 1] = "Expand";
})(GC || (GC = {}));
var QC;
(function(t) {
  t[t.None = 0] = "None", t[t.Collapsed = 1] = "Collapsed", t[t.Expanded = 2] = "Expanded";
})(QC || (QC = {}));
class ss extends Error {
  constructor(e) {
    super(h(4108, "No tree view with id '{0}' registered.", e)), this.name = "NoTreeViewError";
  }
  static is(e) {
    return !!e && e.name === "NoTreeViewError";
  }
}
class _$ {
  constructor() {
    this._dragOperations = /* @__PURE__ */ new Map();
  }
  removeDragOperationTransfer(e) {
    if (e && this._dragOperations.has(e)) {
      const i = this._dragOperations.get(e);
      return this._dragOperations.delete(e), i;
    }
  }
  addDragOperationTransfer(e, i) {
    this._dragOperations.set(e, i);
  }
}
function KC(t, e) {
  if (it(t))
    return { label: t };
  if (t && typeof t == "object" && typeof t.label == "string") {
    let i;
    return Array.isArray(t.highlights) && (i = t.highlights.filter((n) => n.length === 2 && typeof n[0] == "number" && typeof n[1] == "number"), i = i.length ? i : void 0), { label: t.label, highlights: i };
  }
}
class v$ extends ve {
  constructor(e, i, n) {
    super(), this._proxy = e, this._commands = i, this._logService = n, this._treeViews = /* @__PURE__ */ new Map(), this._treeDragAndDropService = new _$();
    function r(s) {
      return s && s.$treeViewId && (s.$treeItemHandle || s.$selectedTreeItems || s.$focusedTreeItem);
    }
    i.registerArgumentProcessor({
      processArgument: (s) => r(s) ? this._convertArgument(s) : Array.isArray(s) && s.length > 0 ? s.map((o) => r(o) ? this._convertArgument(o) : o) : s
    });
  }
  registerTreeDataProvider(e, i, n) {
    const r = this.createTreeView(e, { treeDataProvider: i }, n);
    return { dispose: () => r.dispose() };
  }
  createTreeView(e, i, n) {
    if (!i || !i.treeDataProvider)
      throw new Error("Options with treeDataProvider is mandatory");
    const r = i.dragAndDropController?.dropMimeTypes ?? [], s = i.dragAndDropController?.dragMimeTypes ?? [], o = !!i.dragAndDropController?.handleDrag, a = !!i.dragAndDropController?.handleDrop, l = this._createExtHostTreeView(e, i, n), c = { showCollapseAll: !!i.showCollapseAll, canSelectMany: !!i.canSelectMany, dropMimeTypes: r, dragMimeTypes: s, hasHandleDrag: o, hasHandleDrop: a, manuallyManageCheckboxes: !!i.manageCheckboxStateManually }, u = this._proxy.$registerTreeViewDataProvider(e, c), d = {
      get onDidCollapseElement() {
        return l.onDidCollapseElement;
      },
      get onDidExpandElement() {
        return l.onDidExpandElement;
      },
      get selection() {
        return l.selectedElements;
      },
      get onDidChangeSelection() {
        return l.onDidChangeSelection;
      },
      get activeItem() {
        return $(n, "treeViewActiveItem"), l.focusedElement;
      },
      get onDidChangeActiveItem() {
        return $(n, "treeViewActiveItem"), l.onDidChangeActiveItem;
      },
      get visible() {
        return l.visible;
      },
      get onDidChangeVisibility() {
        return l.onDidChangeVisibility;
      },
      get onDidChangeCheckboxState() {
        return l.onDidChangeCheckboxState;
      },
      get message() {
        return l.message;
      },
      set message(f) {
        dl(f) && $(n, "treeViewMarkdownMessage"), l.message = f;
      },
      get title() {
        return l.title;
      },
      set title(f) {
        l.title = f;
      },
      get description() {
        return l.description;
      },
      set description(f) {
        l.description = f;
      },
      get badge() {
        return l.badge;
      },
      set badge(f) {
        f !== void 0 && Mw.isViewBadge(f) ? l.badge = {
          value: Math.floor(Math.abs(f.value)),
          tooltip: f.tooltip
        } : f === void 0 && (l.badge = void 0);
      },
      reveal: (f, g) => l.reveal(f, g),
      dispose: async () => {
        await u, this._treeViews.delete(e), l.dispose();
      }
    };
    return this._register(d), d;
  }
  async $getChildren(e, i) {
    const n = this._treeViews.get(e);
    if (!n)
      return Promise.reject(new ss(e));
    if (!i) {
      const s = await n.getChildren();
      return s ? [[0, ...s]] : void 0;
    }
    const r = [];
    for (let s = 0; s < i.length; s++) {
      const o = i[s], a = await n.getChildren(o);
      a && r.push([s, ...a]);
    }
    return r;
  }
  async $handleDrop(e, i, n, r, s, o, a, l) {
    const c = this._treeViews.get(e);
    if (!c)
      return Promise.reject(new ss(e));
    const u = fu.toDataTransfer(n, async (d) => (await this._proxy.$resolveDropFileData(e, i, d)).buffer);
    return a === e && l && await this._addAdditionalTransferItems(u, c, l, s, o), c.onDrop(u, r, s);
  }
  async _addAdditionalTransferItems(e, i, n, r, s) {
    const o = this._treeDragAndDropService.removeDragOperationTransfer(s);
    if (o)
      (await o)?.forEach((a, l) => {
        a && e.set(l, a);
      });
    else if (s && i.handleDrag) {
      const a = i.handleDrag(n, e, r);
      this._treeDragAndDropService.addDragOperationTransfer(s, a), await a;
    }
    return e;
  }
  async $handleDrag(e, i, n, r) {
    const s = this._treeViews.get(e);
    if (!s)
      return Promise.reject(new ss(e));
    const o = await this._addAdditionalTransferItems(new Xc(), s, i, r, n);
    if (!(!o || r.isCancellationRequested))
      return fu.from(o);
  }
  async $hasResolve(e) {
    const i = this._treeViews.get(e);
    if (!i)
      throw new ss(e);
    return i.hasResolve;
  }
  $resolve(e, i, n) {
    const r = this._treeViews.get(e);
    if (!r)
      throw new ss(e);
    return r.resolveTreeItem(i, n);
  }
  $setExpanded(e, i, n) {
    const r = this._treeViews.get(e);
    if (!r)
      throw new ss(e);
    r.setExpanded(i, n);
  }
  $setSelectionAndFocus(e, i, n) {
    const r = this._treeViews.get(e);
    if (!r)
      throw new ss(e);
    r.setSelectionAndFocus(i, n);
  }
  $setVisible(e, i) {
    const n = this._treeViews.get(e);
    if (!n) {
      if (!i)
        return;
      throw new ss(e);
    }
    n.setVisible(i);
  }
  $changeCheckboxState(e, i) {
    const n = this._treeViews.get(e);
    if (!n)
      throw new ss(e);
    n.setCheckboxState(i);
  }
  _createExtHostTreeView(e, i, n) {
    const r = this._register(new ox(
      e,
      i,
      this._proxy,
      this._commands.converter,
      this._logService,
      n
    ));
    return this._treeViews.set(e, r), r;
  }
  _convertArgument(e) {
    const i = this._treeViews.get(e.$treeViewId), n = e;
    return i && n.$treeItemHandle ? i.getExtensionElement(n.$treeItemHandle) : i && e.$focusedTreeItem ? i.focusedElement : null;
  }
}
const lc = class lc extends ve {
  get visible() {
    return this._visible;
  }
  get selectedElements() {
    return this._selectedHandles.map((e) => this.getExtensionElement(e)).filter((e) => !ni(e));
  }
  get focusedElement() {
    return this._focusedHandle ? this.getExtensionElement(this._focusedHandle) : void 0;
  }
  constructor(e, i, n, r, s, o) {
    if (super(), this._viewId = e, this._proxy = n, this._commands = r, this._logService = s, this._extension = o, this._roots = void 0, this._elements = /* @__PURE__ */ new Map(), this._nodes = /* @__PURE__ */ new Map(), this._visible = !1, this._selectedHandles = [], this._focusedHandle = void 0, this._onDidExpandElement = this._register(new N()), this.onDidExpandElement = this._onDidExpandElement.event, this._onDidCollapseElement = this._register(new N()), this.onDidCollapseElement = this._onDidCollapseElement.event, this._onDidChangeSelection = this._register(new N()), this.onDidChangeSelection = this._onDidChangeSelection.event, this._onDidChangeActiveItem = this._register(new N()), this.onDidChangeActiveItem = this._onDidChangeActiveItem.event, this._onDidChangeVisibility = this._register(new N()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this._onDidChangeCheckboxState = this._register(new N()), this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event, this._onDidChangeData = this._register(new N()), this._refreshPromise = Promise.resolve(), this._refreshQueue = Promise.resolve(), this._nodesToClear = /* @__PURE__ */ new Set(), this._message = "", this._title = "", this._refreshCancellationSource = new Pt(), o.contributes && o.contributes.views)
      for (const u in o.contributes.views)
        for (const d of o.contributes.views[u])
          d.id === e && (this._title = d.name);
    this._dataProvider = i.treeDataProvider, this._dndController = i.dragAndDropController, this._dataProvider.onDidChangeTreeData && this._register(this._dataProvider.onDidChangeTreeData((u) => {
      Array.isArray(u) && u.length === 0 || this._onDidChangeData.fire({ message: !1, element: u });
    }));
    let a, l;
    const c = It.debounce(this._onDidChangeData.event, (u, d) => (u || (u = { message: !1, elements: [] }), d.element !== !1 && (a || (a = new Promise((f) => l = f), this._refreshPromise = this._refreshPromise.then(() => a)), Array.isArray(d.element) ? u.elements.push(...d.element) : u.elements.push(d.element)), d.message && (u.message = !0), u), 200, !0);
    this._register(c(({ message: u, elements: d }) => {
      d.length && (this._refreshQueue = this._refreshQueue.then(() => {
        const f = l;
        a = null;
        const g = Array.from(this._nodesToClear);
        return this._refresh(d).then(() => (this._clearNodes(g), f()));
      })), u && this._proxy.$setMessage(this._viewId, Ae.fromStrict(this._message) ?? "");
    }));
  }
  async getChildren(e) {
    const i = e ? this.getExtensionElement(e) : void 0;
    if (e && !i)
      return this._logService.error(`No tree item with id '${e}' found.`), Promise.resolve([]);
    let n = this._getChildrenNodes(e);
    return n || (n = await this._fetchChildrenNodes(i)), n ? n.map((r) => r.item) : void 0;
  }
  getExtensionElement(e) {
    return this._elements.get(e);
  }
  reveal(e, i) {
    i = i || { select: !0, focus: !1 };
    const n = ni(i.select) ? !0 : i.select, r = ni(i.focus) ? !1 : i.focus, s = ni(i.expand) ? !1 : i.expand;
    return typeof this._dataProvider.getParent != "function" ? Promise.reject(new Error(
      "Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method"
    )) : e ? this._refreshPromise.then(() => this._resolveUnknownParentChain(e)).then((o) => this._resolveTreeNode(e, o[o.length - 1]).then((a) => this._proxy.$reveal(this._viewId, { item: a.item, parentChain: o.map((l) => l.item) }, { select: n, focus: r, expand: s })), (o) => this._logService.error(o)) : this._proxy.$reveal(this._viewId, void 0, { select: n, focus: r, expand: s });
  }
  get message() {
    return this._message;
  }
  set message(e) {
    this._message = e, this._onDidChangeData.fire({ message: !0, element: !1 });
  }
  get title() {
    return this._title;
  }
  set title(e) {
    this._title = e, this._proxy.$setTitle(this._viewId, e, this._description);
  }
  get description() {
    return this._description;
  }
  set description(e) {
    this._description = e, this._proxy.$setTitle(this._viewId, this._title, e);
  }
  get badge() {
    return this._badge;
  }
  set badge(e) {
    this._badge?.value === e?.value && this._badge?.tooltip === e?.tooltip || (this._badge = km.from(e), this._proxy.$setBadge(this._viewId, e));
  }
  setExpanded(e, i) {
    const n = this.getExtensionElement(e);
    n && (i ? this._onDidExpandElement.fire(Object.freeze({ element: n })) : this._onDidCollapseElement.fire(Object.freeze({ element: n })));
  }
  setSelectionAndFocus(e, i) {
    const n = !An(this._selectedHandles, e);
    this._selectedHandles = e;
    const r = this._focusedHandle !== i;
    this._focusedHandle = i, n && this._onDidChangeSelection.fire(Object.freeze({ selection: this.selectedElements })), r && this._onDidChangeActiveItem.fire(Object.freeze({ activeItem: this.focusedElement }));
  }
  setVisible(e) {
    e !== this._visible && (this._visible = e, this._onDidChangeVisibility.fire(Object.freeze({ visible: this._visible })));
  }
  async setCheckboxState(e) {
    const i = (await Promise.all(e.map(async (n) => {
      const r = this.getExtensionElement(n.treeItemHandle);
      return r ? {
        extensionItem: r,
        treeItem: await this._dataProvider.getTreeItem(r),
        newState: n.newState ? Nr.Checked : Nr.Unchecked
      } : Promise.resolve(void 0);
    }))).filter((n) => n !== void 0);
    i.forEach((n) => {
      n.treeItem.checkboxState = n.newState ? Nr.Checked : Nr.Unchecked;
    }), this._onDidChangeCheckboxState.fire({ items: i.map((n) => [n.extensionItem, n.newState]) });
  }
  async handleDrag(e, i, n) {
    const r = [];
    for (const s of e) {
      const o = this.getExtensionElement(s);
      o && r.push(o);
    }
    if (!(!this._dndController?.handleDrag || r.length === 0))
      return await this._dndController.handleDrag(r, i, n), i;
  }
  get hasHandleDrag() {
    return !!this._dndController?.handleDrag;
  }
  async onDrop(e, i, n) {
    const r = i ? this.getExtensionElement(i) : void 0;
    if (!(!r && i || !this._dndController?.handleDrop))
      return Ai(() => this._dndController?.handleDrop ? this._dndController.handleDrop(r, e, n) : void 0);
  }
  get hasResolve() {
    return !!this._dataProvider.resolveTreeItem;
  }
  async resolveTreeItem(e, i) {
    if (!this._dataProvider.resolveTreeItem)
      return;
    const n = this._elements.get(e);
    if (n) {
      const r = this._nodes.get(n);
      if (r) {
        const s = await this._dataProvider.resolveTreeItem(r.extensionItem, n, i) ?? r.extensionItem;
        return this._validateTreeItem(s), r.item.tooltip = this._getTooltip(s.tooltip), r.item.command = this._getCommand(r.disposableStore, s.command), r.item;
      }
    }
  }
  _resolveUnknownParentChain(e) {
    return this._resolveParent(e).then((i) => i ? this._resolveUnknownParentChain(i).then((n) => this._resolveTreeNode(i, n[n.length - 1]).then((r) => (n.push(r), n))) : Promise.resolve([]));
  }
  _resolveParent(e) {
    const i = this._nodes.get(e);
    return i ? Promise.resolve(i.parent ? this._elements.get(i.parent.item.handle) : void 0) : Ai(() => this._dataProvider.getParent(e));
  }
  _resolveTreeNode(e, i) {
    const n = this._nodes.get(e);
    return n ? Promise.resolve(n) : Ai(() => this._dataProvider.getTreeItem(e)).then((r) => this._createHandle(e, r, i, !0)).then((r) => this.getChildren(i ? i.item.handle : void 0).then(() => {
      const s = this.getExtensionElement(r);
      if (s) {
        const o = this._nodes.get(s);
        if (o)
          return Promise.resolve(o);
      }
      throw new Error(
        `Cannot resolve tree item for element ${r} from extension ${this._extension.identifier.value}`
      );
    }));
  }
  _getChildrenNodes(e) {
    if (e) {
      let i;
      if (typeof e == "string") {
        const n = this.getExtensionElement(e);
        i = n ? this._nodes.get(n) : void 0;
      } else
        i = e;
      return i && i.children || void 0;
    }
    return this._roots;
  }
  async _fetchChildrenNodes(e) {
    this._addChildrenToClear(e);
    const i = new Pt(this._refreshCancellationSource.token);
    try {
      const n = e ? this._nodes.get(e) : void 0, r = await this._dataProvider.getChildren(e);
      if (i.token.isCancellationRequested)
        return;
      const s = Kt(r || []), o = await Promise.all(Kt(s).map((l) => this._dataProvider.getTreeItem(l)));
      if (i.token.isCancellationRequested)
        return;
      const a = o.map(
        (l, c) => l ? this._createAndRegisterTreeNode(s[c], l, n) : null
      );
      return Kt(a);
    } finally {
      i.dispose();
    }
  }
  _refresh(e) {
    if (e.some((n) => !n))
      return this._refreshCancellationSource.dispose(!0), this._refreshCancellationSource = new Pt(), this._addChildrenToClear(), this._proxy.$refresh(this._viewId);
    {
      const n = this._getHandlesToRefresh(e);
      if (n.length)
        return this._refreshHandles(n);
    }
    return Promise.resolve(void 0);
  }
  _getHandlesToRefresh(e) {
    const i = /* @__PURE__ */ new Set(), n = e.map((s) => this._nodes.get(s));
    for (const s of n)
      if (s && !i.has(s.item.handle)) {
        let o = s;
        for (; o && o.parent && n.findIndex((a) => o && o.parent && a && a.item.handle === o.parent.item.handle) === -1; ) {
          const a = this._elements.get(o.parent.item.handle);
          o = a ? this._nodes.get(a) : void 0;
        }
        o && !o.parent && i.add(s.item.handle);
      }
    const r = [];
    return i.forEach((s) => {
      const o = this._elements.get(s);
      if (o) {
        const a = this._nodes.get(o);
        a && (!a.parent || !i.has(a.parent.item.handle)) && r.push(s);
      }
    }), r;
  }
  _refreshHandles(e) {
    const i = {};
    return Promise.all(e.map((n) => this._refreshNode(n).then((r) => {
      r && (i[n] = r.item);
    }))).then(() => Object.keys(i).length ? this._proxy.$refresh(this._viewId, i) : void 0);
  }
  _refreshNode(e) {
    const i = this.getExtensionElement(e);
    if (i) {
      const n = this._nodes.get(i);
      if (n)
        return this._addChildrenToClear(i), Ai(() => this._dataProvider.getTreeItem(i)).then((r) => {
          if (r) {
            const s = this._createTreeNode(i, r, n.parent);
            return this._updateNodeCache(i, s, n, n.parent), n.dispose(), s;
          }
          return null;
        });
    }
    return Promise.resolve(null);
  }
  _createAndRegisterTreeNode(e, i, n) {
    const r = this._createTreeNode(e, i, n);
    if (i.id && this._elements.has(r.item.handle))
      throw new Error(h(2637, "Element with id {0} is already registered", i.id));
    return this._addNodeToCache(e, r), this._addNodeToParentCache(r, n), r;
  }
  _getTooltip(e) {
    return bn.isMarkdownString(e) ? Ae.from(e) : e;
  }
  _getCommand(e, i) {
    return i ? { ...this._commands.toInternal(i, e), originalId: i.command } : void 0;
  }
  _getCheckbox(e) {
    if (e.checkboxState === void 0)
      return;
    let i, n, r;
    return typeof e.checkboxState == "number" ? i = e.checkboxState : (i = e.checkboxState.state, n = e.checkboxState.tooltip, r = e.checkboxState.accessibilityInformation), { isChecked: i === Nr.Checked, tooltip: n, accessibilityInformation: r };
  }
  _validateTreeItem(e) {
    if (!Fg.isTreeItem(e, this._extension))
      throw new Error(
        `Extension ${this._extension.identifier.value} has provided an invalid tree item.`
      );
  }
  _createTreeNode(e, i, n) {
    this._validateTreeItem(i);
    const r = this._register(new De()), s = this._createHandle(e, i, n), o = this._getLightIconPath(i);
    return {
      item: {
        handle: s,
        parentHandle: n ? n.item.handle : void 0,
        label: KC(i.label),
        description: i.description,
        resourceUri: i.resourceUri,
        tooltip: this._getTooltip(i.tooltip),
        command: this._getCommand(r, i.command),
        contextValue: i.contextValue,
        icon: o,
        iconDark: this._getDarkIconPath(i) || o,
        themeIcon: this._getThemeIcon(i),
        collapsibleState: ni(i.collapsibleState) ? Pa.None : i.collapsibleState,
        accessibilityInformation: i.accessibilityInformation,
        checkbox: this._getCheckbox(i)
      },
      extensionItem: i,
      parent: n,
      children: void 0,
      disposableStore: r,
      dispose() {
        r.dispose();
      }
    };
  }
  _getThemeIcon(e) {
    return e.iconPath instanceof qi ? e.iconPath : void 0;
  }
  _createHandle(e, { id: i, label: n, resourceUri: r }, s, o) {
    if (i)
      return `${lc.ID_HANDLE_PREFIX}/${i}`;
    const a = KC(n), l = s ? s.item.handle : lc.LABEL_HANDLE_PREFIX;
    let c = a ? a.label : r ? Fs(r) : "";
    c = c.indexOf("/") !== -1 ? c.replace("/", "//") : c;
    const u = this._nodes.has(e) ? this._nodes.get(e).item.handle : void 0, d = this._getChildrenNodes(s) || [];
    let f, g = 0;
    do {
      if (f = `${l}/${g}:${c}`, o || !this._elements.has(f) || u === f)
        break;
      g++;
    } while (g <= d.length);
    return f;
  }
  _getLightIconPath(e) {
    if (e.iconPath && !(e.iconPath instanceof qi))
      return typeof e.iconPath == "string" || x.isUri(e.iconPath) ? this._getIconPath(e.iconPath) : this._getIconPath(e.iconPath.light);
  }
  _getDarkIconPath(e) {
    if (e.iconPath && !(e.iconPath instanceof qi) && e.iconPath.dark)
      return this._getIconPath(e.iconPath.dark);
  }
  _getIconPath(e) {
    return x.isUri(e) ? e : x.file(e);
  }
  _addNodeToCache(e, i) {
    this._elements.set(i.item.handle, e), this._nodes.set(e, i);
  }
  _updateNodeCache(e, i, n, r) {
    this._elements.delete(i.item.handle), this._nodes.delete(e), i.item.handle !== n.item.handle && this._elements.delete(n.item.handle), this._addNodeToCache(e, i);
    const s = this._getChildrenNodes(r) || [], o = s.filter((a) => a.item.handle === n.item.handle)[0];
    o && s.splice(s.indexOf(o), 1, i);
  }
  _addNodeToParentCache(e, i) {
    i ? (i.children || (i.children = []), i.children.push(e)) : (this._roots || (this._roots = []), this._roots.push(e));
  }
  _addChildrenToClear(e) {
    if (e) {
      const i = this._nodes.get(e);
      if (i) {
        if (i.children)
          for (const n of i.children) {
            this._nodesToClear.add(n);
            const r = this._elements.get(n.item.handle);
            r && (this._addChildrenToClear(r), this._nodes.delete(r), this._elements.delete(n.item.handle));
          }
        i.children = void 0;
      }
    } else
      this._addAllToClear();
  }
  _addAllToClear() {
    this._roots = void 0, this._nodes.forEach((e) => {
      this._nodesToClear.add(e);
    }), this._nodes.clear(), this._elements.clear();
  }
  _clearNodes(e) {
    Wn(e);
  }
  _clearAll() {
    this._roots = void 0, this._elements.clear(), Wn(this._nodes.values()), this._nodes.clear(), Wn(this._nodesToClear), this._nodesToClear.clear();
  }
  dispose() {
    super.dispose(), this._refreshCancellationSource.dispose(), this._clearAll(), this._proxy.$disposeTree(this._viewId);
  }
};
lc.LABEL_HANDLE_PREFIX = "0", lc.ID_HANDLE_PREFIX = "1";
let ox = lc;
const F_ = class F_ {
  constructor(e) {
    this._openers = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadUriOpeners);
  }
  registerExternalUriOpener(e, i, n, r) {
    if (this._openers.has(i))
      throw new Error(`Opener with id '${i}' already registered`);
    const s = r.schemes.find((o) => !F_.supportedSchemes.has(o));
    if (s)
      throw new Error(
        `Scheme '${s}' is not supported. Only http and https are currently supported.`
      );
    return this._openers.set(i, n), this._proxy.$registerUriOpener(i, r.schemes, e, r.label), Ee(() => {
      this._openers.delete(i), this._proxy.$unregisterUriOpener(i);
    });
  }
  async $canOpenUri(e, i, n) {
    const r = this._openers.get(e);
    if (!r)
      throw new Error(`Unknown opener with id: ${e}`);
    const s = x.revive(i);
    return r.canOpenExternalUri(s, n);
  }
  async $openUri(e, i, n) {
    const r = this._openers.get(e);
    if (!r)
      throw new Error(`Unknown opener id: '${e}'`);
    return r.openExternalUri(x.revive(i.resolvedUri), {
      sourceUri: x.revive(i.sourceUri)
    }, n);
  }
};
F_.supportedSchemes = /* @__PURE__ */ new Set([de.http, de.https]);
let ax = F_;
class w$ extends ve {
  #e;
  #t;
  #i;
  #n;
  #s;
  #r;
  #a;
  #o;
  #l;
  #c;
  #u;
  #h;
  #d;
  constructor(e, i, n, r) {
    super(), this.#o = void 0, this.#l = !0, this.#u = !1, this.#h = this._register(new N()), this.onDidDispose = this.#h.event, this.#d = this._register(new N()), this.onDidChangeViewState = this.#d.event, this.#e = e, this.#t = i, this.#n = n, this.#i = r.viewType, this.#s = r.panelOptions, this.#o = r.viewColumn, this.#r = r.title, this.#c = r.active;
  }
  dispose() {
    this.#u || (this.#u = !0, this.#h.fire(), this.#t.$disposeWebview(this.#e), this.#n.dispose(), super.dispose());
  }
  get webview() {
    return this.assertNotDisposed(), this.#n;
  }
  get viewType() {
    return this.assertNotDisposed(), this.#i;
  }
  get title() {
    return this.assertNotDisposed(), this.#r;
  }
  set title(e) {
    this.assertNotDisposed(), this.#r !== e && (this.#r = e, this.#t.$setTitle(this.#e, e));
  }
  get iconPath() {
    return this.assertNotDisposed(), this.#a;
  }
  set iconPath(e) {
    this.assertNotDisposed(), this.#a !== e && (this.#a = e, this.#t.$setIconPath(this.#e, x.isUri(e) ? { light: e, dark: e } : e));
  }
  get options() {
    return this.#s;
  }
  get viewColumn() {
    if (this.assertNotDisposed(), !(typeof this.#o == "number" && this.#o < 0))
      return this.#o;
  }
  get active() {
    return this.assertNotDisposed(), this.#c;
  }
  get visible() {
    return this.assertNotDisposed(), this.#l;
  }
  _updateViewState(e) {
    this.#u || (this.active !== e.active || this.visible !== e.visible || this.viewColumn !== e.viewColumn) && (this.#c = e.active, this.#l = e.visible, this.#o = e.viewColumn, this.#d.fire({ webviewPanel: this }));
  }
  reveal(e, i) {
    this.assertNotDisposed(), this.#t.$reveal(this.#e, {
      viewColumn: typeof e > "u" ? void 0 : si.from(e),
      preserveFocus: !!i
    });
  }
  assertNotDisposed() {
    if (this.#u)
      throw new Error("Webview is disposed");
  }
}
class ME extends ve {
  static newHandle() {
    return on();
  }
  constructor(e, i, n) {
    super(), this.webviews = i, this.workspace = n, this._webviewPanels = /* @__PURE__ */ new Map(), this._serializers = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadWebviewPanels);
  }
  dispose() {
    super.dispose(), this._webviewPanels.forEach((e) => e.dispose()), this._webviewPanels.clear();
  }
  createWebviewPanel(e, i, n, r, s = {}) {
    const o = typeof r == "object" ? r.viewColumn : r, a = {
      viewColumn: si.from(o),
      preserveFocus: typeof r == "object" && !!r.preserveFocus
    }, l = vu(e), c = ME.newHandle();
    this._proxy.$createWebviewPanel(r_(e), c, i, {
      title: n,
      panelOptions: b$(s),
      webviewOptions: L5(e, this.workspace, s),
      serializeBuffersForPostMessage: l
    }, a);
    const u = this.webviews.createNewWebview(c, s, e);
    return this.createNewWebviewPanel(c, i, n, o, s, u, !0);
  }
  $onDidChangeWebviewPanelViewStates(e) {
    const i = Object.keys(e);
    i.sort((n, r) => {
      const s = e[n], o = e[r];
      return s.active ? 1 : o.active ? -1 : +s.visible - +o.visible;
    });
    for (const n of i) {
      const r = this.getWebviewPanel(n);
      if (!r)
        continue;
      const s = e[n];
      r._updateViewState({
        active: s.active,
        visible: s.visible,
        viewColumn: si.to(s.position)
      });
    }
  }
  async $onDidDisposeWebviewPanel(e) {
    this.getWebviewPanel(e)?.dispose(), this._webviewPanels.delete(e), this.webviews.deleteWebview(e);
  }
  registerWebviewPanelSerializer(e, i, n) {
    if (this._serializers.has(i))
      throw new Error(`Serializer for '${i}' already registered`);
    return this._serializers.set(i, { serializer: n, extension: e }), this._proxy.$registerSerializer(i, {
      serializeBuffersForPostMessage: vu(e)
    }), new Ve(() => {
      this._serializers.delete(i), this._proxy.$unregisterSerializer(i);
    });
  }
  async $deserializeWebviewPanel(e, i, n, r) {
    const s = this._serializers.get(i);
    if (!s)
      throw new Error(`No serializer found for '${i}'`);
    const { serializer: o, extension: a } = s, l = this.webviews.createNewWebview(e, n.webviewOptions, a), c = this.createNewWebviewPanel(e, i, n.title, r, n.panelOptions, l, n.active);
    await o.deserializeWebviewPanel(c, n.state);
  }
  createNewWebviewPanel(e, i, n, r, s, o, a) {
    const l = new w$(
      e,
      this._proxy,
      o,
      { viewType: i, title: n, viewColumn: r, panelOptions: s, active: a }
    );
    return this._webviewPanels.set(e, l), l;
  }
  getWebviewPanel(e) {
    return this._webviewPanels.get(e);
  }
}
function b$(t) {
  return {
    enableFindWidget: t.enableFindWidget,
    retainContextWhenHidden: t.retainContextWhenHidden
  };
}
class y$ extends ve {
  #e;
  #t;
  #i;
  #n;
  #s;
  #r;
  #a;
  #o;
  #l;
  constructor(e, i, n, r, s, o) {
    super(), this.#s = !1, this.#c = this._register(new N()), this.onDidChangeVisibility = this.#c.event, this.#u = this._register(new N()), this.onDidDispose = this.#u.event, this.#i = n, this.#a = r, this.#e = e, this.#t = i, this.#n = s, this.#r = o;
  }
  dispose() {
    this.#s || (this.#s = !0, this.#u.fire(), this.#n.dispose(), super.dispose());
  }
  #c;
  #u;
  get title() {
    return this.assertNotDisposed(), this.#a;
  }
  set title(e) {
    this.assertNotDisposed(), this.#a !== e && (this.#a = e, this.#t.$setWebviewViewTitle(this.#e, e));
  }
  get description() {
    return this.assertNotDisposed(), this.#o;
  }
  set description(e) {
    this.assertNotDisposed(), this.#o !== e && (this.#o = e, this.#t.$setWebviewViewDescription(this.#e, e));
  }
  get visible() {
    return this.#r;
  }
  get webview() {
    return this.#n;
  }
  get viewType() {
    return this.#i;
  }
  _setVisible(e) {
    e === this.#r || this.#s || (this.#r = e, this.#c.fire());
  }
  get badge() {
    return this.assertNotDisposed(), this.#l;
  }
  set badge(e) {
    this.assertNotDisposed(), !(e?.value === this.#l?.value && e?.tooltip === this.#l?.tooltip) && (this.#l = km.from(e), this.#t.$setWebviewViewBadge(this.#e, e));
  }
  show(e) {
    this.assertNotDisposed(), this.#t.$show(this.#e, !!e);
  }
  assertNotDisposed() {
    if (this.#s)
      throw new Error("Webview is disposed");
  }
}
class x$ {
  constructor(e, i) {
    this._extHostWebview = i, this._viewProviders = /* @__PURE__ */ new Map(), this._webviewViews = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadWebviewViews);
  }
  registerWebviewViewProvider(e, i, n, r) {
    if (this._viewProviders.has(i))
      throw new Error(`View provider for '${i}' already registered`);
    return this._viewProviders.set(i, { provider: n, extension: e }), this._proxy.$registerWebviewViewProvider(r_(e), i, {
      retainContextWhenHidden: r?.retainContextWhenHidden,
      serializeBuffersForPostMessage: vu(e)
    }), new Ve(() => {
      this._viewProviders.delete(i), this._proxy.$unregisterWebviewViewProvider(i);
    });
  }
  async $resolveWebviewView(e, i, n, r, s) {
    const o = this._viewProviders.get(i);
    if (!o)
      throw new Error(`No view provider found for '${i}'`);
    const { provider: a, extension: l } = o, c = this._extHostWebview.createNewWebview(e, {}, l), u = new y$(e, this._proxy, i, n, c, !0);
    this._webviewViews.set(e, u), await a.resolveWebviewView(u, { state: r }, s);
  }
  async $onDidChangeWebviewViewVisibility(e, i) {
    this.getWebviewView(e)._setVisible(i);
  }
  async $disposeWebviewView(e) {
    const i = this.getWebviewView(e);
    this._webviewViews.delete(e), i.dispose(), this._extHostWebview.deleteWebview(e);
  }
  getWebviewView(e) {
    const i = this._webviewViews.get(e);
    if (!i)
      throw new Error("No webview found");
    return i;
  }
}
class E$ {
  constructor(e) {
    this._settingsSearchProviders = /* @__PURE__ */ new Map(), this._nextHandle = 0, this._proxy = e.getProxy(ee.MainThreadAiSettingsSearch);
  }
  async $startSearch(e, i, n, r) {
    if (this._settingsSearchProviders.size === 0)
      throw new Error("No related information providers registered");
    const s = this._settingsSearchProviders.get(e);
    if (!s)
      throw new Error("Settings search provider not found");
    const o = new Jd((a) => {
      this._proxy.$handleSearchResult(e, hy.fromSettingsSearchResult(a));
    });
    return s.provideSettingsSearchResults(i, n, o, r);
  }
  registerSettingsSearchProvider(e, i) {
    const n = this._nextHandle;
    return this._nextHandle++, this._settingsSearchProviders.set(n, i), this._proxy.$registerAiSettingsSearchProvider(n), new Ve(() => {
      this._proxy.$unregisterAiSettingsSearchProvider(n), this._settingsSearchProviders.delete(n);
    });
  }
}
var lx;
class S$ {
  constructor(e, i, n, r, s, o) {
    this.session = e, this.extension = i, this.proxy = r, this.commandsConverter = s, this.sessionDisposables = o, this._stream = new C0(i, n, r, s, o);
  }
  get activeResponseStream() {
    return this._stream;
  }
  getActiveRequestStream(e) {
    return new C0(
      this.extension,
      e,
      this.proxy,
      this.commandsConverter,
      this.sessionDisposables
    );
  }
}
var Qa;
let cx = (Qa = class extends ve {
  constructor(e, i, n, r) {
    super(), this.commands = e, this._languageModels = i, this._extHostRpc = n, this._logService = r, this._chatSessionItemProviders = /* @__PURE__ */ new Map(), this._chatSessionContentProviders = /* @__PURE__ */ new Map(), this._nextChatSessionItemProviderHandle = 0, this._nextChatSessionContentProviderHandle = 0, this._sessionMap = /* @__PURE__ */ new Map(), this._extHostChatSessions = /* @__PURE__ */ new Map(), this._proxy = this._extHostRpc.getProxy(ee.MainThreadChatSessions), e.registerArgumentProcessor({
      processArgument: (s) => {
        if (s && s.$mid === tt.ChatSessionContext) {
          const o = s.id, a = this._sessionMap.get(o);
          return a || (this._logService.warn(`No chat session found for ID: ${o}`), s);
        }
        return s;
      }
    });
  }
  registerChatSessionItemProvider(e, i, n) {
    const r = this._nextChatSessionItemProviderHandle++, s = new De();
    return this._chatSessionItemProviders.set(r, { provider: n, extension: e, disposable: s }), this._proxy.$registerChatSessionItemProvider(r, i), n.onDidChangeChatSessionItems && s.add(n.onDidChangeChatSessionItems(() => {
      this._proxy.$onDidChangeChatSessionItems(i);
    })), {
      dispose: () => {
        this._chatSessionItemProviders.delete(r), s.dispose(), this._proxy.$unregisterChatSessionItemProvider(r);
      }
    };
  }
  registerChatSessionContentProvider(e, i, n) {
    const r = this._nextChatSessionContentProviderHandle++, s = new De();
    return this._chatSessionContentProviders.set(r, { provider: n, extension: e, disposable: s }), this._proxy.$registerChatSessionContentProvider(r, i), new Ve(() => {
      this._chatSessionContentProviders.delete(r), s.dispose(), this._proxy.$unregisterChatSessionContentProvider(r);
    });
  }
  async showChatSession(e, i, n, r) {
    await this._proxy.$showChatSession(i, n, si.from(r?.viewColumn));
  }
  async $provideChatSessionItems(e, i) {
    const n = this._chatSessionItemProviders.get(e);
    if (!n)
      return this._logService.error(`No provider registered for handle ${e}`), [];
    const r = await n.provider.provideChatSessionItems(i);
    if (!r)
      return [];
    const s = [];
    for (const o of r)
      o.id && (this._sessionMap.set(o.id, o), s.push({
        id: o.id,
        label: o.label,
        iconPath: o.iconPath
      }));
    return s;
  }
  async $provideChatSessionContent(e, i, n) {
    const r = this._chatSessionContentProviders.get(e);
    if (!r)
      throw new Error(`No provider for handle ${e}`);
    const s = await r.provider.provideChatSessionContent(i, n), o = new De(), a = lx._sessionHandlePool++, l = new S$(s, r.extension, {
      sessionId: `${i}.${a}`,
      requestId: "ongoing",
      agentId: i,
      message: "",
      variables: { variables: [] },
      location: nn.Panel
    }, {
      $handleProgressChunk: (u, d) => this._proxy.$handleProgressChunk(e, i, u, d),
      $handleAnchorResolve: (u, d, f) => {
        this._proxy.$handleAnchorResolve(e, i, u, d, f);
      }
    }, this.commands.converter, o), c = o.add(new Pt());
    return this._extHostChatSessions.set(`${e}_${i}`, { sessionObj: l, disposeCts: c }), s.activeResponseCallback && Promise.resolve(s.activeResponseCallback(l.activeResponseStream.apiObject, c.token)).finally(() => {
      this._proxy.$handleProgressComplete(e, i, "ongoing");
    }), {
      id: a + "",
      hasActiveResponseCallback: !!s.activeResponseCallback,
      hasRequestHandler: !!s.requestHandler,
      history: s.history.map((u) => u instanceof om ? { type: "request", prompt: u.prompt } : {
        type: "response",
        parts: Kt(u.response.map(
          (g) => Gh.from(g, this.commands.converter, o)
        ))
      })
    };
  }
  async $interruptChatSessionActiveResponse(e, i, n) {
    const r = `${e}_${i}`;
    this._extHostChatSessions.get(r)?.disposeCts.cancel();
  }
  async $disposeChatSessionContent(e, i) {
    const n = `${e}_${i}`, r = this._extHostChatSessions.get(n);
    if (!r) {
      this._logService.warn(`No chat session found for ID: ${n}`);
      return;
    }
    r.disposeCts.cancel(), r.sessionObj.sessionDisposables.dispose(), this._extHostChatSessions.delete(n);
  }
  async $invokeChatSessionRequestHandler(e, i, n, r, s) {
    const o = this._extHostChatSessions.get(`${e}_${i}`);
    if (!o || !o.sessionObj.session.requestHandler)
      return {};
    const a = Qh.to(n, void 0, await this.getModelForRequest(n, o.sessionObj.extension), [], /* @__PURE__ */ new Map(), o.sessionObj.extension, this._logService), l = o.sessionObj.getActiveRequestStream(n);
    return await o.sessionObj.session.requestHandler(a, { history: r }, l.apiObject, s), {};
  }
  async getModelForRequest(e, i) {
    let n;
    if (e.userSelectedModelId && (n = await this._languageModels.getLanguageModelByIdentifier(i, e.userSelectedModelId)), !n && (n = await this._languageModels.getDefaultLanguageModel(i), !n))
      throw new Error("Language model unavailable");
    return n;
  }
}, lx = Qa, Qa._sessionHandlePool = 0, Qa);
cx = lx = W([
  M(2, Ye),
  M(3, nt)
], cx);
class D$ {
  constructor(e, i) {
    this.webviews = i, this._renderers = /* @__PURE__ */ new Map(), this._proxy = e.getProxy(ee.MainThreadChatOutputRenderer);
  }
  registerChatOutputRenderer(e, i, n) {
    if (this._renderers.has(i))
      throw new Error(`Chat output renderer already registered for: ${i}`);
    return this._renderers.set(i, { extension: e, renderer: n }), this._proxy.$registerChatOutputRenderer(i, e.identifier, e.extensionLocation), new Ve(() => {
      this._renderers.delete(i), this._proxy.$unregisterChatOutputRenderer(i);
    });
  }
  async $renderChatOutput(e, i, n, r, s) {
    const o = this._renderers.get(e);
    if (!o)
      throw new Error(`No chat output renderer registered for: ${e}`);
    const a = this.webviews.createNewWebview(r, {}, o.extension);
    return o.renderer.renderChatOutput(Object.freeze({ mime: i, value: n.buffer }), a, {}, s);
  }
}
function k$(t) {
  const e = t.get(pi), i = t.get(wu), n = t.get(l1), r = t.get(Mo), s = t.get(Us), o = t.get(u1), a = t.get($s), l = t.get(B_), c = t.get(Ye), u = t.get(mE), d = t.get(_E), f = t.get(Lo), g = t.get(nt), _ = t.get(vE), w = t.get(vf), v = t.get(d1), S = t.get(h1), E = t.get(xE), A = t.get(bf), j = t.get(SE), V = t.get(f1), le = t.get(bE), Q = t.get(yE), re = t.get(x0), K = t.get(D5);
  c.set(he.ExtHostFileSystemInfo, i), c.set(he.ExtHostLogLevelServiceShape, f), c.set(he.ExtHostWorkspace, s), c.set(he.ExtHostConfiguration, a), c.set(he.ExtHostExtensionService, r), c.set(he.ExtHostStorage, u), c.set(he.ExtHostTunnelService, _), c.set(he.ExtHostWindow, v), c.set(he.ExtHostUrls, S), c.set(he.ExtHostSecretState, E), c.set(he.ExtHostTelemetry, o), c.set(he.ExtHostEditorTabs, A), c.set(he.ExtHostManagedSockets, j), c.set(he.ExtHostProgress, V), c.set(he.ExtHostAuthentication, le), c.set(he.ExtHostChatProvider, Q), c.set(he.ExtHostDataChannels, K);
  const ye = c.set(he.ExtHostDecorations, t.get(f5)), Fe = c.set(he.ExtHostDocumentsAndEditors, t.get(Su)), Te = c.set(he.ExtHostCommands, t.get(vl)), X = c.set(he.ExtHostTerminalService, t.get(Eu)), Y = c.set(he.ExtHostTerminalShellIntegration, t.get(S5)), Z = c.set(he.ExtHostDebugService, t.get(b5)), ie = c.set(he.ExtHostSearch, t.get(E5)), ce = c.set(he.ExtHostTask, t.get(m5)), Le = c.set(he.ExtHostOutputService, t.get(h5)), Be = c.set(he.ExtHostLocalization, t.get(EE)), qe = c.set(he.ExtHostDocuments, new jF(c, Fe)), St = c.set(he.ExtHostDocumentContentProviders, new L0(c, Fe, g)), Jt = c.set(he.ExtHostDocumentSaveParticipant, new qF(g, qe, c.getProxy(ee.MainThreadBulkEdits))), ct = c.set(he.ExtHostNotebook, new Q0(
    c,
    Te,
    Fe,
    qe,
    n,
    ie,
    g
  )), $t = c.set(he.ExtHostNotebookDocuments, new GU(ct)), ln = c.set(he.ExtHostNotebookEditors, new K0(g, ct)), gi = c.set(he.ExtHostNotebookKernels, new J0(c, e, ct, Te, g)), yr = c.set(he.ExtHostNotebookRenderers, new YU(c, ct)), Gn = c.set(he.ExtHostNotebookDocumentSaveParticipant, new jU(g, ct, c.getProxy(ee.MainThreadBulkEdits))), $i = c.set(he.ExtHostEditors, new h$(c, Fe)), ku = c.set(he.ExtHostTreeViews, new v$(c.getProxy(ee.MainThreadTreeViews), Te, g)), yf = c.set(he.ExtHostEditorInsets, new EF(c.getProxy(ee.MainThreadEditorInsets), $i, e.remote)), Hs = c.set(he.ExtHostDiagnostics, new R0(
    c,
    g,
    i,
    Fe
  )), Mn = c.set(he.ExtHostLanguages, new SU(c, qe, Te.converter, l)), We = c.set(he.ExtHostLanguageFeatures, new N0(
    c,
    l,
    qe,
    Te,
    Hs,
    g,
    w,
    o
  )), _1 = c.set(he.ExtHostCodeMapper, new A0(c)), v1 = c.set(he.ExtHostFileSystem, new a_(c, We)), Je = c.set(he.ExtHostFileSystemEventService, new iU(c, g, Fe)), Oo = c.set(he.ExtHostQuickOpen, ZU(c, s, Te)), xf = c.set(he.ExtHostSCM, new tx(c, Te, qe, g)), Ef = c.set(he.ExtHostQuickDiff, new Z0(c, l)), Bs = c.set(he.ExtHostShare, new ix(c, l)), w1 = c.set(he.ExtHostComments, SF(c, Te, qe)), b1 = c.set(he.ExtHostLabelService, new rU(c)), Sf = c.set(he.ExtHostTheming, new sx(c)), y1 = c.set(he.ExtHostTimeline, new f$(c, Te)), cn = c.set(he.ExtHostWebviews, new NF(
    c,
    e.remote,
    s,
    g,
    w
  )), Iu = c.set(he.ExtHostWebviewPanels, new ME(c, cn, s)), x1 = c.set(he.ExtHostCustomEditors, new HF(
    c,
    qe,
    d,
    cn,
    Iu
  )), E1 = c.set(he.ExtHostWebviewViews, new x$(c, cn)), Ws = c.set(he.ExtHostTesting, t.get(g1)), wl = c.set(he.ExtHostUriOpeners, new ax(c)), bl = c.set(he.ExtHostProfileContentHandlers, new XU(c)), Cu = c.set(he.ExtHostChatOutputRenderer, new D$(c, cn));
  c.set(he.ExtHostInteractive, new nU(
    c,
    ct,
    Fe,
    Te,
    g
  ));
  const Fo = c.set(he.ExtHostLanguageModelTools, new EU(c, Q)), Qn = c.set(he.ExtHostChatAgents2, new T0(
    c,
    g,
    Te,
    qe,
    Q,
    Hs,
    Fo
  )), yl = c.set(he.ExtHostAiRelatedInformation, new lF(c)), xl = c.set(he.ExtHostAiEmbeddingVector, new QF(c)), un = c.set(he.ExtHostAiSettingsSearch, new E$(c)), Vs = c.set(he.ExtHostStatusBar, new d$(c, Te.converter)), Ht = c.set(he.ExtHostSpeech, new nx(c)), Uo = c.set(he.ExtHostEmbeddings, new GF(c)), Tu = c.set(he.ExtHostChatSessions, new cx(Te, Q, c, g));
  c.set(he.ExtHostMcp, t.get(x0));
  const Ni = Object.values(he);
  c.assertRegistered(Ni);
  const S1 = new I0(c, Fe), D1 = new bF(c), Pu = new V0(c, g), Df = new zF(c), k1 = new vF(c);
  return fF.register(Te), function(C, xr, Au) {
    function fe(m) {
      return (b, I, Ie) => {
        const Xe = m((li) => {
          try {
            b.call(I, li);
          } catch (W5) {
            pv(new W4(C.identifier, W5, "FAILED to handle event"));
          }
        });
        return Ie?.push(Xe), Xe;
      };
    }
    const rt = function() {
      let m = !C.isUnderDevelopment;
      function b() {
        m || (g.info(`Extension '${C.identifier.value}' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305`), m = !0);
      }
      return function I(Ie) {
        if (Array.isArray(Ie))
          Ie.forEach(I);
        else if (typeof Ie == "string")
          b();
        else {
          const Xe = Ie;
          typeof Xe.scheme > "u" && b(), typeof Xe.exclusive == "boolean" && $(C, "documentFiltersExclusive");
        }
        return Ie;
      };
    }(), I1 = {
      getSession(m, b, I) {
        return (typeof I?.forceNewSession == "object" && I.forceNewSession.learnMore || typeof I?.createIfNone == "object" && I.createIfNone.learnMore) && $(C, "authLearnMore"), I?.authorizationServer && $(C, "authIssuers"), le.getSession(C, m, b, I);
      },
      getAccounts(m) {
        return le.getAccounts(m);
      },
      async hasSession(m, b) {
        return $(C, "authSession"), !!await le.getSession(C, m, b, { silent: !0 });
      },
      get onDidChangeSessions() {
        return fe(le.getExtensionScopedSessionsEvent(C.identifier.value));
      },
      registerAuthenticationProvider(m, b, I, Ie) {
        return Ie?.supportedAuthorizationServers && $(C, "authIssuers"), le.registerAuthenticationProvider(m, b, I, Ie);
      }
    }, C1 = {
      registerCommand(m, b, I) {
        return Te.registerCommand(!0, m, b, I, void 0, C);
      },
      registerTextEditorCommand(m, b, I) {
        return Te.registerCommand(!0, m, (...Ie) => {
          const Xe = $i.getActiveTextEditor();
          if (!Xe) {
            g.warn("Cannot execute " + m + " because there is no active text editor.");
            return;
          }
          return Xe.edit((li) => {
            b.apply(I, [Xe, li, ...Ie]);
          }).then((li) => {
            li || g.warn("Edits from command " + m + " were not applied.");
          }, (li) => {
            g.warn("An error occurred while running command " + m, li);
          });
        }, void 0, void 0, C);
      },
      registerDiffInformationCommand: (m, b, I) => ($(C, "diffCommand"), Te.registerCommand(!0, m, async (...Ie) => {
        const Xe = Fe.activeEditor(!0);
        if (!Xe) {
          g.warn("Cannot execute " + m + " because there is no active text editor.");
          return;
        }
        const li = await $i.getDiffInformation(Xe.id);
        b.apply(I, [li, ...Ie]);
      }, void 0, void 0, C)),
      executeCommand(m, ...b) {
        return Te.executeCommand(m, ...b);
      },
      getCommands(m = !1) {
        return Te.getCommands(m);
      }
    }, T1 = {
      get machineId() {
        return e.telemetryInfo.machineId;
      },
      get sessionId() {
        return e.telemetryInfo.sessionId;
      },
      get language() {
        return e.environment.appLanguage;
      },
      get appName() {
        return e.environment.appName;
      },
      get appRoot() {
        return e.environment.appRoot?.fsPath ?? "";
      },
      get appHost() {
        return e.environment.appHost;
      },
      get uriScheme() {
        return e.environment.appUriScheme;
      },
      get clipboard() {
        return D1.value;
      },
      get shell() {
        return X.getDefaultShell(!1);
      },
      get onDidChangeShell() {
        return fe(X.onDidChangeShell);
      },
      get isTelemetryEnabled() {
        return o.getTelemetryConfiguration();
      },
      get onDidChangeTelemetryEnabled() {
        return fe(o.onDidChangeTelemetryEnabled);
      },
      get telemetryConfiguration() {
        return $(C, "telemetry"), o.getTelemetryDetails();
      },
      get onDidChangeTelemetryConfiguration() {
        return $(C, "telemetry"), fe(o.onDidChangeTelemetryConfiguration);
      },
      get isNewAppInstall() {
        return KP(e.telemetryInfo.firstSessionDate);
      },
      createTelemetryLogger(m, b) {
        return QP.validateSender(m), o.instantiateLogger(C, m, b);
      },
      openExternal(m, b) {
        return v.openUri(m, {
          allowTunneling: !!e.remote.authority,
          allowContributedOpeners: b?.allowContributedOpeners
        });
      },
      async asExternalUri(m) {
        if (m.scheme === e.environment.appUriScheme)
          return S.createAppUri(m);
        try {
          return await v.asExternalUri(m, { allowTunneling: !!e.remote.authority });
        } catch (b) {
          if (Tv(m, de.http) || Tv(m, de.https))
            return m;
          throw b;
        }
      },
      get remoteName() {
        return Tx(e.remote.authority);
      },
      get remoteAuthority() {
        return $(C, "resolvers"), e.remote.authority;
      },
      get uiKind() {
        return e.uiKind;
      },
      get logLevel() {
        return g.getLevel();
      },
      get onDidChangeLogLevel() {
        return fe(g.onDidChangeLogLevel);
      },
      get appQuality() {
        return $(C, "resolvers"), e.quality;
      },
      get appCommit() {
        return $(C, "resolvers"), e.commit;
      },
      getDataChannel(m) {
        return $(C, "dataChannels"), K.createDataChannel(C, m);
      }
    }, P1 = {
      createTestController(m, b, I) {
        return Ws.createTestController(C, m, b, I);
      },
      createTestObserver() {
        return $(C, "testObserver"), Ws.createTestObserver();
      },
      runTests(m) {
        return $(C, "testObserver"), Ws.runTests(m);
      },
      registerTestFollowupProvider(m) {
        return $(C, "testObserver"), Ws.registerTestFollowupProvider(m);
      },
      get onDidChangeTestResults() {
        return $(C, "testObserver"), fe(Ws.onResultsChanged);
      },
      get testResults() {
        return $(C, "testObserver"), Ws.results;
      }
    }, El = e.remote.isRemote ? Aa.Workspace : Aa.UI, Ru = {
      getExtension(m, b) {
        lt(C, "extensionsAny") || (b = !1);
        const I = xr.mine.getExtensionDescription(m);
        if (I)
          return new Zu(r, C.identifier, I, El, !1);
        if (b) {
          const Ie = xr.all.getExtensionDescription(m);
          if (Ie)
            return new Zu(
              r,
              C.identifier,
              Ie,
              El,
              !0
            );
        }
      },
      get all() {
        const m = [];
        for (const b of xr.mine.getAllExtensionDescriptions())
          m.push(new Zu(r, C.identifier, b, El, !1));
        return m;
      },
      get allAcrossExtensionHosts() {
        $(C, "extensionsAny");
        const m = new ul(xr.mine.getAllExtensionDescriptions().map((I) => I.identifier)), b = [];
        for (const I of xr.all.getAllExtensionDescriptions()) {
          const Ie = !m.has(I.identifier);
          b.push(new Zu(
            r,
            C.identifier,
            I,
            El,
            Ie
          ));
        }
        return b;
      },
      get onDidChange() {
        return lt(C, "extensionsAny") ? fe(It.any(xr.mine.onDidChange, xr.all.onDidChange)) : fe(xr.mine.onDidChange);
      }
    }, A1 = {
      createDiagnosticCollection(m) {
        return Hs.createDiagnosticCollection(C.identifier, m);
      },
      get onDidChangeDiagnostics() {
        return fe(Hs.onDidChangeDiagnostics);
      },
      getDiagnostics: (m) => Hs.getDiagnostics(m),
      getLanguages() {
        return Mn.getLanguages();
      },
      setTextDocumentLanguage(m, b) {
        return Mn.changeLanguage(m.uri, b);
      },
      match(m, b) {
        const I = Vb.from(m);
        let Ie;
        return I5(I) && (Ie = ct.notebookDocuments.find((Xe) => Xe.apiNotebook.getCells().find((li) => li.document === b))?.apiNotebook), k5(I, b.uri, b.languageId, !0, Ie?.uri, Ie?.notebookType);
      },
      registerCodeActionsProvider(m, b, I) {
        return We.registerCodeActionProvider(C, rt(m), b, I);
      },
      registerDocumentPasteEditProvider(m, b, I) {
        return We.registerDocumentPasteEditProvider(C, rt(m), b, I);
      },
      registerCodeLensProvider(m, b) {
        return We.registerCodeLensProvider(C, rt(m), b);
      },
      registerDefinitionProvider(m, b) {
        return We.registerDefinitionProvider(C, rt(m), b);
      },
      registerDeclarationProvider(m, b) {
        return We.registerDeclarationProvider(C, rt(m), b);
      },
      registerImplementationProvider(m, b) {
        return We.registerImplementationProvider(C, rt(m), b);
      },
      registerTypeDefinitionProvider(m, b) {
        return We.registerTypeDefinitionProvider(C, rt(m), b);
      },
      registerHoverProvider(m, b) {
        return We.registerHoverProvider(C, rt(m), b, C.identifier);
      },
      registerEvaluatableExpressionProvider(m, b) {
        return We.registerEvaluatableExpressionProvider(C, rt(m), b, C.identifier);
      },
      registerInlineValuesProvider(m, b) {
        return We.registerInlineValuesProvider(C, rt(m), b, C.identifier);
      },
      registerDocumentHighlightProvider(m, b) {
        return We.registerDocumentHighlightProvider(C, rt(m), b);
      },
      registerMultiDocumentHighlightProvider(m, b) {
        return We.registerMultiDocumentHighlightProvider(C, rt(m), b);
      },
      registerLinkedEditingRangeProvider(m, b) {
        return We.registerLinkedEditingRangeProvider(C, rt(m), b);
      },
      registerReferenceProvider(m, b) {
        return We.registerReferenceProvider(C, rt(m), b);
      },
      registerRenameProvider(m, b) {
        return We.registerRenameProvider(C, rt(m), b);
      },
      registerNewSymbolNamesProvider(m, b) {
        return $(C, "newSymbolNamesProvider"), We.registerNewSymbolNamesProvider(C, rt(m), b);
      },
      registerDocumentSymbolProvider(m, b, I) {
        return We.registerDocumentSymbolProvider(C, rt(m), b, I);
      },
      registerWorkspaceSymbolProvider(m) {
        return We.registerWorkspaceSymbolProvider(C, m);
      },
      registerDocumentFormattingEditProvider(m, b) {
        return We.registerDocumentFormattingEditProvider(C, rt(m), b);
      },
      registerDocumentRangeFormattingEditProvider(m, b) {
        return We.registerDocumentRangeFormattingEditProvider(C, rt(m), b);
      },
      registerOnTypeFormattingEditProvider(m, b, I, ...Ie) {
        return We.registerOnTypeFormattingEditProvider(C, rt(m), b, [I].concat(Ie));
      },
      registerDocumentSemanticTokensProvider(m, b, I) {
        return We.registerDocumentSemanticTokensProvider(C, rt(m), b, I);
      },
      registerDocumentRangeSemanticTokensProvider(m, b, I) {
        return We.registerDocumentRangeSemanticTokensProvider(C, rt(m), b, I);
      },
      registerSignatureHelpProvider(m, b, I, ...Ie) {
        return typeof I == "object" ? We.registerSignatureHelpProvider(C, rt(m), b, I) : We.registerSignatureHelpProvider(C, rt(m), b, typeof I > "u" ? [] : [I, ...Ie]);
      },
      registerCompletionItemProvider(m, b, ...I) {
        return We.registerCompletionItemProvider(C, rt(m), b, I);
      },
      registerInlineCompletionItemProvider(m, b, I) {
        return b.handleDidShowCompletionItem && $(C, "inlineCompletionsAdditions"), b.handleDidPartiallyAcceptCompletionItem && $(C, "inlineCompletionsAdditions"), I && $(C, "inlineCompletionsAdditions"), We.registerInlineCompletionsProvider(C, rt(m), b, I);
      },
      registerDocumentLinkProvider(m, b) {
        return We.registerDocumentLinkProvider(C, rt(m), b);
      },
      registerColorProvider(m, b) {
        return We.registerColorProvider(C, rt(m), b);
      },
      registerFoldingRangeProvider(m, b) {
        return We.registerFoldingRangeProvider(C, rt(m), b);
      },
      registerSelectionRangeProvider(m, b) {
        return We.registerSelectionRangeProvider(C, m, b);
      },
      registerCallHierarchyProvider(m, b) {
        return We.registerCallHierarchyProvider(C, m, b);
      },
      registerTypeHierarchyProvider(m, b) {
        return We.registerTypeHierarchyProvider(C, m, b);
      },
      setLanguageConfiguration: (m, b) => We.setLanguageConfiguration(C, m, b),
      getTokenInformationAtPosition(m, b) {
        return $(C, "tokenInformation"), Mn.tokenAtPosition(m, b);
      },
      registerInlayHintsProvider(m, b) {
        return We.registerInlayHintsProvider(C, m, b);
      },
      createLanguageStatusItem(m, b) {
        return Mn.createLanguageStatusItem(C, m, b);
      },
      registerDocumentDropEditProvider(m, b, I) {
        return We.registerDocumentOnDropEditProvider(C, m, b, I);
      }
    }, R1 = {
      get activeTextEditor() {
        return $i.getActiveTextEditor();
      },
      get visibleTextEditors() {
        return $i.getVisibleTextEditors();
      },
      get activeTerminal() {
        return X.activeTerminal;
      },
      get terminals() {
        return X.terminals;
      },
      async showTextDocument(m, b, I) {
        x.isUri(m) && m.scheme === de.vscodeRemote && !m.authority && w.report("workspace.showTextDocument", C, "A URI of 'vscode-remote' scheme requires an authority.");
        const Ie = await (x.isUri(m) ? Promise.resolve(kf.openTextDocument(m)) : Promise.resolve(m));
        return $i.showTextDocument(Ie, b, I);
      },
      createTextEditorDecorationType(m) {
        return $i.createTextEditorDecorationType(C, m);
      },
      onDidChangeActiveTextEditor(m, b, I) {
        return fe($i.onDidChangeActiveTextEditor)(m, b, I);
      },
      onDidChangeVisibleTextEditors(m, b, I) {
        return fe($i.onDidChangeVisibleTextEditors)(m, b, I);
      },
      onDidChangeTextEditorSelection(m, b, I) {
        return fe($i.onDidChangeTextEditorSelection)(m, b, I);
      },
      onDidChangeTextEditorOptions(m, b, I) {
        return fe($i.onDidChangeTextEditorOptions)(m, b, I);
      },
      onDidChangeTextEditorVisibleRanges(m, b, I) {
        return fe($i.onDidChangeTextEditorVisibleRanges)(m, b, I);
      },
      onDidChangeTextEditorViewColumn(m, b, I) {
        return fe($i.onDidChangeTextEditorViewColumn)(m, b, I);
      },
      onDidChangeTextEditorDiffInformation(m, b, I) {
        return $(C, "textEditorDiffInformation"), fe($i.onDidChangeTextEditorDiffInformation)(m, b, I);
      },
      onDidCloseTerminal(m, b, I) {
        return fe(X.onDidCloseTerminal)(m, b, I);
      },
      onDidOpenTerminal(m, b, I) {
        return fe(X.onDidOpenTerminal)(m, b, I);
      },
      onDidChangeActiveTerminal(m, b, I) {
        return fe(X.onDidChangeActiveTerminal)(m, b, I);
      },
      onDidChangeTerminalDimensions(m, b, I) {
        return $(C, "terminalDimensions"), fe(X.onDidChangeTerminalDimensions)(m, b, I);
      },
      onDidChangeTerminalState(m, b, I) {
        return fe(X.onDidChangeTerminalState)(m, b, I);
      },
      onDidWriteTerminalData(m, b, I) {
        return $(C, "terminalDataWriteEvent"), fe(X.onDidWriteTerminalData)(m, b, I);
      },
      onDidExecuteTerminalCommand(m, b, I) {
        return $(C, "terminalExecuteCommandEvent"), fe(X.onDidExecuteTerminalCommand)(m, b, I);
      },
      onDidChangeTerminalShellIntegration(m, b, I) {
        return fe(Y.onDidChangeTerminalShellIntegration)(m, b, I);
      },
      onDidStartTerminalShellExecution(m, b, I) {
        return fe(Y.onDidStartTerminalShellExecution)(m, b, I);
      },
      onDidEndTerminalShellExecution(m, b, I) {
        return fe(Y.onDidEndTerminalShellExecution)(m, b, I);
      },
      get state() {
        return v.getState();
      },
      onDidChangeWindowState(m, b, I) {
        return fe(v.onDidChangeWindowState)(m, b, I);
      },
      showInformationMessage(m, ...b) {
        return Pu.showMessage(C, Qt.Info, m, b[0], b.slice(1));
      },
      showWarningMessage(m, ...b) {
        return Pu.showMessage(C, Qt.Warning, m, b[0], b.slice(1));
      },
      showErrorMessage(m, ...b) {
        return Pu.showMessage(C, Qt.Error, m, b[0], b.slice(1));
      },
      showQuickPick(m, b, I) {
        return Oo.showQuickPick(C, m, b, I);
      },
      showWorkspaceFolderPick(m) {
        return Oo.showWorkspaceFolderPick(m);
      },
      showInputBox(m, b) {
        return Oo.showInput(m, b);
      },
      showOpenDialog(m) {
        return Df.showOpenDialog(m);
      },
      showSaveDialog(m) {
        return Df.showSaveDialog(m);
      },
      createStatusBarItem(m, b, I) {
        let Ie, Xe, li;
        return typeof m == "string" ? (Ie = m, Xe = b, li = I) : (Xe = m, li = b), Vs.createStatusBarEntry(C, Ie, Xe, li);
      },
      setStatusBarMessage(m, b) {
        return Vs.setStatusBarMessage(m, b);
      },
      withScmProgress(m) {
        return w.report("window.withScmProgress", C, "Use 'withProgress' instead."), V.withProgress(C, { location: xo.SourceControl }, (b, I) => m({ report(Ie) {
        } }));
      },
      withProgress(m, b) {
        return V.withProgress(C, m, b);
      },
      createOutputChannel(m, b) {
        return Le.createOutputChannel(m, b, C);
      },
      createWebviewPanel(m, b, I, Ie) {
        return Iu.createWebviewPanel(C, m, b, I, Ie);
      },
      createWebviewTextEditorInset(m, b, I, Ie) {
        return $(C, "editorInsets"), yf.createWebviewEditorInset(m, b, I, Ie, C);
      },
      createTerminal(m, b, I) {
        return typeof m == "object" ? "pty" in m ? X.createExtensionTerminal(m) : X.createTerminalFromOptions(m) : X.createTerminal(m, b, I);
      },
      registerTerminalLinkProvider(m) {
        return X.registerLinkProvider(m);
      },
      registerTerminalProfileProvider(m, b) {
        return X.registerProfileProvider(C, m, b);
      },
      registerTerminalCompletionProvider(m, ...b) {
        return $(C, "terminalCompletionProvider"), X.registerTerminalCompletionProvider(C, m, ...b);
      },
      registerTerminalQuickFixProvider(m, b) {
        return $(C, "terminalQuickFixProvider"), X.registerTerminalQuickFixProvider(m, C.identifier.value, b);
      },
      registerTreeDataProvider(m, b) {
        return ku.registerTreeDataProvider(m, b, C);
      },
      createTreeView(m, b) {
        return ku.createTreeView(m, b, C);
      },
      registerWebviewPanelSerializer: (m, b) => Iu.registerWebviewPanelSerializer(C, m, b),
      registerCustomEditorProvider: (m, b, I = {}) => x1.registerCustomEditorProvider(C, m, b, I),
      registerFileDecorationProvider(m) {
        return ye.registerFileDecorationProvider(m, C);
      },
      registerUriHandler(m) {
        return S.registerUriHandler(C, m);
      },
      createQuickPick() {
        return Oo.createQuickPick(C);
      },
      createInputBox() {
        return Oo.createInputBox(C);
      },
      get activeColorTheme() {
        return Sf.activeColorTheme;
      },
      onDidChangeActiveColorTheme(m, b, I) {
        return fe(Sf.onDidChangeActiveColorTheme)(m, b, I);
      },
      registerWebviewViewProvider(m, b, I) {
        return E1.registerWebviewViewProvider(C, m, b, I?.webviewOptions);
      },
      get activeNotebookEditor() {
        return ct.activeNotebookEditor;
      },
      onDidChangeActiveNotebookEditor(m, b, I) {
        return fe(ct.onDidChangeActiveNotebookEditor)(m, b, I);
      },
      get visibleNotebookEditors() {
        return ct.visibleNotebookEditors;
      },
      get onDidChangeVisibleNotebookEditors() {
        return fe(ct.onDidChangeVisibleNotebookEditors);
      },
      onDidChangeNotebookEditorSelection(m, b, I) {
        return fe(ln.onDidChangeNotebookEditorSelection)(m, b, I);
      },
      onDidChangeNotebookEditorVisibleRanges(m, b, I) {
        return fe(ln.onDidChangeNotebookEditorVisibleRanges)(m, b, I);
      },
      showNotebookDocument(m, b) {
        return ct.showNotebookDocument(m, b);
      },
      registerExternalUriOpener(m, b, I) {
        return $(C, "externalUriOpener"), wl.registerExternalUriOpener(C.identifier, m, b, I);
      },
      registerProfileContentHandler(m, b) {
        return $(C, "profileContentHandlers"), bl.registerProfileContentHandler(C, m, b);
      },
      registerQuickDiffProvider(m, b, I, Ie, Xe) {
        return $(C, "quickDiffProvider"), Ef.registerQuickDiffProvider(C, rt(m), b, I, Ie, Xe);
      },
      get tabGroups() {
        return A.tabGroups;
      },
      registerShareProvider(m, b) {
        return $(C, "shareProvider"), Bs.registerShareProvider(rt(m), b);
      },
      get nativeHandle() {
        return $(C, "nativeWindowHandle"), v.nativeHandle;
      },
      createChatStatusItem: (m) => ($(C, "chatStatusItem"), k1.createChatStatusItem(C, m)),
      showChatSession: (m, b, I) => ($(C, "chatSessionsProvider"), Tu.showChatSession(C, m, b, I))
    }, kf = {
      get rootPath() {
        return w.report("workspace.rootPath", C, "Please use 'workspace.workspaceFolders' instead. More details: https://aka.ms/vscode-eliminating-rootpath"), s.getPath();
      },
      set rootPath(m) {
        throw new la("rootPath");
      },
      getWorkspaceFolder(m) {
        return s.getWorkspaceFolder(m);
      },
      get workspaceFolders() {
        return s.getWorkspaceFolders();
      },
      get name() {
        return s.name;
      },
      set name(m) {
        throw new la("name");
      },
      get workspaceFile() {
        return s.workspaceFile;
      },
      set workspaceFile(m) {
        throw new la("workspaceFile");
      },
      updateWorkspaceFolders: (m, b, ...I) => s.updateWorkspaceFolders(C, m, b || 0, ...I),
      onDidChangeWorkspaceFolders: function(m, b, I) {
        return fe(s.onDidChangeWorkspace)(m, b, I);
      },
      asRelativePath: (m, b) => s.getRelativePath(m, b),
      findFiles: (m, b, I, Ie) => s.findFiles(m, b, I, C.identifier, Ie),
      findFiles2: (m, b, I) => ($(C, "findFiles2"), s.findFiles2(m, b, C.identifier, I)),
      findTextInFiles: (m, b, I, Ie) => {
        $(C, "findTextInFiles");
        let Xe, li;
        return typeof b == "object" ? (Xe = b, li = I) : (Xe = {}, li = b, Ie = I), s.findTextInFiles(m, Xe || {}, li, C.identifier, Ie);
      },
      findTextInFiles2: (m, b, I) => ($(C, "findTextInFiles2"), $(C, "textSearchProvider2"), s.findTextInFiles2(m, b, C.identifier, I)),
      save: (m) => s.save(m),
      saveAs: (m) => s.saveAs(m),
      saveAll: (m) => s.saveAll(m),
      applyEdit(m, b) {
        return S1.applyWorkspaceEdit(m, C, b);
      },
      createFileSystemWatcher: (m, b, I, Ie) => {
        const Xe = {
          ignoreCreateEvents: !!b,
          ignoreChangeEvents: !!I,
          ignoreDeleteEvents: !!Ie
        };
        return Je.createFileSystemWatcher(s, Au, C, m, Xe);
      },
      get textDocuments() {
        return qe.getAllDocumentData().map((m) => m.document);
      },
      set textDocuments(m) {
        throw new la("textDocuments");
      },
      openTextDocument(m, b) {
        let I;
        if (b = b ?? m, typeof m == "string")
          I = Promise.resolve(x.file(m));
        else if (x.isUri(m))
          I = Promise.resolve(m);
        else if (!b || typeof b == "object")
          I = qe.createDocumentData(b);
        else
          throw new Error("illegal argument - uriOrFileNameOrOptions");
        return I.then((Ie) => (g.trace(`openTextDocument from ${C.identifier}`), Ie.scheme === de.vscodeRemote && !Ie.authority && w.report("workspace.openTextDocument", C, "A URI of 'vscode-remote' scheme requires an authority."), qe.ensureDocumentData(Ie, b).then((Xe) => Xe.document)));
      },
      onDidOpenTextDocument: (m, b, I) => fe(qe.onDidAddDocument)(m, b, I),
      onDidCloseTextDocument: (m, b, I) => fe(qe.onDidRemoveDocument)(m, b, I),
      onDidChangeTextDocument: (m, b, I) => lt(C, "textDocumentChangeReason") ? fe(qe.onDidChangeDocumentWithReason)(m, b, I) : fe(qe.onDidChangeDocument)(m, b, I),
      onDidSaveTextDocument: (m, b, I) => fe(qe.onDidSaveDocument)(m, b, I),
      onWillSaveTextDocument: (m, b, I) => fe(Jt.getOnWillSaveTextDocumentEvent(C))(m, b, I),
      get notebookDocuments() {
        return ct.notebookDocuments.map((m) => m.apiNotebook);
      },
      async openNotebookDocument(m, b) {
        let I;
        if (x.isUri(m))
          I = m, await ct.openNotebookDocument(m);
        else if (typeof m == "string")
          I = x.revive(await ct.createNotebookDocument({ viewType: m, content: b }));
        else
          throw new Error("Invalid arguments");
        return ct.getNotebookDocument(I).apiNotebook;
      },
      onDidSaveNotebookDocument(m, b, I) {
        return fe($t.onDidSaveNotebookDocument)(m, b, I);
      },
      onDidChangeNotebookDocument(m, b, I) {
        return fe($t.onDidChangeNotebookDocument)(m, b, I);
      },
      onWillSaveNotebookDocument(m, b, I) {
        return fe(Gn.getOnWillSaveNotebookDocumentEvent(C))(m, b, I);
      },
      get onDidOpenNotebookDocument() {
        return fe(ct.onDidOpenNotebookDocument);
      },
      get onDidCloseNotebookDocument() {
        return fe(ct.onDidCloseNotebookDocument);
      },
      registerNotebookSerializer(m, b, I, Ie) {
        return ct.registerNotebookSerializer(C, m, b, I, lt(C, "notebookLiveShare") ? Ie : void 0);
      },
      onDidChangeConfiguration: (m, b, I) => fe(Au.onDidChangeConfiguration)(m, b, I),
      getConfiguration(m, b) {
        return b = arguments.length === 1 ? void 0 : b, Au.getConfiguration(m, b, C);
      },
      registerTextDocumentContentProvider(m, b) {
        return St.registerTextDocumentContentProvider(m, b);
      },
      registerTaskProvider: (m, b) => (w.report("window.registerTaskProvider", C, "Use the corresponding function on the 'tasks' namespace instead"), ce.registerTaskProvider(C, m, b)),
      registerFileSystemProvider(m, b, I) {
        return wx(v1.registerFileSystemProvider(C, m, b, I), n.addFileSystemProvider(m, b, I));
      },
      get fs() {
        return n.value;
      },
      registerFileSearchProvider: (m, b) => ($(C, "fileSearchProvider"), ie.registerFileSearchProviderOld(m, b)),
      registerTextSearchProvider: (m, b) => ($(C, "textSearchProvider"), ie.registerTextSearchProviderOld(m, b)),
      registerAITextSearchProvider: (m, b) => ($(C, "aiTextSearchProvider"), $(C, "textSearchProvider2"), ie.registerAITextSearchProvider(m, b)),
      registerFileSearchProvider2: (m, b) => ($(C, "fileSearchProvider2"), ie.registerFileSearchProvider(m, b)),
      registerTextSearchProvider2: (m, b) => ($(C, "textSearchProvider2"), ie.registerTextSearchProvider(m, b)),
      registerRemoteAuthorityResolver: (m, b) => ($(C, "resolvers"), r.registerRemoteAuthorityResolver(m, b)),
      registerResourceLabelFormatter: (m) => ($(C, "resolvers"), b1.$registerResourceLabelFormatter(m)),
      getRemoteExecServer: (m) => ($(C, "resolvers"), r.getRemoteExecServer(m)),
      onDidCreateFiles: (m, b, I) => fe(Je.onDidCreateFile)(m, b, I),
      onDidDeleteFiles: (m, b, I) => fe(Je.onDidDeleteFile)(m, b, I),
      onDidRenameFiles: (m, b, I) => fe(Je.onDidRenameFile)(m, b, I),
      onWillCreateFiles: (m, b, I) => fe(Je.getOnWillCreateFileEvent(C))(m, b, I),
      onWillDeleteFiles: (m, b, I) => fe(Je.getOnWillDeleteFileEvent(C))(m, b, I),
      onWillRenameFiles: (m, b, I) => fe(Je.getOnWillRenameFileEvent(C))(m, b, I),
      openTunnel: (m) => ($(C, "tunnels"), _.openTunnel(C, m).then((b) => {
        if (!b)
          throw new Error("cannot open tunnel");
        return b;
      })),
      get tunnels() {
        return $(C, "tunnels"), _.getTunnels();
      },
      onDidChangeTunnels: (m, b, I) => ($(C, "tunnels"), fe(_.onDidChangeTunnels)(m, b, I)),
      registerPortAttributesProvider: (m, b) => ($(C, "portsAttributes"), _.registerPortsAttributesProvider(m, b)),
      registerTunnelProvider: (m, b) => ($(C, "tunnelFactory"), _.registerTunnelProvider(m, b)),
      registerTimelineProvider: (m, b) => ($(C, "timeline"), y1.registerTimelineProvider(m, b, C.identifier, Te.converter)),
      get isTrusted() {
        return s.trusted;
      },
      requestWorkspaceTrust: (m) => ($(C, "workspaceTrust"), s.requestWorkspaceTrust(m)),
      onDidGrantWorkspaceTrust: (m, b, I) => fe(s.onDidGrantWorkspaceTrust)(m, b, I),
      registerEditSessionIdentityProvider: (m, b) => ($(C, "editSessionIdentityProvider"), s.registerEditSessionIdentityProvider(m, b)),
      onWillCreateEditSessionIdentity: (m, b, I) => ($(C, "editSessionIdentityProvider"), fe(s.getOnWillCreateEditSessionIdentityEvent(C))(m, b, I)),
      registerCanonicalUriProvider: (m, b) => ($(C, "canonicalUriProvider"), s.registerCanonicalUriProvider(m, b)),
      getCanonicalUri: (m, b, I) => ($(C, "canonicalUriProvider"), s.provideCanonicalUri(m, b, I)),
      decode(m, b) {
        return s.decode(m, b);
      },
      encode(m, b) {
        return s.encode(m, b);
      }
    }, D = {
      get inputBox() {
        return w.report("scm.inputBox", C, "Use 'SourceControl.inputBox' instead"), xf.getLastInputBox(C);
      },
      createSourceControl(m, b, I, Ie, Xe) {
        return (Ie || Xe) && $(C, "scmProviderOptions"), xf.createSourceControl(C, m, b, I, Ie, Xe);
      }
    }, F = {
      createCommentController(m, b) {
        return w1.createCommentController(C, m, b);
      }
    }, H = {
      get activeDebugSession() {
        return Z.activeDebugSession;
      },
      get activeDebugConsole() {
        return Z.activeDebugConsole;
      },
      get breakpoints() {
        return Z.breakpoints;
      },
      get activeStackItem() {
        return Z.activeStackItem;
      },
      registerDebugVisualizationProvider(m, b) {
        return $(C, "debugVisualization"), Z.registerDebugVisualizationProvider(C, m, b);
      },
      registerDebugVisualizationTreeProvider(m, b) {
        return $(C, "debugVisualization"), Z.registerDebugVisualizationTree(C, m, b);
      },
      onDidStartDebugSession(m, b, I) {
        return fe(Z.onDidStartDebugSession)(m, b, I);
      },
      onDidTerminateDebugSession(m, b, I) {
        return fe(Z.onDidTerminateDebugSession)(m, b, I);
      },
      onDidChangeActiveDebugSession(m, b, I) {
        return fe(Z.onDidChangeActiveDebugSession)(m, b, I);
      },
      onDidReceiveDebugSessionCustomEvent(m, b, I) {
        return fe(Z.onDidReceiveDebugSessionCustomEvent)(m, b, I);
      },
      onDidChangeBreakpoints(m, b, I) {
        return fe(Z.onDidChangeBreakpoints)(m, b, I);
      },
      onDidChangeActiveStackItem(m, b, I) {
        return fe(Z.onDidChangeActiveStackItem)(m, b, I);
      },
      registerDebugConfigurationProvider(m, b, I) {
        return Z.registerDebugConfigurationProvider(m, b, I || lg.Initial);
      },
      registerDebugAdapterDescriptorFactory(m, b) {
        return Z.registerDebugAdapterDescriptorFactory(C, m, b);
      },
      registerDebugAdapterTrackerFactory(m, b) {
        return Z.registerDebugAdapterTrackerFactory(m, b);
      },
      startDebugging(m, b, I) {
        return !I || typeof I == "object" && "configuration" in I ? Z.startDebugging(m, b, { parentSession: I }) : Z.startDebugging(m, b, I || {});
      },
      stopDebugging(m) {
        return Z.stopDebugging(m);
      },
      addBreakpoints(m) {
        return Z.addBreakpoints(m);
      },
      removeBreakpoints(m) {
        return Z.removeBreakpoints(m);
      },
      asDebugSourceUri(m, b) {
        return Z.asDebugSourceUri(m, b);
      }
    }, oe = {
      registerTaskProvider: (m, b) => ce.registerTaskProvider(C, m, b),
      fetchTasks: (m) => ce.fetchTasks(m),
      executeTask: (m) => ce.executeTask(C, m),
      get taskExecutions() {
        return ce.taskExecutions;
      },
      onDidStartTask: (m, b, I) => {
        const Ie = (Xe) => {
          lt(C, "taskExecutionTerminal") || Xe?.execution?.terminal !== void 0 && (Xe.execution.terminal = void 0);
          const li = {
            ...Xe,
            execution: Xe.execution
          };
          return m.call(b, li);
        };
        return fe(ce.onDidStartTask)(Ie, b, I);
      },
      onDidEndTask: (m, b, I) => fe(ce.onDidEndTask)(m, b, I),
      onDidStartTaskProcess: (m, b, I) => fe(ce.onDidStartTaskProcess)(m, b, I),
      onDidEndTaskProcess: (m, b, I) => fe(ce.onDidEndTaskProcess)(m, b, I),
      onDidStartTaskProblemMatchers: (m, b, I) => ($(C, "taskProblemMatcherStatus"), fe(ce.onDidStartTaskProblemMatchers)(m, b, I)),
      onDidEndTaskProblemMatchers: (m, b, I) => ($(C, "taskProblemMatcherStatus"), fe(ce.onDidEndTaskProblemMatchers)(m, b, I))
    }, J = {
      createNotebookController(m, b, I, Ie, Xe) {
        return gi.createNotebookController(C, m, b, I, Ie, lt(C, "notebookMessaging") ? Xe : void 0);
      },
      registerNotebookCellStatusBarItemProvider: (m, b) => ct.registerNotebookCellStatusBarItemProvider(C, m, b),
      createRendererMessaging(m) {
        return yr.createRendererMessaging(C, m);
      },
      createNotebookControllerDetectionTask(m) {
        return $(C, "notebookKernelSource"), gi.createNotebookControllerDetectionTask(C, m);
      },
      registerKernelSourceActionProvider(m, b) {
        return $(C, "notebookKernelSource"), gi.registerKernelSourceActionProvider(C, m, b);
      }
    }, ke = {
      t(...m) {
        if (typeof m[0] == "string") {
          const b = m.shift(), I = !m || typeof m[0] != "object" ? m : m[0];
          return Be.getMessage(C.identifier.value, { message: b, args: I });
        }
        return Be.getMessage(C.identifier.value, m[0]);
      },
      get bundle() {
        return Be.getBundle(C.identifier.value);
      },
      get uri() {
        return Be.getBundleUri(C.identifier.value);
      }
    }, He = {
      transferActiveChat(m) {
        return $(C, "interactive"), Qn.transferActiveChat(m);
      }
    }, Qe = {
      getRelatedInformation(m, b) {
        return $(C, "aiRelatedInformation"), yl.getRelatedInformation(C, m, b);
      },
      registerRelatedInformationProvider(m, b) {
        return $(C, "aiRelatedInformation"), yl.registerRelatedInformationProvider(C, m, b);
      },
      registerEmbeddingVectorProvider(m, b) {
        return $(C, "aiRelatedInformation"), xl.registerEmbeddingVectorProvider(C, m, b);
      },
      registerSettingsSearchProvider(m) {
        return $(C, "aiSettingsSearch"), un.registerSettingsSearchProvider(C, m);
      }
    }, st = {
      registerMappedEditsProvider(m, b) {
        return $(C, "mappedEditsProvider"), { dispose() {
        } };
      },
      registerMappedEditsProvider2(m) {
        return $(C, "mappedEditsProvider"), _1.registerMappedEditsProvider(C, m);
      },
      createChatParticipant(m, b) {
        return Qn.createChatAgent(C, m, b);
      },
      createDynamicChatParticipant(m, b, I) {
        return $(C, "chatParticipantPrivate"), Qn.createDynamicChatAgent(C, m, b, I);
      },
      registerChatParticipantDetectionProvider(m) {
        return $(C, "chatParticipantPrivate"), Qn.registerChatParticipantDetectionProvider(C, m);
      },
      registerRelatedFilesProvider(m, b) {
        return $(C, "chatEditing"), Qn.registerRelatedFilesProvider(C, m, b);
      },
      onDidDisposeChatSession: (m, b, I) => ($(C, "chatParticipantPrivate"), fe(Qn.onDidDisposeChatSession)(m, b, I)),
      registerChatSessionItemProvider: (m, b) => ($(C, "chatSessionsProvider"), Tu.registerChatSessionItemProvider(C, m, b)),
      registerChatSessionContentProvider(m, b) {
        return $(C, "chatSessionsProvider"), Tu.registerChatSessionContentProvider(C, m, b);
      },
      registerChatOutputRenderer: (m, b) => ($(C, "chatOutputRenderer"), Cu.registerChatOutputRenderer(C, m, b))
    }, On = {
      selectChatModels: (m) => Q.selectLanguageModels(C, m ?? {}),
      onDidChangeChatModels: (m, b, I) => Q.onDidChangeProviders(m, b, I),
      registerChatModelProvider: (m, b) => ($(C, "chatProvider"), Q.registerLanguageModelProvider(C, m, b)),
      get embeddingModels() {
        return $(C, "embeddings"), Uo.embeddingsModels;
      },
      onDidChangeEmbeddingModels: (m, b, I) => ($(C, "embeddings"), Uo.onDidChange(m, b, I)),
      registerEmbeddingsProvider(m, b) {
        return $(C, "embeddings"), Uo.registerEmbeddingsProvider(C, m, b);
      },
      async computeEmbeddings(m, b, I) {
        return $(C, "embeddings"), Uo.computeEmbeddings(m, b, I);
      },
      registerTool(m, b) {
        return Fo.registerTool(C, m, b);
      },
      invokeTool(m, b, I) {
        return Fo.invokeTool(C, m, b, I);
      },
      get tools() {
        return Fo.getTools(C);
      },
      fileIsIgnored(m, b) {
        return Q.fileIsIgnored(C, m, b);
      },
      registerIgnoredFileProvider(m) {
        return Q.registerIgnoredFileProvider(C, m);
      },
      registerMcpServerDefinitionProvider(m, b) {
        return re.registerMcpConfigurationProvider(C, m, b);
      },
      onDidChangeChatRequestTools(...m) {
        return $(C, "chatParticipantAdditions"), fe(Qn.onDidChangeChatRequestTools)(...m);
      }
    }, Fn = {
      registerSpeechProvider(m, b) {
        return $(C, "speech"), Ht.registerProvider(C.identifier, m, b);
      }
    };
    return {
      version: e.version,
      ai: Qe,
      authentication: I1,
      commands: C1,
      comments: F,
      chat: st,
      debug: H,
      env: T1,
      extensions: Ru,
      interactive: He,
      l10n: ke,
      languages: A1,
      lm: On,
      notebooks: J,
      scm: D,
      speech: Fn,
      tasks: oe,
      tests: P1,
      window: R1,
      workspace: kf,
      Breakpoint: Zc,
      TerminalOutputAnchor: _w,
      ChatResultFeedbackKind: Ch,
      ChatVariableLevel: rb,
      ChatCompletionItem: f6,
      ChatReferenceDiagnostic: _P,
      CallHierarchyIncomingCall: GT,
      CallHierarchyItem: Jx,
      CallHierarchyOutgoingCall: QT,
      CancellationError: zn,
      CancellationTokenSource: Pt,
      CandidatePortSource: kv,
      CodeAction: lh,
      CodeActionKind: At,
      CodeActionTriggerKind: ah,
      CodeLens: Cg,
      Color: Jc,
      ColorInformation: Ng,
      ColorPresentation: Mg,
      ColorThemeKind: co,
      CommentMode: Bw,
      CommentState: Ww,
      CommentThreadCollapsibleState: bh,
      CommentThreadState: yh,
      CommentThreadApplicability: xh,
      CommentThreadFocus: Eh,
      CompletionItem: Ag,
      CompletionItemKind: Ce,
      CompletionItemTag: uh,
      CompletionList: Gc,
      CompletionTriggerKind: pc,
      ConfigurationTarget: vc,
      CustomExecution: Yx,
      DebugAdapterExecutable: Bg,
      DebugAdapterInlineImplementation: _h,
      DebugAdapterNamedPipeServer: Wg,
      DebugAdapterServer: mh,
      DebugConfigurationProviderTriggerKind: lg,
      DebugConsoleMode: Gg,
      DebugVisualization: o6,
      DecorationRangeBehavior: ga,
      Diagnostic: Eg,
      DiagnosticRelatedInformation: ih,
      DiagnosticSeverity: Ci,
      DiagnosticTag: fa,
      Disposable: Ve,
      DocumentHighlight: kg,
      DocumentHighlightKind: nh,
      MultiDocumentHighlight: Ig,
      DocumentLink: Lg,
      DocumentSymbol: oh,
      EndOfLine: fr,
      EnvironmentVariableMutatorType: hc,
      EvaluatableExpression: Vg,
      InlineValueText: zg,
      InlineValueVariableLookup: qg,
      InlineValueEvaluatableExpression: jg,
      InlineCompletionTriggerKind: vh,
      InlineCompletionsDisposeReasonKind: ws,
      EventEmitter: N,
      ExtensionKind: Aa,
      ExtensionMode: xc,
      ExternalUriOpenerPriority: Zw,
      FileChangeType: bc,
      FileDecoration: qw,
      FileDecoration2: qw,
      FileSystemError: ui,
      FileType: Da,
      FilePermission: Vc,
      FoldingRange: Hw,
      FoldingRangeKind: bs,
      FunctionBreakpoint: _a,
      InlineCompletionItem: Sw,
      InlineCompletionList: Dw,
      Hover: Sg,
      VerboseHover: Dg,
      HoverVerbosityAction: vw,
      IndentAction: S0,
      Location: Ln,
      MarkdownString: bn,
      OverviewRulerLane: Qv,
      ParameterInformation: ww,
      PortAutoForwardAction: tb,
      Position: je,
      ProcessExecution: Yc,
      ProgressLocation: xo,
      QuickInputButtonLocation: zw,
      QuickInputButtons: Sh,
      Range: Oe,
      RelativePattern: wc,
      Selection: Qr,
      SelectionRange: ch,
      SemanticTokens: eu,
      SemanticTokensBuilder: Xx,
      SemanticTokensEdit: ZT,
      SemanticTokensEdits: pp,
      SemanticTokensLegend: Vw,
      ShellExecution: nl,
      ShellQuoting: Nw,
      SignatureHelp: yw,
      SignatureHelpTriggerKind: xw,
      SignatureInformation: bw,
      SnippetString: il,
      SourceBreakpoint: ma,
      StandardTokenType: po,
      StatusBarAlignment: fo,
      SymbolInformation: sh,
      SymbolKind: bt,
      SymbolTag: rh,
      Task: Og,
      TaskEventKind: Rw,
      TaskGroup: ph,
      TaskPanelKind: Lw,
      TaskRevealKind: Aw,
      TaskScope: To,
      TerminalLink: Q9,
      TerminalQuickFixTerminalCommand: J9,
      TerminalQuickFixOpener: K9,
      TerminalLocation: Tw,
      TerminalProfile: Y9,
      TerminalExitReason: Iw,
      TerminalShellExecutionCommandLineConfidence: fh,
      TerminalCompletionItem: X9,
      TerminalCompletionItemKind: Pw,
      TerminalCompletionList: Z9,
      TerminalShellType: Cw,
      TextDocumentSaveReason: mc,
      TextEdit: Co,
      SnippetTextEdit: Ta,
      TextEditorCursorStyle: cr,
      TextEditorChangeKind: _c,
      TextEditorLineNumbersStyle: rr,
      TextEditorRevealType: Rg,
      TextEditorSelectionChangeKind: Qc,
      SyntaxTokenType: Kc,
      TextDocumentChangeReason: hh,
      ThemeColor: gh,
      ThemeIcon: qi,
      TreeItem: Fg,
      TreeItemCheckboxState: Nr,
      TreeItemCollapsibleState: Pa,
      TypeHierarchyItem: Zx,
      UIKind: $d,
      Uri: x,
      ViewColumn: dh,
      WorkspaceEdit: tl,
      DocumentPasteTriggerKind: Fw,
      DocumentDropEdit: Ow,
      DocumentDropOrPasteEditKind: es,
      DocumentPasteEdit: i6,
      InlayHint: Pg,
      InlayHintLabelPart: Tg,
      InlayHintKind: Ew,
      RemoteAuthorityResolverError: Lr,
      ResolvedAuthority: j9,
      ManagedResolvedAuthority: fp,
      SourceControlInputBoxValidationType: kw,
      ExtensionRuntime: Zg,
      TimelineItem: Yw,
      NotebookRange: Wr,
      NotebookCellKind: va,
      NotebookCellExecutionState: Kw,
      NotebookCellData: Y_,
      NotebookData: eP,
      NotebookRendererScript: iP,
      NotebookCellStatusBarAlignment: Jg,
      NotebookEditorRevealType: Yg,
      NotebookCellOutput: Kg,
      NotebookCellOutputItem: tP,
      CellErrorStackFrame: a6,
      NotebookCellStatusBarItem: l6,
      NotebookControllerAffinity: Jw,
      NotebookControllerAffinity2: Xg,
      NotebookEdit: xg,
      NotebookKernelSourceAction: c6,
      NotebookVariablesRequestKind: kh,
      PortAttributes: d6,
      LinkedEditingRanges: u6,
      TestResultState: Xw,
      TestRunRequest: em,
      TestMessage: tm,
      TestMessageStackFrame: h6,
      TestTag: Ih,
      TestRunProfileKind: Ec,
      TextSearchCompleteMessageType: Vm,
      DataTransfer: Xc,
      DataTransferItem: Ug,
      TestCoverageCount: gp,
      FileCoverage: tu,
      StatementCoverage: rP,
      BranchCoverage: sP,
      DeclarationCoverage: oP,
      WorkspaceTrustState: eb,
      LanguageStatusSeverity: fc,
      QuickPickItemKind: Dh,
      InputBoxValidationSeverity: yc,
      TabInputText: eE,
      TabInputTextDiff: im,
      TabInputTextMerge: aP,
      TabInputCustom: tE,
      TabInputNotebook: iE,
      TabInputNotebookDiff: nE,
      TabInputWebview: lP,
      TabInputTerminal: cP,
      TabInputInteractiveWindow: uP,
      TabInputChat: dP,
      TabInputTextMultiDiff: hP,
      TelemetryTrustedValue: qx,
      LogLevel: Re,
      EditSessionIdentityMatch: D0,
      InteractiveSessionVoteDirection: ib,
      ChatCopyKind: nb,
      ChatEditingSessionActionOutcome: Tr,
      InteractiveEditorResponseFeedbackKind: ob,
      DebugStackFrame: YT,
      DebugThread: XT,
      RelatedInformationType: gb,
      SpeechToTextStatus: _b,
      TextToSpeechStatus: vb,
      PartialAcceptTriggerKind: pa,
      InlineCompletionEndOfLifeReasonKind: gc,
      KeywordRecognitionStatus: wb,
      ChatImageMimeType: uo,
      ChatResponseMarkdownPart: X_,
      ChatResponseFileTreePart: Z_,
      ChatResponseAnchorPart: Ph,
      ChatResponseProgressPart: sE,
      ChatResponseProgressPart2: _p,
      ChatResponseReferencePart: Ra,
      ChatResponseReferencePart2: Ra,
      ChatResponseCodeCitationPart: rm,
      ChatResponseCodeblockUriPart: t1,
      ChatResponseWarningPart: Ah,
      ChatResponseTextEditPart: Rh,
      ChatResponseNotebookEditPart: sm,
      ChatResponseMarkdownWithVulnerabilitiesPart: Th,
      ChatResponseCommandButtonPart: e1,
      ChatResponseConfirmationPart: nm,
      ChatResponseMovePart: i1,
      ChatResponseExtensionsPart: oE,
      ChatResponsePullRequestPart: aE,
      ChatPrepareToolInvocationPart: Lh,
      ChatResponseMultiDiffPart: rE,
      ChatResponseReferencePartStatusKind: ab,
      ChatResponseClearToPreviousToolInvocationReason: lb,
      ChatRequestTurn: om,
      ChatRequestTurn2: om,
      ChatResponseTurn: fP,
      ChatResponseTurn2: p6,
      ChatToolInvocationPart: lE,
      ChatLocation: sr,
      ChatRequestEditorData: pP,
      ChatRequestNotebookData: gP,
      ChatReferenceBinaryData: mP,
      ChatRequestEditedFileEventKind: sb,
      LanguageModelChatMessageRole: _n,
      LanguageModelChatMessage: vP,
      LanguageModelChatMessage2: wP,
      LanguageModelToolResultPart: am,
      LanguageModelToolResultPart2: cb,
      LanguageModelTextPart: Ut,
      LanguageModelTextPart2: Ut,
      ToolResultAudience: fb,
      LanguageModelToolCallPart: rl,
      LanguageModelError: bi,
      LanguageModelToolResult: n1,
      LanguageModelToolResult2: bP,
      LanguageModelDataPart: wn,
      LanguageModelDataPart2: wn,
      LanguageModelToolExtensionSource: yP,
      LanguageModelToolMCPSource: xP,
      ExtendedLanguageModelToolResult: g6,
      LanguageModelChatToolMode: pb,
      LanguageModelPromptTsxPart: ts,
      NewSymbolName: r6,
      NewSymbolNameTag: $w,
      NewSymbolNameTriggerKind: wh,
      ExcludeSettingOptions: xs,
      TextSearchContext2: hE,
      TextSearchMatch2: go,
      AISearchKeyword: fy,
      TextSearchCompleteMessageTypeNew: Vm,
      ChatErrorLevel: ub,
      McpHttpServerDefinition: _6,
      McpStdioServerDefinition: m6,
      SettingsSearchResultKind: mb
    };
  };
}
var Ip;
let ux = class {
  constructor(e, i, n, r, s, o, a) {
    this._apiFactory = e, this._extensionRegistry = i, this._instaService = n, this._extHostConfiguration = r, this._extHostExtensionService = s, this._initData = o, this._logService = a, this._factories = /* @__PURE__ */ new Map(), this._alternatives = [];
  }
  async install() {
    this._installInterceptor(), tn("code/extHost/willWaitForConfig");
    const e = await this._extHostConfiguration.getConfigProvider();
    tn("code/extHost/didWaitForConfig");
    const i = await this._extHostExtensionService.getExtensionPathIndex();
    this.register(new I$(
      this._apiFactory,
      i,
      this._extensionRegistry,
      e,
      this._logService
    )), this.register(this._instaService.createInstance(dx)), this._initData.remote.isRemote && this.register(this._instaService.createInstance(hx, i, this._initData.environment.appUriScheme));
  }
  register(e) {
    if ("nodeModuleName" in e)
      if (Array.isArray(e.nodeModuleName))
        for (const i of e.nodeModuleName)
          this._factories.set(i, e);
      else
        this._factories.set(e.nodeModuleName, e);
    typeof e.alternativeModuleName == "function" && this._alternatives.push((i) => e.alternativeModuleName(i));
  }
};
ux = W([
  M(2, uf),
  M(3, $s),
  M(4, Mo),
  M(5, pi),
  M(6, nt)
], ux);
var Ka;
let dx = (Ka = class {
  constructor(e) {
    if (e.environment.appRoot && Ip.aliased.size) {
      const i = Ja(this.forceForwardSlashes(e.environment.appRoot.fsPath)), n = "[a-z0-9_.-]", r = `@${n}+\\/${n}+|${n}+`, s = "node_modules|node_modules\\.asar(?:\\.unpacked)?";
      this.re = new RegExp(`^(${i}/${s}\\/)(${r})(.*)$`, "i");
    }
  }
  alternativeModuleName(e) {
    if (!this.re)
      return;
    const i = this.re.exec(this.forceForwardSlashes(e));
    if (!i)
      return;
    const [, n, r, s] = i, o = Ip.aliased.get(r);
    if (o !== void 0)
      return console.warn(`${r} as been renamed to ${o}, please update your imports`), n + o + s;
  }
  forceForwardSlashes(e) {
    return e.replace(/\\/g, "/");
  }
}, Ip = Ka, Ka.aliased = /* @__PURE__ */ new Map([
  ["vscode-ripgrep", "@vscode/ripgrep"],
  ["vscode-windows-registry", "@vscode/windows-registry"]
]), Ka);
dx = Ip = W([
  M(0, pi)
], dx);
class I$ {
  constructor(e, i, n, r, s) {
    this._apiFactory = e, this._extensionPaths = i, this._extensionRegistry = n, this._configProvider = r, this._logService = s, this.nodeModuleName = "vscode", this._extApiImpl = new Io();
  }
  load(e, i) {
    const n = this._extensionPaths.findSubstr(i);
    if (n) {
      let r = this._extApiImpl.get(n.identifier);
      return r || (r = this._apiFactory(n, this._extensionRegistry, this._configProvider), this._extApiImpl.set(n.identifier, r)), r;
    }
    if (!this._defaultApiImpl) {
      let r = "";
      this._extensionPaths.forEach((s, o) => r += `	${o} -> ${s.identifier.value}
`), this._logService.warn(`Could not identify extension for 'vscode' require call from ${i}. These are the extension path mappings: 
${r}`), this._defaultApiImpl = this._apiFactory(F3, this._extensionRegistry, this._configProvider);
    }
    return this._defaultApiImpl;
  }
}
let hx = class {
  constructor(e, i, n) {
    this._extensionPaths = e, this._appUriScheme = i, this.nodeModuleName = ["open", "opn"], this._mainThreadTelemetry = n.getProxy(ee.MainThreadTelemetry);
    const r = n.getProxy(ee.MainThreadWindow);
    this._impl = (s, o) => {
      const a = x.parse(s);
      return o ? this.callOriginal(s, o) : a.scheme === "http" || a.scheme === "https" ? r.$openUri(a, s, { allowTunneling: !0 }) : a.scheme === "mailto" || a.scheme === this._appUriScheme ? r.$openUri(a, s, {}) : this.callOriginal(s, o);
    };
  }
  load(e, i, n) {
    const r = this._extensionPaths.findSubstr(i);
    return r && (this._extensionId = r.identifier.value, this.sendShimmingTelemetry()), this._original = n(e), this._impl;
  }
  callOriginal(e, i) {
    return this.sendNoForwardTelemetry(), this._original(e, i);
  }
  sendShimmingTelemetry() {
    this._extensionId && this._mainThreadTelemetry.$publicLog2("shimming.open", { extension: this._extensionId });
  }
  sendNoForwardTelemetry() {
    this._extensionId && this._mainThreadTelemetry.$publicLog2("shimming.open.call.noForward", { extension: this._extensionId });
  }
};
hx = W([
  M(2, Ye)
], hx);
let fx = class {
  constructor(e, i) {
    this._mainThreadConsole = e.getProxy(ee.MainThreadConsole), this._includeStack = i.consoleForward.includeStack, this._logNative = i.consoleForward.logNative, this._wrapConsoleMethod("info", "log"), this._wrapConsoleMethod("log", "log"), this._wrapConsoleMethod("warn", "warn"), this._wrapConsoleMethod("debug", "debug"), this._wrapConsoleMethod("error", "error");
  }
  _wrapConsoleMethod(e, i) {
    const n = this, r = console[e];
    Object.defineProperty(console, e, {
      set: () => {
      },
      get: () => function() {
        n._handleConsoleCall(e, i, r, arguments);
      }
    });
  }
  _handleConsoleCall(e, i, n, r) {
    this._mainThreadConsole.$logExtensionHostMessage({
      type: "__$console",
      severity: i,
      arguments: T$(r, this._includeStack)
    }), this._logNative && this._nativeConsoleLogMessage(e, n, r);
  }
};
fx = W([
  M(0, Ye),
  M(1, pi)
], fx);
const C$ = 1e5;
function T$(t, e) {
  const i = [];
  if (t.length)
    for (let n = 0; n < t.length; n++) {
      let r = t[n];
      if (typeof r > "u")
        r = "undefined";
      else if (r instanceof Error) {
        const s = r;
        s.stack ? r = s.stack : r = s.toString();
      }
      i.push(r);
    }
  if (e) {
    const n = new Error().stack;
    n && i.push({ __$stack: n.split(`
`).slice(3).join(`
`) });
  }
  try {
    const n = S8(i);
    return n.length > C$ ? "Output omitted for a large object that exceeds the limits" : n;
  } catch (n) {
    return `Output omitted for an object that cannot be inspected ('${n.toString()}')`;
  }
}
let px = class extends fx {
  constructor(e, i) {
    super(e, i);
  }
  _nativeConsoleLogMessage(e, i, n) {
    i.apply(console, n);
  }
};
px = W([
  M(0, Ye),
  M(1, pi)
], px);
class P$ extends ux {
  _installInterceptor() {
  }
  getModule(e, i) {
    for (const n of this._alternatives) {
      const r = n(e);
      if (r) {
        e = r;
        break;
      }
    }
    if (this._factories.has(e))
      return this._factories.get(e).load(e, i, () => {
        throw new Error("CANNOT LOAD MODULE from here.");
      });
  }
}
class A$ extends Qy {
  constructor() {
    super(...arguments), this.extensionRuntime = Zg.Webworker;
  }
  async _beforeAlmostReadyToRunExtensions() {
    Wd && this._instaService.createInstance(px), this._apiFactory = this._instaService.invokeFunction(k$), this._fakeModules = this._instaService.createInstance(P$, this._apiFactory, { mine: this._myRegistry, all: this._globalRegistry }), await this._fakeModules.install(), performance.mark("code/extHost/didInitAPI"), await this._waitForDebuggerAttachment();
  }
  _getEntryPoint(e) {
    return e.browser;
  }
  async _loadCommonJSModule(e, i, n) {
    i = i.with({ path: R$(i.path, ".js") });
    const r = e?.identifier.value;
    r && performance.mark(`code/extHost/willFetchExtensionCode/${r}`);
    const s = x.revive(await this._mainThreadExtensionsProxy.$asBrowserUri(i)), o = await fetch(s.toString(!0));
    if (r && performance.mark(`code/extHost/didFetchExtensionCode/${r}`), o.status !== 200)
      throw new Error(o.statusText);
    const a = await o.text(), l = `${i.toString(!0)}#vscode-extension`, c = `${a}
//# sourceURL=${l}`;
    let u;
    try {
      u = new Function("module", "exports", "require", c);
    } catch (_) {
      throw console.error(r ? `Loading code for extension ${r} failed: ${_.message}` : `Loading code failed: ${_.message}`), console.error(`${i.toString(!0)}${typeof _.line == "number" ? ` line ${_.line}` : ""}${typeof _.column == "number" ? ` column ${_.column}` : ""}`), console.error(_), _;
    }
    e && await this._extHostLocalizationService.initializeLocalizedMessages(e);
    const d = {}, f = { exports: d }, g = (_) => {
      const w = this._fakeModules.getModule(_, i);
      if (w === void 0)
        throw new Error(`Cannot load module '${_}'`);
      return w;
    };
    try {
      return n.codeLoadingStart(), r && performance.mark(`code/extHost/willLoadExtensionCode/${r}`), u(f, d, g), f.exports !== d ? f.exports : d;
    } finally {
      r && performance.mark(`code/extHost/didLoadExtensionCode/${r}`), n.codeLoadingStop();
    }
  }
  _loadESMModule(e, i, n) {
    throw new Error("ESM modules are not supported in the web worker extension host");
  }
  async $setRemoteEnvironment(e) {
  }
  async _waitForDebuggerAttachment(e = 5e3) {
    if (!this._initData.environment.isExtensionDevelopmentDebug)
      return;
    const i = Date.now() + e;
    for (; Date.now() < i && !("__jsDebugIsReady" in globalThis); )
      await qr(10);
  }
}
function R$(t, e) {
  return Op(t) ? t : t + e;
}
gt(bE, By, ft.Eager);
gt(Mo, A$, ft.Eager);
gt(_E, Sy, ft.Eager);
gt(u1, new lr(Ay, [!0], !0));
const $5 = self.close.bind(self);
self.close = () => console.trace("'close' has been blocked");
const H5 = postMessage.bind(self);
self.postMessage = () => console.trace("'postMessage' has been blocked");
function JC(t) {
  return /^(file|extension-file|vscode-remote):/i.test(t);
}
const YC = fetch.bind(self);
function L$(t) {
  self.fetch = async function(e, i) {
    return e instanceof Request || JC(String(e)) && (e = (await t(x.parse(String(e)))).toString(!0)), YC(e, i);
  }, self.XMLHttpRequest = class extends XMLHttpRequest {
    open(e, i, n, r, s) {
      (async () => (JC(i.toString()) && (i = (await t(x.parse(i.toString()))).toString(!0)), super.open(e, i, n ?? !0, r, s)))();
    }
  };
}
self.importScripts = () => {
  throw new Error("'importScripts' has been blocked");
};
self.addEventListener = () => console.trace("'addEventListener' has been blocked");
self.AMDLoader = void 0;
self.NLSLoaderPlugin = void 0;
self.define = void 0;
self.require = void 0;
self.webkitRequestFileSystem = void 0;
self.webkitRequestFileSystemSync = void 0;
self.webkitResolveLocalFileSystemSyncURL = void 0;
self.webkitResolveLocalFileSystemURL = void 0;
function N$(t, e) {
  if (self.Worker) {
    const i = self.Worker;
    Worker = function(n, r) {
      if (/^vscode-remote:/i.test(n.toString()))
        throw new Error("Creating workers from remote extensions is currently not supported.");
      async function s(a) {
        const [l, c] = await Promise.all([
          t(a).then((g) => g.toString(!0)),
          e().then((g) => Object.fromEntries(g.map(([_, w]) => [_.toString(!0), w.toString(!0)])))
        ]), d = `(${(function(_, w) {
          function v(A) {
            return typeof A == "string" || A instanceof URL ? (A = String(A).replace(/^file:\/\//i, "vscode-file://vscode-app"), w[A] ?? A) : A;
          }
          const S = fetch.bind(self);
          self.fetch = function(A, j) {
            return A instanceof Request ? S(A, j) : S(v(A), j);
          }, self.XMLHttpRequest = class extends XMLHttpRequest {
            constructor() {
              super(...arguments), this.notFound = !1;
            }
            open(A, j, V, le, Q) {
              const re = v(j);
              return this.notFound = re.startsWith("extension-file:"), super.open(A, re, V ?? !0, le, Q);
            }
            send(A) {
              this.notFound || super.send(A);
            }
            get status() {
              return this.notFound ? 404 : super.status;
            }
          };
          const E = importScripts.bind(self);
          self.importScripts = (...A) => {
            E(...A.map(v));
          }, self.importExt = (A) => new Function("url", "return import(url)")(v(A)), E(_);
        }).toString()}('${l}', ${JSON.stringify(c)}))`, f = new Blob([d], { type: "application/javascript" });
        return URL.createObjectURL(f);
      }
      r = r || {}, r.name = `${name} -> ${r.name || mn(n.toString())}`;
      class o {
        constructor(l, c) {
          this._onmessage = null, this._onmessageerror = null, this._onerror = null, this.workerPromise = s(x.parse(l instanceof URL ? l.toString() : l)).then((u) => new i(u, c));
        }
        set onmessage(l) {
          this._onmessage = l, this.workerPromise.then((c) => {
            c.onmessage = l;
          }, console.error);
        }
        get onmessage() {
          return this._onmessage;
        }
        set onmessageerror(l) {
          this._onmessageerror = l, this.workerPromise.then((c) => {
            c.onmessageerror = l;
          }, console.error);
        }
        get onmessageerror() {
          return this._onmessageerror;
        }
        set onerror(l) {
          this._onerror = l, this.workerPromise.then((c) => {
            c.onerror = l;
          }, console.error);
        }
        get onerror() {
          return this._onerror;
        }
        postMessage(l, c) {
          this.workerPromise.then((u) => {
            u.postMessage(l, c);
          }, console.error);
        }
        terminate() {
          this.workerPromise.then((l) => {
            l.terminate();
          }, console.error);
        }
        addEventListener(l, c, u) {
          this.workerPromise.then((d) => {
            d.addEventListener(l, c, u);
          }, console.error);
        }
        removeEventListener(l, c, u) {
          this.workerPromise.then((d) => {
            d.removeEventListener(l, c, u);
          }, console.error);
        }
        dispatchEvent(l) {
          return this.workerPromise.then((c) => {
            c.dispatchEvent(l);
          }, console.error), !1;
        }
      }
      return new o(n, r);
    };
  } else
    self.Worker = class extends VM {
      constructor(i, n) {
        super(H5, i, { name: mn(i.toString()), ...n });
      }
    };
}
const M$ = new class {
  constructor() {
    this.pid = void 0;
  }
  exit(t) {
    $5();
  }
}();
class O$ {
  constructor() {
    const e = new MessageChannel(), i = new N();
    let n = !1;
    H5(e.port2, [e.port2]), e.port1.onmessage = (r) => {
      const { data: s } = r;
      if (!(s instanceof ArrayBuffer)) {
        console.warn("UNKNOWN data received", s);
        return;
      }
      const o = ue.wrap(new Uint8Array(s, 0, s.byteLength));
      if (NA(o, pr.Terminate)) {
        n = !0, B5("received terminate message from renderer");
        return;
      }
      i.fire(o);
    }, this.protocol = {
      onMessage: i.event,
      send: (r) => {
        if (!n) {
          const s = r.buffer.buffer.slice(r.buffer.byteOffset, r.buffer.byteOffset + r.buffer.byteLength);
          e.port1.postMessage(s, [s]);
        }
      }
    };
  }
}
function F$(t) {
  return new Promise((e) => {
    const i = t.onMessage((n) => {
      i.dispose();
      const r = JSON.parse(n.toString());
      t.send(KE(pr.Initialized)), e({ protocol: t, initData: r });
    });
    t.send(KE(pr.Ready));
  });
}
let B5 = (t) => $5();
function U$(t) {
  return !!t && typeof t == "object" && t.type === "vscode.init" && t.data instanceof Map;
}
function $$() {
  tn("code/extHost/willConnectToRenderer");
  const t = new O$();
  return {
    onmessage(e) {
      U$(e) && F$(t.protocol).then((i) => {
        tn("code/extHost/didWaitForInitData");
        const n = new DE(i.protocol, i.initData, M$, null, e.data);
        L$((r) => n.asBrowserUri(r)), N$((r) => n.asBrowserUri(r), () => n.getAllStaticBrowserUris()), B5 = (r) => n.terminate(r);
      });
    }
  };
}
const H$ = $$();
self.onmessage = (t) => H$.onmessage(t.data);
